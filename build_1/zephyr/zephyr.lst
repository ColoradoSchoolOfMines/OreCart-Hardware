
zephyr.elf:     file format elf32-i386


Disassembly of section .init:

08049000 <_init>:
 8049000:	f3 0f 1e fb          	endbr32 
 8049004:	53                   	push   %ebx
 8049005:	83 ec 08             	sub    $0x8,%esp
 8049008:	e8 43 04 00 00       	call   8049450 <__x86.get_pc_thunk.bx>
 804900d:	81 c3 df ce 01 00    	add    $0x1cedf,%ebx
 8049013:	8b 83 00 01 00 00    	mov    0x100(%ebx),%eax
 8049019:	85 c0                	test   %eax,%eax
 804901b:	74 02                	je     804901f <_init+0x1f>
 804901d:	ff d0                	call   *%eax
 804901f:	83 c4 08             	add    $0x8,%esp
 8049022:	5b                   	pop    %ebx
 8049023:	c3                   	ret    

Disassembly of section .plt:

08049030 <__errno_location@plt-0x10>:
 8049030:	ff 35 f0 5e 06 08    	push   0x8065ef0
 8049036:	ff 25 f4 5e 06 08    	jmp    *0x8065ef4
 804903c:	00 00                	add    %al,(%eax)
	...

08049040 <__errno_location@plt>:
 8049040:	ff 25 f8 5e 06 08    	jmp    *0x8065ef8
 8049046:	68 00 00 00 00       	push   $0x0
 804904b:	e9 e0 ff ff ff       	jmp    8049030 <_init+0x30>

08049050 <sigemptyset@plt>:
 8049050:	ff 25 fc 5e 06 08    	jmp    *0x8065efc
 8049056:	68 08 00 00 00       	push   $0x8
 804905b:	e9 d0 ff ff ff       	jmp    8049030 <_init+0x30>

08049060 <open@plt>:
 8049060:	ff 25 00 5f 06 08    	jmp    *0x8065f00
 8049066:	68 10 00 00 00       	push   $0x10
 804906b:	e9 c0 ff ff ff       	jmp    8049030 <_init+0x30>

08049070 <memcmp@plt>:
 8049070:	ff 25 04 5f 06 08    	jmp    *0x8065f04
 8049076:	68 18 00 00 00       	push   $0x18
 804907b:	e9 b0 ff ff ff       	jmp    8049030 <_init+0x30>

08049080 <pthread_exit@plt>:
 8049080:	ff 25 08 5f 06 08    	jmp    *0x8065f08
 8049086:	68 20 00 00 00       	push   $0x20
 804908b:	e9 a0 ff ff ff       	jmp    8049030 <_init+0x30>

08049090 <random@plt>:
 8049090:	ff 25 0c 5f 06 08    	jmp    *0x8065f0c
 8049096:	68 28 00 00 00       	push   $0x28
 804909b:	e9 90 ff ff ff       	jmp    8049030 <_init+0x30>

080490a0 <clock_gettime@plt>:
 80490a0:	ff 25 10 5f 06 08    	jmp    *0x8065f10
 80490a6:	68 30 00 00 00       	push   $0x30
 80490ab:	e9 80 ff ff ff       	jmp    8049030 <_init+0x30>

080490b0 <__fprintf_chk@plt>:
 80490b0:	ff 25 14 5f 06 08    	jmp    *0x8065f14
 80490b6:	68 38 00 00 00       	push   $0x38
 80490bb:	e9 70 ff ff ff       	jmp    8049030 <_init+0x30>

080490c0 <realloc@plt>:
 80490c0:	ff 25 18 5f 06 08    	jmp    *0x8065f18
 80490c6:	68 40 00 00 00       	push   $0x40
 80490cb:	e9 60 ff ff ff       	jmp    8049030 <_init+0x30>

080490d0 <__printf_chk@plt>:
 80490d0:	ff 25 1c 5f 06 08    	jmp    *0x8065f1c
 80490d6:	68 48 00 00 00       	push   $0x48
 80490db:	e9 50 ff ff ff       	jmp    8049030 <_init+0x30>

080490e0 <strtod@plt>:
 80490e0:	ff 25 20 5f 06 08    	jmp    *0x8065f20
 80490e6:	68 50 00 00 00       	push   $0x50
 80490eb:	e9 40 ff ff ff       	jmp    8049030 <_init+0x30>

080490f0 <strchr@plt>:
 80490f0:	ff 25 24 5f 06 08    	jmp    *0x8065f24
 80490f6:	68 58 00 00 00       	push   $0x58
 80490fb:	e9 30 ff ff ff       	jmp    8049030 <_init+0x30>

08049100 <calloc@plt>:
 8049100:	ff 25 28 5f 06 08    	jmp    *0x8065f28
 8049106:	68 60 00 00 00       	push   $0x60
 804910b:	e9 20 ff ff ff       	jmp    8049030 <_init+0x30>

08049110 <strncpy@plt>:
 8049110:	ff 25 2c 5f 06 08    	jmp    *0x8065f2c
 8049116:	68 68 00 00 00       	push   $0x68
 804911b:	e9 10 ff ff ff       	jmp    8049030 <_init+0x30>

08049120 <putchar@plt>:
 8049120:	ff 25 30 5f 06 08    	jmp    *0x8065f30
 8049126:	68 70 00 00 00       	push   $0x70
 804912b:	e9 00 ff ff ff       	jmp    8049030 <_init+0x30>

08049130 <write@plt>:
 8049130:	ff 25 34 5f 06 08    	jmp    *0x8065f34
 8049136:	68 78 00 00 00       	push   $0x78
 804913b:	e9 f0 fe ff ff       	jmp    8049030 <_init+0x30>

08049140 <__memcpy_chk@plt>:
 8049140:	ff 25 38 5f 06 08    	jmp    *0x8065f38
 8049146:	68 80 00 00 00       	push   $0x80
 804914b:	e9 e0 fe ff ff       	jmp    8049030 <_init+0x30>

08049150 <strrchr@plt>:
 8049150:	ff 25 3c 5f 06 08    	jmp    *0x8065f3c
 8049156:	68 88 00 00 00       	push   $0x88
 804915b:	e9 d0 fe ff ff       	jmp    8049030 <_init+0x30>

08049160 <read@plt>:
 8049160:	ff 25 40 5f 06 08    	jmp    *0x8065f40
 8049166:	68 90 00 00 00       	push   $0x90
 804916b:	e9 c0 fe ff ff       	jmp    8049030 <_init+0x30>

08049170 <strtoll@plt>:
 8049170:	ff 25 44 5f 06 08    	jmp    *0x8065f44
 8049176:	68 98 00 00 00       	push   $0x98
 804917b:	e9 b0 fe ff ff       	jmp    8049030 <_init+0x30>

08049180 <strtol@plt>:
 8049180:	ff 25 48 5f 06 08    	jmp    *0x8065f48
 8049186:	68 a0 00 00 00       	push   $0xa0
 804918b:	e9 a0 fe ff ff       	jmp    8049030 <_init+0x30>

08049190 <pthread_create@plt>:
 8049190:	ff 25 4c 5f 06 08    	jmp    *0x8065f4c
 8049196:	68 a8 00 00 00       	push   $0xa8
 804919b:	e9 90 fe ff ff       	jmp    8049030 <_init+0x30>

080491a0 <free@plt>:
 80491a0:	ff 25 50 5f 06 08    	jmp    *0x8065f50
 80491a6:	68 b0 00 00 00       	push   $0xb0
 80491ab:	e9 80 fe ff ff       	jmp    8049030 <_init+0x30>

080491b0 <strtoull@plt>:
 80491b0:	ff 25 54 5f 06 08    	jmp    *0x8065f54
 80491b6:	68 b8 00 00 00       	push   $0xb8
 80491bb:	e9 70 fe ff ff       	jmp    8049030 <_init+0x30>

080491c0 <sigaction@plt>:
 80491c0:	ff 25 58 5f 06 08    	jmp    *0x8065f58
 80491c6:	68 c0 00 00 00       	push   $0xc0
 80491cb:	e9 60 fe ff ff       	jmp    8049030 <_init+0x30>

080491d0 <__vfprintf_chk@plt>:
 80491d0:	ff 25 5c 5f 06 08    	jmp    *0x8065f5c
 80491d6:	68 c8 00 00 00       	push   $0xc8
 80491db:	e9 50 fe ff ff       	jmp    8049030 <_init+0x30>

080491e0 <ioctl@plt>:
 80491e0:	ff 25 60 5f 06 08    	jmp    *0x8065f60
 80491e6:	68 d0 00 00 00       	push   $0xd0
 80491eb:	e9 40 fe ff ff       	jmp    8049030 <_init+0x30>

080491f0 <__ctype_b_loc@plt>:
 80491f0:	ff 25 64 5f 06 08    	jmp    *0x8065f64
 80491f6:	68 d8 00 00 00       	push   $0xd8
 80491fb:	e9 30 fe ff ff       	jmp    8049030 <_init+0x30>

08049200 <pthread_mutex_unlock@plt>:
 8049200:	ff 25 68 5f 06 08    	jmp    *0x8065f68
 8049206:	68 e0 00 00 00       	push   $0xe0
 804920b:	e9 20 fe ff ff       	jmp    8049030 <_init+0x30>

08049210 <isatty@plt>:
 8049210:	ff 25 6c 5f 06 08    	jmp    *0x8065f6c
 8049216:	68 e8 00 00 00       	push   $0xe8
 804921b:	e9 10 fe ff ff       	jmp    8049030 <_init+0x30>

08049220 <nanosleep@plt>:
 8049220:	ff 25 70 5f 06 08    	jmp    *0x8065f70
 8049226:	68 f0 00 00 00       	push   $0xf0
 804922b:	e9 00 fe ff ff       	jmp    8049030 <_init+0x30>

08049230 <strtoul@plt>:
 8049230:	ff 25 74 5f 06 08    	jmp    *0x8065f74
 8049236:	68 f8 00 00 00       	push   $0xf8
 804923b:	e9 f0 fd ff ff       	jmp    8049030 <_init+0x30>

08049240 <strlen@plt>:
 8049240:	ff 25 78 5f 06 08    	jmp    *0x8065f78
 8049246:	68 00 01 00 00       	push   $0x100
 804924b:	e9 e0 fd ff ff       	jmp    8049030 <_init+0x30>

08049250 <strcpy@plt>:
 8049250:	ff 25 7c 5f 06 08    	jmp    *0x8065f7c
 8049256:	68 08 01 00 00       	push   $0x108
 804925b:	e9 d0 fd ff ff       	jmp    8049030 <_init+0x30>

08049260 <pthread_detach@plt>:
 8049260:	ff 25 80 5f 06 08    	jmp    *0x8065f80
 8049266:	68 10 01 00 00       	push   $0x110
 804926b:	e9 c0 fd ff ff       	jmp    8049030 <_init+0x30>

08049270 <__strcpy_chk@plt>:
 8049270:	ff 25 84 5f 06 08    	jmp    *0x8065f84
 8049276:	68 18 01 00 00       	push   $0x118
 804927b:	e9 b0 fd ff ff       	jmp    8049030 <_init+0x30>

08049280 <pthread_cancel@plt>:
 8049280:	ff 25 88 5f 06 08    	jmp    *0x8065f88
 8049286:	68 20 01 00 00       	push   $0x120
 804928b:	e9 a0 fd ff ff       	jmp    8049030 <_init+0x30>

08049290 <strcasecmp@plt>:
 8049290:	ff 25 8c 5f 06 08    	jmp    *0x8065f8c
 8049296:	68 28 01 00 00       	push   $0x128
 804929b:	e9 90 fd ff ff       	jmp    8049030 <_init+0x30>

080492a0 <select@plt>:
 80492a0:	ff 25 90 5f 06 08    	jmp    *0x8065f90
 80492a6:	68 30 01 00 00       	push   $0x130
 80492ab:	e9 80 fd ff ff       	jmp    8049030 <_init+0x30>

080492b0 <srandom@plt>:
 80492b0:	ff 25 94 5f 06 08    	jmp    *0x8065f94
 80492b6:	68 38 01 00 00       	push   $0x138
 80492bb:	e9 70 fd ff ff       	jmp    8049030 <_init+0x30>

080492c0 <close@plt>:
 80492c0:	ff 25 98 5f 06 08    	jmp    *0x8065f98
 80492c6:	68 40 01 00 00       	push   $0x140
 80492cb:	e9 60 fd ff ff       	jmp    8049030 <_init+0x30>

080492d0 <setvbuf@plt>:
 80492d0:	ff 25 9c 5f 06 08    	jmp    *0x8065f9c
 80492d6:	68 48 01 00 00       	push   $0x148
 80492db:	e9 50 fd ff ff       	jmp    8049030 <_init+0x30>

080492e0 <malloc@plt>:
 80492e0:	ff 25 a0 5f 06 08    	jmp    *0x8065fa0
 80492e6:	68 50 01 00 00       	push   $0x150
 80492eb:	e9 40 fd ff ff       	jmp    8049030 <_init+0x30>

080492f0 <pthread_mutex_lock@plt>:
 80492f0:	ff 25 a4 5f 06 08    	jmp    *0x8065fa4
 80492f6:	68 58 01 00 00       	push   $0x158
 80492fb:	e9 30 fd ff ff       	jmp    8049030 <_init+0x30>

08049300 <__stack_chk_fail@plt>:
 8049300:	ff 25 a8 5f 06 08    	jmp    *0x8065fa8
 8049306:	68 60 01 00 00       	push   $0x160
 804930b:	e9 20 fd ff ff       	jmp    8049030 <_init+0x30>

08049310 <strnlen@plt>:
 8049310:	ff 25 ac 5f 06 08    	jmp    *0x8065fac
 8049316:	68 68 01 00 00       	push   $0x168
 804931b:	e9 10 fd ff ff       	jmp    8049030 <_init+0x30>

08049320 <sleep@plt>:
 8049320:	ff 25 b0 5f 06 08    	jmp    *0x8065fb0
 8049326:	68 70 01 00 00       	push   $0x170
 804932b:	e9 00 fd ff ff       	jmp    8049030 <_init+0x30>

08049330 <pthread_cond_wait@plt>:
 8049330:	ff 25 b4 5f 06 08    	jmp    *0x8065fb4
 8049336:	68 78 01 00 00       	push   $0x178
 804933b:	e9 f0 fc ff ff       	jmp    8049030 <_init+0x30>

08049340 <strncasecmp@plt>:
 8049340:	ff 25 b8 5f 06 08    	jmp    *0x8065fb8
 8049346:	68 80 01 00 00       	push   $0x180
 804934b:	e9 e0 fc ff ff       	jmp    8049030 <_init+0x30>

08049350 <memchr@plt>:
 8049350:	ff 25 bc 5f 06 08    	jmp    *0x8065fbc
 8049356:	68 88 01 00 00       	push   $0x188
 804935b:	e9 d0 fc ff ff       	jmp    8049030 <_init+0x30>

08049360 <__snprintf_chk@plt>:
 8049360:	ff 25 c0 5f 06 08    	jmp    *0x8065fc0
 8049366:	68 90 01 00 00       	push   $0x190
 804936b:	e9 c0 fc ff ff       	jmp    8049030 <_init+0x30>

08049370 <__pthread_unwind_next@plt>:
 8049370:	ff 25 c4 5f 06 08    	jmp    *0x8065fc4
 8049376:	68 98 01 00 00       	push   $0x198
 804937b:	e9 b0 fc ff ff       	jmp    8049030 <_init+0x30>

08049380 <snprintf@plt>:
 8049380:	ff 25 c8 5f 06 08    	jmp    *0x8065fc8
 8049386:	68 a0 01 00 00       	push   $0x1a0
 804938b:	e9 a0 fc ff ff       	jmp    8049030 <_init+0x30>

08049390 <__pthread_register_cancel@plt>:
 8049390:	ff 25 cc 5f 06 08    	jmp    *0x8065fcc
 8049396:	68 a8 01 00 00       	push   $0x1a8
 804939b:	e9 90 fc ff ff       	jmp    8049030 <_init+0x30>

080493a0 <__libc_start_main@plt>:
 80493a0:	ff 25 d0 5f 06 08    	jmp    *0x8065fd0
 80493a6:	68 b0 01 00 00       	push   $0x1b0
 80493ab:	e9 80 fc ff ff       	jmp    8049030 <_init+0x30>

080493b0 <pthread_cond_broadcast@plt>:
 80493b0:	ff 25 d4 5f 06 08    	jmp    *0x8065fd4
 80493b6:	68 b8 01 00 00       	push   $0x1b8
 80493bb:	e9 70 fc ff ff       	jmp    8049030 <_init+0x30>

080493c0 <strcmp@plt>:
 80493c0:	ff 25 d8 5f 06 08    	jmp    *0x8065fd8
 80493c6:	68 c0 01 00 00       	push   $0x1c0
 80493cb:	e9 60 fc ff ff       	jmp    8049030 <_init+0x30>

080493d0 <__sigsetjmp@plt>:
 80493d0:	ff 25 dc 5f 06 08    	jmp    *0x8065fdc
 80493d6:	68 c8 01 00 00       	push   $0x1c8
 80493db:	e9 50 fc ff ff       	jmp    8049030 <_init+0x30>

080493e0 <exit@plt>:
 80493e0:	ff 25 e0 5f 06 08    	jmp    *0x8065fe0
 80493e6:	68 d0 01 00 00       	push   $0x1d0
 80493eb:	e9 40 fc ff ff       	jmp    8049030 <_init+0x30>

080493f0 <pthread_self@plt>:
 80493f0:	ff 25 e4 5f 06 08    	jmp    *0x8065fe4
 80493f6:	68 d8 01 00 00       	push   $0x1d8
 80493fb:	e9 30 fc ff ff       	jmp    8049030 <_init+0x30>

08049400 <__fdelt_chk@plt>:
 8049400:	ff 25 e8 5f 06 08    	jmp    *0x8065fe8
 8049406:	68 e0 01 00 00       	push   $0x1e0
 804940b:	e9 20 fc ff ff       	jmp    8049030 <_init+0x30>

Disassembly of section .plt.got:

08049410 <__cxa_finalize@plt>:
 8049410:	ff 25 f8 5f 06 08    	jmp    *0x8065ff8
 8049416:	66 90                	xchg   %ax,%ax

Disassembly of section .text:

08049420 <_start>:
 8049420:	f3 0f 1e fb          	endbr32 
 8049424:	31 ed                	xor    %ebp,%ebp
 8049426:	5e                   	pop    %esi
 8049427:	89 e1                	mov    %esp,%ecx
 8049429:	83 e4 f0             	and    $0xfffffff0,%esp
 804942c:	50                   	push   %eax
 804942d:	54                   	push   %esp
 804942e:	52                   	push   %edx
 804942f:	e8 18 00 00 00       	call   804944c <_start+0x2c>
 8049434:	81 c3 b8 ca 01 00    	add    $0x1cab8,%ebx
 804943a:	6a 00                	push   $0x0
 804943c:	6a 00                	push   $0x0
 804943e:	51                   	push   %ecx
 804943f:	56                   	push   %esi
 8049440:	ff b3 10 01 00 00    	push   0x110(%ebx)
 8049446:	e8 55 ff ff ff       	call   80493a0 <__libc_start_main@plt>
 804944b:	f4                   	hlt    
 804944c:	8b 1c 24             	mov    (%esp),%ebx
 804944f:	c3                   	ret    

08049450 <__x86.get_pc_thunk.bx>:
 8049450:	8b 1c 24             	mov    (%esp),%ebx
 8049453:	c3                   	ret    
 8049454:	66 90                	xchg   %ax,%ax
 8049456:	66 90                	xchg   %ax,%ax
 8049458:	66 90                	xchg   %ax,%ax
 804945a:	66 90                	xchg   %ax,%ax
 804945c:	66 90                	xchg   %ax,%ax
 804945e:	66 90                	xchg   %ax,%ax

08049460 <deregister_tm_clones>:
 8049460:	e8 f2 03 00 00       	call   8049857 <__x86.get_pc_thunk.dx>
 8049465:	81 c2 87 ca 01 00    	add    $0x1ca87,%edx
 804946b:	8d 8a 00 15 00 00    	lea    0x1500(%edx),%ecx
 8049471:	8d 82 00 15 00 00    	lea    0x1500(%edx),%eax
 8049477:	39 c8                	cmp    %ecx,%eax
 8049479:	74 1d                	je     8049498 <deregister_tm_clones+0x38>
 804947b:	8b 82 04 01 00 00    	mov    0x104(%edx),%eax
 8049481:	85 c0                	test   %eax,%eax
 8049483:	74 13                	je     8049498 <deregister_tm_clones+0x38>
 8049485:	55                   	push   %ebp
 8049486:	89 e5                	mov    %esp,%ebp
 8049488:	83 ec 14             	sub    $0x14,%esp
 804948b:	51                   	push   %ecx
 804948c:	ff d0                	call   *%eax
 804948e:	83 c4 10             	add    $0x10,%esp
 8049491:	c9                   	leave  
 8049492:	c3                   	ret    
 8049493:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 8049497:	90                   	nop
 8049498:	c3                   	ret    
 8049499:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

080494a0 <register_tm_clones>:
 80494a0:	e8 b2 03 00 00       	call   8049857 <__x86.get_pc_thunk.dx>
 80494a5:	81 c2 47 ca 01 00    	add    $0x1ca47,%edx
 80494ab:	55                   	push   %ebp
 80494ac:	89 e5                	mov    %esp,%ebp
 80494ae:	53                   	push   %ebx
 80494af:	8d 8a 00 15 00 00    	lea    0x1500(%edx),%ecx
 80494b5:	8d 82 00 15 00 00    	lea    0x1500(%edx),%eax
 80494bb:	83 ec 04             	sub    $0x4,%esp
 80494be:	29 c8                	sub    %ecx,%eax
 80494c0:	89 c3                	mov    %eax,%ebx
 80494c2:	c1 e8 1f             	shr    $0x1f,%eax
 80494c5:	c1 fb 02             	sar    $0x2,%ebx
 80494c8:	01 d8                	add    %ebx,%eax
 80494ca:	d1 f8                	sar    %eax
 80494cc:	74 14                	je     80494e2 <register_tm_clones+0x42>
 80494ce:	8b 92 08 01 00 00    	mov    0x108(%edx),%edx
 80494d4:	85 d2                	test   %edx,%edx
 80494d6:	74 0a                	je     80494e2 <register_tm_clones+0x42>
 80494d8:	83 ec 08             	sub    $0x8,%esp
 80494db:	50                   	push   %eax
 80494dc:	51                   	push   %ecx
 80494dd:	ff d2                	call   *%edx
 80494df:	83 c4 10             	add    $0x10,%esp
 80494e2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 80494e5:	c9                   	leave  
 80494e6:	c3                   	ret    
 80494e7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 80494ee:	66 90                	xchg   %ax,%ax

080494f0 <__do_global_dtors_aux>:
 80494f0:	f3 0f 1e fb          	endbr32 
 80494f4:	55                   	push   %ebp
 80494f5:	89 e5                	mov    %esp,%ebp
 80494f7:	53                   	push   %ebx
 80494f8:	e8 53 ff ff ff       	call   8049450 <__x86.get_pc_thunk.bx>
 80494fd:	81 c3 ef c9 01 00    	add    $0x1c9ef,%ebx
 8049503:	83 ec 04             	sub    $0x4,%esp
 8049506:	80 bb c0 2b 00 00 00 	cmpb   $0x0,0x2bc0(%ebx)
 804950d:	75 27                	jne    8049536 <__do_global_dtors_aux+0x46>
 804950f:	8b 83 0c 01 00 00    	mov    0x10c(%ebx),%eax
 8049515:	85 c0                	test   %eax,%eax
 8049517:	74 11                	je     804952a <__do_global_dtors_aux+0x3a>
 8049519:	83 ec 0c             	sub    $0xc,%esp
 804951c:	ff b3 6c 14 00 00    	push   0x146c(%ebx)
 8049522:	e8 e9 fe ff ff       	call   8049410 <__cxa_finalize@plt>
 8049527:	83 c4 10             	add    $0x10,%esp
 804952a:	e8 31 ff ff ff       	call   8049460 <deregister_tm_clones>
 804952f:	c6 83 c0 2b 00 00 01 	movb   $0x1,0x2bc0(%ebx)
 8049536:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 8049539:	c9                   	leave  
 804953a:	c3                   	ret    
 804953b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 804953f:	90                   	nop

08049540 <frame_dummy>:
 8049540:	f3 0f 1e fb          	endbr32 
 8049544:	e9 57 ff ff ff       	jmp    80494a0 <register_tm_clones>
 8049549:	66 90                	xchg   %ax,%ax
 804954b:	66 90                	xchg   %ax,%ax
 804954d:	66 90                	xchg   %ax,%ax
 804954f:	90                   	nop

08049550 <__udivdi3>:
 8049550:	f3 0f 1e fb          	endbr32 
 8049554:	55                   	push   %ebp
 8049555:	57                   	push   %edi
 8049556:	56                   	push   %esi
 8049557:	53                   	push   %ebx
 8049558:	83 ec 1c             	sub    $0x1c,%esp
 804955b:	8b 44 24 3c          	mov    0x3c(%esp),%eax
 804955f:	8b 6c 24 30          	mov    0x30(%esp),%ebp
 8049563:	8b 74 24 34          	mov    0x34(%esp),%esi
 8049567:	8b 5c 24 38          	mov    0x38(%esp),%ebx
 804956b:	85 c0                	test   %eax,%eax
 804956d:	75 19                	jne    8049588 <__udivdi3+0x38>
 804956f:	39 f3                	cmp    %esi,%ebx
 8049571:	76 4d                	jbe    80495c0 <__udivdi3+0x70>
 8049573:	31 ff                	xor    %edi,%edi
 8049575:	89 e8                	mov    %ebp,%eax
 8049577:	89 f2                	mov    %esi,%edx
 8049579:	f7 f3                	div    %ebx
 804957b:	89 fa                	mov    %edi,%edx
 804957d:	83 c4 1c             	add    $0x1c,%esp
 8049580:	5b                   	pop    %ebx
 8049581:	5e                   	pop    %esi
 8049582:	5f                   	pop    %edi
 8049583:	5d                   	pop    %ebp
 8049584:	c3                   	ret    
 8049585:	8d 76 00             	lea    0x0(%esi),%esi
 8049588:	39 f0                	cmp    %esi,%eax
 804958a:	76 14                	jbe    80495a0 <__udivdi3+0x50>
 804958c:	31 ff                	xor    %edi,%edi
 804958e:	31 c0                	xor    %eax,%eax
 8049590:	89 fa                	mov    %edi,%edx
 8049592:	83 c4 1c             	add    $0x1c,%esp
 8049595:	5b                   	pop    %ebx
 8049596:	5e                   	pop    %esi
 8049597:	5f                   	pop    %edi
 8049598:	5d                   	pop    %ebp
 8049599:	c3                   	ret    
 804959a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 80495a0:	0f bd f8             	bsr    %eax,%edi
 80495a3:	83 f7 1f             	xor    $0x1f,%edi
 80495a6:	75 48                	jne    80495f0 <__udivdi3+0xa0>
 80495a8:	39 f0                	cmp    %esi,%eax
 80495aa:	72 06                	jb     80495b2 <__udivdi3+0x62>
 80495ac:	31 c0                	xor    %eax,%eax
 80495ae:	39 eb                	cmp    %ebp,%ebx
 80495b0:	77 de                	ja     8049590 <__udivdi3+0x40>
 80495b2:	b8 01 00 00 00       	mov    $0x1,%eax
 80495b7:	eb d7                	jmp    8049590 <__udivdi3+0x40>
 80495b9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 80495c0:	89 d9                	mov    %ebx,%ecx
 80495c2:	85 db                	test   %ebx,%ebx
 80495c4:	75 0b                	jne    80495d1 <__udivdi3+0x81>
 80495c6:	b8 01 00 00 00       	mov    $0x1,%eax
 80495cb:	31 d2                	xor    %edx,%edx
 80495cd:	f7 f3                	div    %ebx
 80495cf:	89 c1                	mov    %eax,%ecx
 80495d1:	31 d2                	xor    %edx,%edx
 80495d3:	89 f0                	mov    %esi,%eax
 80495d5:	f7 f1                	div    %ecx
 80495d7:	89 c6                	mov    %eax,%esi
 80495d9:	89 e8                	mov    %ebp,%eax
 80495db:	89 f7                	mov    %esi,%edi
 80495dd:	f7 f1                	div    %ecx
 80495df:	89 fa                	mov    %edi,%edx
 80495e1:	83 c4 1c             	add    $0x1c,%esp
 80495e4:	5b                   	pop    %ebx
 80495e5:	5e                   	pop    %esi
 80495e6:	5f                   	pop    %edi
 80495e7:	5d                   	pop    %ebp
 80495e8:	c3                   	ret    
 80495e9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 80495f0:	89 f9                	mov    %edi,%ecx
 80495f2:	ba 20 00 00 00       	mov    $0x20,%edx
 80495f7:	29 fa                	sub    %edi,%edx
 80495f9:	d3 e0                	shl    %cl,%eax
 80495fb:	89 44 24 08          	mov    %eax,0x8(%esp)
 80495ff:	89 d1                	mov    %edx,%ecx
 8049601:	89 d8                	mov    %ebx,%eax
 8049603:	d3 e8                	shr    %cl,%eax
 8049605:	8b 4c 24 08          	mov    0x8(%esp),%ecx
 8049609:	09 c1                	or     %eax,%ecx
 804960b:	89 f0                	mov    %esi,%eax
 804960d:	89 4c 24 08          	mov    %ecx,0x8(%esp)
 8049611:	89 f9                	mov    %edi,%ecx
 8049613:	d3 e3                	shl    %cl,%ebx
 8049615:	89 d1                	mov    %edx,%ecx
 8049617:	d3 e8                	shr    %cl,%eax
 8049619:	89 f9                	mov    %edi,%ecx
 804961b:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
 804961f:	89 eb                	mov    %ebp,%ebx
 8049621:	d3 e6                	shl    %cl,%esi
 8049623:	89 d1                	mov    %edx,%ecx
 8049625:	d3 eb                	shr    %cl,%ebx
 8049627:	09 f3                	or     %esi,%ebx
 8049629:	89 c6                	mov    %eax,%esi
 804962b:	89 f2                	mov    %esi,%edx
 804962d:	89 d8                	mov    %ebx,%eax
 804962f:	f7 74 24 08          	divl   0x8(%esp)
 8049633:	89 d6                	mov    %edx,%esi
 8049635:	89 c3                	mov    %eax,%ebx
 8049637:	f7 64 24 0c          	mull   0xc(%esp)
 804963b:	39 d6                	cmp    %edx,%esi
 804963d:	72 19                	jb     8049658 <__udivdi3+0x108>
 804963f:	89 f9                	mov    %edi,%ecx
 8049641:	d3 e5                	shl    %cl,%ebp
 8049643:	39 c5                	cmp    %eax,%ebp
 8049645:	73 04                	jae    804964b <__udivdi3+0xfb>
 8049647:	39 d6                	cmp    %edx,%esi
 8049649:	74 0d                	je     8049658 <__udivdi3+0x108>
 804964b:	89 d8                	mov    %ebx,%eax
 804964d:	31 ff                	xor    %edi,%edi
 804964f:	e9 3c ff ff ff       	jmp    8049590 <__udivdi3+0x40>
 8049654:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 8049658:	8d 43 ff             	lea    -0x1(%ebx),%eax
 804965b:	31 ff                	xor    %edi,%edi
 804965d:	e9 2e ff ff ff       	jmp    8049590 <__udivdi3+0x40>
 8049662:	66 90                	xchg   %ax,%ax
 8049664:	66 90                	xchg   %ax,%ax
 8049666:	66 90                	xchg   %ax,%ax
 8049668:	66 90                	xchg   %ax,%ax
 804966a:	66 90                	xchg   %ax,%ax
 804966c:	66 90                	xchg   %ax,%ax
 804966e:	66 90                	xchg   %ax,%ax

08049670 <__udivmoddi4>:
 8049670:	f3 0f 1e fb          	endbr32 
 8049674:	55                   	push   %ebp
 8049675:	57                   	push   %edi
 8049676:	56                   	push   %esi
 8049677:	53                   	push   %ebx
 8049678:	83 ec 2c             	sub    $0x2c,%esp
 804967b:	8b 44 24 40          	mov    0x40(%esp),%eax
 804967f:	8b 5c 24 44          	mov    0x44(%esp),%ebx
 8049683:	8b 7c 24 4c          	mov    0x4c(%esp),%edi
 8049687:	8b 6c 24 48          	mov    0x48(%esp),%ebp
 804968b:	89 44 24 10          	mov    %eax,0x10(%esp)
 804968f:	89 da                	mov    %ebx,%edx
 8049691:	85 ff                	test   %edi,%edi
 8049693:	75 3b                	jne    80496d0 <__udivmoddi4+0x60>
 8049695:	39 dd                	cmp    %ebx,%ebp
 8049697:	0f 86 a3 00 00 00    	jbe    8049740 <__udivmoddi4+0xd0>
 804969d:	31 f6                	xor    %esi,%esi
 804969f:	f7 f5                	div    %ebp
 80496a1:	8b 7c 24 50          	mov    0x50(%esp),%edi
 80496a5:	89 44 24 0c          	mov    %eax,0xc(%esp)
 80496a9:	85 ff                	test   %edi,%edi
 80496ab:	74 0d                	je     80496ba <__udivmoddi4+0x4a>
 80496ad:	8b 44 24 50          	mov    0x50(%esp),%eax
 80496b1:	89 10                	mov    %edx,(%eax)
 80496b3:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
 80496ba:	8b 44 24 0c          	mov    0xc(%esp),%eax
 80496be:	89 f2                	mov    %esi,%edx
 80496c0:	83 c4 2c             	add    $0x2c,%esp
 80496c3:	5b                   	pop    %ebx
 80496c4:	5e                   	pop    %esi
 80496c5:	5f                   	pop    %edi
 80496c6:	5d                   	pop    %ebp
 80496c7:	c3                   	ret    
 80496c8:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 80496cf:	90                   	nop
 80496d0:	39 df                	cmp    %ebx,%edi
 80496d2:	76 34                	jbe    8049708 <__udivmoddi4+0x98>
 80496d4:	8b 74 24 50          	mov    0x50(%esp),%esi
 80496d8:	85 f6                	test   %esi,%esi
 80496da:	0f 84 40 01 00 00    	je     8049820 <__udivmoddi4+0x1b0>
 80496e0:	8b 44 24 50          	mov    0x50(%esp),%eax
 80496e4:	8b 74 24 10          	mov    0x10(%esp),%esi
 80496e8:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
 80496ef:	00 
 80496f0:	89 30                	mov    %esi,(%eax)
 80496f2:	31 f6                	xor    %esi,%esi
 80496f4:	89 58 04             	mov    %ebx,0x4(%eax)
 80496f7:	8b 44 24 0c          	mov    0xc(%esp),%eax
 80496fb:	89 f2                	mov    %esi,%edx
 80496fd:	83 c4 2c             	add    $0x2c,%esp
 8049700:	5b                   	pop    %ebx
 8049701:	5e                   	pop    %esi
 8049702:	5f                   	pop    %edi
 8049703:	5d                   	pop    %ebp
 8049704:	c3                   	ret    
 8049705:	8d 76 00             	lea    0x0(%esi),%esi
 8049708:	0f bd f7             	bsr    %edi,%esi
 804970b:	83 f6 1f             	xor    $0x1f,%esi
 804970e:	75 60                	jne    8049770 <__udivmoddi4+0x100>
 8049710:	39 df                	cmp    %ebx,%edi
 8049712:	0f 82 18 01 00 00    	jb     8049830 <__udivmoddi4+0x1c0>
 8049718:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
 804971f:	00 
 8049720:	3b 6c 24 10          	cmp    0x10(%esp),%ebp
 8049724:	0f 86 06 01 00 00    	jbe    8049830 <__udivmoddi4+0x1c0>
 804972a:	8b 4c 24 50          	mov    0x50(%esp),%ecx
 804972e:	85 c9                	test   %ecx,%ecx
 8049730:	74 88                	je     80496ba <__udivmoddi4+0x4a>
 8049732:	8b 7c 24 50          	mov    0x50(%esp),%edi
 8049736:	89 07                	mov    %eax,(%edi)
 8049738:	89 57 04             	mov    %edx,0x4(%edi)
 804973b:	e9 7a ff ff ff       	jmp    80496ba <__udivmoddi4+0x4a>
 8049740:	89 e9                	mov    %ebp,%ecx
 8049742:	85 ed                	test   %ebp,%ebp
 8049744:	75 0b                	jne    8049751 <__udivmoddi4+0xe1>
 8049746:	b8 01 00 00 00       	mov    $0x1,%eax
 804974b:	31 d2                	xor    %edx,%edx
 804974d:	f7 f5                	div    %ebp
 804974f:	89 c1                	mov    %eax,%ecx
 8049751:	89 d8                	mov    %ebx,%eax
 8049753:	31 d2                	xor    %edx,%edx
 8049755:	f7 f1                	div    %ecx
 8049757:	89 c3                	mov    %eax,%ebx
 8049759:	8b 44 24 10          	mov    0x10(%esp),%eax
 804975d:	89 de                	mov    %ebx,%esi
 804975f:	f7 f1                	div    %ecx
 8049761:	e9 3b ff ff ff       	jmp    80496a1 <__udivmoddi4+0x31>
 8049766:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 804976d:	8d 76 00             	lea    0x0(%esi),%esi
 8049770:	ba 20 00 00 00       	mov    $0x20,%edx
 8049775:	89 f1                	mov    %esi,%ecx
 8049777:	89 e8                	mov    %ebp,%eax
 8049779:	29 f2                	sub    %esi,%edx
 804977b:	d3 e7                	shl    %cl,%edi
 804977d:	89 d1                	mov    %edx,%ecx
 804977f:	89 54 24 1c          	mov    %edx,0x1c(%esp)
 8049783:	d3 e8                	shr    %cl,%eax
 8049785:	89 f1                	mov    %esi,%ecx
 8049787:	d3 e5                	shl    %cl,%ebp
 8049789:	89 d1                	mov    %edx,%ecx
 804978b:	09 c7                	or     %eax,%edi
 804978d:	89 d0                	mov    %edx,%eax
 804978f:	89 6c 24 0c          	mov    %ebp,0xc(%esp)
 8049793:	89 dd                	mov    %ebx,%ebp
 8049795:	d3 ed                	shr    %cl,%ebp
 8049797:	89 f1                	mov    %esi,%ecx
 8049799:	89 ea                	mov    %ebp,%edx
 804979b:	8b 6c 24 10          	mov    0x10(%esp),%ebp
 804979f:	d3 e3                	shl    %cl,%ebx
 80497a1:	89 c1                	mov    %eax,%ecx
 80497a3:	8b 44 24 10          	mov    0x10(%esp),%eax
 80497a7:	d3 ed                	shr    %cl,%ebp
 80497a9:	89 f1                	mov    %esi,%ecx
 80497ab:	09 dd                	or     %ebx,%ebp
 80497ad:	d3 e0                	shl    %cl,%eax
 80497af:	89 44 24 18          	mov    %eax,0x18(%esp)
 80497b3:	89 e8                	mov    %ebp,%eax
 80497b5:	f7 f7                	div    %edi
 80497b7:	89 d3                	mov    %edx,%ebx
 80497b9:	89 c1                	mov    %eax,%ecx
 80497bb:	89 c5                	mov    %eax,%ebp
 80497bd:	f7 64 24 0c          	mull   0xc(%esp)
 80497c1:	89 44 24 10          	mov    %eax,0x10(%esp)
 80497c5:	89 54 24 14          	mov    %edx,0x14(%esp)
 80497c9:	39 d3                	cmp    %edx,%ebx
 80497cb:	72 08                	jb     80497d5 <__udivmoddi4+0x165>
 80497cd:	75 17                	jne    80497e6 <__udivmoddi4+0x176>
 80497cf:	39 44 24 18          	cmp    %eax,0x18(%esp)
 80497d3:	73 11                	jae    80497e6 <__udivmoddi4+0x176>
 80497d5:	2b 44 24 0c          	sub    0xc(%esp),%eax
 80497d9:	19 fa                	sbb    %edi,%edx
 80497db:	89 54 24 14          	mov    %edx,0x14(%esp)
 80497df:	8d 69 ff             	lea    -0x1(%ecx),%ebp
 80497e2:	89 44 24 10          	mov    %eax,0x10(%esp)
 80497e6:	8b 44 24 50          	mov    0x50(%esp),%eax
 80497ea:	89 6c 24 0c          	mov    %ebp,0xc(%esp)
 80497ee:	85 c0                	test   %eax,%eax
 80497f0:	74 5e                	je     8049850 <__udivmoddi4+0x1e0>
 80497f2:	0f b6 4c 24 1c       	movzbl 0x1c(%esp),%ecx
 80497f7:	8b 44 24 18          	mov    0x18(%esp),%eax
 80497fb:	2b 44 24 10          	sub    0x10(%esp),%eax
 80497ff:	1b 5c 24 14          	sbb    0x14(%esp),%ebx
 8049803:	89 da                	mov    %ebx,%edx
 8049805:	d3 e2                	shl    %cl,%edx
 8049807:	89 f1                	mov    %esi,%ecx
 8049809:	31 f6                	xor    %esi,%esi
 804980b:	d3 e8                	shr    %cl,%eax
 804980d:	d3 eb                	shr    %cl,%ebx
 804980f:	09 c2                	or     %eax,%edx
 8049811:	8b 44 24 50          	mov    0x50(%esp),%eax
 8049815:	89 10                	mov    %edx,(%eax)
 8049817:	89 58 04             	mov    %ebx,0x4(%eax)
 804981a:	e9 9b fe ff ff       	jmp    80496ba <__udivmoddi4+0x4a>
 804981f:	90                   	nop
 8049820:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
 8049827:	00 
 8049828:	31 f6                	xor    %esi,%esi
 804982a:	e9 8b fe ff ff       	jmp    80496ba <__udivmoddi4+0x4a>
 804982f:	90                   	nop
 8049830:	8b 44 24 10          	mov    0x10(%esp),%eax
 8049834:	89 da                	mov    %ebx,%edx
 8049836:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
 804983d:	00 
 804983e:	29 e8                	sub    %ebp,%eax
 8049840:	19 fa                	sbb    %edi,%edx
 8049842:	e9 e3 fe ff ff       	jmp    804972a <__udivmoddi4+0xba>
 8049847:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 804984e:	66 90                	xchg   %ax,%ax
 8049850:	31 f6                	xor    %esi,%esi
 8049852:	e9 63 fe ff ff       	jmp    80496ba <__udivmoddi4+0x4a>

08049857 <__x86.get_pc_thunk.dx>:
 8049857:	8b 14 24             	mov    (%esp),%edx
 804985a:	c3                   	ret    

0804985b <_posix_zephyr_main>:
#define SLEEP_TIME_MS 2000


VanInfo van_info;

int main() {
 804985b:	55                   	push   %ebp
 804985c:	89 e5                	mov    %esp,%ebp
 804985e:	57                   	push   %edi
 804985f:	56                   	push   %esi
 8049860:	83 ec 2c             	sub    $0x2c,%esp
 8049863:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 8049869:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804986c:	31 c0                	xor    %eax,%eax
	printk("Welcome to the OreCart Hardware Project!\r\n");
 804986e:	68 30 27 06 08       	push   $0x8062730
 8049873:	e8 49 06 00 00       	call   8049ec1 <printk>
 8049878:	83 c4 10             	add    $0x10,%esp
    int ret;

	server_module_init();
 804987b:	e8 9f 02 00 00       	call   8049b1f <server_module_init>

#if defined(CONFIG_NRF_MODEM_LIB)
	init_nrf9160_modem();
#endif

	struct VanInfo van_info = {
 8049880:	c7 45 f0 01 30 30 31 	movl   $0x31303001,-0x10(%ebp)
		union { struct { uintptr_t lo, hi; } split; k_timeout_t val; } parm0 = { .val = timeout };
		return (int32_t) arch_syscall_invoke2(parm0.split.lo, parm0.split.hi, K_SYSCALL_K_SLEEP);
	}
#endif
	compiler_barrier();
	return z_impl_k_sleep(timeout);
 8049887:	50                   	push   %eax
		k_sleep(K_SECONDS(15));
		// printk("Beep\r\n");
	#ifndef POSIX_MODE
		gpio_pin_toggle_dt(&led);
	#endif
		server_send_van_location(&van_info, (struct Location){.lat = 213.12, .lon=20.123}, 100);
 8049888:	8d 7d e0             	lea    -0x20(%ebp),%edi
 804988b:	be 00 23 06 08       	mov    $0x8062300,%esi
 8049890:	50                   	push   %eax
 8049891:	6a 00                	push   $0x0
 8049893:	68 dc 05 00 00       	push   $0x5dc
 8049898:	e8 01 6d 01 00       	call   806059e <z_impl_k_sleep>
 804989d:	83 c4 0c             	add    $0xc,%esp
 80498a0:	b9 04 00 00 00       	mov    $0x4,%ecx
 80498a5:	8d 45 f0             	lea    -0x10(%ebp),%eax
 80498a8:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
 80498aa:	6a 00                	push   $0x0
 80498ac:	8d 75 e0             	lea    -0x20(%ebp),%esi
 80498af:	b9 04 00 00 00       	mov    $0x4,%ecx
 80498b4:	6a 64                	push   $0x64
 80498b6:	83 ec 10             	sub    $0x10,%esp
 80498b9:	89 e7                	mov    %esp,%edi
 80498bb:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
 80498bd:	50                   	push   %eax
 80498be:	e8 8e 02 00 00       	call   8049b51 <server_send_van_location>
 80498c3:	83 c4 20             	add    $0x20,%esp
	while (1) {
 80498c6:	eb bf                	jmp    8049887 <_posix_zephyr_main+0x2c>

080498c8 <on_http_response>:
	return 0;
}

static void on_http_response(struct http_response *rsp,
                        enum http_final_call final_data,
                        void *user_data) {
 80498c8:	55                   	push   %ebp
 80498c9:	89 e5                	mov    %esp,%ebp
 80498cb:	53                   	push   %ebx
 80498cc:	83 ec 10             	sub    $0x10,%esp
 80498cf:	8b 5d 10             	mov    0x10(%ebp),%ebx

    
    uint32_t inflight_index = (uint32_t)user_data;
    close(inflight_requests[inflight_index]->sock);
 80498d2:	8b 04 9d 10 89 06 08 	mov    0x8068910(,%ebx,4),%eax
 80498d9:	8b 80 48 01 00 00    	mov    0x148(%eax),%eax
		union { uintptr_t x; int val; } parm0 = { .val = sock };
		return (int) arch_syscall_invoke1(parm0.x, K_SYSCALL_ZSOCK_CLOSE);
	}
#endif
	compiler_barrier();
	return z_impl_zsock_close(sock);
 80498df:	50                   	push   %eax
 80498e0:	e8 d9 20 00 00       	call   804b9be <z_impl_zsock_close>
 80498e5:	58                   	pop    %eax
    free(inflight_requests[inflight_index]);
 80498e6:	ff 34 9d 10 89 06 08 	push   0x8068910(,%ebx,4)
 80498ed:	e8 ae f8 ff ff       	call   80491a0 <free@plt>
 80498f2:	83 c4 10             	add    $0x10,%esp
    inflight_requests[inflight_index] = NULL;
 80498f5:	c7 04 9d 10 89 06 08 	movl   $0x0,0x8068910(,%ebx,4)
 80498fc:	00 00 00 00 
		(void) arch_syscall_invoke1(parm0.x, K_SYSCALL_K_SEM_GIVE);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_sem_give(sem);
 8049900:	c7 45 08 e8 75 06 08 	movl   $0x80675e8,0x8(%ebp)
    k_sem_give(&http_requests_sem);
}
 8049907:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 804990a:	c9                   	leave  
 804990b:	e9 3a 5d 01 00       	jmp    805f64a <z_impl_k_sem_give>

08049910 <server_work_handler>:


// Process queue items, send them over to the server.
static void server_work_handler(struct k_work* work) {
 8049910:	55                   	push   %ebp
 8049911:	89 e5                	mov    %esp,%ebp
 8049913:	57                   	push   %edi
 8049914:	56                   	push   %esi
 8049915:	53                   	push   %ebx
 8049916:	83 ec 74             	sub    $0x74,%esp
 8049919:	8b 5d 08             	mov    0x8(%ebp),%ebx
 804991c:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 8049922:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 8049925:	31 c0                	xor    %eax,%eax
	return z_impl_k_sleep(timeout);
 8049927:	6a 00                	push   $0x0
 8049929:	68 90 01 00 00       	push   $0x190
 804992e:	e8 6b 6c 01 00       	call   806059e <z_impl_k_sleep>
    k_sleep(K_SECONDS(4));
    printk("New work handle called.\r\n");
 8049933:	c7 04 24 5b 27 06 08 	movl   $0x806275b,(%esp)
 804993a:	e8 82 05 00 00       	call   8049ec1 <printk>
 804993f:	83 c4 0c             	add    $0xc,%esp
	return z_impl_k_sem_take(sem, timeout);
 8049942:	6a ff                	push   $0xffffffff
 8049944:	6a ff                	push   $0xffffffff
 8049946:	68 e8 75 06 08       	push   $0x80675e8
 804994b:	e8 62 5d 01 00       	call   805f6b2 <z_impl_k_sem_take>

    // Semaphore limits inflight requests, this makes us wait
    // if there are still requests that haven't been handled.
    k_sem_take(&http_requests_sem, K_FOREVER); // TODO: Add some sane timeout.

    printk("Got past semaphore.\r\n");
 8049950:	c7 04 24 75 27 06 08 	movl   $0x8062775,(%esp)
 8049957:	e8 65 05 00 00       	call   8049ec1 <printk>
 804995c:	83 c4 10             	add    $0x10,%esp
        work, struct OreCartRequest, work
    );

    // Pick first available buffer (TODO: THIS IS NOT THREAD SAFE YET!!!!)
    uint32_t i = 0;
    while (inflight_requests[i] != NULL) {
 804995f:	83 3d 10 89 06 08 00 	cmpl   $0x0,0x8068910
 8049966:	74 1d                	je     8049985 <server_work_handler+0x75>
 8049968:	83 3d 14 89 06 08 00 	cmpl   $0x0,0x8068914
 804996f:	74 18                	je     8049989 <server_work_handler+0x79>
 8049971:	83 3d 18 89 06 08 00 	cmpl   $0x0,0x8068918
        i++;
 8049978:	be 02 00 00 00       	mov    $0x2,%esi
    while (inflight_requests[i] != NULL) {
 804997d:	0f 85 83 01 00 00    	jne    8049b06 <server_work_handler+0x1f6>
 8049983:	eb 09                	jmp    804998e <server_work_handler+0x7e>
    uint32_t i = 0;
 8049985:	31 f6                	xor    %esi,%esi
 8049987:	eb 05                	jmp    804998e <server_work_handler+0x7e>
        i++;
 8049989:	be 01 00 00 00       	mov    $0x1,%esi

    struct http_request* http_req = &request->http_req;

    http_req->response = on_http_response;
    http_req->recv_buf_len = sizeof(MAX_RESP_LEN);
    http_req->recv_buf = request->resp_buffer;
 804998e:	8d 83 4c 01 00 00    	lea    0x14c(%ebx),%eax

    struct addrinfo *res;
	struct addrinfo hints = {
 8049994:	8d 7d 94             	lea    -0x6c(%ebp),%edi
 8049997:	b9 14 00 00 00       	mov    $0x14,%ecx
    http_req->response = on_http_response;
 804999c:	c7 83 ac 00 00 00 c8 	movl   $0x80498c8,0xac(%ebx)
 80499a3:	98 04 08 
    http_req->recv_buf = request->resp_buffer;
 80499a6:	89 83 b4 00 00 00    	mov    %eax,0xb4(%ebx)
	struct addrinfo hints = {
 80499ac:	31 c0                	xor    %eax,%eax
 80499ae:	f3 ab                	rep stos %eax,%es:(%edi)
/** POSIX wrapper for @ref zsock_getaddrinfo */
static inline int getaddrinfo(const char *host, const char *service,
			      const struct zsock_addrinfo *hints,
			      struct zsock_addrinfo **res)
{
	return zsock_getaddrinfo(host, service, hints, res);
 80499b0:	8d 45 88             	lea    -0x78(%ebp),%eax
    http_req->recv_buf_len = sizeof(MAX_RESP_LEN);
 80499b3:	c7 83 b8 00 00 00 04 	movl   $0x4,0xb8(%ebx)
 80499ba:	00 00 00 
 80499bd:	50                   	push   %eax
 80499be:	8d 45 94             	lea    -0x6c(%ebp),%eax
 80499c1:	50                   	push   %eax
 80499c2:	68 8b 27 06 08       	push   $0x806278b
 80499c7:	68 90 27 06 08       	push   $0x8062790
    inflight_requests[i] = request;
 80499cc:	89 1c b5 10 89 06 08 	mov    %ebx,0x8068910(,%esi,4)
	struct addrinfo hints = {
 80499d3:	c7 45 98 00 04 00 00 	movl   $0x400,-0x68(%ebp)
 80499da:	c7 45 a0 01 00 00 00 	movl   $0x1,-0x60(%ebp)
 80499e1:	e8 e7 17 00 00       	call   804b1cd <zsock_getaddrinfo>
 80499e6:	83 c4 10             	add    $0x10,%esp
		.ai_flags = AI_NUMERICSERV, /* Let getaddrinfo() set port */
		.ai_socktype = SOCK_STREAM,
	};

    int err = getaddrinfo(SERVER_HOST, SERVER_PORT, &hints, &res);
	if (err) {
 80499e9:	85 c0                	test   %eax,%eax
 80499eb:	74 13                	je     8049a00 <server_work_handler+0xf0>
		printk("getaddrinfo() failed, err %d\n", errno);
 80499ed:	e8 4e f6 ff ff       	call   8049040 <__errno_location@plt>
 80499f2:	53                   	push   %ebx
 80499f3:	53                   	push   %ebx
 80499f4:	ff 30                	push   (%eax)
 80499f6:	68 a6 27 06 08       	push   $0x80627a6
 80499fb:	e9 cc 00 00 00       	jmp    8049acc <server_work_handler+0x1bc>
	const sec_tag_t tls_sec_tag[] = {
 8049a00:	c7 45 90 2a 00 00 00 	movl   $0x2a,-0x70(%ebp)
		return 0;
	}

    err = tls_setup(request->sock);
 8049a07:	8b bb 48 01 00 00    	mov    0x148(%ebx),%edi
	verify = REQUIRED;
 8049a0d:	c7 45 8c 02 00 00 00 	movl   $0x2,-0x74(%ebp)
		union { uintptr_t x; socklen_t val; } parm4 = { .val = optlen };
		return (int) arch_syscall_invoke5(parm0.x, parm1.x, parm2.x, parm3.x, parm4.x, K_SYSCALL_ZSOCK_SETSOCKOPT);
	}
#endif
	compiler_barrier();
	return z_impl_zsock_setsockopt(sock, level, optname, optval, optlen);
 8049a14:	83 ec 0c             	sub    $0xc,%esp
 8049a17:	8d 45 8c             	lea    -0x74(%ebp),%eax
 8049a1a:	6a 04                	push   $0x4
 8049a1c:	50                   	push   %eax
 8049a1d:	6a 05                	push   $0x5
 8049a1f:	68 1a 01 00 00       	push   $0x11a
 8049a24:	57                   	push   %edi
 8049a25:	e8 00 33 00 00       	call   804cd2a <z_impl_zsock_setsockopt>
 8049a2a:	83 c4 20             	add    $0x20,%esp
	if (err) {
 8049a2d:	85 c0                	test   %eax,%eax
 8049a2f:	74 13                	je     8049a44 <server_work_handler+0x134>
		printk("Failed to setup peer verification, err %d\n", errno);
 8049a31:	e8 0a f6 ff ff       	call   8049040 <__errno_location@plt>
 8049a36:	51                   	push   %ecx
 8049a37:	51                   	push   %ecx
 8049a38:	ff 30                	push   (%eax)
 8049a3a:	68 c4 27 06 08       	push   $0x80627c4
 8049a3f:	e9 88 00 00 00       	jmp    8049acc <server_work_handler+0x1bc>
 8049a44:	83 ec 0c             	sub    $0xc,%esp
 8049a47:	8d 45 90             	lea    -0x70(%ebp),%eax
 8049a4a:	6a 04                	push   $0x4
 8049a4c:	50                   	push   %eax
 8049a4d:	6a 01                	push   $0x1
 8049a4f:	68 1a 01 00 00       	push   $0x11a
 8049a54:	57                   	push   %edi
 8049a55:	e8 d0 32 00 00       	call   804cd2a <z_impl_zsock_setsockopt>
 8049a5a:	83 c4 20             	add    $0x20,%esp
	if (err) {
 8049a5d:	85 c0                	test   %eax,%eax
 8049a5f:	74 10                	je     8049a71 <server_work_handler+0x161>
		printk("Failed to setup TLS sec tag, err %d\n", errno);
 8049a61:	e8 da f5 ff ff       	call   8049040 <__errno_location@plt>
 8049a66:	52                   	push   %edx
 8049a67:	52                   	push   %edx
 8049a68:	ff 30                	push   (%eax)
 8049a6a:	68 ef 27 06 08       	push   $0x80627ef
 8049a6f:	eb 5b                	jmp    8049acc <server_work_handler+0x1bc>
 8049a71:	83 ec 0c             	sub    $0xc,%esp
 8049a74:	6a 15                	push   $0x15
 8049a76:	68 90 27 06 08       	push   $0x8062790
 8049a7b:	6a 02                	push   $0x2
 8049a7d:	68 1a 01 00 00       	push   $0x11a
 8049a82:	57                   	push   %edi
 8049a83:	e8 a2 32 00 00       	call   804cd2a <z_impl_zsock_setsockopt>
 8049a88:	83 c4 20             	add    $0x20,%esp
	if (err) {
 8049a8b:	85 c0                	test   %eax,%eax
 8049a8d:	75 2f                	jne    8049abe <server_work_handler+0x1ae>
	if (err) {
        return;
    }

	err = connect(request->sock, res->ai_addr, res->ai_addrlen);
 8049a8f:	8b 45 88             	mov    -0x78(%ebp),%eax
 8049a92:	8b 48 14             	mov    0x14(%eax),%ecx
 8049a95:	8b 50 18             	mov    0x18(%eax),%edx
 8049a98:	8b 83 48 01 00 00    	mov    0x148(%ebx),%eax
	return z_impl_zsock_connect(sock, addr, addrlen);
 8049a9e:	57                   	push   %edi
 8049a9f:	51                   	push   %ecx
 8049aa0:	52                   	push   %edx
 8049aa1:	50                   	push   %eax
 8049aa2:	e8 84 21 00 00       	call   804bc2b <z_impl_zsock_connect>
 8049aa7:	83 c4 10             	add    $0x10,%esp
	if (err) {
 8049aaa:	85 c0                	test   %eax,%eax
 8049aac:	74 25                	je     8049ad3 <server_work_handler+0x1c3>
		printk("connect() failed, err: %d\n", errno);
 8049aae:	e8 8d f5 ff ff       	call   8049040 <__errno_location@plt>
 8049ab3:	51                   	push   %ecx
 8049ab4:	51                   	push   %ecx
 8049ab5:	ff 30                	push   (%eax)
 8049ab7:	68 3a 28 06 08       	push   $0x806283a
 8049abc:	eb 0e                	jmp    8049acc <server_work_handler+0x1bc>
		printk("Failed to setup TLS hostname, err %d\n", errno);
 8049abe:	e8 7d f5 ff ff       	call   8049040 <__errno_location@plt>
 8049ac3:	53                   	push   %ebx
 8049ac4:	53                   	push   %ebx
 8049ac5:	ff 30                	push   (%eax)
 8049ac7:	68 14 28 06 08       	push   $0x8062814
		printk("connect() failed, err: %d\n", errno);
 8049acc:	e8 f0 03 00 00       	call   8049ec1 <printk>
 8049ad1:	eb 30                	jmp    8049b03 <server_work_handler+0x1f3>
		return;
	}

    request->sock = socket(res->ai_family, SOCK_STREAM | SOCK_NATIVE_TLS, IPPROTO_TLS_1_2);
 8049ad3:	8b 45 88             	mov    -0x78(%ebp),%eax
 8049ad6:	8b 40 08             	mov    0x8(%eax),%eax
	return z_impl_zsock_socket(family, type, proto);
 8049ad9:	52                   	push   %edx
    struct http_request* http_req = &request->http_req;
 8049ada:	83 c3 10             	add    $0x10,%ebx
 8049add:	68 02 01 00 00       	push   $0x102
 8049ae2:	68 01 00 00 40       	push   $0x40000001
 8049ae7:	50                   	push   %eax
 8049ae8:	e8 f7 1d 00 00       	call   804b8e4 <z_impl_zsock_socket>
 8049aed:	83 c4 10             	add    $0x10,%esp
    request->sock = socket(res->ai_family, SOCK_STREAM | SOCK_NATIVE_TLS, IPPROTO_TLS_1_2);
 8049af0:	89 83 38 01 00 00    	mov    %eax,0x138(%ebx)
    int ret = http_client_req(request->sock, &request->http_req, TIMEOUT, (void*)i);
 8049af6:	56                   	push   %esi
 8049af7:	68 88 13 00 00       	push   $0x1388
 8049afc:	53                   	push   %ebx
 8049afd:	50                   	push   %eax
 8049afe:	e8 f2 41 01 00       	call   805dcf5 <http_client_req>
 8049b03:	83 c4 10             	add    $0x10,%esp
}
 8049b06:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8049b09:	65 2b 05 14 00 00 00 	sub    %gs:0x14,%eax
 8049b10:	74 05                	je     8049b17 <server_work_handler+0x207>
 8049b12:	e8 e9 f7 ff ff       	call   8049300 <__stack_chk_fail@plt>
 8049b17:	8d 65 f4             	lea    -0xc(%ebp),%esp
 8049b1a:	5b                   	pop    %ebx
 8049b1b:	5e                   	pop    %esi
 8049b1c:	5f                   	pop    %edi
 8049b1d:	5d                   	pop    %ebp
 8049b1e:	c3                   	ret    

08049b1f <server_module_init>:

void server_module_init() {
 8049b1f:	55                   	push   %ebp
 8049b20:	89 e5                	mov    %esp,%ebp
 8049b22:	83 ec 14             	sub    $0x14,%esp
    k_work_queue_init(&server_work_q);
 8049b25:	68 20 77 06 08       	push   $0x8067720
 8049b2a:	e8 70 60 01 00       	call   805fb9f <k_work_queue_init>

    k_work_queue_start(&server_work_q, server_stack_area,
 8049b2f:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 8049b36:	6a 05                	push   $0x5
 8049b38:	68 00 01 00 00       	push   $0x100
 8049b3d:	68 b8 8a 06 08       	push   $0x8068ab8
 8049b42:	68 20 77 06 08       	push   $0x8067720
 8049b47:	e8 66 60 01 00       	call   805fbb2 <k_work_queue_start>
 8049b4c:	83 c4 20             	add    $0x20,%esp
        K_THREAD_STACK_SIZEOF(server_stack_area), _PRIORITY,
        NULL
    );
}
 8049b4f:	c9                   	leave  
 8049b50:	c3                   	ret    

08049b51 <server_send_van_location>:

bool server_send_van_location(VanInfo* vanInfo, struct Location location, uint64_t ts) {
 8049b51:	55                   	push   %ebp
 8049b52:	89 e5                	mov    %esp,%ebp
 8049b54:	57                   	push   %edi
 8049b55:	56                   	push   %esi
 8049b56:	53                   	push   %ebx
 8049b57:	83 ec 38             	sub    $0x38,%esp
 8049b5a:	8b 75 1c             	mov    0x1c(%ebp),%esi
 8049b5d:	8b 7d 20             	mov    0x20(%ebp),%edi
    // This will need to stay allocated until the work is finished (ie: HTTP response received)
    OreCartRequest* request = malloc(sizeof(OreCartRequest));
 8049b60:	68 cc 01 00 00       	push   $0x1cc
 8049b65:	e8 76 f7 ff ff       	call   80492e0 <malloc@plt>

    printk("Sending location...\r\n");
 8049b6a:	c7 04 24 55 28 06 08 	movl   $0x8062855,(%esp)
    OreCartRequest* request = malloc(sizeof(OreCartRequest));
 8049b71:	89 c3                	mov    %eax,%ebx
    printk("Sending location...\r\n");
 8049b73:	e8 49 03 00 00       	call   8049ec1 <printk>
 8049b78:	83 c4 10             	add    $0x10,%esp

    // Handle memory allocation failure
    if (request == NULL) {
 8049b7b:	31 c0                	xor    %eax,%eax
 8049b7d:	85 db                	test   %ebx,%ebx
 8049b7f:	0f 84 38 01 00 00    	je     8049cbd <server_send_van_location+0x16c>
        return false;
    }
    printk("Allocation successful.\r\n");
 8049b85:	83 ec 0c             	sub    $0xc,%esp
 8049b88:	68 6b 28 06 08       	push   $0x806286b
 8049b8d:	e8 2f 03 00 00       	call   8049ec1 <printk>
        double lon;
        uint64_t ts;
    } payload;

    payload.van_id = vanInfo->van_id;
    payload.lat = location.lat;
 8049b92:	dd 45 0c             	fldl   0xc(%ebp)
    payload.van_id = vanInfo->van_id;
 8049b95:	8b 45 08             	mov    0x8(%ebp),%eax
 8049b98:	8a 00                	mov    (%eax),%al
    payload.lon = location.lon;
    payload.ts = ts;

    printk("Do Payload successful.\r\n");
 8049b9a:	c7 04 24 84 28 06 08 	movl   $0x8062884,(%esp)
    payload.lat = location.lat;
 8049ba1:	dd 5d d8             	fstpl  -0x28(%ebp)
    payload.lon = location.lon;
 8049ba4:	dd 45 14             	fldl   0x14(%ebp)
    payload.van_id = vanInfo->van_id;
 8049ba7:	88 45 d7             	mov    %al,-0x29(%ebp)
    payload.lon = location.lon;
 8049baa:	dd 5d e0             	fstpl  -0x20(%ebp)
    printk("Do Payload successful.\r\n");
 8049bad:	e8 0f 03 00 00       	call   8049ec1 <printk>

__fortify_function void *
__NTH (memcpy (void *__restrict __dest, const void *__restrict __src,
	       size_t __len))
{
  return __builtin___memcpy_chk (__dest, __src, __len,
 8049bb2:	dd 45 d8             	fldl   -0x28(%ebp)
 8049bb5:	8a 45 d7             	mov    -0x29(%ebp),%al


    memcpy(&request->payload, &payload, sizeof(struct VanLocationPayload));

    printk("Do Memcpy successful.\r\n");
 8049bb8:	c7 04 24 9d 28 06 08 	movl   $0x806289d,(%esp)
 8049bbf:	89 b3 fc 00 00 00    	mov    %esi,0xfc(%ebx)
 8049bc5:	88 83 e8 00 00 00    	mov    %al,0xe8(%ebx)
 8049bcb:	dd 9b ec 00 00 00    	fstpl  0xec(%ebx)
 8049bd1:	dd 45 e0             	fldl   -0x20(%ebp)
 8049bd4:	89 bb 00 01 00 00    	mov    %edi,0x100(%ebx)
 8049bda:	dd 9b f4 00 00 00    	fstpl  0xf4(%ebx)
 8049be0:	e8 dc 02 00 00       	call   8049ec1 <printk>
 8049be5:	59                   	pop    %ecx
 8049be6:	5e                   	pop    %esi
    
    // Construct the route url, we need to append the van id at the end
    request->url[0] = '\0';
    strcpy(request->url, SEND_VAN_LOCATION_ROUTE);
 8049be7:	8d b3 28 01 00 00    	lea    0x128(%ebx),%esi
#endif

__fortify_function char *
__NTH (strcpy (char *__restrict __dest, const char *__restrict __src))
{
  return __builtin___strcpy_chk (__dest, __src, __glibc_objsize (__dest));
 8049bed:	68 b5 28 06 08       	push   $0x80628b5
 8049bf2:	56                   	push   %esi
    request->url[0] = '\0';
 8049bf3:	c6 83 28 01 00 00 00 	movb   $0x0,0x128(%ebx)
 8049bfa:	e8 51 f6 ff ff       	call   8049250 <strcpy@plt>
 8049bff:	8b 45 08             	mov    0x8(%ebp),%eax
 8049c02:	83 c4 0c             	add    $0xc,%esp
 8049c05:	6a 20                	push   $0x20
 8049c07:	40                   	inc    %eax
 8049c08:	50                   	push   %eax
 8049c09:	56                   	push   %esi
 8049c0a:	e8 61 f6 ff ff       	call   8049270 <__strcpy_chk@plt>
    strcpy(request->url, vanInfo->van_id_str);

    printk("Do request url.\r\n");
 8049c0f:	c7 04 24 c0 28 06 08 	movl   $0x80628c0,(%esp)
 8049c16:	e8 a6 02 00 00       	call   8049ec1 <printk>
    memcpy(&request->payload, &payload, sizeof(struct VanLocationPayload));
 8049c1b:	8d 83 e8 00 00 00    	lea    0xe8(%ebx),%eax
    http_req->host = SERVER_HOST;
    http_req->protocol = PROTOCOL;
    http_req->payload_len = sizeof(struct VanLocationPayload);
    http_req->payload = request->payload;

    printk("HTTP REQ.\r\n");
 8049c21:	c7 04 24 d7 28 06 08 	movl   $0x80628d7,(%esp)
    memcpy(&request->payload, &payload, sizeof(struct VanLocationPayload));
 8049c28:	89 83 d8 00 00 00    	mov    %eax,0xd8(%ebx)
    http_req->method = HTTP_POST;
 8049c2e:	c7 83 a8 00 00 00 03 	movl   $0x3,0xa8(%ebx)
 8049c35:	00 00 00 
    http_req->url = request->url;
 8049c38:	89 b3 bc 00 00 00    	mov    %esi,0xbc(%ebx)
    http_req->host = SERVER_HOST;
 8049c3e:	c7 83 cc 00 00 00 90 	movl   $0x8062790,0xcc(%ebx)
 8049c45:	27 06 08 
    http_req->protocol = PROTOCOL;
 8049c48:	c7 83 c0 00 00 00 d2 	movl   $0x80628d2,0xc0(%ebx)
 8049c4f:	28 06 08 
    http_req->payload_len = sizeof(struct VanLocationPayload);
 8049c52:	c7 83 dc 00 00 00 1c 	movl   $0x1c,0xdc(%ebx)
 8049c59:	00 00 00 
    printk("HTTP REQ.\r\n");
 8049c5c:	e8 60 02 00 00       	call   8049ec1 <printk>
 8049c61:	5f                   	pop    %edi
 8049c62:	58                   	pop    %eax

    k_work_init( &request->work, server_work_handler);
 8049c63:	68 10 99 04 08       	push   $0x8049910
 8049c68:	53                   	push   %ebx
 8049c69:	e8 89 5e 01 00       	call   805faf7 <k_work_init>

    printk("WORK INIT.\r\n");
 8049c6e:	c7 04 24 e3 28 06 08 	movl   $0x80628e3,(%esp)
 8049c75:	e8 47 02 00 00       	call   8049ec1 <printk>
 8049c7a:	58                   	pop    %eax
 8049c7b:	5a                   	pop    %edx

    int err = k_work_submit_to_queue(&server_work_q, &request->work);
 8049c7c:	53                   	push   %ebx
 8049c7d:	68 20 77 06 08       	push   $0x8067720
 8049c82:	e8 e5 5e 01 00       	call   805fb6c <k_work_submit_to_queue>
 8049c87:	83 c4 10             	add    $0x10,%esp

    if (err) {
 8049c8a:	85 c0                	test   %eax,%eax
 8049c8c:	74 11                	je     8049c9f <server_send_van_location+0x14e>
}

__fortify_function int
printf (const char *__restrict __fmt, ...)
{
  return __printf_chk (__USE_FORTIFY_LEVEL - 1, __fmt, __va_arg_pack ());
 8049c8e:	52                   	push   %edx
 8049c8f:	50                   	push   %eax
 8049c90:	68 f0 28 06 08       	push   $0x80628f0
 8049c95:	6a 01                	push   $0x1
 8049c97:	e8 34 f4 ff ff       	call   80490d0 <__printf_chk@plt>
 8049c9c:	83 c4 10             	add    $0x10,%esp
        printf("err result: %i\r\n", err);
    }

    printk("END\r\n");
 8049c9f:	83 ec 0c             	sub    $0xc,%esp
 8049ca2:	68 01 29 06 08       	push   $0x8062901
 8049ca7:	e8 15 02 00 00       	call   8049ec1 <printk>

    printk("\r\n\r\n");
 8049cac:	c7 04 24 07 29 06 08 	movl   $0x8062907,(%esp)
 8049cb3:	e8 09 02 00 00       	call   8049ec1 <printk>
 8049cb8:	83 c4 10             	add    $0x10,%esp

    return true;
 8049cbb:	b0 01                	mov    $0x1,%al
}
 8049cbd:	8d 65 f4             	lea    -0xc(%ebp),%esp
 8049cc0:	5b                   	pop    %ebx
 8049cc1:	5e                   	pop    %esi
 8049cc2:	5f                   	pop    %edi
 8049cc3:	5d                   	pop    %ebp
 8049cc4:	c3                   	ret    

08049cc5 <_check_fd>:
	errno = ENFILE;
	return -1;
}

static int _check_fd(int fd)
{
 8049cc5:	55                   	push   %ebp
 8049cc6:	89 e5                	mov    %esp,%ebp
 8049cc8:	83 ec 08             	sub    $0x8,%esp
	if (fd < 0 || fd >= ARRAY_SIZE(fdtable)) {
 8049ccb:	83 f8 03             	cmp    $0x3,%eax
 8049cce:	77 0f                	ja     8049cdf <_check_fd+0x1a>
 *
 * @return Value of @a target.
 */
static inline atomic_val_t atomic_get(const atomic_t *target)
{
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
 8049cd0:	c1 e0 05             	shl    $0x5,%eax
 8049cd3:	8b 90 a8 77 06 08    	mov    0x80677a8(%eax),%edx
	if (!atomic_get(&fdtable[fd].refcount)) {
		errno = EBADF;
		return -1;
	}

	return 0;
 8049cd9:	31 c0                	xor    %eax,%eax
	if (!atomic_get(&fdtable[fd].refcount)) {
 8049cdb:	85 d2                	test   %edx,%edx
 8049cdd:	75 0e                	jne    8049ced <_check_fd+0x28>
		errno = EBADF;
 8049cdf:	e8 5c f3 ff ff       	call   8049040 <__errno_location@plt>
 8049ce4:	c7 00 09 00 00 00    	movl   $0x9,(%eax)
 8049cea:	83 c8 ff             	or     $0xffffffff,%eax
}
 8049ced:	c9                   	leave  
 8049cee:	c3                   	ret    

08049cef <z_fdtable_call_ioctl.constprop.0>:
 * @param vtable vtable containing ioctl function pointer
 * @param obj Object to call ioctl on
 * @param request ioctl request number
 * @param ... Variadic arguments to ioctl
 */
static inline int z_fdtable_call_ioctl(const struct fd_op_vtable *vtable, void *obj,
 8049cef:	55                   	push   %ebp
 8049cf0:	89 e5                	mov    %esp,%ebp
 8049cf2:	83 ec 0c             	sub    $0xc,%esp
				       unsigned long request, ...)
{
	va_list args;
	int res;

	va_start(args, request);
 8049cf5:	8d 45 14             	lea    0x14(%ebp),%eax
	res = vtable->ioctl(obj, request, args);
 8049cf8:	50                   	push   %eax
 8049cf9:	8b 45 08             	mov    0x8(%ebp),%eax
 8049cfc:	68 05 01 00 00       	push   $0x105
 8049d01:	ff 75 0c             	push   0xc(%ebp)
 8049d04:	ff 50 0c             	call   *0xc(%eax)
 8049d07:	83 c4 10             	add    $0x10,%esp
	va_end(args);

	return res;
}
 8049d0a:	c9                   	leave  
 8049d0b:	c3                   	ret    

08049d0c <z_get_fd_obj_and_vtable>:
	return entry->obj;
}

void *z_get_fd_obj_and_vtable(int fd, const struct fd_op_vtable **vtable,
			      struct k_mutex **lock)
{
 8049d0c:	55                   	push   %ebp
 8049d0d:	89 e5                	mov    %esp,%ebp
 8049d0f:	56                   	push   %esi
 8049d10:	53                   	push   %ebx
 8049d11:	8b 5d 08             	mov    0x8(%ebp),%ebx
 8049d14:	8b 75 10             	mov    0x10(%ebp),%esi
	struct fd_entry *entry;

	if (_check_fd(fd) < 0) {
 8049d17:	89 d8                	mov    %ebx,%eax
 8049d19:	e8 a7 ff ff ff       	call   8049cc5 <_check_fd>
 8049d1e:	89 c2                	mov    %eax,%edx
 8049d20:	31 c0                	xor    %eax,%eax
 8049d22:	85 d2                	test   %edx,%edx
 8049d24:	78 24                	js     8049d4a <z_get_fd_obj_and_vtable+0x3e>
		return NULL;
	}

	entry = &fdtable[fd];
	*vtable = entry->vtable;
 8049d26:	89 d8                	mov    %ebx,%eax
 8049d28:	8b 55 0c             	mov    0xc(%ebp),%edx
 8049d2b:	c1 e0 05             	shl    $0x5,%eax
 8049d2e:	8b 88 a4 77 06 08    	mov    0x80677a4(%eax),%ecx
 8049d34:	89 0a                	mov    %ecx,(%edx)

	if (lock) {
 8049d36:	85 f6                	test   %esi,%esi
 8049d38:	74 07                	je     8049d41 <z_get_fd_obj_and_vtable+0x35>
		*lock = &entry->lock;
 8049d3a:	05 ac 77 06 08       	add    $0x80677ac,%eax
 8049d3f:	89 06                	mov    %eax,(%esi)
	}

	return entry->obj;
 8049d41:	c1 e3 05             	shl    $0x5,%ebx
 8049d44:	8b 83 a0 77 06 08    	mov    0x80677a0(%ebx),%eax
}
 8049d4a:	5b                   	pop    %ebx
 8049d4b:	5e                   	pop    %esi
 8049d4c:	5d                   	pop    %ebp
 8049d4d:	c3                   	ret    

08049d4e <z_reserve_fd>:

int z_reserve_fd(void)
{
 8049d4e:	55                   	push   %ebp
 8049d4f:	89 e5                	mov    %esp,%ebp
 8049d51:	53                   	push   %ebx
 8049d52:	83 ec 08             	sub    $0x8,%esp
	return z_impl_k_mutex_lock(mutex, timeout);
 8049d55:	6a ff                	push   $0xffffffff
	for (fd = 0; fd < ARRAY_SIZE(fdtable); fd++) {
 8049d57:	31 db                	xor    %ebx,%ebx
 8049d59:	6a ff                	push   $0xffffffff
 8049d5b:	68 ac 75 06 08       	push   $0x80675ac
 8049d60:	e8 33 54 01 00       	call   805f198 <z_impl_k_mutex_lock>
 8049d65:	83 c4 10             	add    $0x10,%esp
 8049d68:	ba a8 77 06 08       	mov    $0x80677a8,%edx
 8049d6d:	89 d8                	mov    %ebx,%eax
 8049d6f:	c1 e0 05             	shl    $0x5,%eax
 8049d72:	8b 0a                	mov    (%edx),%ecx
		if (!atomic_get(&fdtable[fd].refcount)) {
 8049d74:	85 c9                	test   %ecx,%ecx
 8049d76:	74 19                	je     8049d91 <z_reserve_fd+0x43>
	for (fd = 0; fd < ARRAY_SIZE(fdtable); fd++) {
 8049d78:	43                   	inc    %ebx
 8049d79:	83 c2 20             	add    $0x20,%edx
 8049d7c:	83 fb 04             	cmp    $0x4,%ebx
 8049d7f:	75 ec                	jne    8049d6d <z_reserve_fd+0x1f>
	errno = ENFILE;
 8049d81:	e8 ba f2 ff ff       	call   8049040 <__errno_location@plt>
	return -1;
 8049d86:	83 cb ff             	or     $0xffffffff,%ebx
	errno = ENFILE;
 8049d89:	c7 00 17 00 00 00    	movl   $0x17,(%eax)
	int fd;

	(void)k_mutex_lock(&fdtable_lock, K_FOREVER);

	fd = _find_fd_entry();
	if (fd >= 0) {
 8049d8f:	eb 28                	jmp    8049db9 <z_reserve_fd+0x6b>
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
 8049d91:	f0 ff 02             	lock incl (%edx)
		/* Mark entry as used, z_finalize_fd() will fill it in. */
		(void)z_fd_ref(fd);
		fdtable[fd].obj = NULL;
 8049d94:	c7 80 a0 77 06 08 00 	movl   $0x0,0x80677a0(%eax)
 8049d9b:	00 00 00 
		fdtable[fd].vtable = NULL;
 8049d9e:	c7 80 a4 77 06 08 00 	movl   $0x0,0x80677a4(%eax)
 8049da5:	00 00 00 
	return z_impl_k_mutex_init(mutex);
 8049da8:	83 ec 0c             	sub    $0xc,%esp
		k_mutex_init(&fdtable[fd].lock);
 8049dab:	05 ac 77 06 08       	add    $0x80677ac,%eax
 8049db0:	50                   	push   %eax
 8049db1:	e8 c5 53 01 00       	call   805f17b <z_impl_k_mutex_init>
 8049db6:	83 c4 10             	add    $0x10,%esp
	return z_impl_k_mutex_unlock(mutex);
 8049db9:	83 ec 0c             	sub    $0xc,%esp
 8049dbc:	68 ac 75 06 08       	push   $0x80675ac
 8049dc1:	e8 e0 54 01 00       	call   805f2a6 <z_impl_k_mutex_unlock>
	}

	k_mutex_unlock(&fdtable_lock);

	return fd;
}
 8049dc6:	89 d8                	mov    %ebx,%eax
 8049dc8:	83 c4 10             	add    $0x10,%esp
 8049dcb:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 8049dce:	c9                   	leave  
 8049dcf:	c3                   	ret    

08049dd0 <z_finalize_fd>:

void z_finalize_fd(int fd, void *obj, const struct fd_op_vtable *vtable)
{
 8049dd0:	55                   	push   %ebp
 8049dd1:	89 e5                	mov    %esp,%ebp
 8049dd3:	83 ec 08             	sub    $0x8,%esp
	 * This call is a no-op if obj is invalid or points to something
	 * not a kernel object.
	 */
	z_object_recycle(obj);
#endif
	fdtable[fd].obj = obj;
 8049dd6:	8b 45 08             	mov    0x8(%ebp),%eax
{
 8049dd9:	8b 4d 0c             	mov    0xc(%ebp),%ecx
 8049ddc:	8b 55 10             	mov    0x10(%ebp),%edx
	fdtable[fd].obj = obj;
 8049ddf:	c1 e0 05             	shl    $0x5,%eax
 8049de2:	89 88 a0 77 06 08    	mov    %ecx,0x80677a0(%eax)
	fdtable[fd].vtable = vtable;
 8049de8:	89 90 a4 77 06 08    	mov    %edx,0x80677a4(%eax)

	/* Let the object know about the lock just in case it needs it
	 * for something. For BSD sockets, the lock is used with condition
	 * variables to avoid keeping the lock for a long period of time.
	 */
	if (vtable && vtable->ioctl) {
 8049dee:	85 d2                	test   %edx,%edx
 8049df0:	74 1b                	je     8049e0d <z_finalize_fd+0x3d>
 8049df2:	83 7a 0c 00          	cmpl   $0x0,0xc(%edx)
 8049df6:	74 15                	je     8049e0d <z_finalize_fd+0x3d>
		(void)z_fdtable_call_ioctl(vtable, obj, ZFD_IOCTL_SET_LOCK,
 8049df8:	05 ac 77 06 08       	add    $0x80677ac,%eax
 8049dfd:	50                   	push   %eax
 8049dfe:	68 05 01 00 00       	push   $0x105
 8049e03:	51                   	push   %ecx
 8049e04:	52                   	push   %edx
 8049e05:	e8 e5 fe ff ff       	call   8049cef <z_fdtable_call_ioctl.constprop.0>
 8049e0a:	83 c4 10             	add    $0x10,%esp
					   &fdtable[fd].lock);
	}
}
 8049e0d:	c9                   	leave  
 8049e0e:	c3                   	ret    

08049e0f <z_free_fd>:

void z_free_fd(int fd)
{
 8049e0f:	55                   	push   %ebp
 8049e10:	89 e5                	mov    %esp,%ebp
 8049e12:	56                   	push   %esi
 8049e13:	8b 55 08             	mov    0x8(%ebp),%edx
 8049e16:	53                   	push   %ebx
		old_rc = atomic_get(&fdtable[fd].refcount);
 8049e17:	89 d1                	mov    %edx,%ecx
 8049e19:	c1 e1 05             	shl    $0x5,%ecx
 8049e1c:	81 c1 a8 77 06 08    	add    $0x80677a8,%ecx
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
 8049e22:	8b 19                	mov    (%ecx),%ebx
		if (!old_rc) {
 8049e24:	85 db                	test   %ebx,%ebx
 8049e26:	74 25                	je     8049e4d <z_free_fd+0x3e>
	} while (!atomic_cas(&fdtable[fd].refcount, old_rc, old_rc - 1));
 8049e28:	8d 73 ff             	lea    -0x1(%ebx),%esi
	return __atomic_compare_exchange_n(target, &old_value, new_value,
 8049e2b:	89 d8                	mov    %ebx,%eax
 8049e2d:	f0 0f b1 31          	lock cmpxchg %esi,(%ecx)
 8049e31:	75 ef                	jne    8049e22 <z_free_fd+0x13>
	if (old_rc != 1) {
 8049e33:	4b                   	dec    %ebx
 8049e34:	75 17                	jne    8049e4d <z_free_fd+0x3e>
	fdtable[fd].obj = NULL;
 8049e36:	c1 e2 05             	shl    $0x5,%edx
 8049e39:	c7 82 a0 77 06 08 00 	movl   $0x0,0x80677a0(%edx)
 8049e40:	00 00 00 
	fdtable[fd].vtable = NULL;
 8049e43:	c7 82 a4 77 06 08 00 	movl   $0x0,0x80677a4(%edx)
 8049e4a:	00 00 00 
	/* Assumes fd was already bounds-checked. */
	(void)z_fd_unref(fd);
}
 8049e4d:	5b                   	pop    %ebx
 8049e4e:	5e                   	pop    %esi
 8049e4f:	5d                   	pop    %ebp
 8049e50:	c3                   	ret    

08049e51 <arch_printk_char_out>:
{
	ARG_UNUSED(c);

	/* do nothing */
	return 0;
}
 8049e51:	31 c0                	xor    %eax,%eax
 8049e53:	c3                   	ret    

08049e54 <char_out>:
}

static int char_out(int c, void *ctx_p)
{
	(void) ctx_p;
	return _char_out(c);
 8049e54:	ff 25 5c 73 06 08    	jmp    *0x806735c

08049e5a <str_out>:
	int max;
	int count;
};

static int str_out(int c, struct str_context *ctx)
{
 8049e5a:	55                   	push   %ebp
 8049e5b:	89 e5                	mov    %esp,%ebp
 8049e5d:	56                   	push   %esi
 8049e5e:	8b 45 0c             	mov    0xc(%ebp),%eax
 8049e61:	53                   	push   %ebx
	if (ctx->str == NULL || ctx->count >= ctx->max) {
 8049e62:	8b 48 08             	mov    0x8(%eax),%ecx
 8049e65:	8b 10                	mov    (%eax),%edx
		ctx->count++;
		return c;
	}

	if (ctx->count == ctx->max - 1) {
		ctx->str[ctx->count++] = '\0';
 8049e67:	8d 71 01             	lea    0x1(%ecx),%esi
	if (ctx->str == NULL || ctx->count >= ctx->max) {
 8049e6a:	85 d2                	test   %edx,%edx
 8049e6c:	74 07                	je     8049e75 <str_out+0x1b>
 8049e6e:	8b 58 04             	mov    0x4(%eax),%ebx
 8049e71:	39 cb                	cmp    %ecx,%ebx
 8049e73:	7f 05                	jg     8049e7a <str_out+0x20>
		ctx->count++;
 8049e75:	89 70 08             	mov    %esi,0x8(%eax)
		return c;
 8049e78:	eb 14                	jmp    8049e8e <str_out+0x34>
	if (ctx->count == ctx->max - 1) {
 8049e7a:	4b                   	dec    %ebx
		ctx->str[ctx->count++] = '\0';
 8049e7b:	89 70 08             	mov    %esi,0x8(%eax)
 8049e7e:	01 ca                	add    %ecx,%edx
	if (ctx->count == ctx->max - 1) {
 8049e80:	39 cb                	cmp    %ecx,%ebx
 8049e82:	75 05                	jne    8049e89 <str_out+0x2f>
		ctx->str[ctx->count++] = '\0';
 8049e84:	c6 02 00             	movb   $0x0,(%edx)
 8049e87:	eb 05                	jmp    8049e8e <str_out+0x34>
	} else {
		ctx->str[ctx->count++] = c;
 8049e89:	8a 45 08             	mov    0x8(%ebp),%al
 8049e8c:	88 02                	mov    %al,(%edx)
	}

	return c;
}
 8049e8e:	8b 45 08             	mov    0x8(%ebp),%eax
 8049e91:	5b                   	pop    %ebx
 8049e92:	5e                   	pop    %esi
 8049e93:	5d                   	pop    %ebp
 8049e94:	c3                   	ret    

08049e95 <__printk_hook_install>:
{
 8049e95:	55                   	push   %ebp
 8049e96:	89 e5                	mov    %esp,%ebp
	_char_out = fn;
 8049e98:	8b 45 08             	mov    0x8(%ebp),%eax
}
 8049e9b:	5d                   	pop    %ebp
	_char_out = fn;
 8049e9c:	a3 5c 73 06 08       	mov    %eax,0x806735c
}
 8049ea1:	c3                   	ret    

08049ea2 <vprintk>:
{
 8049ea2:	55                   	push   %ebp
 8049ea3:	89 e5                	mov    %esp,%ebp
 8049ea5:	83 ec 14             	sub    $0x14,%esp
int cbvprintf(cbprintf_cb out, void *ctx, const char *format, va_list ap);
#else
static inline
int cbvprintf(cbprintf_cb out, void *ctx, const char *format, va_list ap)
{
	return z_cbvprintf_impl(out, ctx, format, ap, 0);
 8049ea8:	6a 00                	push   $0x0
 8049eaa:	ff 75 0c             	push   0xc(%ebp)
 8049ead:	ff 75 08             	push   0x8(%ebp)
 8049eb0:	6a 00                	push   $0x0
 8049eb2:	68 54 9e 04 08       	push   $0x8049e54
 8049eb7:	e8 4d 07 00 00       	call   804a609 <z_cbvprintf_impl>
 8049ebc:	83 c4 20             	add    $0x20,%esp
}
 8049ebf:	c9                   	leave  
 8049ec0:	c3                   	ret    

08049ec1 <printk>:
{
 8049ec1:	55                   	push   %ebp
 8049ec2:	89 e5                	mov    %esp,%ebp
 8049ec4:	83 ec 10             	sub    $0x10,%esp
	va_start(ap, fmt);
 8049ec7:	8d 45 0c             	lea    0xc(%ebp),%eax
	vprintk(fmt, ap);
 8049eca:	50                   	push   %eax
 8049ecb:	ff 75 08             	push   0x8(%ebp)
 8049ece:	e8 cf ff ff ff       	call   8049ea2 <vprintk>
 8049ed3:	83 c4 10             	add    $0x10,%esp
}
 8049ed6:	c9                   	leave  
 8049ed7:	c3                   	ret    

08049ed8 <vsnprintk>:

	return ret;
}

int vsnprintk(char *str, size_t size, const char *fmt, va_list ap)
{
 8049ed8:	55                   	push   %ebp
 8049ed9:	89 e5                	mov    %esp,%ebp
 8049edb:	53                   	push   %ebx
 8049edc:	83 ec 20             	sub    $0x20,%esp
 8049edf:	8b 5d 08             	mov    0x8(%ebp),%ebx
 8049ee2:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 8049ee8:	89 45 f4             	mov    %eax,-0xc(%ebp)
 8049eeb:	31 c0                	xor    %eax,%eax
	struct str_context ctx = { str, size, 0 };
 8049eed:	8b 45 0c             	mov    0xc(%ebp),%eax
 8049ef0:	6a 00                	push   $0x0
 8049ef2:	ff 75 14             	push   0x14(%ebp)
 8049ef5:	89 45 ec             	mov    %eax,-0x14(%ebp)
 8049ef8:	8d 45 e8             	lea    -0x18(%ebp),%eax
 8049efb:	ff 75 10             	push   0x10(%ebp)
 8049efe:	50                   	push   %eax
 8049eff:	68 5a 9e 04 08       	push   $0x8049e5a
 8049f04:	89 5d e8             	mov    %ebx,-0x18(%ebp)
 8049f07:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
 8049f0e:	e8 f6 06 00 00       	call   804a609 <z_cbvprintf_impl>

	cbvprintf(str_out, &ctx, fmt, ap);

	if (ctx.count < ctx.max) {
 8049f13:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8049f16:	83 c4 20             	add    $0x20,%esp
 8049f19:	3b 45 ec             	cmp    -0x14(%ebp),%eax
 8049f1c:	7d 04                	jge    8049f22 <vsnprintk+0x4a>
		str[ctx.count] = '\0';
 8049f1e:	c6 04 03 00          	movb   $0x0,(%ebx,%eax,1)
	}

	return ctx.count;
}
 8049f22:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8049f25:	65 2b 15 14 00 00 00 	sub    %gs:0x14,%edx
 8049f2c:	74 05                	je     8049f33 <vsnprintk+0x5b>
 8049f2e:	e8 cd f3 ff ff       	call   8049300 <__stack_chk_fail@plt>
 8049f33:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 8049f36:	c9                   	leave  
 8049f37:	c3                   	ret    

08049f38 <snprintk>:
{
 8049f38:	55                   	push   %ebp
 8049f39:	89 e5                	mov    %esp,%ebp
 8049f3b:	83 ec 08             	sub    $0x8,%esp
	va_start(ap, fmt);
 8049f3e:	8d 45 14             	lea    0x14(%ebp),%eax
	ret = vsnprintk(str, size, fmt, ap);
 8049f41:	50                   	push   %eax
 8049f42:	ff 75 10             	push   0x10(%ebp)
 8049f45:	ff 75 0c             	push   0xc(%ebp)
 8049f48:	ff 75 08             	push   0x8(%ebp)
 8049f4b:	e8 88 ff ff ff       	call   8049ed8 <vsnprintk>
 8049f50:	83 c4 10             	add    $0x10,%esp
}
 8049f53:	c9                   	leave  
 8049f54:	c3                   	ret    

08049f55 <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
 8049f55:	55                   	push   %ebp
 8049f56:	89 e5                	mov    %esp,%ebp
 8049f58:	83 ec 0c             	sub    $0xc,%esp
#ifdef CONFIG_THREAD_LOCAL_STORAGE
	z_tls_current = z_current_get();
#endif
	entry(p1, p2, p3);
 8049f5b:	ff 75 14             	push   0x14(%ebp)
 8049f5e:	ff 75 10             	push   0x10(%ebp)
 8049f61:	ff 75 0c             	push   0xc(%ebp)
 8049f64:	ff 55 08             	call   *0x8(%ebp)
 8049f67:	83 c4 10             	add    $0x10,%esp
	return z_impl_z_current_get();
 8049f6a:	e8 65 66 01 00       	call   80605d4 <z_impl_z_current_get>
	z_impl_k_thread_abort(thread);
 8049f6f:	83 ec 0c             	sub    $0xc,%esp
 8049f72:	50                   	push   %eax
 8049f73:	e8 4a 34 00 00       	call   804d3c2 <z_impl_k_thread_abort>
 8049f78:	83 c4 0c             	add    $0xc,%esp
	/*
	 * Compiler can't tell that k_thread_abort() won't return and issues a
	 * warning unless we tell it that control never gets this far.
	 */

	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
 8049f7b:	6a 2d                	push   $0x2d
 8049f7d:	68 1d 29 06 08       	push   $0x806291d
 8049f82:	68 46 29 06 08       	push   $0x8062946
 8049f87:	e8 18 46 00 00       	call   804e5a4 <posix_print_error_and_exit>
 8049f8c:	83 c4 10             	add    $0x10,%esp

08049f8f <chunk_size>:
	void *cmem = &buf[c];

	if (big_heap(h)) {
		return ((uint32_t *)cmem)[f];
	} else {
		return ((uint16_t *)cmem)[f];
 8049f8f:	0f b7 44 d0 02       	movzwl 0x2(%eax,%edx,8),%eax
	return chunk_field(h, c, SIZE_AND_USED) & 1U;
}

static inline chunksz_t chunk_size(struct z_heap *h, chunkid_t c)
{
	return chunk_field(h, c, SIZE_AND_USED) >> 1;
 8049f94:	d1 e8                	shr    %eax
}
 8049f96:	c3                   	ret    

08049f97 <set_chunk_used>:

static inline void set_chunk_used(struct z_heap *h, chunkid_t c, bool used)
{
 8049f97:	55                   	push   %ebp
	chunk_unit_t *buf = chunk_buf(h);
	void *cmem = &buf[c];
 8049f98:	8d 04 d0             	lea    (%eax,%edx,8),%eax
{
 8049f9b:	89 e5                	mov    %esp,%ebp
 8049f9d:	53                   	push   %ebx
		} else {
			((uint32_t *)cmem)[SIZE_AND_USED] &= ~1U;
		}
	} else {
		if (used) {
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
 8049f9e:	66 8b 58 02          	mov    0x2(%eax),%bx
		} else {
			((uint16_t *)cmem)[SIZE_AND_USED] &= ~1U;
 8049fa2:	89 da                	mov    %ebx,%edx
 8049fa4:	83 e2 fe             	and    $0xfffffffe,%edx
		if (used) {
 8049fa7:	84 c9                	test   %cl,%cl
 8049fa9:	74 05                	je     8049fb0 <set_chunk_used+0x19>
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
 8049fab:	83 cb 01             	or     $0x1,%ebx
 8049fae:	89 da                	mov    %ebx,%edx
 8049fb0:	66 89 50 02          	mov    %dx,0x2(%eax)
		}
	}
}
 8049fb4:	5b                   	pop    %ebx
 8049fb5:	5d                   	pop    %ebp
 8049fb6:	c3                   	ret    

08049fb7 <free_list_add>:
	h->free_bytes += chunksz_to_bytes(h, chunk_size(h, c));
#endif
}

static void free_list_add(struct z_heap *h, chunkid_t c)
{
 8049fb7:	55                   	push   %ebp
}

static inline int bucket_idx(struct z_heap *h, chunksz_t sz)
{
	unsigned int usable_sz = sz - min_chunk_size(h) + 1;
	return 31 - __builtin_clz(usable_sz);
 8049fb8:	b9 1f 00 00 00       	mov    $0x1f,%ecx
 8049fbd:	89 e5                	mov    %esp,%ebp
 8049fbf:	57                   	push   %edi
 8049fc0:	56                   	push   %esi
	void *cmem = &buf[c];
 8049fc1:	8d 34 d5 00 00 00 00 	lea    0x0(,%edx,8),%esi
 8049fc8:	53                   	push   %ebx
 8049fc9:	89 c3                	mov    %eax,%ebx
		((uint16_t *)cmem)[f] = val;
 8049fcb:	8d 7c 33 04          	lea    0x4(%ebx,%esi,1),%edi
 8049fcf:	8d 74 33 06          	lea    0x6(%ebx,%esi,1),%esi
 8049fd3:	83 ec 1c             	sub    $0x1c,%esp
	if (!solo_free_header(h, c)) {
		int bidx = bucket_idx(h, chunk_size(h, c));
 8049fd6:	e8 b4 ff ff ff       	call   8049f8f <chunk_size>
 8049fdb:	89 7d e0             	mov    %edi,-0x20(%ebp)
	return 31 - __builtin_clz(usable_sz);
 8049fde:	0f bd c0             	bsr    %eax,%eax
		((uint16_t *)cmem)[f] = val;
 8049fe1:	89 75 dc             	mov    %esi,-0x24(%ebp)
	return 31 - __builtin_clz(usable_sz);
 8049fe4:	83 f0 1f             	xor    $0x1f,%eax
 8049fe7:	29 c1                	sub    %eax,%ecx
	if (b->next == 0U) {
 8049fe9:	89 c8                	mov    %ecx,%eax
 8049feb:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
 8049fee:	83 c0 04             	add    $0x4,%eax
 8049ff1:	8b 0c 83             	mov    (%ebx,%eax,4),%ecx
 8049ff4:	85 c9                	test   %ecx,%ecx
 8049ff6:	75 1b                	jne    804a013 <free_list_add+0x5c>
		h->avail_buckets |= BIT(bidx);
 8049ff8:	8a 4d e4             	mov    -0x1c(%ebp),%cl
 8049ffb:	bf 01 00 00 00       	mov    $0x1,%edi
 804a000:	d3 e7                	shl    %cl,%edi
 804a002:	09 7b 0c             	or     %edi,0xc(%ebx)
		b->next = c;
 804a005:	89 14 83             	mov    %edx,(%ebx,%eax,4)
		((uint16_t *)cmem)[f] = val;
 804a008:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804a00b:	66 89 10             	mov    %dx,(%eax)
 804a00e:	66 89 16             	mov    %dx,(%esi)
}
 804a011:	eb 1b                	jmp    804a02e <free_list_add+0x77>
		return ((uint16_t *)cmem)[f];
 804a013:	8d 7c cb 04          	lea    0x4(%ebx,%ecx,8),%edi
		((uint16_t *)cmem)[f] = val;
 804a017:	8b 75 e0             	mov    -0x20(%ebp),%esi
		return ((uint16_t *)cmem)[f];
 804a01a:	0f b7 07             	movzwl (%edi),%eax
		((uint16_t *)cmem)[f] = val;
 804a01d:	66 89 06             	mov    %ax,(%esi)
 804a020:	8b 75 dc             	mov    -0x24(%ebp),%esi
 804a023:	66 89 0e             	mov    %cx,(%esi)
 804a026:	66 89 54 c3 06       	mov    %dx,0x6(%ebx,%eax,8)
 804a02b:	66 89 17             	mov    %dx,(%edi)
		free_list_add_bidx(h, c, bidx);
	}
}
 804a02e:	83 c4 1c             	add    $0x1c,%esp
 804a031:	5b                   	pop    %ebx
 804a032:	5e                   	pop    %esi
 804a033:	5f                   	pop    %edi
 804a034:	5d                   	pop    %ebp
 804a035:	c3                   	ret    

0804a036 <free_list_remove_bidx>:
{
 804a036:	55                   	push   %ebp
 804a037:	89 e5                	mov    %esp,%ebp
 804a039:	57                   	push   %edi
 804a03a:	56                   	push   %esi
	void *cmem = &buf[c];
 804a03b:	8d 34 d5 00 00 00 00 	lea    0x0(,%edx,8),%esi
 804a042:	53                   	push   %ebx
		return ((uint16_t *)cmem)[f];
 804a043:	0f b7 5c 30 06       	movzwl 0x6(%eax,%esi,1),%ebx
	if (next_free_chunk(h, c) == c) {
 804a048:	39 da                	cmp    %ebx,%edx
 804a04a:	8d 51 04             	lea    0x4(%ecx),%edx
 804a04d:	75 13                	jne    804a062 <free_list_remove_bidx+0x2c>
		h->avail_buckets &= ~BIT(bidx);
 804a04f:	bb fe ff ff ff       	mov    $0xfffffffe,%ebx
 804a054:	d3 c3                	rol    %cl,%ebx
 804a056:	21 58 0c             	and    %ebx,0xc(%eax)
		b->next = 0;
 804a059:	c7 04 90 00 00 00 00 	movl   $0x0,(%eax,%edx,4)
}
 804a060:	eb 15                	jmp    804a077 <free_list_remove_bidx+0x41>
 804a062:	66 8b 4c 30 04       	mov    0x4(%eax,%esi,1),%cx
		b->next = second;
 804a067:	89 1c 90             	mov    %ebx,(%eax,%edx,4)
 804a06a:	0f b7 d1             	movzwl %cx,%edx
		((uint16_t *)cmem)[f] = val;
 804a06d:	66 89 5c d0 06       	mov    %bx,0x6(%eax,%edx,8)
 804a072:	66 89 4c d8 04       	mov    %cx,0x4(%eax,%ebx,8)
}
 804a077:	5b                   	pop    %ebx
 804a078:	5e                   	pop    %esi
 804a079:	5f                   	pop    %edi
 804a07a:	5d                   	pop    %ebp
 804a07b:	c3                   	ret    

0804a07c <free_list_remove>:
{
 804a07c:	55                   	push   %ebp
 804a07d:	89 e5                	mov    %esp,%ebp
 804a07f:	53                   	push   %ebx
 804a080:	89 c3                	mov    %eax,%ebx
 804a082:	51                   	push   %ecx
	return 31 - __builtin_clz(usable_sz);
 804a083:	b9 1f 00 00 00       	mov    $0x1f,%ecx
		int bidx = bucket_idx(h, chunk_size(h, c));
 804a088:	e8 02 ff ff ff       	call   8049f8f <chunk_size>
 804a08d:	0f bd c0             	bsr    %eax,%eax
 804a090:	83 f0 1f             	xor    $0x1f,%eax
 804a093:	29 c1                	sub    %eax,%ecx
		free_list_remove_bidx(h, c, bidx);
 804a095:	89 d8                	mov    %ebx,%eax
}
 804a097:	5b                   	pop    %ebx
 804a098:	5b                   	pop    %ebx
 804a099:	5d                   	pop    %ebp
		free_list_remove_bidx(h, c, bidx);
 804a09a:	e9 97 ff ff ff       	jmp    804a036 <free_list_remove_bidx>

0804a09f <alloc_chunk>:

	return chunk_sz - (addr - chunk_base);
}

static chunkid_t alloc_chunk(struct z_heap *h, chunksz_t sz)
{
 804a09f:	55                   	push   %ebp
 804a0a0:	b9 1f 00 00 00       	mov    $0x1f,%ecx
 804a0a5:	89 e5                	mov    %esp,%ebp
 804a0a7:	57                   	push   %edi
 804a0a8:	56                   	push   %esi
 804a0a9:	89 c6                	mov    %eax,%esi
 804a0ab:	53                   	push   %ebx
 804a0ac:	83 ec 1c             	sub    $0x1c,%esp
 804a0af:	0f bd c2             	bsr    %edx,%eax
 804a0b2:	89 55 d8             	mov    %edx,-0x28(%ebp)
 804a0b5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 804a0b8:	83 75 e4 1f          	xorl   $0x1f,-0x1c(%ebp)
 804a0bc:	2b 4d e4             	sub    -0x1c(%ebp),%ecx
	 * course.  But even in pathological situations we still
	 * maintain our constant time performance and at worst see
	 * fragmentation waste of the order of the block allocated
	 * only.
	 */
	if (b->next) {
 804a0bf:	8d 3c 8e             	lea    (%esi,%ecx,4),%edi
 804a0c2:	8b 47 10             	mov    0x10(%edi),%eax
 804a0c5:	89 45 e0             	mov    %eax,-0x20(%ebp)
 804a0c8:	85 c0                	test   %eax,%eax
 804a0ca:	74 2e                	je     804a0fa <alloc_chunk+0x5b>
		chunkid_t first = b->next;
		int i = CONFIG_SYS_HEAP_ALLOC_LOOPS;
 804a0cc:	c7 45 dc 03 00 00 00 	movl   $0x3,-0x24(%ebp)
		do {
			chunkid_t c = b->next;
 804a0d3:	8b 5f 10             	mov    0x10(%edi),%ebx
			if (chunk_size(h, c) >= sz) {
 804a0d6:	89 f0                	mov    %esi,%eax
 804a0d8:	89 da                	mov    %ebx,%edx
 804a0da:	e8 b0 fe ff ff       	call   8049f8f <chunk_size>
 804a0df:	3b 45 d8             	cmp    -0x28(%ebp),%eax
 804a0e2:	73 31                	jae    804a115 <alloc_chunk+0x76>
		return ((uint16_t *)cmem)[f];
 804a0e4:	0f b7 44 de 06       	movzwl 0x6(%esi,%ebx,8),%eax
				free_list_remove_bidx(h, c, bi);
				return c;
			}
			b->next = next_free_chunk(h, c);
			CHECK(b->next != 0);
		} while (--i && b->next != first);
 804a0e9:	ff 4d dc             	decl   -0x24(%ebp)
			b->next = next_free_chunk(h, c);
 804a0ec:	89 47 10             	mov    %eax,0x10(%edi)
		} while (--i && b->next != first);
 804a0ef:	39 45 e0             	cmp    %eax,-0x20(%ebp)
 804a0f2:	74 06                	je     804a0fa <alloc_chunk+0x5b>
 804a0f4:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
 804a0f8:	75 d9                	jne    804a0d3 <alloc_chunk+0x34>
	}

	/* Otherwise pick the smallest non-empty bucket guaranteed to
	 * fit and use that unconditionally.
	 */
	uint32_t bmask = h->avail_buckets & ~BIT_MASK(bi + 1);
 804a0fa:	b9 20 00 00 00       	mov    $0x20,%ecx
 804a0ff:	83 cb ff             	or     $0xffffffff,%ebx
 804a102:	2b 4d e4             	sub    -0x1c(%ebp),%ecx
 804a105:	d3 e3                	shl    %cl,%ebx

	if (bmask != 0U) {
 804a107:	23 5e 0c             	and    0xc(%esi),%ebx
 804a10a:	74 10                	je     804a11c <alloc_chunk+0x7d>
		int minbucket = __builtin_ctz(bmask);
 804a10c:	0f bc cb             	bsf    %ebx,%ecx
		chunkid_t c = h->buckets[minbucket].next;
 804a10f:	8b 5c 8e 10          	mov    0x10(%esi,%ecx,4),%ebx

		free_list_remove_bidx(h, c, minbucket);
 804a113:	89 da                	mov    %ebx,%edx
 804a115:	89 f0                	mov    %esi,%eax
 804a117:	e8 1a ff ff ff       	call   804a036 <free_list_remove_bidx>
		CHECK(chunk_size(h, c) >= sz);
		return c;
	}

	return 0;
}
 804a11c:	83 c4 1c             	add    $0x1c,%esp
 804a11f:	89 d8                	mov    %ebx,%eax
 804a121:	5b                   	pop    %ebx
 804a122:	5e                   	pop    %esi
 804a123:	5f                   	pop    %edi
 804a124:	5d                   	pop    %ebp
 804a125:	c3                   	ret    

0804a126 <merge_chunks>:
{
 804a126:	55                   	push   %ebp
 804a127:	89 e5                	mov    %esp,%ebp
 804a129:	57                   	push   %edi
 804a12a:	56                   	push   %esi
 804a12b:	89 d6                	mov    %edx,%esi
 804a12d:	53                   	push   %ebx
 804a12e:	89 c3                	mov    %eax,%ebx
 804a130:	83 ec 0c             	sub    $0xc,%esp
	chunksz_t newsz = chunk_size(h, lc) + chunk_size(h, rc);
 804a133:	e8 57 fe ff ff       	call   8049f8f <chunk_size>
 804a138:	89 ca                	mov    %ecx,%edx
 804a13a:	89 c7                	mov    %eax,%edi
 804a13c:	89 d8                	mov    %ebx,%eax
 804a13e:	e8 4c fe ff ff       	call   8049f8f <chunk_size>
 804a143:	01 c7                	add    %eax,%edi
	chunk_set(h, c, SIZE_AND_USED, size << 1);
 804a145:	8d 04 3f             	lea    (%edi,%edi,1),%eax
		((uint16_t *)cmem)[f] = val;
 804a148:	66 89 44 f3 02       	mov    %ax,0x2(%ebx,%esi,8)
	return c + chunk_size(h, c);
 804a14d:	89 d8                	mov    %ebx,%eax
 804a14f:	e8 3b fe ff ff       	call   8049f8f <chunk_size>
	void *cmem = &buf[c];
 804a154:	01 c1                	add    %eax,%ecx
		((uint16_t *)cmem)[f] = val;
 804a156:	66 89 3c cb          	mov    %di,(%ebx,%ecx,8)
}
 804a15a:	83 c4 0c             	add    $0xc,%esp
 804a15d:	5b                   	pop    %ebx
 804a15e:	5e                   	pop    %esi
 804a15f:	5f                   	pop    %edi
 804a160:	5d                   	pop    %ebp
 804a161:	c3                   	ret    

0804a162 <split_chunks>:
{
 804a162:	55                   	push   %ebp
 804a163:	89 e5                	mov    %esp,%ebp
 804a165:	57                   	push   %edi
 804a166:	56                   	push   %esi
	chunksz_t rsz = sz0 - lsz;
 804a167:	89 d6                	mov    %edx,%esi
{
 804a169:	53                   	push   %ebx
 804a16a:	89 c3                	mov    %eax,%ebx
	chunksz_t rsz = sz0 - lsz;
 804a16c:	29 ce                	sub    %ecx,%esi
{
 804a16e:	83 ec 0c             	sub    $0xc,%esp
	chunksz_t sz0 = chunk_size(h, lc);
 804a171:	e8 19 fe ff ff       	call   8049f8f <chunk_size>
 804a176:	89 c7                	mov    %eax,%edi
	chunksz_t lsz = rc - lc;
 804a178:	89 c8                	mov    %ecx,%eax
 804a17a:	29 d0                	sub    %edx,%eax
	chunksz_t rsz = sz0 - lsz;
 804a17c:	01 fe                	add    %edi,%esi
	chunk_set(h, c, SIZE_AND_USED, size << 1);
 804a17e:	8d 3c 00             	lea    (%eax,%eax,1),%edi
		((uint16_t *)cmem)[f] = val;
 804a181:	66 89 7c d3 02       	mov    %di,0x2(%ebx,%edx,8)
	chunk_set(h, c, SIZE_AND_USED, size << 1);
 804a186:	8d 14 36             	lea    (%esi,%esi,1),%edx
		((uint16_t *)cmem)[f] = val;
 804a189:	66 89 54 cb 02       	mov    %dx,0x2(%ebx,%ecx,8)
	return c + chunk_size(h, c);
 804a18e:	89 ca                	mov    %ecx,%edx
		((uint16_t *)cmem)[f] = val;
 804a190:	66 89 04 cb          	mov    %ax,(%ebx,%ecx,8)
	return c + chunk_size(h, c);
 804a194:	89 d8                	mov    %ebx,%eax
 804a196:	e8 f4 fd ff ff       	call   8049f8f <chunk_size>
	void *cmem = &buf[c];
 804a19b:	01 c1                	add    %eax,%ecx
		((uint16_t *)cmem)[f] = val;
 804a19d:	66 89 34 cb          	mov    %si,(%ebx,%ecx,8)
}
 804a1a1:	83 c4 0c             	add    $0xc,%esp
 804a1a4:	5b                   	pop    %ebx
 804a1a5:	5e                   	pop    %esi
 804a1a6:	5f                   	pop    %edi
 804a1a7:	5d                   	pop    %ebp
 804a1a8:	c3                   	ret    

0804a1a9 <free_chunk>:
{
 804a1a9:	55                   	push   %ebp
 804a1aa:	89 e5                	mov    %esp,%ebp
 804a1ac:	57                   	push   %edi
 804a1ad:	56                   	push   %esi
 804a1ae:	89 c6                	mov    %eax,%esi
 804a1b0:	53                   	push   %ebx
 804a1b1:	89 d3                	mov    %edx,%ebx
 804a1b3:	83 ec 0c             	sub    $0xc,%esp
	return c + chunk_size(h, c);
 804a1b6:	e8 d4 fd ff ff       	call   8049f8f <chunk_size>
 804a1bb:	01 c2                	add    %eax,%edx
	if (!chunk_used(h, right_chunk(h, c))) {
 804a1bd:	f6 44 d6 02 01       	testb  $0x1,0x2(%esi,%edx,8)
 804a1c2:	75 1a                	jne    804a1de <free_chunk+0x35>
		free_list_remove(h, right_chunk(h, c));
 804a1c4:	89 f0                	mov    %esi,%eax
 804a1c6:	e8 b1 fe ff ff       	call   804a07c <free_list_remove>
 804a1cb:	89 da                	mov    %ebx,%edx
 804a1cd:	89 f0                	mov    %esi,%eax
 804a1cf:	e8 bb fd ff ff       	call   8049f8f <chunk_size>
 804a1d4:	8d 0c 03             	lea    (%ebx,%eax,1),%ecx
		merge_chunks(h, c, right_chunk(h, c));
 804a1d7:	89 f0                	mov    %esi,%eax
 804a1d9:	e8 48 ff ff ff       	call   804a126 <merge_chunks>
		return ((uint16_t *)cmem)[f];
 804a1de:	8d 3c de             	lea    (%esi,%ebx,8),%edi
	return c - chunk_field(h, c, LEFT_SIZE);
 804a1e1:	89 da                	mov    %ebx,%edx
		return ((uint16_t *)cmem)[f];
 804a1e3:	0f b7 07             	movzwl (%edi),%eax
	return c - chunk_field(h, c, LEFT_SIZE);
 804a1e6:	29 c2                	sub    %eax,%edx
	if (!chunk_used(h, left_chunk(h, c))) {
 804a1e8:	f6 44 d6 02 01       	testb  $0x1,0x2(%esi,%edx,8)
 804a1ed:	75 1c                	jne    804a20b <free_chunk+0x62>
		free_list_remove(h, left_chunk(h, c));
 804a1ef:	89 f0                	mov    %esi,%eax
 804a1f1:	e8 86 fe ff ff       	call   804a07c <free_list_remove>
		return ((uint16_t *)cmem)[f];
 804a1f6:	0f b7 07             	movzwl (%edi),%eax
	return c - chunk_field(h, c, LEFT_SIZE);
 804a1f9:	89 da                	mov    %ebx,%edx
		merge_chunks(h, left_chunk(h, c), c);
 804a1fb:	89 d9                	mov    %ebx,%ecx
 804a1fd:	29 c2                	sub    %eax,%edx
 804a1ff:	89 f0                	mov    %esi,%eax
 804a201:	e8 20 ff ff ff       	call   804a126 <merge_chunks>
		return ((uint16_t *)cmem)[f];
 804a206:	0f b7 07             	movzwl (%edi),%eax
	return c - chunk_field(h, c, LEFT_SIZE);
 804a209:	29 c3                	sub    %eax,%ebx
}
 804a20b:	83 c4 0c             	add    $0xc,%esp
	free_list_add(h, c);
 804a20e:	89 da                	mov    %ebx,%edx
 804a210:	89 f0                	mov    %esi,%eax
}
 804a212:	5b                   	pop    %ebx
 804a213:	5e                   	pop    %esi
 804a214:	5f                   	pop    %edi
 804a215:	5d                   	pop    %ebp
	free_list_add(h, c);
 804a216:	e9 9c fd ff ff       	jmp    8049fb7 <free_list_add>

0804a21b <sys_heap_free>:
{
 804a21b:	55                   	push   %ebp
 804a21c:	89 e5                	mov    %esp,%ebp
 804a21e:	83 ec 18             	sub    $0x18,%esp
 804a221:	8b 55 0c             	mov    0xc(%ebp),%edx
 804a224:	8b 45 08             	mov    0x8(%ebp),%eax
	if (mem == NULL) {
 804a227:	85 d2                	test   %edx,%edx
 804a229:	74 23                	je     804a24e <sys_heap_free+0x33>
 804a22b:	8b 00                	mov    (%eax),%eax
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
 804a22d:	83 ea 04             	sub    $0x4,%edx
	set_chunk_used(h, c, false);
 804a230:	31 c9                	xor    %ecx,%ecx
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
 804a232:	29 c2                	sub    %eax,%edx
	set_chunk_used(h, c, false);
 804a234:	89 45 f4             	mov    %eax,-0xc(%ebp)
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
 804a237:	c1 ea 03             	shr    $0x3,%edx
	set_chunk_used(h, c, false);
 804a23a:	89 55 f0             	mov    %edx,-0x10(%ebp)
 804a23d:	e8 55 fd ff ff       	call   8049f97 <set_chunk_used>
	free_chunk(h, c);
 804a242:	8b 55 f0             	mov    -0x10(%ebp),%edx
 804a245:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 804a248:	c9                   	leave  
	free_chunk(h, c);
 804a249:	e9 5b ff ff ff       	jmp    804a1a9 <free_chunk>
}
 804a24e:	c9                   	leave  
 804a24f:	c3                   	ret    

0804a250 <sys_heap_alloc>:

void *sys_heap_alloc(struct sys_heap *heap, size_t bytes)
{
 804a250:	55                   	push   %ebp
 804a251:	89 e5                	mov    %esp,%ebp
 804a253:	57                   	push   %edi
 804a254:	56                   	push   %esi
 804a255:	53                   	push   %ebx
 804a256:	83 ec 0c             	sub    $0xc,%esp
	struct z_heap *h = heap->heap;
 804a259:	8b 45 08             	mov    0x8(%ebp),%eax
{
 804a25c:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	struct z_heap *h = heap->heap;
 804a25f:	8b 38                	mov    (%eax),%edi
	void *mem;

	if (bytes == 0U || size_too_big(h, bytes)) {
 804a261:	85 db                	test   %ebx,%ebx
 804a263:	75 04                	jne    804a269 <sys_heap_alloc+0x19>
		return NULL;
 804a265:	31 c0                	xor    %eax,%eax
 804a267:	eb 52                	jmp    804a2bb <sys_heap_alloc+0x6b>
{
	/*
	 * Quick check to bail out early if size is too big.
	 * Also guards against potential arithmetic overflows elsewhere.
	 */
	return (bytes / CHUNK_UNIT) >= h->end_chunk;
 804a269:	89 d8                	mov    %ebx,%eax
 804a26b:	c1 e8 03             	shr    $0x3,%eax
	if (bytes == 0U || size_too_big(h, bytes)) {
 804a26e:	39 47 08             	cmp    %eax,0x8(%edi)
 804a271:	76 f2                	jbe    804a265 <sys_heap_alloc+0x15>
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
 804a273:	83 c3 0b             	add    $0xb,%ebx
	}

	chunksz_t chunk_sz = bytes_to_chunksz(h, bytes);
	chunkid_t c = alloc_chunk(h, chunk_sz);
 804a276:	89 f8                	mov    %edi,%eax
 804a278:	c1 eb 03             	shr    $0x3,%ebx
 804a27b:	89 da                	mov    %ebx,%edx
 804a27d:	e8 1d fe ff ff       	call   804a09f <alloc_chunk>
 804a282:	89 c6                	mov    %eax,%esi
	if (c == 0U) {
 804a284:	85 c0                	test   %eax,%eax
 804a286:	74 dd                	je     804a265 <sys_heap_alloc+0x15>
		return NULL;
	}

	/* Split off remainder if any */
	if (chunk_size(h, c) > chunk_sz) {
 804a288:	89 c2                	mov    %eax,%edx
 804a28a:	89 f8                	mov    %edi,%eax
 804a28c:	e8 fe fc ff ff       	call   8049f8f <chunk_size>
 804a291:	39 d8                	cmp    %ebx,%eax
 804a293:	76 14                	jbe    804a2a9 <sys_heap_alloc+0x59>
		split_chunks(h, c, c + chunk_sz);
 804a295:	01 f3                	add    %esi,%ebx
 804a297:	89 f8                	mov    %edi,%eax
 804a299:	89 d9                	mov    %ebx,%ecx
 804a29b:	e8 c2 fe ff ff       	call   804a162 <split_chunks>
		free_list_add(h, c + chunk_sz);
 804a2a0:	89 da                	mov    %ebx,%edx
 804a2a2:	89 f8                	mov    %edi,%eax
 804a2a4:	e8 0e fd ff ff       	call   8049fb7 <free_list_add>
	}

	set_chunk_used(h, c, true);
 804a2a9:	89 f8                	mov    %edi,%eax
 804a2ab:	b9 01 00 00 00       	mov    $0x1,%ecx
 804a2b0:	89 f2                	mov    %esi,%edx
 804a2b2:	e8 e0 fc ff ff       	call   8049f97 <set_chunk_used>
	uint8_t *ret = ((uint8_t *)&buf[c]) + chunk_header_bytes(h);
 804a2b7:	8d 44 f7 04          	lea    0x4(%edi,%esi,8),%eax
				   chunksz_to_bytes(h, chunk_size(h, c)));
#endif

	IF_ENABLED(CONFIG_MSAN, (__msan_allocated_memory(mem, bytes)));
	return mem;
}
 804a2bb:	83 c4 0c             	add    $0xc,%esp
 804a2be:	5b                   	pop    %ebx
 804a2bf:	5e                   	pop    %esi
 804a2c0:	5f                   	pop    %edi
 804a2c1:	5d                   	pop    %ebp
 804a2c2:	c3                   	ret    

0804a2c3 <sys_heap_aligned_alloc>:

void *sys_heap_aligned_alloc(struct sys_heap *heap, size_t align, size_t bytes)
{
 804a2c3:	55                   	push   %ebp
 804a2c4:	89 e5                	mov    %esp,%ebp
 804a2c6:	57                   	push   %edi
 804a2c7:	56                   	push   %esi
 804a2c8:	53                   	push   %ebx
 804a2c9:	83 ec 1c             	sub    $0x1c,%esp
 804a2cc:	8b 55 0c             	mov    0xc(%ebp),%edx
	struct z_heap *h = heap->heap;
 804a2cf:	8b 45 08             	mov    0x8(%ebp),%eax
{
 804a2d2:	8b 4d 10             	mov    0x10(%ebp),%ecx
	 * We allow for one bit of rewind in addition to the alignment
	 * value to efficiently accommodate z_heap_aligned_alloc().
	 * So if e.g. align = 0x28 (32 | 8) this means we align to a 32-byte
	 * boundary and then rewind 8 bytes.
	 */
	rew = align & -align;
 804a2d5:	89 d7                	mov    %edx,%edi
	struct z_heap *h = heap->heap;
 804a2d7:	8b 18                	mov    (%eax),%ebx
	rew = align & -align;
 804a2d9:	f7 df                	neg    %edi
 804a2db:	21 d7                	and    %edx,%edi
	if (align != rew) {
 804a2dd:	39 fa                	cmp    %edi,%edx
 804a2df:	74 12                	je     804a2f3 <sys_heap_aligned_alloc+0x30>
		align -= rew;
		gap = MIN(rew, chunk_header_bytes(h));
 804a2e1:	b8 04 00 00 00       	mov    $0x4,%eax
 804a2e6:	89 fe                	mov    %edi,%esi
 804a2e8:	39 c7                	cmp    %eax,%edi
 804a2ea:	0f 46 c7             	cmovbe %edi,%eax
		align -= rew;
 804a2ed:	29 fa                	sub    %edi,%edx
 804a2ef:	89 d7                	mov    %edx,%edi
 804a2f1:	eb 1b                	jmp    804a30e <sys_heap_aligned_alloc+0x4b>
	} else {
		if (align <= chunk_header_bytes(h)) {
 804a2f3:	83 fa 04             	cmp    $0x4,%edx
 804a2f6:	77 0f                	ja     804a307 <sys_heap_aligned_alloc+0x44>
			return sys_heap_alloc(heap, bytes);
 804a2f8:	89 4d 0c             	mov    %ecx,0xc(%ebp)
				   chunksz_to_bytes(h, chunk_size(h, c)));
#endif

	IF_ENABLED(CONFIG_MSAN, (__msan_allocated_memory(mem, bytes)));
	return mem;
}
 804a2fb:	83 c4 1c             	add    $0x1c,%esp
 804a2fe:	5b                   	pop    %ebx
 804a2ff:	5e                   	pop    %esi
 804a300:	5f                   	pop    %edi
 804a301:	5d                   	pop    %ebp
			return sys_heap_alloc(heap, bytes);
 804a302:	e9 49 ff ff ff       	jmp    804a250 <sys_heap_alloc>
		rew = 0;
 804a307:	31 f6                	xor    %esi,%esi
		gap = chunk_header_bytes(h);
 804a309:	b8 04 00 00 00       	mov    $0x4,%eax
	if (bytes == 0 || size_too_big(h, bytes)) {
 804a30e:	85 c9                	test   %ecx,%ecx
 804a310:	75 07                	jne    804a319 <sys_heap_aligned_alloc+0x56>
		return NULL;
 804a312:	31 ff                	xor    %edi,%edi
 804a314:	e9 99 00 00 00       	jmp    804a3b2 <sys_heap_aligned_alloc+0xef>
	return (bytes / CHUNK_UNIT) >= h->end_chunk;
 804a319:	89 ca                	mov    %ecx,%edx
 804a31b:	c1 ea 03             	shr    $0x3,%edx
	if (bytes == 0 || size_too_big(h, bytes)) {
 804a31e:	39 53 08             	cmp    %edx,0x8(%ebx)
 804a321:	76 ef                	jbe    804a312 <sys_heap_aligned_alloc+0x4f>
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
 804a323:	8d 54 0f 0b          	lea    0xb(%edi,%ecx,1),%edx
 804a327:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
 804a32a:	29 c2                	sub    %eax,%edx
	chunkid_t c0 = alloc_chunk(h, padded_sz);
 804a32c:	89 d8                	mov    %ebx,%eax
 804a32e:	c1 ea 03             	shr    $0x3,%edx
 804a331:	e8 69 fd ff ff       	call   804a09f <alloc_chunk>
 804a336:	89 c2                	mov    %eax,%edx
	if (c0 == 0) {
 804a338:	85 c0                	test   %eax,%eax
 804a33a:	74 d6                	je     804a312 <sys_heap_aligned_alloc+0x4f>
	mem = (uint8_t *) ROUND_UP(mem + rew, align) - rew;
 804a33c:	8d 44 c6 04          	lea    0x4(%esi,%eax,8),%eax
	chunk_unit_t *end = (chunk_unit_t *) ROUND_UP(mem + bytes, CHUNK_UNIT);
 804a340:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
	mem = (uint8_t *) ROUND_UP(mem + rew, align) - rew;
 804a343:	01 d8                	add    %ebx,%eax
 804a345:	8d 44 07 ff          	lea    -0x1(%edi,%eax,1),%eax
 804a349:	f7 df                	neg    %edi
 804a34b:	21 c7                	and    %eax,%edi
 804a34d:	29 f7                	sub    %esi,%edi
	chunk_unit_t *end = (chunk_unit_t *) ROUND_UP(mem + bytes, CHUNK_UNIT);
 804a34f:	8d 44 0f 07          	lea    0x7(%edi,%ecx,1),%eax
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
 804a353:	8d 77 fc             	lea    -0x4(%edi),%esi
	chunk_unit_t *end = (chunk_unit_t *) ROUND_UP(mem + bytes, CHUNK_UNIT);
 804a356:	83 e0 f8             	and    $0xfffffff8,%eax
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
 804a359:	29 de                	sub    %ebx,%esi
	chunkid_t c_end = end - chunk_buf(h);
 804a35b:	29 d8                	sub    %ebx,%eax
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
 804a35d:	c1 ee 03             	shr    $0x3,%esi
	chunkid_t c_end = end - chunk_buf(h);
 804a360:	c1 f8 03             	sar    $0x3,%eax
 804a363:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (c > c0) {
 804a366:	39 d6                	cmp    %edx,%esi
 804a368:	76 16                	jbe    804a380 <sys_heap_aligned_alloc+0xbd>
		split_chunks(h, c0, c);
 804a36a:	89 d8                	mov    %ebx,%eax
 804a36c:	89 f1                	mov    %esi,%ecx
 804a36e:	89 55 e0             	mov    %edx,-0x20(%ebp)
 804a371:	e8 ec fd ff ff       	call   804a162 <split_chunks>
		free_list_add(h, c0);
 804a376:	8b 55 e0             	mov    -0x20(%ebp),%edx
 804a379:	89 d8                	mov    %ebx,%eax
 804a37b:	e8 37 fc ff ff       	call   8049fb7 <free_list_add>
	return c + chunk_size(h, c);
 804a380:	89 f2                	mov    %esi,%edx
 804a382:	89 d8                	mov    %ebx,%eax
 804a384:	e8 06 fc ff ff       	call   8049f8f <chunk_size>
 804a389:	01 f0                	add    %esi,%eax
	if (right_chunk(h, c) > c_end) {
 804a38b:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
 804a38e:	73 14                	jae    804a3a4 <sys_heap_aligned_alloc+0xe1>
		split_chunks(h, c, c_end);
 804a390:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
 804a393:	89 d8                	mov    %ebx,%eax
 804a395:	e8 c8 fd ff ff       	call   804a162 <split_chunks>
		free_list_add(h, c_end);
 804a39a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 804a39d:	89 d8                	mov    %ebx,%eax
 804a39f:	e8 13 fc ff ff       	call   8049fb7 <free_list_add>
	set_chunk_used(h, c, true);
 804a3a4:	b9 01 00 00 00       	mov    $0x1,%ecx
 804a3a9:	89 f2                	mov    %esi,%edx
 804a3ab:	89 d8                	mov    %ebx,%eax
 804a3ad:	e8 e5 fb ff ff       	call   8049f97 <set_chunk_used>
}
 804a3b2:	83 c4 1c             	add    $0x1c,%esp
 804a3b5:	89 f8                	mov    %edi,%eax
 804a3b7:	5b                   	pop    %ebx
 804a3b8:	5e                   	pop    %esi
 804a3b9:	5f                   	pop    %edi
 804a3ba:	5d                   	pop    %ebp
 804a3bb:	c3                   	ret    

0804a3bc <sys_heap_init>:
	}
	return ptr2;
}

void sys_heap_init(struct sys_heap *heap, void *mem, size_t bytes)
{
 804a3bc:	55                   	push   %ebp
	h->free_bytes = 0;
	h->allocated_bytes = 0;
	h->max_allocated_bytes = 0;
#endif

	int nb_buckets = bucket_idx(h, heap_sz) + 1;
 804a3bd:	b9 20 00 00 00       	mov    $0x20,%ecx
{
 804a3c2:	89 e5                	mov    %esp,%ebp
 804a3c4:	57                   	push   %edi
 804a3c5:	56                   	push   %esi
 804a3c6:	53                   	push   %ebx
 804a3c7:	83 ec 1c             	sub    $0x1c,%esp
 804a3ca:	8b 45 0c             	mov    0xc(%ebp),%eax
	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
 804a3cd:	8b 55 10             	mov    0x10(%ebp),%edx
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
 804a3d0:	8d 58 07             	lea    0x7(%eax),%ebx
	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
 804a3d3:	8d 44 10 fc          	lea    -0x4(%eax,%edx,1),%eax
	chunksz_t chunk0_size = chunksz(sizeof(struct z_heap) +
 804a3d7:	ba 24 00 00 00       	mov    $0x24,%edx
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
 804a3dc:	83 e3 f8             	and    $0xfffffff8,%ebx
	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
 804a3df:	83 e0 f8             	and    $0xfffffff8,%eax
 804a3e2:	89 45 e0             	mov    %eax,-0x20(%ebp)
	chunksz_t heap_sz = (end - addr) / CHUNK_UNIT;
 804a3e5:	29 d8                	sub    %ebx,%eax
 804a3e7:	c1 e8 03             	shr    $0x3,%eax
 804a3ea:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	heap->heap = h;
 804a3ed:	8b 45 08             	mov    0x8(%ebp),%eax
 804a3f0:	89 18                	mov    %ebx,(%eax)
	h->end_chunk = heap_sz;
 804a3f2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
	h->avail_buckets = 0;
 804a3f5:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
	h->end_chunk = heap_sz;
 804a3fc:	89 43 08             	mov    %eax,0x8(%ebx)
	return 31 - __builtin_clz(usable_sz);
 804a3ff:	0f bd c0             	bsr    %eax,%eax
 804a402:	83 f0 1f             	xor    $0x1f,%eax
	chunksz_t chunk0_size = chunksz(sizeof(struct z_heap) +
 804a405:	29 c2                	sub    %eax,%edx
	int nb_buckets = bucket_idx(h, heap_sz) + 1;
 804a407:	29 c1                	sub    %eax,%ecx
				     nb_buckets * sizeof(struct z_heap_bucket));

	__ASSERT(chunk0_size + min_chunk_size(h) <= heap_sz, "heap size is too small");

	for (int i = 0; i < nb_buckets; i++) {
		h->buckets[i].next = 0;
 804a409:	31 c0                	xor    %eax,%eax
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
 804a40b:	8d 34 95 07 00 00 00 	lea    0x7(,%edx,4),%esi
 804a412:	8d 53 10             	lea    0x10(%ebx),%edx
 804a415:	c1 e1 02             	shl    $0x2,%ecx
 804a418:	89 d7                	mov    %edx,%edi
 804a41a:	c1 ee 03             	shr    $0x3,%esi
	}

	/* chunk containing our struct z_heap */
	set_chunk_size(h, 0, chunk0_size);
	set_left_chunk_size(h, 0, 0);
	set_chunk_used(h, 0, true);
 804a41d:	31 d2                	xor    %edx,%edx
		h->buckets[i].next = 0;
 804a41f:	f3 aa                	rep stos %al,%es:(%edi)
	chunk_set(h, c, SIZE_AND_USED, size << 1);
 804a421:	8d 04 36             	lea    (%esi,%esi,1),%eax
		((uint16_t *)cmem)[f] = val;
 804a424:	66 c7 03 00 00       	movw   $0x0,(%ebx)
	set_chunk_used(h, 0, true);
 804a429:	b9 01 00 00 00       	mov    $0x1,%ecx
 804a42e:	66 89 43 02          	mov    %ax,0x2(%ebx)
 804a432:	89 d8                	mov    %ebx,%eax
 804a434:	e8 5e fb ff ff       	call   8049f97 <set_chunk_used>

	/* chunk containing the free heap */
	set_chunk_size(h, chunk0_size, heap_sz - chunk0_size);
 804a439:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804a43c:	8b 7d e0             	mov    -0x20(%ebp),%edi
 804a43f:	66 89 34 f3          	mov    %si,(%ebx,%esi,8)
 804a443:	29 f0                	sub    %esi,%eax
	chunk_set(h, c, SIZE_AND_USED, size << 1);
 804a445:	8d 14 00             	lea    (%eax,%eax,1),%edx
		((uint16_t *)cmem)[f] = val;
 804a448:	66 89 54 f3 02       	mov    %dx,0x2(%ebx,%esi,8)
	set_left_chunk_size(h, chunk0_size, chunk0_size);

	/* the end marker chunk */
	set_chunk_size(h, heap_sz, 0);
	set_left_chunk_size(h, heap_sz, heap_sz - chunk0_size);
	set_chunk_used(h, heap_sz, true);
 804a44d:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 804a450:	66 89 07             	mov    %ax,(%edi)
 804a453:	89 d8                	mov    %ebx,%eax
 804a455:	66 c7 47 02 00 00    	movw   $0x0,0x2(%edi)
 804a45b:	e8 37 fb ff ff       	call   8049f97 <set_chunk_used>

	free_list_add(h, chunk0_size);
}
 804a460:	83 c4 1c             	add    $0x1c,%esp
	free_list_add(h, chunk0_size);
 804a463:	89 f2                	mov    %esi,%edx
 804a465:	89 d8                	mov    %ebx,%eax
}
 804a467:	5b                   	pop    %ebx
 804a468:	5e                   	pop    %esi
 804a469:	5f                   	pop    %edi
 804a46a:	5d                   	pop    %ebp
	free_list_add(h, chunk0_size);
 804a46b:	e9 47 fb ff ff       	jmp    8049fb7 <free_list_add>

0804a470 <crc16_reflect>:

	return crc;
}

uint16_t crc16_reflect(uint16_t poly, uint16_t seed, const uint8_t *src, size_t len)
{
 804a470:	55                   	push   %ebp
 804a471:	89 e5                	mov    %esp,%ebp
 804a473:	57                   	push   %edi
 804a474:	8b 55 10             	mov    0x10(%ebp),%edx
	uint16_t crc = seed;
 804a477:	8b 45 0c             	mov    0xc(%ebp),%eax
{
 804a47a:	56                   	push   %esi
 804a47b:	53                   	push   %ebx
 804a47c:	8b 5d 14             	mov    0x14(%ebp),%ebx
 804a47f:	8b 75 08             	mov    0x8(%ebp),%esi
 804a482:	01 d3                	add    %edx,%ebx
	size_t i, j;

	for (i = 0; i < len; i++) {
 804a484:	39 da                	cmp    %ebx,%edx
 804a486:	74 1f                	je     804a4a7 <crc16_reflect+0x37>
		crc ^= (uint16_t)src[i];
 804a488:	0f b6 0a             	movzbl (%edx),%ecx
 804a48b:	31 c8                	xor    %ecx,%eax
 804a48d:	b9 08 00 00 00       	mov    $0x8,%ecx

		for (j = 0; j < 8; j++) {
			if (crc & 0x0001UL) {
 804a492:	89 c7                	mov    %eax,%edi
				crc = (crc >> 1U) ^ poly;
 804a494:	66 d1 e8             	shr    %ax
 804a497:	83 e7 01             	and    $0x1,%edi
			if (crc & 0x0001UL) {
 804a49a:	66 85 ff             	test   %di,%di
 804a49d:	74 02                	je     804a4a1 <crc16_reflect+0x31>
				crc = (crc >> 1U) ^ poly;
 804a49f:	31 f0                	xor    %esi,%eax
		for (j = 0; j < 8; j++) {
 804a4a1:	49                   	dec    %ecx
 804a4a2:	75 ee                	jne    804a492 <crc16_reflect+0x22>
	for (i = 0; i < len; i++) {
 804a4a4:	42                   	inc    %edx
 804a4a5:	eb dd                	jmp    804a484 <crc16_reflect+0x14>
		}
	}


	return crc;
}
 804a4a7:	5b                   	pop    %ebx
 804a4a8:	5e                   	pop    %esi
 804a4a9:	5f                   	pop    %edi
 804a4aa:	5d                   	pop    %ebp
 804a4ab:	c3                   	ret    

0804a4ac <outs>:
/* Outline function to emit all characters in [sp, ep). */
static int outs(cbprintf_cb out,
		void *ctx,
		const char *sp,
		const char *ep)
{
 804a4ac:	55                   	push   %ebp
 804a4ad:	89 e5                	mov    %esp,%ebp
 804a4af:	57                   	push   %edi
 804a4b0:	89 cf                	mov    %ecx,%edi
 804a4b2:	56                   	push   %esi
 804a4b3:	89 c6                	mov    %eax,%esi
 804a4b5:	53                   	push   %ebx
	size_t count = 0;
 804a4b6:	31 db                	xor    %ebx,%ebx
{
 804a4b8:	83 ec 1c             	sub    $0x1c,%esp

	while ((sp < ep) || ((ep == NULL) && *sp)) {
 804a4bb:	8d 04 1f             	lea    (%edi,%ebx,1),%eax
 804a4be:	39 45 08             	cmp    %eax,0x8(%ebp)
 804a4c1:	76 1a                	jbe    804a4dd <outs+0x31>
		int rc = out((int)*sp++, ctx);
 804a4c3:	50                   	push   %eax
 804a4c4:	50                   	push   %eax
 804a4c5:	0f be 04 1f          	movsbl (%edi,%ebx,1),%eax
 804a4c9:	52                   	push   %edx
 804a4ca:	50                   	push   %eax
 804a4cb:	89 55 e4             	mov    %edx,-0x1c(%ebp)
 804a4ce:	ff d6                	call   *%esi
 804a4d0:	83 c4 10             	add    $0x10,%esp

		if (rc < 0) {
 804a4d3:	85 c0                	test   %eax,%eax
 804a4d5:	78 18                	js     804a4ef <outs+0x43>
			return rc;
		}
		++count;
 804a4d7:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 804a4da:	43                   	inc    %ebx
 804a4db:	eb de                	jmp    804a4bb <outs+0xf>
	while ((sp < ep) || ((ep == NULL) && *sp)) {
 804a4dd:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 804a4e1:	74 04                	je     804a4e7 <outs+0x3b>
	}

	return (int)count;
 804a4e3:	89 d8                	mov    %ebx,%eax
 804a4e5:	eb 08                	jmp    804a4ef <outs+0x43>
	while ((sp < ep) || ((ep == NULL) && *sp)) {
 804a4e7:	80 3c 1f 00          	cmpb   $0x0,(%edi,%ebx,1)
 804a4eb:	75 d6                	jne    804a4c3 <outs+0x17>
 804a4ed:	eb f4                	jmp    804a4e3 <outs+0x37>
}
 804a4ef:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804a4f2:	5b                   	pop    %ebx
 804a4f3:	5e                   	pop    %esi
 804a4f4:	5f                   	pop    %edi
 804a4f5:	5d                   	pop    %ebp
 804a4f6:	c3                   	ret    

0804a4f7 <extract_decimal>:
{
 804a4f7:	55                   	push   %ebp
 804a4f8:	89 e5                	mov    %esp,%ebp
 804a4fa:	57                   	push   %edi
 804a4fb:	56                   	push   %esi
 804a4fc:	53                   	push   %ebx
 804a4fd:	89 c3                	mov    %eax,%ebx
 804a4ff:	83 ec 0c             	sub    $0xc,%esp
	const char *sp = *str;
 804a502:	8b 30                	mov    (%eax),%esi
	while (isdigit((int)(unsigned char)*sp) != 0) {
 804a504:	e8 e7 ec ff ff       	call   80491f0 <__ctype_b_loc@plt>
 804a509:	8b 08                	mov    (%eax),%ecx
	size_t val = 0;
 804a50b:	31 c0                	xor    %eax,%eax
	while (isdigit((int)(unsigned char)*sp) != 0) {
 804a50d:	0f be 16             	movsbl (%esi),%edx
 804a510:	0f b6 fa             	movzbl %dl,%edi
 804a513:	f6 44 79 01 08       	testb  $0x8,0x1(%ecx,%edi,2)
 804a518:	74 0a                	je     804a524 <extract_decimal+0x2d>
		val = 10U * val + *sp++ - '0';
 804a51a:	6b c0 0a             	imul   $0xa,%eax,%eax
 804a51d:	46                   	inc    %esi
 804a51e:	8d 44 10 d0          	lea    -0x30(%eax,%edx,1),%eax
 804a522:	eb e9                	jmp    804a50d <extract_decimal+0x16>
	*str = sp;
 804a524:	89 33                	mov    %esi,(%ebx)
}
 804a526:	83 c4 0c             	add    $0xc,%esp
 804a529:	5b                   	pop    %ebx
 804a52a:	5e                   	pop    %esi
 804a52b:	5f                   	pop    %edi
 804a52c:	5d                   	pop    %ebp
 804a52d:	c3                   	ret    

0804a52e <encode_uint>:
{
 804a52e:	55                   	push   %ebp
 804a52f:	89 e5                	mov    %esp,%ebp
 804a531:	57                   	push   %edi
 804a532:	56                   	push   %esi
 804a533:	89 ce                	mov    %ecx,%esi
 804a535:	53                   	push   %ebx
	switch (specifier) {
 804a536:	bb 08 00 00 00       	mov    $0x8,%ebx
{
 804a53b:	83 ec 3c             	sub    $0x3c,%esp
 804a53e:	89 55 dc             	mov    %edx,-0x24(%ebp)
 804a541:	89 45 d8             	mov    %eax,-0x28(%ebp)
	bool upcase = isupper((int)conv->specifier) != 0;
 804a544:	e8 a7 ec ff ff       	call   80491f0 <__ctype_b_loc@plt>
 804a549:	0f b6 4e 03          	movzbl 0x3(%esi),%ecx
 804a54d:	8b 10                	mov    (%eax),%edx
 804a54f:	66 8b 14 4a          	mov    (%edx,%ecx,2),%dx
 804a553:	66 81 e2 00 01       	and    $0x100,%dx
 804a558:	66 89 55 ce          	mov    %dx,-0x32(%ebp)
	switch (specifier) {
 804a55c:	80 f9 6f             	cmp    $0x6f,%cl
 804a55f:	74 1b                	je     804a57c <encode_uint+0x4e>
 804a561:	89 c8                	mov    %ecx,%eax
 804a563:	77 05                	ja     804a56a <encode_uint+0x3c>
		return 16;
 804a565:	80 f9 58             	cmp    $0x58,%cl
 804a568:	eb 05                	jmp    804a56f <encode_uint+0x41>
	switch (specifier) {
 804a56a:	83 e0 f7             	and    $0xfffffff7,%eax
		return 16;
 804a56d:	3c 70                	cmp    $0x70,%al
 804a56f:	bb 0a 00 00 00       	mov    $0xa,%ebx
 804a574:	b8 10 00 00 00       	mov    $0x10,%eax
 804a579:	0f 44 d8             	cmove  %eax,%ebx
		unsigned int lsv = (unsigned int)(value % radix);
 804a57c:	89 5d d0             	mov    %ebx,-0x30(%ebp)
	char *bp = bps + (bpe - bps);
 804a57f:	8b 7d 0c             	mov    0xc(%ebp),%edi
		unsigned int lsv = (unsigned int)(value % radix);
 804a582:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
 804a589:	83 ec 0c             	sub    $0xc,%esp
 804a58c:	8d 45 e0             	lea    -0x20(%ebp),%eax
 804a58f:	50                   	push   %eax
 804a590:	ff 75 d4             	push   -0x2c(%ebp)
 804a593:	ff 75 d0             	push   -0x30(%ebp)
 804a596:	ff 75 dc             	push   -0x24(%ebp)
 804a599:	ff 75 d8             	push   -0x28(%ebp)
 804a59c:	e8 cf f0 ff ff       	call   8049670 <__udivmoddi4>
 804a5a1:	83 c4 20             	add    $0x20,%esp
 804a5a4:	89 45 c0             	mov    %eax,-0x40(%ebp)
 804a5a7:	8b 45 e0             	mov    -0x20(%ebp),%eax
		*--bp = (lsv <= 9) ? ('0' + lsv)
 804a5aa:	89 55 c4             	mov    %edx,-0x3c(%ebp)
 804a5ad:	8d 50 30             	lea    0x30(%eax),%edx
 804a5b0:	83 f8 09             	cmp    $0x9,%eax
 804a5b3:	76 0d                	jbe    804a5c2 <encode_uint+0x94>
 804a5b5:	66 83 7d ce 00       	cmpw   $0x0,-0x32(%ebp)
			: upcase ? ('A' + lsv - 10) : ('a' + lsv - 10);
 804a5ba:	8d 50 57             	lea    0x57(%eax),%edx
		*--bp = (lsv <= 9) ? ('0' + lsv)
 804a5bd:	74 03                	je     804a5c2 <encode_uint+0x94>
			: upcase ? ('A' + lsv - 10) : ('a' + lsv - 10);
 804a5bf:	8d 50 37             	lea    0x37(%eax),%edx
	} while ((value != 0) && (bps < bp));
 804a5c2:	8b 45 d0             	mov    -0x30(%ebp),%eax
		*--bp = (lsv <= 9) ? ('0' + lsv)
 804a5c5:	4f                   	dec    %edi
	} while ((value != 0) && (bps < bp));
 804a5c6:	39 45 d8             	cmp    %eax,-0x28(%ebp)
		*--bp = (lsv <= 9) ? ('0' + lsv)
 804a5c9:	88 17                	mov    %dl,(%edi)
	} while ((value != 0) && (bps < bp));
 804a5cb:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804a5ce:	1b 45 d4             	sbb    -0x2c(%ebp),%eax
 804a5d1:	72 13                	jb     804a5e6 <encode_uint+0xb8>
 804a5d3:	3b 7d 08             	cmp    0x8(%ebp),%edi
 804a5d6:	76 0e                	jbe    804a5e6 <encode_uint+0xb8>
		value /= radix;
 804a5d8:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804a5db:	8b 55 c4             	mov    -0x3c(%ebp),%edx
 804a5de:	89 45 d8             	mov    %eax,-0x28(%ebp)
 804a5e1:	89 55 dc             	mov    %edx,-0x24(%ebp)
 804a5e4:	eb a3                	jmp    804a589 <encode_uint+0x5b>
	if (conv->flag_hash) {
 804a5e6:	f6 06 20             	testb  $0x20,(%esi)
 804a5e9:	74 14                	je     804a5ff <encode_uint+0xd1>
		if (radix == 8) {
 804a5eb:	83 fb 08             	cmp    $0x8,%ebx
 804a5ee:	75 06                	jne    804a5f6 <encode_uint+0xc8>
			conv->altform_0 = true;
 804a5f0:	80 4e 02 08          	orb    $0x8,0x2(%esi)
 804a5f4:	eb 09                	jmp    804a5ff <encode_uint+0xd1>
		} else if (radix == 16) {
 804a5f6:	83 fb 10             	cmp    $0x10,%ebx
 804a5f9:	75 04                	jne    804a5ff <encode_uint+0xd1>
			conv->altform_0c = true;
 804a5fb:	80 4e 02 10          	orb    $0x10,0x2(%esi)
}
 804a5ff:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804a602:	89 f8                	mov    %edi,%eax
 804a604:	5b                   	pop    %ebx
 804a605:	5e                   	pop    %esi
 804a606:	5f                   	pop    %edi
 804a607:	5d                   	pop    %ebp
 804a608:	c3                   	ret    

0804a609 <z_cbvprintf_impl>:

int z_cbvprintf_impl(cbprintf_cb out, void *ctx, const char *fp,
		     va_list ap, uint32_t flags)
{
 804a609:	55                   	push   %ebp
 804a60a:	89 e5                	mov    %esp,%ebp
 804a60c:	57                   	push   %edi
 804a60d:	56                   	push   %esi
 804a60e:	53                   	push   %ebx
 804a60f:	83 ec 6c             	sub    $0x6c,%esp
 804a612:	8b 45 08             	mov    0x8(%ebp),%eax
 804a615:	8b 75 14             	mov    0x14(%ebp),%esi
 804a618:	89 45 9c             	mov    %eax,-0x64(%ebp)
 804a61b:	8b 45 0c             	mov    0xc(%ebp),%eax
 804a61e:	89 45 98             	mov    %eax,-0x68(%ebp)
 804a621:	8b 45 10             	mov    0x10(%ebp),%eax
 804a624:	89 45 8c             	mov    %eax,-0x74(%ebp)
 804a627:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 804a62d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 804a630:	31 c0                	xor    %eax,%eax
	char buf[CONVERTED_BUFLEN];
	size_t count = 0;
 804a632:	c7 45 a4 00 00 00 00 	movl   $0x0,-0x5c(%ebp)
		return rc; \
	} \
	count += rc; \
} while (false)

	while (*fp != 0) {
 804a639:	8b 45 8c             	mov    -0x74(%ebp),%eax
 804a63c:	0f be 00             	movsbl (%eax),%eax
 804a63f:	84 c0                	test   %al,%al
 804a641:	0f 84 89 07 00 00    	je     804add0 <z_cbvprintf_impl+0x7c7>
		if (*fp != '%') {
			OUTC(*fp++);
 804a647:	8b 7d 8c             	mov    -0x74(%ebp),%edi
 804a64a:	47                   	inc    %edi
 804a64b:	89 7d 94             	mov    %edi,-0x6c(%ebp)
		if (*fp != '%') {
 804a64e:	3c 25                	cmp    $0x25,%al
 804a650:	74 20                	je     804a672 <z_cbvprintf_impl+0x69>
			OUTC(*fp++);
 804a652:	53                   	push   %ebx
 804a653:	53                   	push   %ebx
 804a654:	ff 75 98             	push   -0x68(%ebp)
 804a657:	50                   	push   %eax
 804a658:	8b 45 9c             	mov    -0x64(%ebp),%eax
 804a65b:	ff d0                	call   *%eax
 804a65d:	83 c4 10             	add    $0x10,%esp
 804a660:	85 c0                	test   %eax,%eax
 804a662:	0f 88 7a 07 00 00    	js     804ade2 <z_cbvprintf_impl+0x7d9>
 804a668:	ff 45 a4             	incl   -0x5c(%ebp)
			continue;
 804a66b:	89 f3                	mov    %esi,%ebx
 804a66d:	e9 51 07 00 00       	jmp    804adc3 <z_cbvprintf_impl+0x7ba>
		 * mitigate LLVM code generation bug.
		 */
		struct {
			union argument_value value;
			struct conversion conv;
		} state = {
 804a672:	31 c0                	xor    %eax,%eax
 804a674:	8d 7d b4             	lea    -0x4c(%ebp),%edi
 804a677:	b9 06 00 00 00       	mov    $0x6,%ecx
 804a67c:	f3 ab                	rep stos %eax,%es:(%edi)
	if (*sp == '%') {
 804a67e:	8b 45 8c             	mov    -0x74(%ebp),%eax
 804a681:	80 78 01 25          	cmpb   $0x25,0x1(%eax)
 804a685:	75 1c                	jne    804a6a3 <z_cbvprintf_impl+0x9a>
		conv->specifier = *sp++;
 804a687:	83 c0 02             	add    $0x2,%eax
 804a68a:	c6 45 c3 25          	movb   $0x25,-0x3d(%ebp)
 804a68e:	89 45 94             	mov    %eax,-0x6c(%ebp)
		return sp;
 804a691:	e9 5c 02 00 00       	jmp    804a8f2 <z_cbvprintf_impl+0x2e9>
		switch (*sp) {
 804a696:	7e 16                	jle    804a6ae <z_cbvprintf_impl+0xa5>
 804a698:	3c 2d                	cmp    $0x2d,%al
 804a69a:	75 1c                	jne    804a6b8 <z_cbvprintf_impl+0xaf>
			conv->flag_dash = true;
 804a69c:	80 4d c0 04          	orb    $0x4,-0x40(%ebp)
			++sp;
 804a6a0:	ff 45 94             	incl   -0x6c(%ebp)
		switch (*sp) {
 804a6a3:	8b 45 94             	mov    -0x6c(%ebp),%eax
 804a6a6:	8a 00                	mov    (%eax),%al
 804a6a8:	3c 2b                	cmp    $0x2b,%al
 804a6aa:	75 ea                	jne    804a696 <z_cbvprintf_impl+0x8d>
 804a6ac:	eb 23                	jmp    804a6d1 <z_cbvprintf_impl+0xc8>
 804a6ae:	3c 20                	cmp    $0x20,%al
 804a6b0:	74 25                	je     804a6d7 <z_cbvprintf_impl+0xce>
 804a6b2:	3c 23                	cmp    $0x23,%al
 804a6b4:	74 27                	je     804a6dd <z_cbvprintf_impl+0xd4>
 804a6b6:	eb 04                	jmp    804a6bc <z_cbvprintf_impl+0xb3>
 804a6b8:	3c 30                	cmp    $0x30,%al
 804a6ba:	74 27                	je     804a6e3 <z_cbvprintf_impl+0xda>
	if (conv->flag_zero && conv->flag_dash) {
 804a6bc:	8a 45 c0             	mov    -0x40(%ebp),%al
 804a6bf:	89 c2                	mov    %eax,%edx
 804a6c1:	83 e2 44             	and    $0x44,%edx
 804a6c4:	80 fa 44             	cmp    $0x44,%dl
 804a6c7:	75 20                	jne    804a6e9 <z_cbvprintf_impl+0xe0>
		conv->flag_zero = false;
 804a6c9:	83 e0 bf             	and    $0xffffffbf,%eax
 804a6cc:	88 45 c0             	mov    %al,-0x40(%ebp)
 804a6cf:	eb 18                	jmp    804a6e9 <z_cbvprintf_impl+0xe0>
			conv->flag_plus = true;
 804a6d1:	80 4d c0 08          	orb    $0x8,-0x40(%ebp)
			break;
 804a6d5:	eb c9                	jmp    804a6a0 <z_cbvprintf_impl+0x97>
			conv->flag_space = true;
 804a6d7:	80 4d c0 10          	orb    $0x10,-0x40(%ebp)
			break;
 804a6db:	eb c3                	jmp    804a6a0 <z_cbvprintf_impl+0x97>
			conv->flag_hash = true;
 804a6dd:	80 4d c0 20          	orb    $0x20,-0x40(%ebp)
			break;
 804a6e1:	eb bd                	jmp    804a6a0 <z_cbvprintf_impl+0x97>
			conv->flag_zero = true;
 804a6e3:	80 4d c0 40          	orb    $0x40,-0x40(%ebp)
			break;
 804a6e7:	eb b7                	jmp    804a6a0 <z_cbvprintf_impl+0x97>
	sp = extract_width(conv, sp);
 804a6e9:	8b 45 94             	mov    -0x6c(%ebp),%eax
	conv->width_present = true;
 804a6ec:	80 4d c0 80          	orb    $0x80,-0x40(%ebp)
 804a6f0:	89 45 b0             	mov    %eax,-0x50(%ebp)
	if (*sp == '*') {
 804a6f3:	80 38 2a             	cmpb   $0x2a,(%eax)
 804a6f6:	75 09                	jne    804a701 <z_cbvprintf_impl+0xf8>
		return ++sp;
 804a6f8:	89 c2                	mov    %eax,%edx
		conv->width_star = true;
 804a6fa:	80 4d c1 01          	orb    $0x1,-0x3f(%ebp)
		return ++sp;
 804a6fe:	42                   	inc    %edx
 804a6ff:	eb 23                	jmp    804a724 <z_cbvprintf_impl+0x11b>
	size_t width = extract_decimal(&sp);
 804a701:	8d 45 b0             	lea    -0x50(%ebp),%eax
 804a704:	e8 ee fd ff ff       	call   804a4f7 <extract_decimal>
	if (sp != wp) {
 804a709:	8b 55 b0             	mov    -0x50(%ebp),%edx
 804a70c:	3b 55 94             	cmp    -0x6c(%ebp),%edx
 804a70f:	74 13                	je     804a724 <z_cbvprintf_impl+0x11b>
		conv->unsupported |= ((conv->width_value < 0)
 804a711:	8a 4d c0             	mov    -0x40(%ebp),%cl
		conv->width_value = width;
 804a714:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		conv->unsupported |= ((conv->width_value < 0)
 804a717:	c1 e8 1f             	shr    $0x1f,%eax
 804a71a:	01 c0                	add    %eax,%eax
 804a71c:	83 e1 fd             	and    $0xfffffffd,%ecx
 804a71f:	09 c1                	or     %eax,%ecx
 804a721:	88 4d c0             	mov    %cl,-0x40(%ebp)
	sp = extract_prec(conv, sp);
 804a724:	89 55 b0             	mov    %edx,-0x50(%ebp)
	conv->prec_present = (*sp == '.');
 804a727:	8a 02                	mov    (%edx),%al
 804a729:	8a 4d c1             	mov    -0x3f(%ebp),%cl
 804a72c:	3c 2e                	cmp    $0x2e,%al
 804a72e:	0f 94 c3             	sete   %bl
 804a731:	83 e1 fd             	and    $0xfffffffd,%ecx
 804a734:	01 db                	add    %ebx,%ebx
 804a736:	09 d9                	or     %ebx,%ecx
 804a738:	88 4d c1             	mov    %cl,-0x3f(%ebp)
	if (!conv->prec_present) {
 804a73b:	3c 2e                	cmp    $0x2e,%al
 804a73d:	75 40                	jne    804a77f <z_cbvprintf_impl+0x176>
	++sp;
 804a73f:	8d 42 01             	lea    0x1(%edx),%eax
 804a742:	89 45 b0             	mov    %eax,-0x50(%ebp)
	if (*sp == '*') {
 804a745:	80 7a 01 2a          	cmpb   $0x2a,0x1(%edx)
 804a749:	75 0b                	jne    804a756 <z_cbvprintf_impl+0x14d>
		conv->prec_star = true;
 804a74b:	83 c9 04             	or     $0x4,%ecx
		return ++sp;
 804a74e:	83 c2 02             	add    $0x2,%edx
		conv->prec_star = true;
 804a751:	88 4d c1             	mov    %cl,-0x3f(%ebp)
		return ++sp;
 804a754:	eb 29                	jmp    804a77f <z_cbvprintf_impl+0x176>
	size_t prec = extract_decimal(&sp);
 804a756:	8d 45 b0             	lea    -0x50(%ebp),%eax
 804a759:	e8 99 fd ff ff       	call   804a4f7 <extract_decimal>
	conv->unsupported |= ((conv->prec_value < 0)
 804a75e:	8a 4d c0             	mov    -0x40(%ebp),%cl
	size_t prec = extract_decimal(&sp);
 804a761:	89 c2                	mov    %eax,%edx
	conv->prec_value = prec;
 804a763:	89 45 c8             	mov    %eax,-0x38(%ebp)
	conv->unsupported |= ((conv->prec_value < 0)
 804a766:	89 c8                	mov    %ecx,%eax
			      || (prec != (size_t)conv->prec_value));
 804a768:	c1 ea 1f             	shr    $0x1f,%edx
	conv->unsupported |= ((conv->prec_value < 0)
 804a76b:	83 e1 fd             	and    $0xfffffffd,%ecx
 804a76e:	d0 e8                	shr    %al
 804a770:	83 e0 01             	and    $0x1,%eax
 804a773:	09 d0                	or     %edx,%eax
	return sp;
 804a775:	8b 55 b0             	mov    -0x50(%ebp),%edx
	conv->unsupported |= ((conv->prec_value < 0)
 804a778:	01 c0                	add    %eax,%eax
 804a77a:	09 c1                	or     %eax,%ecx
 804a77c:	88 4d c0             	mov    %cl,-0x40(%ebp)
	switch (*sp) {
 804a77f:	8a 02                	mov    (%edx),%al
		if (*++sp == 'h') {
 804a781:	8d 4a 01             	lea    0x1(%edx),%ecx
	switch (*sp) {
 804a784:	3c 6c                	cmp    $0x6c,%al
 804a786:	74 35                	je     804a7bd <z_cbvprintf_impl+0x1b4>
 804a788:	7f 0e                	jg     804a798 <z_cbvprintf_impl+0x18f>
 804a78a:	3c 68                	cmp    $0x68,%al
 804a78c:	74 16                	je     804a7a4 <z_cbvprintf_impl+0x19b>
 804a78e:	3c 6a                	cmp    $0x6a,%al
 804a790:	74 4a                	je     804a7dc <z_cbvprintf_impl+0x1d3>
 804a792:	3c 4c                	cmp    $0x4c,%al
 804a794:	74 6a                	je     804a800 <z_cbvprintf_impl+0x1f7>
 804a796:	eb 08                	jmp    804a7a0 <z_cbvprintf_impl+0x197>
 804a798:	3c 74                	cmp    $0x74,%al
 804a79a:	74 56                	je     804a7f2 <z_cbvprintf_impl+0x1e9>
 804a79c:	3c 7a                	cmp    $0x7a,%al
 804a79e:	74 47                	je     804a7e7 <z_cbvprintf_impl+0x1de>
 804a7a0:	89 d1                	mov    %edx,%ecx
 804a7a2:	eb 6b                	jmp    804a80f <z_cbvprintf_impl+0x206>
		if (*++sp == 'h') {
 804a7a4:	80 7a 01 68          	cmpb   $0x68,0x1(%edx)
 804a7a8:	8a 45 c1             	mov    -0x3f(%ebp),%al
 804a7ab:	75 08                	jne    804a7b5 <z_cbvprintf_impl+0x1ac>
			conv->length_mod = LENGTH_HH;
 804a7ad:	83 e0 87             	and    $0xffffff87,%eax
 804a7b0:	83 c8 08             	or     $0x8,%eax
 804a7b3:	eb 17                	jmp    804a7cc <z_cbvprintf_impl+0x1c3>
			conv->length_mod = LENGTH_H;
 804a7b5:	83 e0 87             	and    $0xffffff87,%eax
 804a7b8:	83 c8 10             	or     $0x10,%eax
 804a7bb:	eb 3e                	jmp    804a7fb <z_cbvprintf_impl+0x1f2>
		if (*++sp == 'l') {
 804a7bd:	80 7a 01 6c          	cmpb   $0x6c,0x1(%edx)
 804a7c1:	8a 45 c1             	mov    -0x3f(%ebp),%al
 804a7c4:	75 0e                	jne    804a7d4 <z_cbvprintf_impl+0x1cb>
			conv->length_mod = LENGTH_LL;
 804a7c6:	83 e0 87             	and    $0xffffff87,%eax
 804a7c9:	83 c8 20             	or     $0x20,%eax
 804a7cc:	88 45 c1             	mov    %al,-0x3f(%ebp)
			++sp;
 804a7cf:	8d 4a 02             	lea    0x2(%edx),%ecx
 804a7d2:	eb 3b                	jmp    804a80f <z_cbvprintf_impl+0x206>
			conv->length_mod = LENGTH_L;
 804a7d4:	83 e0 87             	and    $0xffffff87,%eax
 804a7d7:	83 c8 18             	or     $0x18,%eax
 804a7da:	eb 1f                	jmp    804a7fb <z_cbvprintf_impl+0x1f2>
		conv->length_mod = LENGTH_J;
 804a7dc:	8a 45 c1             	mov    -0x3f(%ebp),%al
 804a7df:	83 e0 87             	and    $0xffffff87,%eax
 804a7e2:	83 c8 28             	or     $0x28,%eax
 804a7e5:	eb 14                	jmp    804a7fb <z_cbvprintf_impl+0x1f2>
		conv->length_mod = LENGTH_Z;
 804a7e7:	8a 45 c1             	mov    -0x3f(%ebp),%al
 804a7ea:	83 e0 87             	and    $0xffffff87,%eax
 804a7ed:	83 c8 30             	or     $0x30,%eax
 804a7f0:	eb 09                	jmp    804a7fb <z_cbvprintf_impl+0x1f2>
		conv->length_mod = LENGTH_T;
 804a7f2:	8a 45 c1             	mov    -0x3f(%ebp),%al
 804a7f5:	83 e0 87             	and    $0xffffff87,%eax
 804a7f8:	83 c8 38             	or     $0x38,%eax
 804a7fb:	88 45 c1             	mov    %al,-0x3f(%ebp)
		break;
 804a7fe:	eb 0f                	jmp    804a80f <z_cbvprintf_impl+0x206>
		conv->unsupported = true;
 804a800:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804a803:	66 25 fd 87          	and    $0x87fd,%ax
 804a807:	66 0d 02 40          	or     $0x4002,%ax
 804a80b:	66 89 45 c0          	mov    %ax,-0x40(%ebp)
	conv->specifier = *sp++;
 804a80f:	8d 41 01             	lea    0x1(%ecx),%eax
		if (conv->length_mod == LENGTH_UPPER_L) {
 804a812:	8a 55 c1             	mov    -0x3f(%ebp),%dl
	conv->specifier = *sp++;
 804a815:	89 45 94             	mov    %eax,-0x6c(%ebp)
 804a818:	8a 01                	mov    (%ecx),%al
 804a81a:	88 45 c3             	mov    %al,-0x3d(%ebp)
	switch (conv->specifier) {
 804a81d:	3c 78                	cmp    $0x78,%al
 804a81f:	0f 8f b1 00 00 00    	jg     804a8d6 <z_cbvprintf_impl+0x2cd>
 804a825:	3c 6d                	cmp    $0x6d,%al
 804a827:	7f 1d                	jg     804a846 <z_cbvprintf_impl+0x23d>
 804a829:	3c 69                	cmp    $0x69,%al
 804a82b:	0f 8f a5 00 00 00    	jg     804a8d6 <z_cbvprintf_impl+0x2cd>
 804a831:	3c 57                	cmp    $0x57,%al
 804a833:	7f 44                	jg     804a879 <z_cbvprintf_impl+0x270>
 804a835:	3c 41                	cmp    $0x41,%al
 804a837:	74 79                	je     804a8b2 <z_cbvprintf_impl+0x2a9>
 804a839:	83 e8 45             	sub    $0x45,%eax
 804a83c:	3c 02                	cmp    $0x2,%al
 804a83e:	0f 87 92 00 00 00    	ja     804a8d6 <z_cbvprintf_impl+0x2cd>
 804a844:	eb 6c                	jmp    804a8b2 <z_cbvprintf_impl+0x2a9>
 804a846:	8d 48 92             	lea    -0x6e(%eax),%ecx
 804a849:	bb 01 00 00 00       	mov    $0x1,%ebx
 804a84e:	d3 e3                	shl    %cl,%ebx
 804a850:	f7 c3 82 04 00 00    	test   $0x482,%ebx
 804a856:	75 37                	jne    804a88f <z_cbvprintf_impl+0x286>
 804a858:	f6 c3 24             	test   $0x24,%bl
 804a85b:	75 65                	jne    804a8c2 <z_cbvprintf_impl+0x2b9>
 804a85d:	80 e3 01             	and    $0x1,%bl
 804a860:	74 74                	je     804a8d6 <z_cbvprintf_impl+0x2cd>
		conv->specifier_cat = SPECIFIER_PTR;
 804a862:	8a 45 c2             	mov    -0x3e(%ebp),%al
		if (conv->length_mod == LENGTH_UPPER_L) {
 804a865:	83 e2 78             	and    $0x78,%edx
		conv->specifier_cat = SPECIFIER_PTR;
 804a868:	83 e0 f8             	and    $0xfffffff8,%eax
 804a86b:	83 c8 03             	or     $0x3,%eax
		if (conv->length_mod == LENGTH_UPPER_L) {
 804a86e:	80 fa 40             	cmp    $0x40,%dl
		conv->specifier_cat = SPECIFIER_PTR;
 804a871:	88 45 c2             	mov    %al,-0x3e(%ebp)
		if (conv->length_mod == LENGTH_UPPER_L) {
 804a874:	0f 94 c1             	sete   %cl
 804a877:	eb 63                	jmp    804a8dc <z_cbvprintf_impl+0x2d3>
	switch (conv->specifier) {
 804a879:	8d 48 a8             	lea    -0x58(%eax),%ecx
 804a87c:	80 f9 11             	cmp    $0x11,%cl
 804a87f:	77 55                	ja     804a8d6 <z_cbvprintf_impl+0x2cd>
 804a881:	0f b6 c9             	movzbl %cl,%ecx
 804a884:	ff 24 8d 14 23 06 08 	jmp    *0x8062314(,%ecx,4)
 804a88b:	b3 01                	mov    $0x1,%bl
 804a88d:	eb 02                	jmp    804a891 <z_cbvprintf_impl+0x288>
 804a88f:	b3 02                	mov    $0x2,%bl
		conv->specifier_cat = SPECIFIER_SINT;
 804a891:	8a 4d c2             	mov    -0x3e(%ebp),%cl
		if (conv->length_mod == LENGTH_UPPER_L) {
 804a894:	83 e2 78             	and    $0x78,%edx
		conv->specifier_cat = SPECIFIER_SINT;
 804a897:	83 e1 f8             	and    $0xfffffff8,%ecx
 804a89a:	09 d9                	or     %ebx,%ecx
 804a89c:	88 4d c2             	mov    %cl,-0x3e(%ebp)
		if (conv->length_mod == LENGTH_UPPER_L) {
 804a89f:	80 fa 40             	cmp    $0x40,%dl
 804a8a2:	75 04                	jne    804a8a8 <z_cbvprintf_impl+0x29f>
			conv->invalid = true;
 804a8a4:	80 4d c0 01          	orb    $0x1,-0x40(%ebp)
	bool unsupported = false;
 804a8a8:	31 c9                	xor    %ecx,%ecx
		if (conv->specifier == 'c') {
 804a8aa:	3c 63                	cmp    $0x63,%al
 804a8ac:	75 2e                	jne    804a8dc <z_cbvprintf_impl+0x2d3>
			unsupported = (conv->length_mod != LENGTH_NONE);
 804a8ae:	84 d2                	test   %dl,%dl
 804a8b0:	eb 1f                	jmp    804a8d1 <z_cbvprintf_impl+0x2c8>
		conv->specifier_cat = SPECIFIER_FP;
 804a8b2:	8a 45 c2             	mov    -0x3e(%ebp),%al
			unsupported = true;
 804a8b5:	b1 01                	mov    $0x1,%cl
		conv->specifier_cat = SPECIFIER_FP;
 804a8b7:	83 e0 f8             	and    $0xfffffff8,%eax
 804a8ba:	83 c8 04             	or     $0x4,%eax
 804a8bd:	88 45 c2             	mov    %al,-0x3e(%ebp)
			break;
 804a8c0:	eb 1a                	jmp    804a8dc <z_cbvprintf_impl+0x2d3>
		conv->specifier_cat = SPECIFIER_PTR;
 804a8c2:	8a 45 c2             	mov    -0x3e(%ebp),%al
 804a8c5:	83 e0 f8             	and    $0xfffffff8,%eax
 804a8c8:	83 c8 03             	or     $0x3,%eax
		if (conv->length_mod != LENGTH_NONE) {
 804a8cb:	80 e2 78             	and    $0x78,%dl
		conv->specifier_cat = SPECIFIER_PTR;
 804a8ce:	88 45 c2             	mov    %al,-0x3e(%ebp)
		if (conv->length_mod != LENGTH_NONE) {
 804a8d1:	0f 95 c1             	setne  %cl
 804a8d4:	eb 06                	jmp    804a8dc <z_cbvprintf_impl+0x2d3>
		conv->invalid = true;
 804a8d6:	80 4d c0 01          	orb    $0x1,-0x40(%ebp)
	bool unsupported = false;
 804a8da:	31 c9                	xor    %ecx,%ecx
	conv->unsupported |= unsupported;
 804a8dc:	8a 55 c0             	mov    -0x40(%ebp),%dl
 804a8df:	89 d0                	mov    %edx,%eax
 804a8e1:	83 e2 fd             	and    $0xfffffffd,%edx
 804a8e4:	d0 e8                	shr    %al
 804a8e6:	83 e0 01             	and    $0x1,%eax
 804a8e9:	09 c8                	or     %ecx,%eax
 804a8eb:	01 c0                	add    %eax,%eax
 804a8ed:	09 c2                	or     %eax,%edx
 804a8ef:	88 55 c0             	mov    %dl,-0x40(%ebp)
		fp = extract_conversion(conv, sp);

		/* If dynamic width is specified, process it,
		 * otherwise set width if present.
		 */
		if (conv->width_star) {
 804a8f2:	8a 45 c1             	mov    -0x3f(%ebp),%al
 804a8f5:	a8 01                	test   $0x1,%al
 804a8f7:	74 11                	je     804a90a <z_cbvprintf_impl+0x301>
			width = va_arg(ap, int);
 804a8f9:	8b 3e                	mov    (%esi),%edi
 804a8fb:	83 c6 04             	add    $0x4,%esi

			if (width < 0) {
 804a8fe:	85 ff                	test   %edi,%edi
 804a900:	79 14                	jns    804a916 <z_cbvprintf_impl+0x30d>
				conv->flag_dash = true;
 804a902:	80 4d c0 04          	orb    $0x4,-0x40(%ebp)
				width = -width;
 804a906:	f7 df                	neg    %edi
 804a908:	eb 0c                	jmp    804a916 <z_cbvprintf_impl+0x30d>
		int width = -1;
 804a90a:	83 cf ff             	or     $0xffffffff,%edi
			}
		} else if (conv->width_present) {
 804a90d:	80 7d c0 00          	cmpb   $0x0,-0x40(%ebp)
 804a911:	79 03                	jns    804a916 <z_cbvprintf_impl+0x30d>
			width = conv->width_value;
 804a913:	8b 7d c4             	mov    -0x3c(%ebp),%edi

		/* If dynamic precision is specified, process it, otherwise
		 * set precision if present.  For floating point where
		 * precision is not present use 6.
		 */
		if (conv->prec_star) {
 804a916:	a8 04                	test   $0x4,%al
 804a918:	74 12                	je     804a92c <z_cbvprintf_impl+0x323>
			int arg = va_arg(ap, int);
 804a91a:	8b 06                	mov    (%esi),%eax
 804a91c:	8d 5e 04             	lea    0x4(%esi),%ebx
 804a91f:	89 45 90             	mov    %eax,-0x70(%ebp)

			if (arg < 0) {
 804a922:	85 c0                	test   %eax,%eax
 804a924:	79 1d                	jns    804a943 <z_cbvprintf_impl+0x33a>
				conv->prec_present = false;
 804a926:	80 65 c1 fd          	andb   $0xfd,-0x3f(%ebp)
 804a92a:	eb 10                	jmp    804a93c <z_cbvprintf_impl+0x333>
			} else {
				precision = arg;
			}
		} else if (conv->prec_present) {
 804a92c:	a8 02                	test   $0x2,%al
 804a92e:	74 0a                	je     804a93a <z_cbvprintf_impl+0x331>
			precision = conv->prec_value;
 804a930:	8b 45 c8             	mov    -0x38(%ebp),%eax
 804a933:	89 f3                	mov    %esi,%ebx
 804a935:	89 45 90             	mov    %eax,-0x70(%ebp)
 804a938:	eb 09                	jmp    804a943 <z_cbvprintf_impl+0x33a>
 804a93a:	89 f3                	mov    %esi,%ebx
		int precision = -1;
 804a93c:	c7 45 90 ff ff ff ff 	movl   $0xffffffff,-0x70(%ebp)
		 * This can't be extracted to a helper function because
		 * passing a pointer to va_list doesn't work on x86_64.  See
		 * https://stackoverflow.com/a/8048892.
		 */
		enum specifier_cat_enum specifier_cat
			= (enum specifier_cat_enum)conv->specifier_cat;
 804a943:	8a 45 c2             	mov    -0x3e(%ebp),%al
		enum length_mod_enum length_mod
			= (enum length_mod_enum)conv->length_mod;
 804a946:	8a 55 c1             	mov    -0x3f(%ebp),%dl
		conv->pad0_value = 0;
 804a949:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
		conv->pad0_pre_exp = 0;
 804a950:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
			= (enum length_mod_enum)conv->length_mod;
 804a957:	c0 ea 03             	shr    $0x3,%dl
		enum specifier_cat_enum specifier_cat
 804a95a:	83 e0 07             	and    $0x7,%eax
			= (enum length_mod_enum)conv->length_mod;
 804a95d:	88 55 a0             	mov    %dl,-0x60(%ebp)
 804a960:	80 65 a0 0f          	andb   $0xf,-0x60(%ebp)
		enum length_mod_enum length_mod
 804a964:	0f b6 4d a0          	movzbl -0x60(%ebp),%ecx
		/* Extract the value based on the argument category and length.
		 *
		 * Note that the length modifier doesn't affect the value of a
		 * pointer argument.
		 */
		if (specifier_cat == SPECIFIER_SINT) {
 804a968:	83 f8 01             	cmp    $0x1,%eax
 804a96b:	75 4f                	jne    804a9bc <z_cbvprintf_impl+0x3b3>
			switch (length_mod) {
 804a96d:	80 7d a0 05          	cmpb   $0x5,-0x60(%ebp)
 804a971:	74 70                	je     804a9e3 <z_cbvprintf_impl+0x3da>
 804a973:	77 19                	ja     804a98e <z_cbvprintf_impl+0x385>
 804a975:	80 7d a0 03          	cmpb   $0x3,-0x60(%ebp)
 804a979:	74 08                	je     804a983 <z_cbvprintf_impl+0x37a>
 804a97b:	80 7d a0 04          	cmpb   $0x4,-0x60(%ebp)
 804a97f:	74 62                	je     804a9e3 <z_cbvprintf_impl+0x3da>
 804a981:	eb 0b                	jmp    804a98e <z_cbvprintf_impl+0x385>
				if (WCHAR_IS_SIGNED
				    && (conv->specifier == 'c')) {
					value->sint = (wchar_t)va_arg(ap,
							      WINT_TYPE);
				} else {
					value->sint = va_arg(ap, long);
 804a983:	8b 03                	mov    (%ebx),%eax
				value->sint = va_arg(ap, int);
 804a985:	8d 4b 04             	lea    0x4(%ebx),%ecx
					value->sint = va_arg(ap, long);
 804a988:	99                   	cltd   
 804a989:	e9 47 04 00 00       	jmp    804add5 <z_cbvprintf_impl+0x7cc>
				 * unsigned and signed equivalents of each
				 * other.  This can be checked in a platform
				 * test.
				 */
				value->sint =
					(sint_value_type)va_arg(ap, ptrdiff_t);
 804a98e:	8b 03                	mov    (%ebx),%eax
 804a990:	83 c3 04             	add    $0x4,%ebx
 804a993:	99                   	cltd   
				value->sint = va_arg(ap, int);
 804a994:	89 45 b4             	mov    %eax,-0x4c(%ebp)
 804a997:	89 55 b8             	mov    %edx,-0x48(%ebp)
				break;
			}
			if (length_mod == LENGTH_HH) {
 804a99a:	83 f9 01             	cmp    $0x1,%ecx
 804a99d:	75 05                	jne    804a9a4 <z_cbvprintf_impl+0x39b>
				value->sint = (signed char)value->sint;
 804a99f:	0f be c0             	movsbl %al,%eax
 804a9a2:	eb 0a                	jmp    804a9ae <z_cbvprintf_impl+0x3a5>
			} else if (length_mod == LENGTH_H) {
 804a9a4:	83 f9 02             	cmp    $0x2,%ecx
 804a9a7:	0f 85 9d 00 00 00    	jne    804aa4a <z_cbvprintf_impl+0x441>
				value->sint = (short)value->sint;
 804a9ad:	98                   	cwtl   
 804a9ae:	89 45 b4             	mov    %eax,-0x4c(%ebp)
 804a9b1:	c1 f8 1f             	sar    $0x1f,%eax
 804a9b4:	89 45 b8             	mov    %eax,-0x48(%ebp)
 804a9b7:	e9 8e 00 00 00       	jmp    804aa4a <z_cbvprintf_impl+0x441>
			}
		} else if (specifier_cat == SPECIFIER_UINT) {
 804a9bc:	83 f8 02             	cmp    $0x2,%eax
 804a9bf:	75 5e                	jne    804aa1f <z_cbvprintf_impl+0x416>
			switch (length_mod) {
 804a9c1:	80 7d a0 05          	cmpb   $0x5,-0x60(%ebp)
 804a9c5:	74 1c                	je     804a9e3 <z_cbvprintf_impl+0x3da>
 804a9c7:	77 27                	ja     804a9f0 <z_cbvprintf_impl+0x3e7>
 804a9c9:	80 7d a0 03          	cmpb   $0x3,-0x60(%ebp)
 804a9cd:	74 08                	je     804a9d7 <z_cbvprintf_impl+0x3ce>
 804a9cf:	80 7d a0 04          	cmpb   $0x4,-0x60(%ebp)
 804a9d3:	74 0e                	je     804a9e3 <z_cbvprintf_impl+0x3da>
 804a9d5:	eb 19                	jmp    804a9f0 <z_cbvprintf_impl+0x3e7>
				if ((!WCHAR_IS_SIGNED)
				    && (conv->specifier == 'c')) {
					value->uint = (wchar_t)va_arg(ap,
							      WINT_TYPE);
				} else {
					value->uint = va_arg(ap, unsigned long);
 804a9d7:	8b 03                	mov    (%ebx),%eax
 804a9d9:	8d 4b 04             	lea    0x4(%ebx),%ecx
 804a9dc:	31 d2                	xor    %edx,%edx
				}
				break;
 804a9de:	e9 f2 03 00 00       	jmp    804add5 <z_cbvprintf_impl+0x7cc>
					(uint_value_type)va_arg(ap,
						unsigned long long);
				break;
			case LENGTH_J:
				value->uint =
					(uint_value_type)va_arg(ap,
 804a9e3:	8b 03                	mov    (%ebx),%eax
 804a9e5:	8b 53 04             	mov    0x4(%ebx),%edx
 804a9e8:	8d 4b 08             	lea    0x8(%ebx),%ecx
								uintmax_t);
				break;
 804a9eb:	e9 e5 03 00 00       	jmp    804add5 <z_cbvprintf_impl+0x7cc>
			case LENGTH_Z:		/* size_t */
			case LENGTH_T:		/* ptrdiff_t */
				value->uint =
					(uint_value_type)va_arg(ap, size_t);
 804a9f0:	8b 03                	mov    (%ebx),%eax
 804a9f2:	31 d2                	xor    %edx,%edx
 804a9f4:	83 c3 04             	add    $0x4,%ebx
				value->uint = va_arg(ap, unsigned int);
 804a9f7:	89 55 b8             	mov    %edx,-0x48(%ebp)
 804a9fa:	89 45 b4             	mov    %eax,-0x4c(%ebp)
				break;
			}
			if (length_mod == LENGTH_HH) {
 804a9fd:	83 f9 01             	cmp    $0x1,%ecx
 804aa00:	75 07                	jne    804aa09 <z_cbvprintf_impl+0x400>
				value->uint = (unsigned char)value->uint;
 804aa02:	25 ff 00 00 00       	and    $0xff,%eax
 804aa07:	eb 0a                	jmp    804aa13 <z_cbvprintf_impl+0x40a>
			} else if (length_mod == LENGTH_H) {
 804aa09:	83 f9 02             	cmp    $0x2,%ecx
 804aa0c:	75 3c                	jne    804aa4a <z_cbvprintf_impl+0x441>
				value->uint = (unsigned short)value->uint;
 804aa0e:	25 ff ff 00 00       	and    $0xffff,%eax
 804aa13:	89 45 b4             	mov    %eax,-0x4c(%ebp)
 804aa16:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
 804aa1d:	eb 2b                	jmp    804aa4a <z_cbvprintf_impl+0x441>
			}
		} else if (specifier_cat == SPECIFIER_FP) {
 804aa1f:	83 f8 04             	cmp    $0x4,%eax
 804aa22:	75 19                	jne    804aa3d <z_cbvprintf_impl+0x434>
			if (length_mod == LENGTH_UPPER_L) {
 804aa24:	83 f9 08             	cmp    $0x8,%ecx
 804aa27:	75 0a                	jne    804aa33 <z_cbvprintf_impl+0x42a>
				value->ldbl = va_arg(ap, long double);
 804aa29:	db 2b                	fldt   (%ebx)
 804aa2b:	83 c3 0c             	add    $0xc,%ebx
 804aa2e:	db 7d b4             	fstpt  -0x4c(%ebp)
 804aa31:	eb 17                	jmp    804aa4a <z_cbvprintf_impl+0x441>
			} else {
				value->dbl = va_arg(ap, double);
 804aa33:	dd 03                	fldl   (%ebx)
 804aa35:	83 c3 08             	add    $0x8,%ebx
 804aa38:	dd 5d b4             	fstpl  -0x4c(%ebp)
 804aa3b:	eb 0d                	jmp    804aa4a <z_cbvprintf_impl+0x441>
			}
		} else if (specifier_cat == SPECIFIER_PTR) {
 804aa3d:	83 f8 03             	cmp    $0x3,%eax
 804aa40:	75 08                	jne    804aa4a <z_cbvprintf_impl+0x441>
			value->ptr = va_arg(ap, void *);
 804aa42:	8b 03                	mov    (%ebx),%eax
 804aa44:	83 c3 04             	add    $0x4,%ebx
 804aa47:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		/* We've now consumed all arguments related to this
		 * specification.  If the conversion is invalid, or is
		 * something we don't support, then output the original
		 * specification and move on.
		 */
		if (conv->invalid || conv->unsupported) {
 804aa4a:	8a 45 c0             	mov    -0x40(%ebp),%al
 804aa4d:	a8 03                	test   $0x3,%al
 804aa4f:	74 27                	je     804aa78 <z_cbvprintf_impl+0x46f>
			OUTS(sp, fp);
 804aa51:	83 ec 0c             	sub    $0xc,%esp
 804aa54:	8b 4d 8c             	mov    -0x74(%ebp),%ecx
 804aa57:	8b 55 98             	mov    -0x68(%ebp),%edx
 804aa5a:	ff 75 94             	push   -0x6c(%ebp)
 804aa5d:	8b 45 9c             	mov    -0x64(%ebp),%eax
 804aa60:	e8 47 fa ff ff       	call   804a4ac <outs>
 804aa65:	83 c4 10             	add    $0x10,%esp
 804aa68:	85 c0                	test   %eax,%eax
 804aa6a:	0f 88 72 03 00 00    	js     804ade2 <z_cbvprintf_impl+0x7d9>
 804aa70:	01 45 a4             	add    %eax,-0x5c(%ebp)
			continue;
 804aa73:	e9 4b 03 00 00       	jmp    804adc3 <z_cbvprintf_impl+0x7ba>
		}

		/* Do formatting, either into the buffer or
		 * referencing external data.
		 */
		switch (conv->specifier) {
 804aa78:	8a 55 c3             	mov    -0x3d(%ebp),%dl
 804aa7b:	80 fa 78             	cmp    $0x78,%dl
 804aa7e:	0f 87 3f 03 00 00    	ja     804adc3 <z_cbvprintf_impl+0x7ba>
 804aa84:	80 fa 62             	cmp    $0x62,%dl
 804aa87:	77 13                	ja     804aa9c <z_cbvprintf_impl+0x493>
 804aa89:	80 fa 25             	cmp    $0x25,%dl
 804aa8c:	74 24                	je     804aab2 <z_cbvprintf_impl+0x4a9>
 804aa8e:	80 fa 58             	cmp    $0x58,%dl
 804aa91:	0f 84 b3 00 00 00    	je     804ab4a <z_cbvprintf_impl+0x541>
 804aa97:	e9 27 03 00 00       	jmp    804adc3 <z_cbvprintf_impl+0x7ba>
 804aa9c:	83 ea 63             	sub    $0x63,%edx
 804aa9f:	80 fa 15             	cmp    $0x15,%dl
 804aaa2:	0f 87 1b 03 00 00    	ja     804adc3 <z_cbvprintf_impl+0x7ba>
 804aaa8:	0f b6 d2             	movzbl %dl,%edx
 804aaab:	ff 24 95 5c 23 06 08 	jmp    *0x806235c(,%edx,4)
		case '%':
			OUTC('%');
 804aab2:	51                   	push   %ecx
 804aab3:	8b 45 9c             	mov    -0x64(%ebp),%eax
 804aab6:	51                   	push   %ecx
 804aab7:	ff 75 98             	push   -0x68(%ebp)
 804aaba:	6a 25                	push   $0x25
 804aabc:	ff d0                	call   *%eax
 804aabe:	83 c4 10             	add    $0x10,%esp
 804aac1:	85 c0                	test   %eax,%eax
 804aac3:	0f 88 19 03 00 00    	js     804ade2 <z_cbvprintf_impl+0x7d9>
 804aac9:	ff 45 a4             	incl   -0x5c(%ebp)
			break;
 804aacc:	e9 f2 02 00 00       	jmp    804adc3 <z_cbvprintf_impl+0x7ba>
		case 's': {
			bps = (const char *)value->ptr;
 804aad1:	8b 45 b4             	mov    -0x4c(%ebp),%eax

			size_t len;

			if (precision >= 0) {
 804aad4:	83 7d 90 00          	cmpl   $0x0,-0x70(%ebp)
			bps = (const char *)value->ptr;
 804aad8:	89 45 a0             	mov    %eax,-0x60(%ebp)
			if (precision >= 0) {
 804aadb:	78 0d                	js     804aaea <z_cbvprintf_impl+0x4e1>
				len = strnlen(bps, precision);
 804aadd:	52                   	push   %edx
 804aade:	52                   	push   %edx
 804aadf:	ff 75 90             	push   -0x70(%ebp)
 804aae2:	50                   	push   %eax
 804aae3:	e8 28 e8 ff ff       	call   8049310 <strnlen@plt>
 804aae8:	eb 0b                	jmp    804aaf5 <z_cbvprintf_impl+0x4ec>
			} else {
				len = strlen(bps);
 804aaea:	83 ec 0c             	sub    $0xc,%esp
 804aaed:	ff 75 a0             	push   -0x60(%ebp)
 804aaf0:	e8 4b e7 ff ff       	call   8049240 <strlen@plt>
			}

			bpe = bps + len;
 804aaf5:	03 45 a0             	add    -0x60(%ebp),%eax
				len = strlen(bps);
 804aaf8:	83 c4 10             	add    $0x10,%esp
		char sign = 0;
 804aafb:	31 f6                	xor    %esi,%esi
			bpe = bps + len;
 804aafd:	89 45 8c             	mov    %eax,-0x74(%ebp)
			precision = -1;

			break;
 804ab00:	e9 17 01 00 00       	jmp    804ac1c <z_cbvprintf_impl+0x613>
		}
		case 'c':
			bps = buf;
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
 804ab05:	8b 45 b4             	mov    -0x4c(%ebp),%eax
 804ab08:	88 45 ce             	mov    %al,-0x32(%ebp)
			bps = buf;
 804ab0b:	8d 45 ce             	lea    -0x32(%ebp),%eax
 804ab0e:	89 45 a0             	mov    %eax,-0x60(%ebp)
			bpe = buf + 1;
 804ab11:	8d 45 cf             	lea    -0x31(%ebp),%eax
 804ab14:	89 45 8c             	mov    %eax,-0x74(%ebp)
 804ab17:	e9 19 01 00 00       	jmp    804ac35 <z_cbvprintf_impl+0x62c>
			break;
		case 'd':
		case 'i':
			if (conv->flag_plus) {
				sign = '+';
 804ab1c:	be 2b 00 00 00       	mov    $0x2b,%esi
			if (conv->flag_plus) {
 804ab21:	a8 08                	test   $0x8,%al
 804ab23:	75 07                	jne    804ab2c <z_cbvprintf_impl+0x523>
			} else if (conv->flag_space) {
 804ab25:	01 c0                	add    %eax,%eax
 804ab27:	83 e0 20             	and    $0x20,%eax
 804ab2a:	89 c6                	mov    %eax,%esi

			/* sint/uint overlay in the union, and so
			 * can't appear in read and write operations
			 * in the same statement.
			 */
			sint = value->sint;
 804ab2c:	8b 55 b8             	mov    -0x48(%ebp),%edx
 804ab2f:	8b 45 b4             	mov    -0x4c(%ebp),%eax
			if (sint < 0) {
 804ab32:	85 d2                	test   %edx,%edx
 804ab34:	79 16                	jns    804ab4c <z_cbvprintf_impl+0x543>
				sign = '-';
				value->uint = (uint_value_type)-sint;
 804ab36:	f7 d8                	neg    %eax
				sign = '-';
 804ab38:	be 2d 00 00 00       	mov    $0x2d,%esi
				value->uint = (uint_value_type)-sint;
 804ab3d:	83 d2 00             	adc    $0x0,%edx
 804ab40:	89 45 b4             	mov    %eax,-0x4c(%ebp)
 804ab43:	f7 da                	neg    %edx
 804ab45:	89 55 b8             	mov    %edx,-0x48(%ebp)
 804ab48:	eb 02                	jmp    804ab4c <z_cbvprintf_impl+0x543>
		switch (conv->specifier) {
 804ab4a:	31 f6                	xor    %esi,%esi
			__fallthrough;
		case 'o':
		case 'u':
		case 'x':
		case 'X':
			bps = encode_uint(value->uint, conv, buf, bpe);
 804ab4c:	8d 55 e4             	lea    -0x1c(%ebp),%edx
 804ab4f:	50                   	push   %eax
 804ab50:	8d 4d c0             	lea    -0x40(%ebp),%ecx
 804ab53:	50                   	push   %eax
 804ab54:	8d 45 ce             	lea    -0x32(%ebp),%eax
 804ab57:	52                   	push   %edx
 804ab58:	8b 55 b8             	mov    -0x48(%ebp),%edx
 804ab5b:	50                   	push   %eax
 804ab5c:	8b 45 b4             	mov    -0x4c(%ebp),%eax
 804ab5f:	e8 ca f9 ff ff       	call   804a52e <encode_uint>
 804ab64:	83 c4 10             	add    $0x10,%esp
 804ab67:	89 45 a0             	mov    %eax,-0x60(%ebp)
			/* Update pad0 values based on precision and converted
			 * length.  Note that a non-empty sign is not in the
			 * converted sequence, but it does not affect the
			 * padding size.
			 */
			if (precision >= 0) {
 804ab6a:	83 7d 90 00          	cmpl   $0x0,-0x70(%ebp)
 804ab6e:	8d 45 e4             	lea    -0x1c(%ebp),%eax
 804ab71:	0f 88 a2 00 00 00    	js     804ac19 <z_cbvprintf_impl+0x610>
				size_t len = bpe - bps;
 804ab77:	89 c2                	mov    %eax,%edx

				/* Zero-padding flag is ignored for integer
				 * conversions with precision.
				 */
				conv->flag_zero = false;
 804ab79:	80 65 c0 bf          	andb   $0xbf,-0x40(%ebp)
				size_t len = bpe - bps;
 804ab7d:	2b 55 a0             	sub    -0x60(%ebp),%edx
		const char *bpe = buf + sizeof(buf);
 804ab80:	89 45 8c             	mov    %eax,-0x74(%ebp)

				/* Set pad0_value to satisfy precision */
				if (len < (size_t)precision) {
 804ab83:	39 55 90             	cmp    %edx,-0x70(%ebp)
 804ab86:	0f 86 90 00 00 00    	jbe    804ac1c <z_cbvprintf_impl+0x613>
					conv->pad0_value = precision - (int)len;
 804ab8c:	8b 4d 90             	mov    -0x70(%ebp),%ecx
 804ab8f:	29 d1                	sub    %edx,%ecx
 804ab91:	89 4d c4             	mov    %ecx,-0x3c(%ebp)
 804ab94:	e9 83 00 00 00       	jmp    804ac1c <z_cbvprintf_impl+0x613>
		case 'p':
			/* Implementation-defined: null is "(nil)", non-null
			 * has 0x prefix followed by significant address hex
			 * digits, no leading zeros.
			 */
			if (value->ptr != NULL) {
 804ab99:	8b 45 b4             	mov    -0x4c(%ebp),%eax
 804ab9c:	85 c0                	test   %eax,%eax
 804ab9e:	0f 84 83 00 00 00    	je     804ac27 <z_cbvprintf_impl+0x61e>
				bps = encode_uint((uintptr_t)value->ptr, conv,
 804aba4:	8d 75 e4             	lea    -0x1c(%ebp),%esi
 804aba7:	51                   	push   %ecx
 804aba8:	31 d2                	xor    %edx,%edx
 804abaa:	51                   	push   %ecx
 804abab:	8d 4d ce             	lea    -0x32(%ebp),%ecx
 804abae:	56                   	push   %esi
		char sign = 0;
 804abaf:	31 f6                	xor    %esi,%esi
				bps = encode_uint((uintptr_t)value->ptr, conv,
 804abb1:	51                   	push   %ecx
 804abb2:	8d 4d c0             	lea    -0x40(%ebp),%ecx
 804abb5:	e8 74 f9 ff ff       	call   804a52e <encode_uint>
 804abba:	83 c4 10             	add    $0x10,%esp
 804abbd:	89 45 a0             	mov    %eax,-0x60(%ebp)
						  buf, bpe);

				/* Use 0x prefix */
				conv->altform_0c = true;
 804abc0:	66 8b 45 c2          	mov    -0x3e(%ebp),%ax
 804abc4:	66 25 ef 00          	and    $0xef,%ax
 804abc8:	66 0d 10 78          	or     $0x7810,%ax
 804abcc:	66 89 45 c2          	mov    %ax,-0x3e(%ebp)
				conv->specifier = 'x';

				goto prec_int_pad0;
 804abd0:	eb 98                	jmp    804ab6a <z_cbvprintf_impl+0x561>
	switch ((enum length_mod_enum)conv->length_mod) {
 804abd2:	80 7d a0 07          	cmpb   $0x7,-0x60(%ebp)
			bpe = bps + 5;

			break;
		case 'n':
			if (IS_ENABLED(CONFIG_CBPRINTF_N_SPECIFIER)) {
				store_count(conv, value->ptr, count);
 804abd6:	8b 45 b4             	mov    -0x4c(%ebp),%eax
	switch ((enum length_mod_enum)conv->length_mod) {
 804abd9:	0f 87 e4 01 00 00    	ja     804adc3 <z_cbvprintf_impl+0x7ba>
 804abdf:	0f b6 55 a0          	movzbl -0x60(%ebp),%edx
 804abe3:	ff 24 95 b4 23 06 08 	jmp    *0x80623b4(,%edx,4)
		*(signed char *)dp = (signed char)count;
 804abea:	8a 55 a4             	mov    -0x5c(%ebp),%dl
 804abed:	88 10                	mov    %dl,(%eax)
		break;
 804abef:	e9 cf 01 00 00       	jmp    804adc3 <z_cbvprintf_impl+0x7ba>
		*(short *)dp = (short)count;
 804abf4:	8b 7d a4             	mov    -0x5c(%ebp),%edi
 804abf7:	66 89 38             	mov    %di,(%eax)
		break;
 804abfa:	e9 c4 01 00 00       	jmp    804adc3 <z_cbvprintf_impl+0x7ba>
		*(intmax_t *)dp = (intmax_t)count;
 804abff:	8b 7d a4             	mov    -0x5c(%ebp),%edi
 804ac02:	89 38                	mov    %edi,(%eax)
 804ac04:	c1 ff 1f             	sar    $0x1f,%edi
 804ac07:	89 78 04             	mov    %edi,0x4(%eax)
		break;
 804ac0a:	e9 b4 01 00 00       	jmp    804adc3 <z_cbvprintf_impl+0x7ba>
		*(ptrdiff_t *)dp = (ptrdiff_t)count;
 804ac0f:	8b 7d a4             	mov    -0x5c(%ebp),%edi
 804ac12:	89 38                	mov    %edi,(%eax)
		break;
 804ac14:	e9 aa 01 00 00       	jmp    804adc3 <z_cbvprintf_impl+0x7ba>
		const char *bpe = buf + sizeof(buf);
 804ac19:	89 45 8c             	mov    %eax,-0x74(%ebp)
		}

		/* If we don't have a converted value to emit, move
		 * on.
		 */
		if (bps == NULL) {
 804ac1c:	83 7d a0 00          	cmpl   $0x0,-0x60(%ebp)
 804ac20:	75 15                	jne    804ac37 <z_cbvprintf_impl+0x62e>
 804ac22:	e9 9c 01 00 00       	jmp    804adc3 <z_cbvprintf_impl+0x7ba>
			bps = "(nil)";
 804ac27:	c7 45 a0 6b 29 06 08 	movl   $0x806296b,-0x60(%ebp)
			bpe = bps + 5;
 804ac2e:	c7 45 8c 70 29 06 08 	movl   $0x8062970,-0x74(%ebp)
 804ac35:	31 f6                	xor    %esi,%esi
		 */
		size_t nj_len = (bpe - bps);
		int pad_len = 0;

		if (sign != 0) {
			nj_len += 1U;
 804ac37:	89 f1                	mov    %esi,%ecx
		}

		if (conv->altform_0c) {
 804ac39:	8a 55 c2             	mov    -0x3e(%ebp),%dl
		size_t nj_len = (bpe - bps);
 804ac3c:	8b 45 8c             	mov    -0x74(%ebp),%eax
 804ac3f:	2b 45 a0             	sub    -0x60(%ebp),%eax
			nj_len += 1U;
 804ac42:	80 f9 01             	cmp    $0x1,%cl
 804ac45:	83 d8 ff             	sbb    $0xffffffff,%eax
		if (conv->altform_0c) {
 804ac48:	f6 c2 10             	test   $0x10,%dl
 804ac4b:	74 05                	je     804ac52 <z_cbvprintf_impl+0x649>
			nj_len += 2U;
 804ac4d:	83 c0 02             	add    $0x2,%eax
 804ac50:	eb 0b                	jmp    804ac5d <z_cbvprintf_impl+0x654>
		} else if (conv->altform_0) {
 804ac52:	89 d1                	mov    %edx,%ecx
 804ac54:	83 e1 08             	and    $0x8,%ecx
			nj_len += 1U;
 804ac57:	80 f9 01             	cmp    $0x1,%cl
 804ac5a:	83 d8 ff             	sbb    $0xffffffff,%eax
		}

		nj_len += conv->pad0_value;
 804ac5d:	03 45 c4             	add    -0x3c(%ebp),%eax
		if (conv->pad_fp) {
 804ac60:	80 e2 40             	and    $0x40,%dl
 804ac63:	74 03                	je     804ac68 <z_cbvprintf_impl+0x65f>
			nj_len += conv->pad0_pre_exp;
 804ac65:	03 45 c8             	add    -0x38(%ebp),%eax
		 * result in no padding.
		 *
		 * If a non-negative padding width is present and we're doing
		 * right-justification, emit the padding now.
		 */
		if (width > 0) {
 804ac68:	85 ff                	test   %edi,%edi
 804ac6a:	7e 7e                	jle    804acea <z_cbvprintf_impl+0x6e1>
			width -= (int)nj_len;
 804ac6c:	29 c7                	sub    %eax,%edi

			if (!conv->flag_dash) {
 804ac6e:	8a 45 c0             	mov    -0x40(%ebp),%al
			width -= (int)nj_len;
 804ac71:	89 7d 90             	mov    %edi,-0x70(%ebp)
			if (!conv->flag_dash) {
 804ac74:	a8 04                	test   $0x4,%al
 804ac76:	75 6f                	jne    804ace7 <z_cbvprintf_impl+0x6de>
				char pad = ' ';

				/* If we're zero-padding we have to emit the
				 * sign first.
				 */
				if (conv->flag_zero) {
 804ac78:	a8 40                	test   $0x40,%al
 804ac7a:	74 2b                	je     804aca7 <z_cbvprintf_impl+0x69e>
					if (sign != 0) {
 804ac7c:	89 f0                	mov    %esi,%eax
 804ac7e:	84 c0                	test   %al,%al
 804ac80:	74 2c                	je     804acae <z_cbvprintf_impl+0x6a5>
						OUTC(sign);
 804ac82:	56                   	push   %esi
 804ac83:	56                   	push   %esi
 804ac84:	0f be f0             	movsbl %al,%esi
 804ac87:	8b 45 9c             	mov    -0x64(%ebp),%eax
 804ac8a:	ff 75 98             	push   -0x68(%ebp)
 804ac8d:	56                   	push   %esi
 804ac8e:	ff d0                	call   *%eax
 804ac90:	83 c4 10             	add    $0x10,%esp
 804ac93:	85 c0                	test   %eax,%eax
 804ac95:	0f 88 47 01 00 00    	js     804ade2 <z_cbvprintf_impl+0x7d9>
 804ac9b:	ff 45 a4             	incl   -0x5c(%ebp)
						sign = 0;
					}
					pad = '0';
 804ac9e:	ba 30 00 00 00       	mov    $0x30,%edx
						OUTC(sign);
 804aca3:	31 f6                	xor    %esi,%esi
 804aca5:	eb 0c                	jmp    804acb3 <z_cbvprintf_impl+0x6aa>
				char pad = ' ';
 804aca7:	ba 20 00 00 00       	mov    $0x20,%edx
 804acac:	eb 05                	jmp    804acb3 <z_cbvprintf_impl+0x6aa>
					pad = '0';
 804acae:	ba 30 00 00 00       	mov    $0x30,%edx
 804acb3:	8b 7d 90             	mov    -0x70(%ebp),%edi
 804acb6:	8b 45 90             	mov    -0x70(%ebp),%eax
 804acb9:	89 f9                	mov    %edi,%ecx
 804acbb:	03 45 a4             	add    -0x5c(%ebp),%eax
 804acbe:	29 f8                	sub    %edi,%eax
				}

				while (width-- > 0) {
 804acc0:	4f                   	dec    %edi
 804acc1:	85 c9                	test   %ecx,%ecx
 804acc3:	7e 1d                	jle    804ace2 <z_cbvprintf_impl+0x6d9>
					OUTC(pad);
 804acc5:	51                   	push   %ecx
 804acc6:	8b 45 9c             	mov    -0x64(%ebp),%eax
 804acc9:	51                   	push   %ecx
 804acca:	ff 75 98             	push   -0x68(%ebp)
 804accd:	52                   	push   %edx
 804acce:	89 55 88             	mov    %edx,-0x78(%ebp)
 804acd1:	ff d0                	call   *%eax
 804acd3:	8b 55 88             	mov    -0x78(%ebp),%edx
 804acd6:	83 c4 10             	add    $0x10,%esp
 804acd9:	85 c0                	test   %eax,%eax
 804acdb:	79 d9                	jns    804acb6 <z_cbvprintf_impl+0x6ad>
 804acdd:	e9 00 01 00 00       	jmp    804ade2 <z_cbvprintf_impl+0x7d9>
 804ace2:	89 45 a4             	mov    %eax,-0x5c(%ebp)
 804ace5:	eb 03                	jmp    804acea <z_cbvprintf_impl+0x6e1>
			width -= (int)nj_len;
 804ace7:	8b 7d 90             	mov    -0x70(%ebp),%edi
		}

		/* If we have a sign that hasn't been emitted, now's the
		 * time....
		 */
		if (sign != 0) {
 804acea:	89 f0                	mov    %esi,%eax
 804acec:	84 c0                	test   %al,%al
 804acee:	74 1c                	je     804ad0c <z_cbvprintf_impl+0x703>
			OUTC(sign);
 804acf0:	0f be f0             	movsbl %al,%esi
 804acf3:	52                   	push   %edx
 804acf4:	8b 45 9c             	mov    -0x64(%ebp),%eax
 804acf7:	52                   	push   %edx
 804acf8:	ff 75 98             	push   -0x68(%ebp)
 804acfb:	56                   	push   %esi
 804acfc:	ff d0                	call   *%eax
 804acfe:	83 c4 10             	add    $0x10,%esp
 804ad01:	85 c0                	test   %eax,%eax
 804ad03:	0f 88 d9 00 00 00    	js     804ade2 <z_cbvprintf_impl+0x7d9>
 804ad09:	ff 45 a4             	incl   -0x5c(%ebp)
				OUTC('0');
			}

			OUTS(cp, bpe);
		} else {
			if (conv->altform_0c | conv->altform_0) {
 804ad0c:	8a 45 c2             	mov    -0x3e(%ebp),%al
 804ad0f:	a8 10                	test   $0x10,%al
 804ad11:	75 04                	jne    804ad17 <z_cbvprintf_impl+0x70e>
 804ad13:	a8 08                	test   $0x8,%al
 804ad15:	74 1a                	je     804ad31 <z_cbvprintf_impl+0x728>
				OUTC('0');
 804ad17:	56                   	push   %esi
 804ad18:	8b 45 9c             	mov    -0x64(%ebp),%eax
 804ad1b:	56                   	push   %esi
 804ad1c:	ff 75 98             	push   -0x68(%ebp)
 804ad1f:	6a 30                	push   $0x30
 804ad21:	ff d0                	call   *%eax
 804ad23:	83 c4 10             	add    $0x10,%esp
 804ad26:	85 c0                	test   %eax,%eax
 804ad28:	0f 88 b4 00 00 00    	js     804ade2 <z_cbvprintf_impl+0x7d9>
 804ad2e:	ff 45 a4             	incl   -0x5c(%ebp)
			}

			if (conv->altform_0c) {
 804ad31:	f6 45 c2 10          	testb  $0x10,-0x3e(%ebp)
 804ad35:	74 1d                	je     804ad54 <z_cbvprintf_impl+0x74b>
				OUTC(conv->specifier);
 804ad37:	0f b6 45 c3          	movzbl -0x3d(%ebp),%eax
 804ad3b:	51                   	push   %ecx
 804ad3c:	51                   	push   %ecx
 804ad3d:	ff 75 98             	push   -0x68(%ebp)
 804ad40:	50                   	push   %eax
 804ad41:	8b 45 9c             	mov    -0x64(%ebp),%eax
 804ad44:	ff d0                	call   *%eax
 804ad46:	83 c4 10             	add    $0x10,%esp
 804ad49:	85 c0                	test   %eax,%eax
 804ad4b:	0f 88 91 00 00 00    	js     804ade2 <z_cbvprintf_impl+0x7d9>
 804ad51:	ff 45 a4             	incl   -0x5c(%ebp)
			}

			pad_len = conv->pad0_value;
 804ad54:	8b 55 c4             	mov    -0x3c(%ebp),%edx
			while (pad_len-- > 0) {
 804ad57:	8b 75 a4             	mov    -0x5c(%ebp),%esi
 804ad5a:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 804ad5d:	01 d0                	add    %edx,%eax
 804ad5f:	29 f0                	sub    %esi,%eax
 804ad61:	85 c0                	test   %eax,%eax
 804ad63:	7e 1c                	jle    804ad81 <z_cbvprintf_impl+0x778>
 804ad65:	89 55 90             	mov    %edx,-0x70(%ebp)
				OUTC('0');
 804ad68:	8b 45 9c             	mov    -0x64(%ebp),%eax
 804ad6b:	52                   	push   %edx
 804ad6c:	52                   	push   %edx
 804ad6d:	ff 75 98             	push   -0x68(%ebp)
 804ad70:	6a 30                	push   $0x30
 804ad72:	ff d0                	call   *%eax
 804ad74:	83 c4 10             	add    $0x10,%esp
 804ad77:	85 c0                	test   %eax,%eax
 804ad79:	78 67                	js     804ade2 <z_cbvprintf_impl+0x7d9>
 804ad7b:	8b 55 90             	mov    -0x70(%ebp),%edx
 804ad7e:	46                   	inc    %esi
 804ad7f:	eb d9                	jmp    804ad5a <z_cbvprintf_impl+0x751>
			}

			OUTS(bps, bpe);
 804ad81:	83 ec 0c             	sub    $0xc,%esp
 804ad84:	8b 4d a0             	mov    -0x60(%ebp),%ecx
 804ad87:	8b 55 98             	mov    -0x68(%ebp),%edx
 804ad8a:	ff 75 8c             	push   -0x74(%ebp)
 804ad8d:	8b 45 9c             	mov    -0x64(%ebp),%eax
 804ad90:	e8 17 f7 ff ff       	call   804a4ac <outs>
 804ad95:	83 c4 10             	add    $0x10,%esp
 804ad98:	85 c0                	test   %eax,%eax
 804ad9a:	78 46                	js     804ade2 <z_cbvprintf_impl+0x7d9>
 804ad9c:	01 c6                	add    %eax,%esi
 804ad9e:	89 75 a4             	mov    %esi,-0x5c(%ebp)
		}

		/* Finish left justification */
		while (width > 0) {
 804ada1:	8d 04 37             	lea    (%edi,%esi,1),%eax
 804ada4:	2b 45 a4             	sub    -0x5c(%ebp),%eax
 804ada7:	85 c0                	test   %eax,%eax
 804ada9:	7e 18                	jle    804adc3 <z_cbvprintf_impl+0x7ba>
			OUTC(' ');
 804adab:	50                   	push   %eax
 804adac:	50                   	push   %eax
 804adad:	8b 45 9c             	mov    -0x64(%ebp),%eax
 804adb0:	ff 75 98             	push   -0x68(%ebp)
 804adb3:	6a 20                	push   $0x20
 804adb5:	ff d0                	call   *%eax
 804adb7:	83 c4 10             	add    $0x10,%esp
 804adba:	85 c0                	test   %eax,%eax
 804adbc:	78 24                	js     804ade2 <z_cbvprintf_impl+0x7d9>
 804adbe:	ff 45 a4             	incl   -0x5c(%ebp)
 804adc1:	eb de                	jmp    804ada1 <z_cbvprintf_impl+0x798>
 804adc3:	8b 45 94             	mov    -0x6c(%ebp),%eax
 804adc6:	89 de                	mov    %ebx,%esi
 804adc8:	89 45 8c             	mov    %eax,-0x74(%ebp)
 804adcb:	e9 69 f8 ff ff       	jmp    804a639 <z_cbvprintf_impl+0x30>
			--width;
		}
	}

	return count;
 804add0:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 804add3:	eb 0d                	jmp    804ade2 <z_cbvprintf_impl+0x7d9>
					value->uint = va_arg(ap, unsigned long);
 804add5:	89 45 b4             	mov    %eax,-0x4c(%ebp)
 804add8:	89 cb                	mov    %ecx,%ebx
 804adda:	89 55 b8             	mov    %edx,-0x48(%ebp)
			} else if (length_mod == LENGTH_H) {
 804addd:	e9 68 fc ff ff       	jmp    804aa4a <z_cbvprintf_impl+0x441>
#undef OUTS
#undef OUTC
}
 804ade2:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 804ade5:	65 2b 15 14 00 00 00 	sub    %gs:0x14,%edx
 804adec:	74 05                	je     804adf3 <z_cbvprintf_impl+0x7ea>
 804adee:	e8 0d e5 ff ff       	call   8049300 <__stack_chk_fail@plt>
 804adf3:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804adf6:	5b                   	pop    %ebx
 804adf7:	5e                   	pop    %esi
 804adf8:	5f                   	pop    %edi
 804adf9:	5d                   	pop    %ebp
 804adfa:	c3                   	ret    

0804adfb <assert_print>:

	k_panic();
}

void assert_print(const char *fmt, ...)
{
 804adfb:	55                   	push   %ebp
 804adfc:	89 e5                	mov    %esp,%ebp
 804adfe:	83 ec 10             	sub    $0x10,%esp
	va_list ap;

	va_start(ap, fmt);
 804ae01:	8d 45 0c             	lea    0xc(%ebp),%eax

	vprintk(fmt, ap);
 804ae04:	50                   	push   %eax
 804ae05:	ff 75 08             	push   0x8(%ebp)
 804ae08:	e8 95 f0 ff ff       	call   8049ea2 <vprintk>
 804ae0d:	83 c4 10             	add    $0x10,%esp

	va_end(ap);
}
 804ae10:	c9                   	leave  
 804ae11:	c3                   	ret    

0804ae12 <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_BUILD_OUTPUT_STRIP_PATHS, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_WARN_DEPRECATED, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_EXPERIMENTAL, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_COMPAT_INCLUDES, 1);

GEN_ABS_SYM_END
 804ae12:	c3                   	ret    

0804ae13 <sys_trace_isr_enter>:
 *
 * SPDX-License-Identifier: Apache-2.0
 */


void sys_trace_isr_enter(void) {}
 804ae13:	c3                   	ret    

0804ae14 <sys_trace_isr_exit>:
 804ae14:	c3                   	ret    

0804ae15 <sys_trace_idle>:
 804ae15:	c3                   	ret    

0804ae16 <dns_resolve_cb>:
	struct zsock_addrinfo *ai_arr;
};

static void dns_resolve_cb(enum dns_resolve_status status,
			   struct dns_addrinfo *info, void *user_data)
{
 804ae16:	55                   	push   %ebp
 804ae17:	89 e5                	mov    %esp,%ebp
 804ae19:	57                   	push   %edi
 804ae1a:	56                   	push   %esi
 804ae1b:	53                   	push   %ebx
 804ae1c:	83 ec 1c             	sub    $0x1c,%esp
 804ae1f:	8b 5d 0c             	mov    0xc(%ebp),%ebx
 804ae22:	8b 45 08             	mov    0x8(%ebp),%eax
 804ae25:	8b 55 10             	mov    0x10(%ebp),%edx
	struct zsock_addrinfo *ai;
	int socktype = SOCK_STREAM;

	NET_DBG("dns status: %d", status);

	if (info == NULL) {
 804ae28:	85 db                	test   %ebx,%ebx
 804ae2a:	75 1c                	jne    804ae48 <dns_resolve_cb+0x32>
		if (status == DNS_EAI_ALLDONE) {
 804ae2c:	83 f8 99             	cmp    $0xffffff99,%eax
 804ae2f:	75 02                	jne    804ae33 <dns_resolve_cb+0x1d>
			status = 0;
 804ae31:	31 c0                	xor    %eax,%eax
		}
		state->status = status;
 804ae33:	89 42 1c             	mov    %eax,0x1c(%edx)
		k_sem_give(&state->sem);
 804ae36:	8d 42 04             	lea    0x4(%edx),%eax
 804ae39:	89 45 08             	mov    %eax,0x8(%ebp)

	ai->ai_socktype = socktype;
	ai->ai_protocol = (socktype == SOCK_DGRAM) ? IPPROTO_UDP : IPPROTO_TCP;

	state->idx++;
}
 804ae3c:	83 c4 1c             	add    $0x1c,%esp
 804ae3f:	5b                   	pop    %ebx
 804ae40:	5e                   	pop    %esi
 804ae41:	5f                   	pop    %edi
 804ae42:	5d                   	pop    %ebp
	z_impl_k_sem_give(sem);
 804ae43:	e9 02 48 01 00       	jmp    805f64a <z_impl_k_sem_give>
	if (state->idx >= AI_ARR_MAX) {
 804ae48:	8b 72 20             	mov    0x20(%edx),%esi
 804ae4b:	66 83 fe 01          	cmp    $0x1,%si
 804ae4f:	0f 87 86 00 00 00    	ja     804aedb <dns_resolve_cb+0xc5>
	ai = &state->ai_arr[state->idx];
 804ae55:	0f b7 ce             	movzwl %si,%ecx
 804ae58:	8b 7a 28             	mov    0x28(%edx),%edi
 804ae5b:	6b c9 50             	imul   $0x50,%ecx,%ecx
 804ae5e:	8d 04 0f             	lea    (%edi,%ecx,1),%eax
	if (state->idx > 0) {
 804ae61:	66 85 f6             	test   %si,%si
 804ae64:	74 04                	je     804ae6a <dns_resolve_cb+0x54>
		state->ai_arr[state->idx - 1].ai_next = ai;
 804ae66:	89 44 0f b0          	mov    %eax,-0x50(%edi,%ecx,1)
  return __builtin___memcpy_chk (__dest, __src, __len,
 804ae6a:	8b 4b 18             	mov    0x18(%ebx),%ecx
	memcpy(&ai->_ai_addr, &info->ai_addr, info->ai_addrlen);
 804ae6d:	8d 78 20             	lea    0x20(%eax),%edi
 804ae70:	89 de                	mov    %ebx,%esi
 804ae72:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
	ai->ai_addr = &ai->_ai_addr;
 804ae74:	8d 78 20             	lea    0x20(%eax),%edi
	memcpy(&ai->_ai_canonname, &info->ai_canonname,
 804ae77:	8d 70 38             	lea    0x38(%eax),%esi
 804ae7a:	89 75 e4             	mov    %esi,-0x1c(%ebp)
 804ae7d:	8d 73 1d             	lea    0x1d(%ebx),%esi
	net_sin(&ai->_ai_addr)->sin_port = state->port;
 804ae80:	66 8b 4a 22          	mov    0x22(%edx),%cx
	ai->ai_addr = &ai->_ai_addr;
 804ae84:	89 78 18             	mov    %edi,0x18(%eax)
 804ae87:	8b 7d e4             	mov    -0x1c(%ebp),%edi
	net_sin(&ai->_ai_addr)->sin_port = state->port;
 804ae8a:	66 89 48 22          	mov    %cx,0x22(%eax)
	ai->ai_addrlen = info->ai_addrlen;
 804ae8e:	8b 4b 18             	mov    0x18(%ebx),%ecx
 804ae91:	89 48 14             	mov    %ecx,0x14(%eax)
 804ae94:	b9 15 00 00 00       	mov    $0x15,%ecx
 804ae99:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
	ai->ai_canonname = ai->_ai_canonname;
 804ae9b:	8b 7d e4             	mov    -0x1c(%ebp),%edi
 804ae9e:	89 78 1c             	mov    %edi,0x1c(%eax)
	ai->ai_family = info->ai_family;
 804aea1:	0f b6 4b 1c          	movzbl 0x1c(%ebx),%ecx
 804aea5:	89 48 08             	mov    %ecx,0x8(%eax)
	if (state->hints) {
 804aea8:	8b 0a                	mov    (%edx),%ecx
 804aeaa:	85 c9                	test   %ecx,%ecx
 804aeac:	74 19                	je     804aec7 <dns_resolve_cb+0xb1>
		if (state->hints->ai_socktype) {
 804aeae:	8b 59 0c             	mov    0xc(%ecx),%ebx
 804aeb1:	85 db                	test   %ebx,%ebx
 804aeb3:	74 12                	je     804aec7 <dns_resolve_cb+0xb1>
	ai->ai_protocol = (socktype == SOCK_DGRAM) ? IPPROTO_UDP : IPPROTO_TCP;
 804aeb5:	83 fb 02             	cmp    $0x2,%ebx
 804aeb8:	b9 06 00 00 00       	mov    $0x6,%ecx
 804aebd:	be 11 00 00 00       	mov    $0x11,%esi
 804aec2:	0f 44 ce             	cmove  %esi,%ecx
 804aec5:	eb 0a                	jmp    804aed1 <dns_resolve_cb+0xbb>
 804aec7:	bb 01 00 00 00       	mov    $0x1,%ebx
 804aecc:	b9 06 00 00 00       	mov    $0x6,%ecx
	ai->ai_socktype = socktype;
 804aed1:	89 58 0c             	mov    %ebx,0xc(%eax)
	ai->ai_protocol = (socktype == SOCK_DGRAM) ? IPPROTO_UDP : IPPROTO_TCP;
 804aed4:	89 48 10             	mov    %ecx,0x10(%eax)
	state->idx++;
 804aed7:	66 ff 42 20          	incw   0x20(%edx)
}
 804aedb:	83 c4 1c             	add    $0x1c,%esp
 804aede:	5b                   	pop    %ebx
 804aedf:	5e                   	pop    %esi
 804aee0:	5f                   	pop    %edi
 804aee1:	5d                   	pop    %ebp
 804aee2:	c3                   	ret    

0804aee3 <exec_query>:

static int exec_query(const char *host, int family,
		      struct getaddrinfo_state *ai_state)
{
 804aee3:	55                   	push   %ebp
 804aee4:	89 e5                	mov    %esp,%ebp
 804aee6:	57                   	push   %edi
	enum dns_query_type qtype = DNS_QUERY_TYPE_A;
	int st, ret;

	if (family == AF_INET6) {
		qtype = DNS_QUERY_TYPE_AAAA;
 804aee7:	bf 01 00 00 00       	mov    $0x1,%edi
{
 804aeec:	56                   	push   %esi
 804aeed:	89 ce                	mov    %ecx,%esi
 804aeef:	53                   	push   %ebx
 804aef0:	89 c3                	mov    %eax,%ebx
		qtype = DNS_QUERY_TYPE_AAAA;
 804aef2:	b8 1c 00 00 00       	mov    $0x1c,%eax
{
 804aef7:	83 ec 0c             	sub    $0xc,%esp
		qtype = DNS_QUERY_TYPE_AAAA;
 804aefa:	83 fa 02             	cmp    $0x2,%edx
 804aefd:	0f 44 f8             	cmove  %eax,%edi
				    uint16_t *dns_id,
				    dns_resolve_cb_t cb,
				    void *user_data,
				    int32_t timeout)
{
	return dns_resolve_name(dns_resolve_get_default(),
 804af00:	e8 67 0d 01 00       	call   805bc6c <dns_resolve_get_default>
 804af05:	52                   	push   %edx
	}

	ret = dns_get_addr_info(host, qtype, &ai_state->dns_id,
 804af06:	8d 56 24             	lea    0x24(%esi),%edx
 804af09:	68 d0 07 00 00       	push   $0x7d0
 804af0e:	56                   	push   %esi
 804af0f:	68 16 ae 04 08       	push   $0x804ae16
 804af14:	52                   	push   %edx
 804af15:	57                   	push   %edi
 804af16:	53                   	push   %ebx
 804af17:	50                   	push   %eax
 804af18:	e8 29 09 01 00       	call   805b846 <dns_resolve_name>
 804af1d:	83 c4 20             	add    $0x20,%esp
				dns_resolve_cb, ai_state,
				CONFIG_NET_SOCKETS_DNS_TIMEOUT);
	if (ret == 0) {
 804af20:	85 c0                	test   %eax,%eax
 804af22:	75 3a                	jne    804af5e <exec_query+0x7b>
		 * dns_resolve_cb() would not be called, then we want the
		 * semaphore to timeout so that we will not hang forever.
		 * So make the sem timeout longer than the DNS timeout so that
		 * we do not need to start to cancel any pending DNS queries.
		 */
		ret = k_sem_take(&ai_state->sem, K_MSEC(CONFIG_NET_SOCKETS_DNS_TIMEOUT + 100));
 804af24:	8d 46 04             	lea    0x4(%esi),%eax
	return z_impl_k_sem_take(sem, timeout);
 804af27:	51                   	push   %ecx
 804af28:	6a 00                	push   $0x0
 804af2a:	68 d2 00 00 00       	push   $0xd2
 804af2f:	50                   	push   %eax
 804af30:	e8 7d 47 01 00       	call   805f6b2 <z_impl_k_sem_take>
 804af35:	83 c4 10             	add    $0x10,%esp
		if (ret == -EAGAIN) {
 804af38:	83 f8 f5             	cmp    $0xfffffff5,%eax
 804af3b:	75 1c                	jne    804af59 <exec_query+0x76>
			(void)dns_cancel_addr_info(ai_state->dns_id);
 804af3d:	0f b7 5e 24          	movzwl 0x24(%esi),%ebx
 *
 * @return 0 if ok, <0 if error.
 */
static inline int dns_cancel_addr_info(uint16_t dns_id)
{
	return dns_resolve_cancel(dns_resolve_get_default(), dns_id);
 804af41:	e8 26 0d 01 00       	call   805bc6c <dns_resolve_get_default>
 804af46:	52                   	push   %edx
 804af47:	52                   	push   %edx
 804af48:	53                   	push   %ebx
 804af49:	50                   	push   %eax
 804af4a:	e8 e5 08 01 00       	call   805b834 <dns_resolve_cancel>
 804af4f:	83 c4 10             	add    $0x10,%esp
			st = DNS_EAI_AGAIN;
 804af52:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
 804af57:	eb 1f                	jmp    804af78 <exec_query+0x95>
		} else {
			st = ai_state->status;
 804af59:	8b 46 1c             	mov    0x1c(%esi),%eax
	} else {
		errno = -ret;
		st = DNS_EAI_SYSTEM;
	}

	return st;
 804af5c:	eb 1a                	jmp    804af78 <exec_query+0x95>
 804af5e:	89 c3                	mov    %eax,%ebx
		st = DNS_EAI_ADDRFAMILY;
 804af60:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
	} else if (ret == -EPFNOSUPPORT) {
 804af65:	83 fb a0             	cmp    $0xffffffa0,%ebx
 804af68:	74 0e                	je     804af78 <exec_query+0x95>
		errno = -ret;
 804af6a:	e8 d1 e0 ff ff       	call   8049040 <__errno_location@plt>
 804af6f:	f7 db                	neg    %ebx
 804af71:	89 18                	mov    %ebx,(%eax)
		st = DNS_EAI_SYSTEM;
 804af73:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
}
 804af78:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804af7b:	5b                   	pop    %ebx
 804af7c:	5e                   	pop    %esi
 804af7d:	5f                   	pop    %edi
 804af7e:	5d                   	pop    %ebp
 804af7f:	c3                   	ret    

0804af80 <z_impl_z_zsock_getaddrinfo_internal>:
}

int z_impl_z_zsock_getaddrinfo_internal(const char *host, const char *service,
				       const struct zsock_addrinfo *hints,
				       struct zsock_addrinfo *res)
{
 804af80:	55                   	push   %ebp
 804af81:	89 e5                	mov    %esp,%ebp
 804af83:	57                   	push   %edi
 804af84:	56                   	push   %esi
 804af85:	53                   	push   %ebx
 804af86:	83 ec 4c             	sub    $0x4c,%esp
 804af89:	8b 45 08             	mov    0x8(%ebp),%eax
 804af8c:	8b 55 10             	mov    0x10(%ebp),%edx
 804af8f:	8b 5d 14             	mov    0x14(%ebp),%ebx
 804af92:	89 45 b0             	mov    %eax,-0x50(%ebp)
 804af95:	8b 45 0c             	mov    0xc(%ebp),%eax
 804af98:	65 8b 0d 14 00 00 00 	mov    %gs:0x14,%ecx
 804af9f:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
 804afa2:	31 c9                	xor    %ecx,%ecx
	long int port = 0;
	int st1 = DNS_EAI_ADDRFAMILY, st2 = DNS_EAI_ADDRFAMILY;
	struct sockaddr *ai_addr;
	struct getaddrinfo_state ai_state;

	if (hints) {
 804afa4:	85 d2                	test   %edx,%edx
 804afa6:	74 26                	je     804afce <z_impl_z_zsock_getaddrinfo_internal+0x4e>
		family = hints->ai_family;
 804afa8:	8b 7a 08             	mov    0x8(%edx),%edi
		ai_flags = hints->ai_flags;
 804afab:	8b 4a 04             	mov    0x4(%edx),%ecx

		if ((family != AF_UNSPEC) && (family != AF_INET) && (family != AF_INET6)) {
			return DNS_EAI_ADDRFAMILY;
 804afae:	be f7 ff ff ff       	mov    $0xfffffff7,%esi
		family = hints->ai_family;
 804afb3:	89 7d b4             	mov    %edi,-0x4c(%ebp)
		if ((family != AF_UNSPEC) && (family != AF_INET) && (family != AF_INET6)) {
 804afb6:	83 ff 02             	cmp    $0x2,%edi
 804afb9:	0f 87 f3 01 00 00    	ja     804b1b2 <z_impl_z_zsock_getaddrinfo_internal+0x232>
		}
	}

	if (ai_flags & AI_NUMERICHOST) {
 804afbf:	80 e1 04             	and    $0x4,%cl
 804afc2:	74 11                	je     804afd5 <z_impl_z_zsock_getaddrinfo_internal+0x55>
		/* Asked to resolve host as numeric, but it wasn't possible
		 * to do that.
		 */
		return DNS_EAI_FAIL;
 804afc4:	be fc ff ff ff       	mov    $0xfffffffc,%esi
 804afc9:	e9 e4 01 00 00       	jmp    804b1b2 <z_impl_z_zsock_getaddrinfo_internal+0x232>
	int family = AF_UNSPEC;
 804afce:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%ebp)
	}

	if (service) {
 804afd5:	85 c0                	test   %eax,%eax
 804afd7:	74 29                	je     804b002 <z_impl_z_zsock_getaddrinfo_internal+0x82>
 804afd9:	89 55 ac             	mov    %edx,-0x54(%ebp)
		port = strtol(service, NULL, 10);
		if (port < 1 || port > 65535) {
			return DNS_EAI_NONAME;
 804afdc:	be fe ff ff ff       	mov    $0xfffffffe,%esi
		port = strtol(service, NULL, 10);
 804afe1:	52                   	push   %edx
 804afe2:	6a 0a                	push   $0xa
 804afe4:	6a 00                	push   $0x0
 804afe6:	50                   	push   %eax
 804afe7:	e8 94 e1 ff ff       	call   8049180 <strtol@plt>
 804afec:	83 c4 10             	add    $0x10,%esp
		if (port < 1 || port > 65535) {
 804afef:	8b 55 ac             	mov    -0x54(%ebp),%edx
 804aff2:	8d 48 ff             	lea    -0x1(%eax),%ecx
 804aff5:	81 f9 fe ff 00 00    	cmp    $0xfffe,%ecx
 804affb:	76 22                	jbe    804b01f <z_impl_z_zsock_getaddrinfo_internal+0x9f>
 804affd:	e9 b0 01 00 00       	jmp    804b1b2 <z_impl_z_zsock_getaddrinfo_internal+0x232>
	long int port = 0;
 804b002:	31 c0                	xor    %eax,%eax
		}
	}

	if (host == NULL) {
 804b004:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
 804b008:	75 1f                	jne    804b029 <z_impl_z_zsock_getaddrinfo_internal+0xa9>
		/* Per POSIX, both can't be NULL. */
		if (service == NULL) {
			errno = EINVAL;
 804b00a:	e8 31 e0 ff ff       	call   8049040 <__errno_location@plt>
			return DNS_EAI_SYSTEM;
 804b00f:	be f5 ff ff ff       	mov    $0xfffffff5,%esi
			errno = EINVAL;
 804b014:	c7 00 16 00 00 00    	movl   $0x16,(%eax)
			return DNS_EAI_SYSTEM;
 804b01a:	e9 93 01 00 00       	jmp    804b1b2 <z_impl_z_zsock_getaddrinfo_internal+0x232>
	if (host == NULL) {
 804b01f:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
 804b023:	0f 84 be 00 00 00    	je     804b0e7 <z_impl_z_zsock_getaddrinfo_internal+0x167>
		return getaddrinfo_null_host(port, hints, res);
	}

	ai_state.hints = hints;
	ai_state.idx = 0U;
	ai_state.port = htons(port);
 804b029:	89 c7                	mov    %eax,%edi
 804b02b:	c1 e0 08             	shl    $0x8,%eax
	ai_state.hints = hints;
 804b02e:	89 55 b8             	mov    %edx,-0x48(%ebp)
	ai_state.port = htons(port);
 804b031:	c1 ff 08             	sar    $0x8,%edi
	ai_state.idx = 0U;
 804b034:	66 c7 45 d8 00 00    	movw   $0x0,-0x28(%ebp)
	ai_state.port = htons(port);
 804b03a:	09 c7                	or     %eax,%edi
	ai_state.ai_arr = res;
 804b03c:	89 5d e0             	mov    %ebx,-0x20(%ebp)
	ai_state.port = htons(port);
 804b03f:	66 89 7d da          	mov    %di,-0x26(%ebp)
	ai_state.dns_id = 0;
 804b043:	66 c7 45 dc 00 00    	movw   $0x0,-0x24(%ebp)
	return z_impl_k_sem_init(sem, initial_count, limit);
 804b049:	50                   	push   %eax
 804b04a:	8d 45 bc             	lea    -0x44(%ebp),%eax
	int st1 = DNS_EAI_ADDRFAMILY, st2 = DNS_EAI_ADDRFAMILY;
 804b04d:	be f7 ff ff ff       	mov    $0xfffffff7,%esi
 804b052:	6a ff                	push   $0xffffffff
 804b054:	6a 00                	push   $0x0
 804b056:	50                   	push   %eax
 804b057:	e8 bb 45 01 00       	call   805f617 <z_impl_k_sem_init>
 804b05c:	83 c4 10             	add    $0x10,%esp
	k_sem_init(&ai_state.sem, 0, K_SEM_MAX_LIMIT);

	/* If family is AF_UNSPEC, then we query IPv4 address first
	 * if IPv4 is enabled in the config.
	 */
	if ((family != AF_INET6) && IS_ENABLED(CONFIG_NET_IPV4)) {
 804b05f:	83 7d b4 02          	cmpl   $0x2,-0x4c(%ebp)
 804b063:	74 2c                	je     804b091 <z_impl_z_zsock_getaddrinfo_internal+0x111>
		st1 = exec_query(host, AF_INET, &ai_state);
 804b065:	8b 45 b0             	mov    -0x50(%ebp),%eax
 804b068:	8d 4d b8             	lea    -0x48(%ebp),%ecx
 804b06b:	ba 01 00 00 00       	mov    $0x1,%edx
 804b070:	e8 6e fe ff ff       	call   804aee3 <exec_query>
 804b075:	89 c6                	mov    %eax,%esi
		if (st1 == DNS_EAI_AGAIN) {
 804b077:	83 f8 fd             	cmp    $0xfffffffd,%eax
 804b07a:	75 0a                	jne    804b086 <z_impl_z_zsock_getaddrinfo_internal+0x106>
			return st1;
 804b07c:	be fd ff ff ff       	mov    $0xfffffffd,%esi
 804b081:	e9 2c 01 00 00       	jmp    804b1b2 <z_impl_z_zsock_getaddrinfo_internal+0x232>
	}

	/* If family is AF_UNSPEC, the IPv4 query has been already done
	 * so we can do IPv6 query next if IPv6 is enabled in the config.
	 */
	if ((family != AF_INET) && IS_ENABLED(CONFIG_NET_IPV6)) {
 804b086:	83 7d b4 01          	cmpl   $0x1,-0x4c(%ebp)
	int st1 = DNS_EAI_ADDRFAMILY, st2 = DNS_EAI_ADDRFAMILY;
 804b08a:	ba f7 ff ff ff       	mov    $0xfffffff7,%edx
	if ((family != AF_INET) && IS_ENABLED(CONFIG_NET_IPV6)) {
 804b08f:	74 17                	je     804b0a8 <z_impl_z_zsock_getaddrinfo_internal+0x128>
		st2 = exec_query(host, AF_INET6, &ai_state);
 804b091:	8b 45 b0             	mov    -0x50(%ebp),%eax
 804b094:	ba 02 00 00 00       	mov    $0x2,%edx
 804b099:	8d 4d b8             	lea    -0x48(%ebp),%ecx
 804b09c:	e8 42 fe ff ff       	call   804aee3 <exec_query>
 804b0a1:	89 c2                	mov    %eax,%edx
		if (st2 == DNS_EAI_AGAIN) {
 804b0a3:	83 f8 fd             	cmp    $0xfffffffd,%eax
 804b0a6:	74 d4                	je     804b07c <z_impl_z_zsock_getaddrinfo_internal+0xfc>
			return st2;
		}
	}

	for (uint16_t idx = 0; idx < ai_state.idx; idx++) {
 804b0a8:	0f b7 45 d8          	movzwl -0x28(%ebp),%eax
 804b0ac:	31 c9                	xor    %ecx,%ecx
 804b0ae:	66 39 c8             	cmp    %cx,%ax
 804b0b1:	76 0d                	jbe    804b0c0 <z_impl_z_zsock_getaddrinfo_internal+0x140>
		ai_addr = &ai_state.ai_arr[idx]._ai_addr;
		net_sin(ai_addr)->sin_port = htons(port);
 804b0b3:	6b d9 50             	imul   $0x50,%ecx,%ebx
 804b0b6:	03 5d e0             	add    -0x20(%ebp),%ebx
 804b0b9:	41                   	inc    %ecx
 804b0ba:	66 89 7b 22          	mov    %di,0x22(%ebx)
	for (uint16_t idx = 0; idx < ai_state.idx; idx++) {
 804b0be:	eb ee                	jmp    804b0ae <z_impl_z_zsock_getaddrinfo_internal+0x12e>
	}

	/* If both attempts failed, it's error */
	if (st1 && st2) {
 804b0c0:	85 f6                	test   %esi,%esi
 804b0c2:	74 0f                	je     804b0d3 <z_impl_z_zsock_getaddrinfo_internal+0x153>
 804b0c4:	85 d2                	test   %edx,%edx
 804b0c6:	74 0b                	je     804b0d3 <z_impl_z_zsock_getaddrinfo_internal+0x153>
		if (st1 != DNS_EAI_ADDRFAMILY) {
 804b0c8:	83 fe f7             	cmp    $0xfffffff7,%esi
 804b0cb:	0f 44 f2             	cmove  %edx,%esi
 804b0ce:	e9 df 00 00 00       	jmp    804b1b2 <z_impl_z_zsock_getaddrinfo_internal+0x232>
		}
		return st2;
	}

	/* Mark entry as last */
	ai_state.ai_arr[ai_state.idx - 1].ai_next = NULL;
 804b0d3:	6b c0 50             	imul   $0x50,%eax,%eax
 804b0d6:	03 45 e0             	add    -0x20(%ebp),%eax
 804b0d9:	c7 40 b0 00 00 00 00 	movl   $0x0,-0x50(%eax)
	return 0;
 804b0e0:	31 f6                	xor    %esi,%esi
 804b0e2:	e9 cb 00 00 00       	jmp    804b1b2 <z_impl_z_zsock_getaddrinfo_internal+0x232>
	if (!hints || !(hints->ai_flags & AI_PASSIVE)) {
 804b0e7:	85 d2                	test   %edx,%edx
 804b0e9:	0f 84 d5 fe ff ff    	je     804afc4 <z_impl_z_zsock_getaddrinfo_internal+0x44>
 804b0ef:	8b 4a 04             	mov    0x4(%edx),%ecx
 804b0f2:	83 e1 01             	and    $0x1,%ecx
 804b0f5:	0f 84 c9 fe ff ff    	je     804afc4 <z_impl_z_zsock_getaddrinfo_internal+0x44>
	if (hints->ai_family == AF_INET || hints->ai_family == AF_UNSPEC) {
 804b0fb:	8b 72 08             	mov    0x8(%edx),%esi
 804b0fe:	83 fe 01             	cmp    $0x1,%esi
 804b101:	77 2b                	ja     804b12e <z_impl_z_zsock_getaddrinfo_internal+0x1ae>
		addr->sin_port = htons(port);
 804b103:	89 c6                	mov    %eax,%esi
 804b105:	c1 e0 08             	shl    $0x8,%eax
		struct sockaddr_in *addr = net_sin(&res->_ai_addr);
 804b108:	8d 7b 20             	lea    0x20(%ebx),%edi
		addr->sin_addr.s_addr = INADDR_ANY;
 804b10b:	c7 43 24 00 00 00 00 	movl   $0x0,0x24(%ebx)
		addr->sin_port = htons(port);
 804b112:	c1 fe 08             	sar    $0x8,%esi
		struct sockaddr_in *addr = net_sin(&res->_ai_addr);
 804b115:	89 7d b4             	mov    %edi,-0x4c(%ebp)
		addr->sin_port = htons(port);
 804b118:	09 f0                	or     %esi,%eax
		addr->sin_family = AF_INET;
 804b11a:	66 c7 43 20 01 00    	movw   $0x1,0x20(%ebx)
 804b120:	be 08 00 00 00       	mov    $0x8,%esi
		addr->sin_port = htons(port);
 804b125:	66 89 43 22          	mov    %ax,0x22(%ebx)
		INIT_ADDRINFO(res, addr);
 804b129:	8d 43 38             	lea    0x38(%ebx),%eax
		res->ai_family = AF_INET;
 804b12c:	eb 3f                	jmp    804b16d <z_impl_z_zsock_getaddrinfo_internal+0x1ed>
	} else if (hints->ai_family == AF_INET6) {
 804b12e:	83 fe 02             	cmp    $0x2,%esi
 804b131:	0f 85 8d fe ff ff    	jne    804afc4 <z_impl_z_zsock_getaddrinfo_internal+0x44>
		struct sockaddr_in6 *addr6 = net_sin6(&res->_ai_addr);
 804b137:	8d 7b 20             	lea    0x20(%ebx),%edi
		addr6->sin6_addr = in6addr_any;
 804b13a:	be 58 24 06 08       	mov    $0x8062458,%esi
 804b13f:	b9 04 00 00 00       	mov    $0x4,%ecx
		struct sockaddr_in6 *addr6 = net_sin6(&res->_ai_addr);
 804b144:	89 7d b4             	mov    %edi,-0x4c(%ebp)
		addr6->sin6_addr = in6addr_any;
 804b147:	8d 7b 24             	lea    0x24(%ebx),%edi
 804b14a:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
		addr6->sin6_port = htons(port);
 804b14c:	89 c1                	mov    %eax,%ecx
		addr6->sin6_family = AF_INET6;
 804b14e:	66 c7 43 20 02 00    	movw   $0x2,0x20(%ebx)
		addr6->sin6_port = htons(port);
 804b154:	c1 e0 08             	shl    $0x8,%eax
 804b157:	c1 f9 08             	sar    $0x8,%ecx
 804b15a:	be 18 00 00 00       	mov    $0x18,%esi
 804b15f:	09 c8                	or     %ecx,%eax
 804b161:	b9 02 00 00 00       	mov    $0x2,%ecx
 804b166:	66 89 43 22          	mov    %ax,0x22(%ebx)
		INIT_ADDRINFO(res, addr6);
 804b16a:	8d 43 38             	lea    0x38(%ebx),%eax
		INIT_ADDRINFO(res, addr);
 804b16d:	8b 7d b4             	mov    -0x4c(%ebp),%edi
 804b170:	89 73 14             	mov    %esi,0x14(%ebx)
 804b173:	89 43 1c             	mov    %eax,0x1c(%ebx)
 804b176:	89 7b 18             	mov    %edi,0x18(%ebx)
 804b179:	c6 43 38 00          	movb   $0x0,0x38(%ebx)
 804b17d:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
		res->ai_family = AF_INET;
 804b183:	89 4b 08             	mov    %ecx,0x8(%ebx)
	if (hints->ai_socktype == SOCK_DGRAM) {
 804b186:	83 7a 0c 02          	cmpl   $0x2,0xc(%edx)
 804b18a:	75 13                	jne    804b19f <z_impl_z_zsock_getaddrinfo_internal+0x21f>
		res->ai_socktype = SOCK_DGRAM;
 804b18c:	c7 43 0c 02 00 00 00 	movl   $0x2,0xc(%ebx)
		res->ai_protocol = IPPROTO_UDP;
 804b193:	c7 43 10 11 00 00 00 	movl   $0x11,0x10(%ebx)
 804b19a:	e9 41 ff ff ff       	jmp    804b0e0 <z_impl_z_zsock_getaddrinfo_internal+0x160>
		res->ai_socktype = SOCK_STREAM;
 804b19f:	c7 43 0c 01 00 00 00 	movl   $0x1,0xc(%ebx)
		res->ai_protocol = IPPROTO_TCP;
 804b1a6:	c7 43 10 06 00 00 00 	movl   $0x6,0x10(%ebx)
 804b1ad:	e9 2e ff ff ff       	jmp    804b0e0 <z_impl_z_zsock_getaddrinfo_internal+0x160>

	return 0;
}
 804b1b2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804b1b5:	65 2b 05 14 00 00 00 	sub    %gs:0x14,%eax
 804b1bc:	74 05                	je     804b1c3 <z_impl_z_zsock_getaddrinfo_internal+0x243>
 804b1be:	e8 3d e1 ff ff       	call   8049300 <__stack_chk_fail@plt>
 804b1c3:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804b1c6:	89 f0                	mov    %esi,%eax
 804b1c8:	5b                   	pop    %ebx
 804b1c9:	5e                   	pop    %esi
 804b1ca:	5f                   	pop    %edi
 804b1cb:	5d                   	pop    %ebp
 804b1cc:	c3                   	ret    

0804b1cd <zsock_getaddrinfo>:
#endif /* CONFIG_NET_IP */

int zsock_getaddrinfo(const char *host, const char *service,
		      const struct zsock_addrinfo *hints,
		      struct zsock_addrinfo **res)
{
 804b1cd:	55                   	push   %ebp
 804b1ce:	89 e5                	mov    %esp,%ebp
 804b1d0:	57                   	push   %edi
 804b1d1:	56                   	push   %esi
 804b1d2:	53                   	push   %ebx
 804b1d3:	83 ec 24             	sub    $0x24,%esp
	}

	int ret = DNS_EAI_FAIL;

#if defined(ANY_RESOLVER)
	*res = calloc(AI_ARR_MAX, sizeof(struct zsock_addrinfo));
 804b1d6:	6a 50                	push   $0x50
 804b1d8:	6a 02                	push   $0x2
 804b1da:	e8 21 df ff ff       	call   8049100 <calloc@plt>
 804b1df:	83 c4 10             	add    $0x10,%esp
 804b1e2:	89 c3                	mov    %eax,%ebx
 804b1e4:	8b 45 14             	mov    0x14(%ebp),%eax
 804b1e7:	89 18                	mov    %ebx,(%eax)
	if (!(*res)) {
		return DNS_EAI_MEMORY;
 804b1e9:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
	if (!(*res)) {
 804b1ee:	85 db                	test   %ebx,%ebx
 804b1f0:	0f 84 64 01 00 00    	je     804b35a <zsock_getaddrinfo+0x18d>
	if (!host) {
 804b1f6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 804b1fa:	0f 84 20 01 00 00    	je     804b320 <zsock_getaddrinfo+0x153>
	if (hints) {
 804b200:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
 804b204:	74 17                	je     804b21d <zsock_getaddrinfo+0x50>
		family = hints->ai_family;
 804b206:	8b 45 10             	mov    0x10(%ebp),%eax
		if (hints->ai_socktype == SOCK_DGRAM) {
 804b209:	8b 78 0c             	mov    0xc(%eax),%edi
		family = hints->ai_family;
 804b20c:	8b 48 08             	mov    0x8(%eax),%ecx
		if (hints->ai_socktype == SOCK_DGRAM) {
 804b20f:	83 ff 02             	cmp    $0x2,%edi
 804b212:	75 19                	jne    804b22d <zsock_getaddrinfo+0x60>
			protocol = IPPROTO_UDP;
 804b214:	c7 45 e0 11 00 00 00 	movl   $0x11,-0x20(%ebp)
 804b21b:	eb 1c                	jmp    804b239 <zsock_getaddrinfo+0x6c>
	int protocol = IPPROTO_TCP;
 804b21d:	c7 45 e0 06 00 00 00 	movl   $0x6,-0x20(%ebp)
	int socktype = SOCK_STREAM;
 804b224:	bf 01 00 00 00       	mov    $0x1,%edi
	int family = AF_UNSPEC;
 804b229:	31 c9                	xor    %ecx,%ecx
 804b22b:	eb 0c                	jmp    804b239 <zsock_getaddrinfo+0x6c>
	int protocol = IPPROTO_TCP;
 804b22d:	c7 45 e0 06 00 00 00 	movl   $0x6,-0x20(%ebp)
	int socktype = SOCK_STREAM;
 804b234:	bf 01 00 00 00       	mov    $0x1,%edi
	result = net_ipaddr_parse(host, strlen(host), &res->_ai_addr);
 804b239:	83 ec 0c             	sub    $0xc,%esp
 804b23c:	ff 75 08             	push   0x8(%ebp)
 804b23f:	8d 73 20             	lea    0x20(%ebx),%esi
 804b242:	89 4d dc             	mov    %ecx,-0x24(%ebp)
 804b245:	e8 f6 df ff ff       	call   8049240 <strlen@plt>
 804b24a:	83 c4 0c             	add    $0xc,%esp
 804b24d:	56                   	push   %esi
 804b24e:	50                   	push   %eax
 804b24f:	ff 75 08             	push   0x8(%ebp)
 804b252:	e8 71 84 00 00       	call   80536c8 <net_ipaddr_parse>
 804b257:	83 c4 10             	add    $0x10,%esp
	if (!result) {
 804b25a:	84 c0                	test   %al,%al
 804b25c:	0f 84 be 00 00 00    	je     804b320 <zsock_getaddrinfo+0x153>
	resolved_family = res->_ai_addr.sa_family;
 804b262:	0f b7 53 20          	movzwl 0x20(%ebx),%edx
	if ((family != AF_UNSPEC) && (resolved_family != family)) {
 804b266:	8b 4d dc             	mov    -0x24(%ebp),%ecx
	resolved_family = res->_ai_addr.sa_family;
 804b269:	66 89 55 e4          	mov    %dx,-0x1c(%ebp)
	if ((family != AF_UNSPEC) && (resolved_family != family)) {
 804b26d:	85 c9                	test   %ecx,%ecx
 804b26f:	74 08                	je     804b279 <zsock_getaddrinfo+0xac>
 804b271:	39 ca                	cmp    %ecx,%edx
 804b273:	0f 85 a7 00 00 00    	jne    804b320 <zsock_getaddrinfo+0x153>
	if (service) {
 804b279:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
 804b27d:	74 23                	je     804b2a2 <zsock_getaddrinfo+0xd5>
		port = strtol(service, NULL, 10);
 804b27f:	50                   	push   %eax
 804b280:	6a 0a                	push   $0xa
 804b282:	6a 00                	push   $0x0
 804b284:	ff 75 0c             	push   0xc(%ebp)
 804b287:	89 55 dc             	mov    %edx,-0x24(%ebp)
 804b28a:	e8 f1 de ff ff       	call   8049180 <strtol@plt>
 804b28f:	83 c4 10             	add    $0x10,%esp
		if (port < 1 || port > 65535) {
 804b292:	8b 55 dc             	mov    -0x24(%ebp),%edx
 804b295:	8d 48 ff             	lea    -0x1(%eax),%ecx
 804b298:	81 f9 fe ff 00 00    	cmp    $0xfffe,%ecx
 804b29e:	76 04                	jbe    804b2a4 <zsock_getaddrinfo+0xd7>
 804b2a0:	eb 7e                	jmp    804b320 <zsock_getaddrinfo+0x153>
	long port = 0;
 804b2a2:	31 c0                	xor    %eax,%eax
	res->ai_socktype = socktype;
 804b2a4:	89 7b 0c             	mov    %edi,0xc(%ebx)
	res->ai_protocol = protocol;
 804b2a7:	8b 7d e0             	mov    -0x20(%ebp),%edi
	switch (resolved_family) {
 804b2aa:	66 83 7d e4 01       	cmpw   $0x1,-0x1c(%ebp)
	res->ai_family = resolved_family;
 804b2af:	89 53 08             	mov    %edx,0x8(%ebx)
	res->ai_protocol = protocol;
 804b2b2:	89 7b 10             	mov    %edi,0x10(%ebx)
	switch (resolved_family) {
 804b2b5:	74 37                	je     804b2ee <zsock_getaddrinfo+0x121>
 804b2b7:	66 83 7d e4 02       	cmpw   $0x2,-0x1c(%ebp)
 804b2bc:	75 62                	jne    804b320 <zsock_getaddrinfo+0x153>
		INIT_ADDRINFO(res, addr);
 804b2be:	8d 53 38             	lea    0x38(%ebx),%edx
 804b2c1:	89 73 18             	mov    %esi,0x18(%ebx)
 804b2c4:	89 53 1c             	mov    %edx,0x1c(%ebx)
		addr->sin6_port = htons(port);
 804b2c7:	89 c2                	mov    %eax,%edx
 804b2c9:	c1 e0 08             	shl    $0x8,%eax
 804b2cc:	c1 fa 08             	sar    $0x8,%edx
		INIT_ADDRINFO(res, addr);
 804b2cf:	c7 43 14 18 00 00 00 	movl   $0x18,0x14(%ebx)
		addr->sin6_port = htons(port);
 804b2d6:	09 d0                	or     %edx,%eax
		INIT_ADDRINFO(res, addr);
 804b2d8:	c6 43 38 00          	movb   $0x0,0x38(%ebx)
 804b2dc:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
		addr->sin6_port = htons(port);
 804b2e2:	66 89 43 22          	mov    %ax,0x22(%ebx)
		addr->sin6_family = AF_INET6;
 804b2e6:	66 c7 43 20 02 00    	movw   $0x2,0x20(%ebx)
 804b2ec:	eb 2e                	jmp    804b31c <zsock_getaddrinfo+0x14f>
		INIT_ADDRINFO(res, addr);
 804b2ee:	8d 53 38             	lea    0x38(%ebx),%edx
 804b2f1:	89 73 18             	mov    %esi,0x18(%ebx)
 804b2f4:	89 53 1c             	mov    %edx,0x1c(%ebx)
		addr->sin_port = htons(port);
 804b2f7:	89 c2                	mov    %eax,%edx
 804b2f9:	c1 e0 08             	shl    $0x8,%eax
 804b2fc:	c1 fa 08             	sar    $0x8,%edx
		INIT_ADDRINFO(res, addr);
 804b2ff:	c7 43 14 08 00 00 00 	movl   $0x8,0x14(%ebx)
		addr->sin_port = htons(port);
 804b306:	09 d0                	or     %edx,%eax
		INIT_ADDRINFO(res, addr);
 804b308:	c6 43 38 00          	movb   $0x0,0x38(%ebx)
 804b30c:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
		addr->sin_port = htons(port);
 804b312:	66 89 43 22          	mov    %ax,0x22(%ebx)
		addr->sin_family = AF_INET;
 804b316:	66 c7 43 20 01 00    	movw   $0x1,0x20(%ebx)
		addr->sin6_family = AF_INET6;
 804b31c:	31 c0                	xor    %eax,%eax
 804b31e:	eb 3a                	jmp    804b35a <zsock_getaddrinfo+0x18d>
	}
#endif

#if defined(CONFIG_DNS_RESOLVER)
	if (ret) {
		ret = z_zsock_getaddrinfo_internal(host, service, hints, *res);
 804b320:	8b 45 14             	mov    0x14(%ebp),%eax
 804b323:	8b 00                	mov    (%eax),%eax
		union { uintptr_t x; struct zsock_addrinfo * val; } parm3 = { .val = res };
		return (int) arch_syscall_invoke4(parm0.x, parm1.x, parm2.x, parm3.x, K_SYSCALL_Z_ZSOCK_GETADDRINFO_INTERNAL);
	}
#endif
	compiler_barrier();
	return z_impl_z_zsock_getaddrinfo_internal(host, service, hints, res);
 804b325:	50                   	push   %eax
 804b326:	ff 75 10             	push   0x10(%ebp)
 804b329:	ff 75 0c             	push   0xc(%ebp)
 804b32c:	ff 75 08             	push   0x8(%ebp)
 804b32f:	e8 4c fc ff ff       	call   804af80 <z_impl_z_zsock_getaddrinfo_internal>
 804b334:	83 c4 10             	add    $0x10,%esp
	}
#endif

#if defined(ANY_RESOLVER)
	if (ret) {
 804b337:	85 c0                	test   %eax,%eax
 804b339:	74 1f                	je     804b35a <zsock_getaddrinfo+0x18d>
 804b33b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		free(*res);
 804b33e:	8b 45 14             	mov    0x14(%ebp),%eax
 804b341:	83 ec 0c             	sub    $0xc,%esp
 804b344:	ff 30                	push   (%eax)
 804b346:	e8 55 de ff ff       	call   80491a0 <free@plt>
		*res = NULL;
 804b34b:	8b 45 14             	mov    0x14(%ebp),%eax
		free(*res);
 804b34e:	83 c4 10             	add    $0x10,%esp
		*res = NULL;
 804b351:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
 804b357:	8b 45 e4             	mov    -0x1c(%ebp),%eax
	}
#endif

	return ret;
}
 804b35a:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804b35d:	5b                   	pop    %ebx
 804b35e:	5e                   	pop    %esi
 804b35f:	5f                   	pop    %edi
 804b360:	5d                   	pop    %ebp
 804b361:	c3                   	ret    

0804b362 <inet_is_supported>:
	.getsockname = sock_getsockname_vmeth,
};

#if defined(CONFIG_NET_NATIVE)
static bool inet_is_supported(int family, int type, int proto)
{
 804b362:	55                   	push   %ebp
 804b363:	89 e5                	mov    %esp,%ebp
	if (family != AF_INET && family != AF_INET6) {
 804b365:	8b 45 08             	mov    0x8(%ebp),%eax
		return false;
	}

	return true;
}
 804b368:	5d                   	pop    %ebp
	if (family != AF_INET && family != AF_INET6) {
 804b369:	48                   	dec    %eax
 804b36a:	83 f8 01             	cmp    $0x1,%eax
 804b36d:	0f 96 c0             	setbe  %al
}
 804b370:	c3                   	ret    

0804b371 <sock_ioctl_vmeth>:
{
 804b371:	55                   	push   %ebp
 804b372:	89 e5                	mov    %esp,%ebp
 804b374:	57                   	push   %edi
 804b375:	56                   	push   %esi
 804b376:	53                   	push   %ebx
 804b377:	83 ec 0c             	sub    $0xc,%esp
 804b37a:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b37d:	8b 55 08             	mov    0x8(%ebp),%edx
 804b380:	8b 4d 10             	mov    0x10(%ebp),%ecx
	switch (request) {
 804b383:	3d 02 01 00 00       	cmp    $0x102,%eax
 804b388:	74 66                	je     804b3f0 <sock_ioctl_vmeth+0x7f>
 804b38a:	77 0f                	ja     804b39b <sock_ioctl_vmeth+0x2a>
 804b38c:	83 f8 03             	cmp    $0x3,%eax
 804b38f:	74 2d                	je     804b3be <sock_ioctl_vmeth+0x4d>
 804b391:	83 f8 04             	cmp    $0x4,%eax
 804b394:	74 38                	je     804b3ce <sock_ioctl_vmeth+0x5d>
 804b396:	e9 f4 00 00 00       	jmp    804b48f <sock_ioctl_vmeth+0x11e>
 804b39b:	3d 03 01 00 00       	cmp    $0x103,%eax
 804b3a0:	0f 84 a0 00 00 00    	je     804b446 <sock_ioctl_vmeth+0xd5>
 804b3a6:	3d 05 01 00 00       	cmp    $0x105,%eax
 804b3ab:	0f 85 de 00 00 00    	jne    804b48f <sock_ioctl_vmeth+0x11e>
		lock = va_arg(args, struct k_mutex *);
 804b3b1:	8b 01                	mov    (%ecx),%eax
	ctx->cond.lock = lock;
 804b3b3:	89 82 90 00 00 00    	mov    %eax,0x90(%edx)
 804b3b9:	e9 cd 00 00 00       	jmp    804b48b <sock_ioctl_vmeth+0x11a>
		if (sock_is_nonblock(obj)) {
 804b3be:	8b 42 6c             	mov    0x6c(%edx),%eax
 804b3c1:	c1 e0 0a             	shl    $0xa,%eax
 804b3c4:	25 00 08 00 00       	and    $0x800,%eax
 804b3c9:	e9 cf 00 00 00       	jmp    804b49d <sock_ioctl_vmeth+0x12c>
		if (flags & O_NONBLOCK) {
 804b3ce:	8b 01                	mov    (%ecx),%eax
static inline void sock_set_flag(struct net_context *ctx, uintptr_t mask,
				 uintptr_t flag)
{
	uintptr_t val = POINTER_TO_UINT(ctx->socket_data);

	val = (val & ~mask) | flag;
 804b3d0:	8b 4a 6c             	mov    0x6c(%edx),%ecx
 804b3d3:	83 e1 fd             	and    $0xfffffffd,%ecx
 804b3d6:	25 00 08 00 00       	and    $0x800,%eax
 804b3db:	74 0b                	je     804b3e8 <sock_ioctl_vmeth+0x77>
 804b3dd:	83 c9 02             	or     $0x2,%ecx
 804b3e0:	89 4a 6c             	mov    %ecx,0x6c(%edx)
 804b3e3:	e9 a3 00 00 00       	jmp    804b48b <sock_ioctl_vmeth+0x11a>
	(ctx)->socket_data = UINT_TO_POINTER(val);
 804b3e8:	89 4a 6c             	mov    %ecx,0x6c(%edx)
}
 804b3eb:	e9 ad 00 00 00       	jmp    804b49d <sock_ioctl_vmeth+0x12c>
		pfd = va_arg(args, struct zsock_pollfd *);
 804b3f0:	8b 31                	mov    (%ecx),%esi
		pev = va_arg(args, struct k_poll_event **);
 804b3f2:	8b 59 04             	mov    0x4(%ecx),%ebx
		pev_end = va_arg(args, struct k_poll_event *);
 804b3f5:	8b 79 08             	mov    0x8(%ecx),%edi
	if (pfd->events & ZSOCK_POLLIN) {
 804b3f8:	f6 46 04 01          	testb  $0x1,0x4(%esi)
 804b3fc:	74 35                	je     804b433 <sock_ioctl_vmeth+0xc2>
		if (*pev == pev_end) {
 804b3fe:	8b 0b                	mov    (%ebx),%ecx
			return -ENOMEM;
 804b400:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
		if (*pev == pev_end) {
 804b405:	39 cf                	cmp    %ecx,%edi
 804b407:	0f 84 90 00 00 00    	je     804b49d <sock_ioctl_vmeth+0x12c>
		(*pev)->obj = &ctx->recv_q;
 804b40d:	8d 42 70             	lea    0x70(%edx),%eax
 804b410:	89 41 10             	mov    %eax,0x10(%ecx)
		(*pev)->type = K_POLL_TYPE_FIFO_DATA_AVAILABLE;
 804b413:	8b 0b                	mov    (%ebx),%ecx
 804b415:	8a 41 0d             	mov    0xd(%ecx),%al
 804b418:	83 e0 c0             	and    $0xffffffc0,%eax
 804b41b:	83 c8 04             	or     $0x4,%eax
 804b41e:	88 41 0d             	mov    %al,0xd(%ecx)
		(*pev)->mode = K_POLL_MODE_NOTIFY_ONLY;
 804b421:	8b 03                	mov    (%ebx),%eax
 804b423:	80 60 0e df          	andb   $0xdf,0xe(%eax)
		(*pev)->state = K_POLL_STATE_NOT_READY;
 804b427:	8b 03                	mov    (%ebx),%eax
 804b429:	81 60 0c ff 3f e0 ff 	andl   $0xffe03fff,0xc(%eax)
		(*pev)++;
 804b430:	83 03 14             	addl   $0x14,(%ebx)
			return -EALREADY;
 804b433:	b8 8e ff ff ff       	mov    $0xffffff8e,%eax
	if (pfd->events & ZSOCK_POLLOUT) {
 804b438:	f6 46 04 04          	testb  $0x4,0x4(%esi)
 804b43c:	75 5f                	jne    804b49d <sock_ioctl_vmeth+0x12c>
	if (sock_is_eof(ctx) || sock_is_error(ctx)) {
 804b43e:	f6 42 6c 05          	testb  $0x5,0x6c(%edx)
 804b442:	74 47                	je     804b48b <sock_ioctl_vmeth+0x11a>
 804b444:	eb 57                	jmp    804b49d <sock_ioctl_vmeth+0x12c>
		pfd = va_arg(args, struct zsock_pollfd *);
 804b446:	8b 01                	mov    (%ecx),%eax
	if (pfd->events & ZSOCK_POLLIN) {
 804b448:	f6 40 04 01          	testb  $0x1,0x4(%eax)
 804b44c:	74 1c                	je     804b46a <sock_ioctl_vmeth+0xf9>
		pev = va_arg(args, struct k_poll_event **);
 804b44e:	8b 49 04             	mov    0x4(%ecx),%ecx
		if ((*pev)->state != K_POLL_STATE_NOT_READY || sock_is_eof(ctx)) {
 804b451:	8b 19                	mov    (%ecx),%ebx
 804b453:	f7 43 0c 00 c0 1f 00 	testl  $0x1fc000,0xc(%ebx)
 804b45a:	75 06                	jne    804b462 <sock_ioctl_vmeth+0xf1>
 804b45c:	f6 42 6c 01          	testb  $0x1,0x6c(%edx)
 804b460:	74 05                	je     804b467 <sock_ioctl_vmeth+0xf6>
			pfd->revents |= ZSOCK_POLLIN;
 804b462:	66 83 48 06 01       	orw    $0x1,0x6(%eax)
		(*pev)++;
 804b467:	83 01 14             	addl   $0x14,(%ecx)
	if (pfd->events & ZSOCK_POLLOUT) {
 804b46a:	f6 40 04 04          	testb  $0x4,0x4(%eax)
 804b46e:	74 05                	je     804b475 <sock_ioctl_vmeth+0x104>
			pfd->revents |= ZSOCK_POLLOUT;
 804b470:	66 83 48 06 04       	orw    $0x4,0x6(%eax)
	if (sock_is_error(ctx)) {
 804b475:	f6 42 6c 04          	testb  $0x4,0x6c(%edx)
 804b479:	74 05                	je     804b480 <sock_ioctl_vmeth+0x10f>
		pfd->revents |= ZSOCK_POLLERR;
 804b47b:	66 83 48 06 08       	orw    $0x8,0x6(%eax)
	if (sock_is_eof(ctx)) {
 804b480:	f6 42 6c 01          	testb  $0x1,0x6c(%edx)
 804b484:	74 05                	je     804b48b <sock_ioctl_vmeth+0x11a>
		pfd->revents |= ZSOCK_POLLHUP;
 804b486:	66 83 48 06 10       	orw    $0x10,0x6(%eax)
		return 0;
 804b48b:	31 c0                	xor    %eax,%eax
 804b48d:	eb 0e                	jmp    804b49d <sock_ioctl_vmeth+0x12c>
		errno = EOPNOTSUPP;
 804b48f:	e8 ac db ff ff       	call   8049040 <__errno_location@plt>
 804b494:	c7 00 5f 00 00 00    	movl   $0x5f,(%eax)
		return -1;
 804b49a:	83 c8 ff             	or     $0xffffffff,%eax
}
 804b49d:	83 c4 0c             	add    $0xc,%esp
 804b4a0:	5b                   	pop    %ebx
 804b4a1:	5e                   	pop    %esi
 804b4a2:	5f                   	pop    %edi
 804b4a3:	5d                   	pop    %ebp
 804b4a4:	c3                   	ret    

0804b4a5 <z_fdtable_call_ioctl>:
{
 804b4a5:	55                   	push   %ebp
 804b4a6:	89 e5                	mov    %esp,%ebp
 804b4a8:	83 ec 0c             	sub    $0xc,%esp
	va_start(args, request);
 804b4ab:	8d 45 14             	lea    0x14(%ebp),%eax
	res = vtable->ioctl(obj, request, args);
 804b4ae:	50                   	push   %eax
 804b4af:	8b 45 08             	mov    0x8(%ebp),%eax
 804b4b2:	ff 75 10             	push   0x10(%ebp)
 804b4b5:	ff 75 0c             	push   0xc(%ebp)
 804b4b8:	ff 50 0c             	call   *0xc(%eax)
 804b4bb:	83 c4 10             	add    $0x10,%esp
}
 804b4be:	c9                   	leave  
 804b4bf:	c3                   	ret    

0804b4c0 <zsock_connected_cb>:
{
 804b4c0:	55                   	push   %ebp
 804b4c1:	89 e5                	mov    %esp,%ebp
 804b4c3:	83 ec 08             	sub    $0x8,%esp
 804b4c6:	8b 55 0c             	mov    0xc(%ebp),%edx
 804b4c9:	8b 45 08             	mov    0x8(%ebp),%eax
	if (status < 0) {
 804b4cc:	85 d2                	test   %edx,%edx
 804b4ce:	79 0b                	jns    804b4db <zsock_connected_cb+0x1b>
		ctx->user_data = INT_TO_POINTER(-status);
 804b4d0:	f7 da                	neg    %edx
	val = (val & ~mask) | flag;
 804b4d2:	83 48 6c 04          	orl    $0x4,0x6c(%eax)
 804b4d6:	89 50 04             	mov    %edx,0x4(%eax)
}
 804b4d9:	eb 1a                	jmp    804b4f5 <zsock_connected_cb+0x35>
	} else if (status == 0) {
 804b4db:	75 18                	jne    804b4f5 <zsock_connected_cb+0x35>
		(void)net_context_recv(ctx, zsock_received_cb, K_NO_WAIT, ctx->user_data);
 804b4dd:	83 ec 0c             	sub    $0xc,%esp
 804b4e0:	ff 70 04             	push   0x4(%eax)
 804b4e3:	6a 00                	push   $0x0
 804b4e5:	6a 00                	push   $0x0
 804b4e7:	68 32 b7 04 08       	push   $0x804b732
 804b4ec:	50                   	push   %eax
 804b4ed:	e8 68 92 00 00       	call   805475a <net_context_recv>
 804b4f2:	83 c4 20             	add    $0x20,%esp
}
 804b4f5:	c9                   	leave  
 804b4f6:	c3                   	ret    

0804b4f7 <timeout_recalc>:
{
 804b4f7:	55                   	push   %ebp
 804b4f8:	89 e5                	mov    %esp,%ebp
 804b4fa:	57                   	push   %edi
 804b4fb:	56                   	push   %esi
 804b4fc:	89 ce                	mov    %ecx,%esi
 804b4fe:	53                   	push   %ebx
 804b4ff:	83 ec 1c             	sub    $0x1c,%esp
	if (!K_TIMEOUT_EQ(*timeout, K_NO_WAIT) &&
 804b502:	8b 09                	mov    (%ecx),%ecx
 804b504:	8b 5e 04             	mov    0x4(%esi),%ebx
{
 804b507:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (!K_TIMEOUT_EQ(*timeout, K_NO_WAIT) &&
 804b50a:	b8 01 00 00 00       	mov    $0x1,%eax
{
 804b50f:	89 55 e4             	mov    %edx,-0x1c(%ebp)
	if (!K_TIMEOUT_EQ(*timeout, K_NO_WAIT) &&
 804b512:	83 c1 01             	add    $0x1,%ecx
 804b515:	83 d3 00             	adc    $0x0,%ebx
 804b518:	31 ff                	xor    %edi,%edi
 804b51a:	39 c8                	cmp    %ecx,%eax
 804b51c:	89 f8                	mov    %edi,%eax
 804b51e:	19 d8                	sbb    %ebx,%eax
 804b520:	73 29                	jae    804b54b <timeout_recalc+0x54>
		int64_t remaining = end - sys_clock_tick_get();
 804b522:	e8 a3 56 01 00       	call   8060bca <sys_clock_tick_get>
 804b527:	8b 4d e0             	mov    -0x20(%ebp),%ecx
 804b52a:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
 804b52d:	29 c1                	sub    %eax,%ecx
 804b52f:	19 d3                	sbb    %edx,%ebx
		if (remaining <= 0) {
 804b531:	39 cf                	cmp    %ecx,%edi
 804b533:	19 df                	sbb    %ebx,%edi
 804b535:	7c 0f                	jl     804b546 <timeout_recalc+0x4f>
			*timeout = K_NO_WAIT;
 804b537:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
 804b53d:	c7 46 04 00 00 00 00 	movl   $0x0,0x4(%esi)
 804b544:	eb 05                	jmp    804b54b <timeout_recalc+0x54>
			*timeout = Z_TIMEOUT_TICKS(remaining);
 804b546:	89 0e                	mov    %ecx,(%esi)
 804b548:	89 5e 04             	mov    %ebx,0x4(%esi)
}
 804b54b:	83 c4 1c             	add    $0x1c,%esp
 804b54e:	5b                   	pop    %ebx
 804b54f:	5e                   	pop    %esi
 804b550:	5f                   	pop    %edi
 804b551:	5d                   	pop    %ebp
 804b552:	c3                   	ret    

0804b553 <k_mutex_lock.constprop.0.isra.0>:
static inline int k_mutex_lock(struct k_mutex * mutex, k_timeout_t timeout)
 804b553:	55                   	push   %ebp
 804b554:	89 e5                	mov    %esp,%ebp
 804b556:	53                   	push   %ebx
 804b557:	83 ec 08             	sub    $0x8,%esp
	return z_impl_k_mutex_lock(mutex, timeout);
 804b55a:	51                   	push   %ecx
 804b55b:	52                   	push   %edx
 804b55c:	50                   	push   %eax
 804b55d:	e8 36 3c 01 00       	call   805f198 <z_impl_k_mutex_lock>
}
 804b562:	8b 5d fc             	mov    -0x4(%ebp),%ebx
	return z_impl_k_mutex_lock(mutex, timeout);
 804b565:	83 c4 10             	add    $0x10,%esp
}
 804b568:	c9                   	leave  
 804b569:	c3                   	ret    

0804b56a <zsock_socket_internal>:
{
 804b56a:	55                   	push   %ebp
 804b56b:	89 e5                	mov    %esp,%ebp
 804b56d:	57                   	push   %edi
 804b56e:	56                   	push   %esi
 804b56f:	53                   	push   %ebx
 804b570:	83 ec 1c             	sub    $0x1c,%esp
 804b573:	8b 7d 0c             	mov    0xc(%ebp),%edi
 804b576:	8b 75 10             	mov    0x10(%ebp),%esi
 804b579:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 804b57f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 804b582:	31 c0                	xor    %eax,%eax
	int fd = z_reserve_fd();
 804b584:	e8 c5 e7 ff ff       	call   8049d4e <z_reserve_fd>
	if (fd < 0) {
 804b589:	85 c0                	test   %eax,%eax
 804b58b:	0f 88 b0 00 00 00    	js     804b641 <zsock_socket_internal+0xd7>
 804b591:	89 c3                	mov    %eax,%ebx
	if (proto == 0) {
 804b593:	85 f6                	test   %esi,%esi
 804b595:	75 20                	jne    804b5b7 <zsock_socket_internal+0x4d>
		if (family == AF_INET || family == AF_INET6) {
 804b597:	8b 45 08             	mov    0x8(%ebp),%eax
 804b59a:	48                   	dec    %eax
 804b59b:	83 f8 01             	cmp    $0x1,%eax
 804b59e:	77 17                	ja     804b5b7 <zsock_socket_internal+0x4d>
			if (type == SOCK_DGRAM) {
 804b5a0:	83 ff 02             	cmp    $0x2,%edi
 804b5a3:	74 0d                	je     804b5b2 <zsock_socket_internal+0x48>
				proto = IPPROTO_TCP;
 804b5a5:	83 ff 01             	cmp    $0x1,%edi
 804b5a8:	b8 06 00 00 00       	mov    $0x6,%eax
 804b5ad:	0f 44 f0             	cmove  %eax,%esi
 804b5b0:	eb 05                	jmp    804b5b7 <zsock_socket_internal+0x4d>
				proto = IPPROTO_UDP;
 804b5b2:	be 11 00 00 00       	mov    $0x11,%esi
	res = net_context_get(family, type, proto, &ctx);
 804b5b7:	8d 45 e0             	lea    -0x20(%ebp),%eax
 804b5ba:	50                   	push   %eax
 804b5bb:	0f b7 c6             	movzwl %si,%eax
 804b5be:	50                   	push   %eax
 804b5bf:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
 804b5c3:	57                   	push   %edi
 804b5c4:	50                   	push   %eax
 804b5c5:	e8 b3 83 00 00       	call   805397d <net_context_get>
 804b5ca:	83 c4 10             	add    $0x10,%esp
 804b5cd:	89 c7                	mov    %eax,%edi
	if (res < 0) {
 804b5cf:	85 c0                	test   %eax,%eax
 804b5d1:	79 17                	jns    804b5ea <zsock_socket_internal+0x80>
		z_free_fd(fd);
 804b5d3:	83 ec 0c             	sub    $0xc,%esp
		errno = -res;
 804b5d6:	f7 df                	neg    %edi
		z_free_fd(fd);
 804b5d8:	53                   	push   %ebx
 804b5d9:	e8 31 e8 ff ff       	call   8049e0f <z_free_fd>
 804b5de:	83 c4 10             	add    $0x10,%esp
		errno = -res;
 804b5e1:	e8 5a da ff ff       	call   8049040 <__errno_location@plt>
 804b5e6:	89 38                	mov    %edi,(%eax)
		return -1;
 804b5e8:	eb 57                	jmp    804b641 <zsock_socket_internal+0xd7>
	ctx->user_data = NULL;
 804b5ea:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804b5ed:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	ctx->socket_data = NULL;
 804b5f4:	c7 40 6c 00 00 00 00 	movl   $0x0,0x6c(%eax)
	k_fifo_init(&ctx->recv_q);
 804b5fb:	83 c0 70             	add    $0x70,%eax
	z_impl_k_queue_init(queue);
 804b5fe:	83 ec 0c             	sub    $0xc,%esp
 804b601:	50                   	push   %eax
 804b602:	e8 6e 3e 01 00       	call   805f475 <z_impl_k_queue_init>
	k_condvar_init(&ctx->cond.recv);
 804b607:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804b60a:	05 88 00 00 00       	add    $0x88,%eax
	return z_impl_k_condvar_init(condvar);
 804b60f:	89 04 24             	mov    %eax,(%esp)
 804b612:	e8 60 51 01 00       	call   8060777 <z_impl_k_condvar_init>
 804b617:	83 c4 10             	add    $0x10,%esp
	if (proto == IPPROTO_TCP) {
 804b61a:	83 fe 06             	cmp    $0x6,%esi
 804b61d:	75 0e                	jne    804b62d <zsock_socket_internal+0xc3>
		net_context_ref(ctx);
 804b61f:	83 ec 0c             	sub    $0xc,%esp
 804b622:	ff 75 e0             	push   -0x20(%ebp)
 804b625:	e8 2f 85 00 00       	call   8053b59 <net_context_ref>
 804b62a:	83 c4 10             	add    $0x10,%esp
	z_finalize_fd(fd, ctx, (const struct fd_op_vtable *)&sock_fd_op_vtable);
 804b62d:	50                   	push   %eax
 804b62e:	68 00 20 06 08       	push   $0x8062000
 804b633:	ff 75 e0             	push   -0x20(%ebp)
 804b636:	53                   	push   %ebx
 804b637:	e8 94 e7 ff ff       	call   8049dd0 <z_finalize_fd>
 804b63c:	83 c4 10             	add    $0x10,%esp
	return fd;
 804b63f:	eb 03                	jmp    804b644 <zsock_socket_internal+0xda>
		return -1;
 804b641:	83 cb ff             	or     $0xffffffff,%ebx
}
 804b644:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804b647:	65 2b 05 14 00 00 00 	sub    %gs:0x14,%eax
 804b64e:	74 05                	je     804b655 <zsock_socket_internal+0xeb>
 804b650:	e8 ab dc ff ff       	call   8049300 <__stack_chk_fail@plt>
 804b655:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804b658:	89 d8                	mov    %ebx,%eax
 804b65a:	5b                   	pop    %ebx
 804b65b:	5e                   	pop    %esi
 804b65c:	5f                   	pop    %edi
 804b65d:	5d                   	pop    %ebp
 804b65e:	c3                   	ret    

0804b65f <k_mutex_unlock.isra.0>:
static inline int k_mutex_unlock(struct k_mutex * mutex)
 804b65f:	55                   	push   %ebp
 804b660:	89 e5                	mov    %esp,%ebp
 804b662:	83 ec 14             	sub    $0x14,%esp
	return z_impl_k_mutex_unlock(mutex);
 804b665:	50                   	push   %eax
 804b666:	e8 3b 3c 01 00       	call   805f2a6 <z_impl_k_mutex_unlock>
 804b66b:	83 c4 10             	add    $0x10,%esp
}
 804b66e:	c9                   	leave  
 804b66f:	c3                   	ret    

0804b670 <zsock_flush_queue>:
{
 804b670:	55                   	push   %ebp
 804b671:	89 e5                	mov    %esp,%ebp
 804b673:	57                   	push   %edi
 804b674:	56                   	push   %esi
 804b675:	89 c6                	mov    %eax,%esi
 804b677:	53                   	push   %ebx
 804b678:	83 ec 0c             	sub    $0xc,%esp
enum net_context_state net_context_get_state(struct net_context *context)
{
	NET_ASSERT(context);

	return (enum net_context_state)
		((context->flags >> NET_CONTEXT_STATE_SHIFT) &
 804b67b:	8b 98 98 00 00 00    	mov    0x98(%eax),%ebx
 804b681:	66 d1 eb             	shr    %bx
 804b684:	83 e3 03             	and    $0x3,%ebx
	while ((p = k_fifo_get(&ctx->recv_q, K_NO_WAIT)) != NULL) {
 804b687:	8d 7e 70             	lea    0x70(%esi),%edi
	return z_impl_k_queue_get(queue, timeout);
 804b68a:	50                   	push   %eax
 804b68b:	6a 00                	push   $0x0
 804b68d:	6a 00                	push   $0x0
 804b68f:	57                   	push   %edi
 804b690:	e8 a6 3e 01 00       	call   805f53b <z_impl_k_queue_get>
 804b695:	83 c4 10             	add    $0x10,%esp
 804b698:	85 c0                	test   %eax,%eax
 804b69a:	74 1f                	je     804b6bb <zsock_flush_queue+0x4b>
		if (is_listen) {
 804b69c:	66 83 fb 03          	cmp    $0x3,%bx
 804b6a0:	75 0b                	jne    804b6ad <zsock_flush_queue+0x3d>
			net_context_put(p);
 804b6a2:	83 ec 0c             	sub    $0xc,%esp
 804b6a5:	50                   	push   %eax
 804b6a6:	e8 1a 85 00 00       	call   8053bc5 <net_context_put>
 804b6ab:	eb 09                	jmp    804b6b6 <zsock_flush_queue+0x46>
			net_pkt_unref(p);
 804b6ad:	83 ec 0c             	sub    $0xc,%esp
 804b6b0:	50                   	push   %eax
 804b6b1:	e8 32 97 00 00       	call   8054de8 <net_pkt_unref>
 804b6b6:	83 c4 10             	add    $0x10,%esp
 804b6b9:	eb cc                	jmp    804b687 <zsock_flush_queue+0x17>
	z_impl_k_queue_cancel_wait(queue);
 804b6bb:	83 ec 0c             	sub    $0xc,%esp
 804b6be:	57                   	push   %edi
 804b6bf:	e8 d8 3d 01 00       	call   805f49c <z_impl_k_queue_cancel_wait>
 804b6c4:	83 c4 10             	add    $0x10,%esp
}
 804b6c7:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804b6ca:	5b                   	pop    %ebx
 804b6cb:	5e                   	pop    %esi
 804b6cc:	5f                   	pop    %edi
 804b6cd:	5d                   	pop    %ebp
 804b6ce:	c3                   	ret    

0804b6cf <zsock_accepted_cb>:
			      int status, void *user_data) {
 804b6cf:	55                   	push   %ebp
 804b6d0:	89 e5                	mov    %esp,%ebp
 804b6d2:	56                   	push   %esi
	if (status == 0) {
 804b6d3:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
			      int status, void *user_data) {
 804b6d7:	8b 75 18             	mov    0x18(%ebp),%esi
 804b6da:	53                   	push   %ebx
 804b6db:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (status == 0) {
 804b6de:	75 4b                	jne    804b72b <zsock_accepted_cb+0x5c>
		(void)net_context_recv(new_ctx, zsock_received_cb, K_NO_WAIT,
 804b6e0:	83 ec 0c             	sub    $0xc,%esp
 804b6e3:	6a 00                	push   $0x0
 804b6e5:	6a 00                	push   $0x0
 804b6e7:	6a 00                	push   $0x0
 804b6e9:	68 32 b7 04 08       	push   $0x804b732
 804b6ee:	53                   	push   %ebx
 804b6ef:	e8 66 90 00 00       	call   805475a <net_context_recv>
 804b6f4:	83 c4 14             	add    $0x14,%esp
		k_fifo_init(&new_ctx->recv_q);
 804b6f7:	8d 43 70             	lea    0x70(%ebx),%eax
	z_impl_k_queue_init(queue);
 804b6fa:	50                   	push   %eax
 804b6fb:	e8 75 3d 01 00       	call   805f475 <z_impl_k_queue_init>
		k_condvar_init(&new_ctx->cond.recv);
 804b700:	8d 83 88 00 00 00    	lea    0x88(%ebx),%eax
		k_fifo_put(&parent->accept_q, new_ctx);
 804b706:	83 c6 70             	add    $0x70,%esi
	return z_impl_k_condvar_init(condvar);
 804b709:	89 04 24             	mov    %eax,(%esp)
 804b70c:	e8 66 50 01 00       	call   8060777 <z_impl_k_condvar_init>
 804b711:	58                   	pop    %eax
 804b712:	5a                   	pop    %edx
 804b713:	53                   	push   %ebx
 804b714:	56                   	push   %esi
 804b715:	e8 e3 3d 01 00       	call   805f4fd <k_queue_append>
		net_context_ref(new_ctx);
 804b71a:	89 5d 08             	mov    %ebx,0x8(%ebp)
		k_fifo_put(&parent->accept_q, new_ctx);
 804b71d:	83 c4 10             	add    $0x10,%esp
}
 804b720:	8d 65 f8             	lea    -0x8(%ebp),%esp
 804b723:	5b                   	pop    %ebx
 804b724:	5e                   	pop    %esi
 804b725:	5d                   	pop    %ebp
		net_context_ref(new_ctx);
 804b726:	e9 2e 84 00 00       	jmp    8053b59 <net_context_ref>
}
 804b72b:	8d 65 f8             	lea    -0x8(%ebp),%esp
 804b72e:	5b                   	pop    %ebx
 804b72f:	5e                   	pop    %esi
 804b730:	5d                   	pop    %ebp
 804b731:	c3                   	ret    

0804b732 <zsock_received_cb>:
{
 804b732:	55                   	push   %ebp
 804b733:	89 e5                	mov    %esp,%ebp
 804b735:	57                   	push   %edi
 804b736:	56                   	push   %esi
 804b737:	53                   	push   %ebx
 804b738:	83 ec 0c             	sub    $0xc,%esp
 804b73b:	8b 5d 08             	mov    0x8(%ebp),%ebx
 804b73e:	8b 75 0c             	mov    0xc(%ebp),%esi
 804b741:	8b 7d 18             	mov    0x18(%ebp),%edi
	if (ctx->cond.lock) {
 804b744:	8b 83 90 00 00 00    	mov    0x90(%ebx),%eax
 804b74a:	85 c0                	test   %eax,%eax
 804b74c:	74 0a                	je     804b758 <zsock_received_cb+0x26>
		(void)k_mutex_lock(ctx->cond.lock, K_FOREVER);
 804b74e:	83 ca ff             	or     $0xffffffff,%edx
 804b751:	89 d1                	mov    %edx,%ecx
 804b753:	e8 fb fd ff ff       	call   804b553 <k_mutex_lock.constprop.0.isra.0>
	if (status < 0) {
 804b758:	85 ff                	test   %edi,%edi
 804b75a:	79 09                	jns    804b765 <zsock_received_cb+0x33>
		ctx->user_data = INT_TO_POINTER(-status);
 804b75c:	f7 df                	neg    %edi
	val = (val & ~mask) | flag;
 804b75e:	83 4b 6c 04          	orl    $0x4,0x6c(%ebx)
 804b762:	89 7b 04             	mov    %edi,0x4(%ebx)
		struct net_pkt *last_pkt = k_fifo_peek_tail(&ctx->recv_q);
 804b765:	8d 7b 70             	lea    0x70(%ebx),%edi
	if (!pkt) {
 804b768:	85 f6                	test   %esi,%esi
 804b76a:	75 25                	jne    804b791 <zsock_received_cb+0x5f>
	return z_impl_k_queue_peek_tail(queue);
 804b76c:	83 ec 0c             	sub    $0xc,%esp
 804b76f:	57                   	push   %edi
 804b770:	e8 8a 3e 01 00       	call   805f5ff <z_impl_k_queue_peek_tail>
 804b775:	83 c4 10             	add    $0x10,%esp
		if (!last_pkt) {
 804b778:	85 c0                	test   %eax,%eax
 804b77a:	75 0f                	jne    804b78b <zsock_received_cb+0x59>
 804b77c:	83 4b 6c 01          	orl    $0x1,0x6c(%ebx)
	z_impl_k_queue_cancel_wait(queue);
 804b780:	83 ec 0c             	sub    $0xc,%esp
 804b783:	57                   	push   %edi
 804b784:	e8 13 3d 01 00       	call   805f49c <z_impl_k_queue_cancel_wait>
 804b789:	eb 13                	jmp    804b79e <zsock_received_cb+0x6c>
	return pkt->sent_or_eof;
}

static inline void net_pkt_set_eof(struct net_pkt *pkt, bool eof)
{
	pkt->sent_or_eof = eof;
 804b78b:	80 48 33 02          	orb    $0x2,0x33(%eax)
			NET_DBG("Set EOF flag on pkt %p", last_pkt);
 804b78f:	eb 10                	jmp    804b7a1 <zsock_received_cb+0x6f>
 804b791:	80 66 33 fd          	andb   $0xfd,0x33(%esi)
	k_fifo_put(&ctx->recv_q, pkt);
 804b795:	50                   	push   %eax
 804b796:	50                   	push   %eax
 804b797:	56                   	push   %esi
 804b798:	57                   	push   %edi
 804b799:	e8 5f 3d 01 00       	call   805f4fd <k_queue_append>
 804b79e:	83 c4 10             	add    $0x10,%esp
	if (ctx->cond.lock) {
 804b7a1:	8b 83 90 00 00 00    	mov    0x90(%ebx),%eax
 804b7a7:	85 c0                	test   %eax,%eax
 804b7a9:	74 05                	je     804b7b0 <zsock_received_cb+0x7e>
		(void)k_mutex_unlock(ctx->cond.lock);
 804b7ab:	e8 af fe ff ff       	call   804b65f <k_mutex_unlock.isra.0>
	(void)k_condvar_signal(&ctx->cond.recv);
 804b7b0:	81 c3 88 00 00 00    	add    $0x88,%ebx
 804b7b6:	89 5d 08             	mov    %ebx,0x8(%ebp)
}
 804b7b9:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804b7bc:	5b                   	pop    %ebx
 804b7bd:	5e                   	pop    %esi
 804b7be:	5f                   	pop    %edi
 804b7bf:	5d                   	pop    %ebp
	return z_impl_k_condvar_signal(condvar);
 804b7c0:	e9 c1 4f 01 00       	jmp    8060786 <z_impl_k_condvar_signal>

0804b7c5 <send_check_and_wait>:
{
 804b7c5:	55                   	push   %ebp
 804b7c6:	89 e5                	mov    %esp,%ebp
 804b7c8:	57                   	push   %edi
 804b7c9:	56                   	push   %esi
 804b7ca:	53                   	push   %ebx
 804b7cb:	89 d3                	mov    %edx,%ebx
 804b7cd:	83 ec 1c             	sub    $0x1c,%esp
 804b7d0:	8b 4d 10             	mov    0x10(%ebp),%ecx
 804b7d3:	8b 55 0c             	mov    0xc(%ebp),%edx
 804b7d6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 804b7d9:	8b 45 08             	mov    0x8(%ebp),%eax
 804b7dc:	89 c6                	mov    %eax,%esi
 804b7de:	8b 45 14             	mov    0x14(%ebp),%eax
 804b7e1:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
 804b7e4:	09 c8                	or     %ecx,%eax
 804b7e6:	0f 84 e2 00 00 00    	je     804b8ce <send_check_and_wait+0x109>
 804b7ec:	89 d7                	mov    %edx,%edi
	if (status != -ENOBUFS && status != -EAGAIN) {
 804b7ee:	83 fb 97             	cmp    $0xffffff97,%ebx
 804b7f1:	74 09                	je     804b7fc <send_check_and_wait+0x37>
 804b7f3:	83 fb f5             	cmp    $0xfffffff5,%ebx
 804b7f6:	0f 85 d2 00 00 00    	jne    804b8ce <send_check_and_wait+0x109>
 804b7fc:	89 4d dc             	mov    %ecx,-0x24(%ebp)
	remaining = buf_timeout - sys_clock_tick_get();
 804b7ff:	e8 c6 53 01 00       	call   8060bca <sys_clock_tick_get>
	if (remaining <= 0) {
 804b804:	8b 4d dc             	mov    -0x24(%ebp),%ecx
	remaining = buf_timeout - sys_clock_tick_get();
 804b807:	29 c6                	sub    %eax,%esi
 804b809:	19 d7                	sbb    %edx,%edi
	if (remaining <= 0) {
 804b80b:	31 c0                	xor    %eax,%eax
 804b80d:	39 f0                	cmp    %esi,%eax
 804b80f:	19 f8                	sbb    %edi,%eax
 804b811:	7c 13                	jl     804b826 <send_check_and_wait+0x61>
		if (status == -ENOBUFS) {
 804b813:	83 fb 97             	cmp    $0xffffff97,%ebx
 804b816:	0f 84 ad 00 00 00    	je     804b8c9 <send_check_and_wait+0x104>
			status = -ENOBUFS;
 804b81c:	bb 97 ff ff ff       	mov    $0xffffff97,%ebx
 804b821:	e9 a8 00 00 00       	jmp    804b8ce <send_check_and_wait+0x109>
	if (!K_TIMEOUT_EQ(timeout, K_FOREVER)) {
 804b826:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
 804b82a:	75 05                	jne    804b831 <send_check_and_wait+0x6c>
 804b82c:	83 f9 ff             	cmp    $0xffffffff,%ecx
 804b82f:	74 12                	je     804b843 <send_check_and_wait+0x7e>
		*retry_timeout =
 804b831:	8b 45 18             	mov    0x18(%ebp),%eax
 804b834:	6b c9 0a             	imul   $0xa,%ecx,%ecx
 804b837:	8b 00                	mov    (%eax),%eax
 804b839:	39 c1                	cmp    %eax,%ecx
 804b83b:	0f 47 c8             	cmova  %eax,%ecx
 804b83e:	8b 45 18             	mov    0x18(%ebp),%eax
 804b841:	89 08                	mov    %ecx,(%eax)
	if (ctx->cond.lock) {
 804b843:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804b846:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
 804b84c:	85 c0                	test   %eax,%eax
 804b84e:	74 05                	je     804b855 <send_check_and_wait+0x90>
		(void)k_mutex_unlock(ctx->cond.lock);
 804b850:	e8 0a fe ff ff       	call   804b65f <k_mutex_unlock.isra.0>
		k_sleep(K_MSEC(*retry_timeout));
 804b855:	8b 45 18             	mov    0x18(%ebp),%eax
 804b858:	8b 00                	mov    (%eax),%eax
	if (status == -ENOBUFS) {
 804b85a:	83 fb 97             	cmp    $0xffffff97,%ebx
 804b85d:	75 15                	jne    804b874 <send_check_and_wait+0xaf>
		k_sleep(K_MSEC(*retry_timeout));
 804b85f:	31 d2                	xor    %edx,%edx
	 * the same mathematical relationship, each expressed with and
	 * without truncation to 32 bits (I couldn't find a way to make
	 * the compiler correctly guess at the 32 bit result otherwise).
	 */
	if (div_ratio) {
		t += off;
 804b861:	83 c0 09             	add    $0x9,%eax
		if (result32 && (t < BIT64(32))) {
			return ((uint32_t)t) / (from_hz / to_hz);
		} else {
			return t / ((uint64_t)from_hz / to_hz);
 804b864:	6a 00                	push   $0x0
		t += off;
 804b866:	83 d2 00             	adc    $0x0,%edx
			return t / ((uint64_t)from_hz / to_hz);
 804b869:	6a 0a                	push   $0xa
 804b86b:	52                   	push   %edx
 804b86c:	50                   	push   %eax
 804b86d:	e8 de dc ff ff       	call   8049550 <__udivdi3>
 804b872:	eb 18                	jmp    804b88c <send_check_and_wait+0xc7>
	if (status == -EAGAIN) {
 804b874:	83 fb f5             	cmp    $0xfffffff5,%ebx
 804b877:	75 1f                	jne    804b898 <send_check_and_wait+0xd3>
			k_sleep(K_MSEC(*retry_timeout));
 804b879:	31 d2                	xor    %edx,%edx
		t += off;
 804b87b:	83 c0 09             	add    $0x9,%eax
			return t / ((uint64_t)from_hz / to_hz);
 804b87e:	6a 00                	push   $0x0
		t += off;
 804b880:	83 d2 00             	adc    $0x0,%edx
			return t / ((uint64_t)from_hz / to_hz);
 804b883:	6a 0a                	push   $0xa
 804b885:	52                   	push   %edx
 804b886:	50                   	push   %eax
 804b887:	e8 c4 dc ff ff       	call   8049550 <__udivdi3>
 804b88c:	59                   	pop    %ecx
 804b88d:	5b                   	pop    %ebx
	return z_impl_k_sleep(timeout);
 804b88e:	52                   	push   %edx
 804b88f:	50                   	push   %eax
 804b890:	e8 09 4d 01 00       	call   806059e <z_impl_k_sleep>
 804b895:	83 c4 10             	add    $0x10,%esp
	*retry_timeout = MIN(WAIT_BUFS_MAX_MS, *retry_timeout << 1);
 804b898:	8b 45 18             	mov    0x18(%ebp),%eax
 804b89b:	ba 64 00 00 00       	mov    $0x64,%edx
 804b8a0:	8b 7d 18             	mov    0x18(%ebp),%edi
 804b8a3:	8b 00                	mov    (%eax),%eax
 804b8a5:	01 c0                	add    %eax,%eax
 804b8a7:	39 d0                	cmp    %edx,%eax
 804b8a9:	0f 47 c2             	cmova  %edx,%eax
	return 0;
 804b8ac:	31 db                	xor    %ebx,%ebx
	*retry_timeout = MIN(WAIT_BUFS_MAX_MS, *retry_timeout << 1);
 804b8ae:	89 07                	mov    %eax,(%edi)
	if (ctx->cond.lock) {
 804b8b0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804b8b3:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
 804b8b9:	85 c0                	test   %eax,%eax
 804b8bb:	74 1d                	je     804b8da <send_check_and_wait+0x115>
		(void)k_mutex_lock(ctx->cond.lock, K_FOREVER);
 804b8bd:	83 ca ff             	or     $0xffffffff,%edx
 804b8c0:	89 d1                	mov    %edx,%ecx
 804b8c2:	e8 8c fc ff ff       	call   804b553 <k_mutex_lock.constprop.0.isra.0>
 804b8c7:	eb 11                	jmp    804b8da <send_check_and_wait+0x115>
			status = -ENOMEM;
 804b8c9:	bb f4 ff ff ff       	mov    $0xfffffff4,%ebx
	errno = -status;
 804b8ce:	e8 6d d7 ff ff       	call   8049040 <__errno_location@plt>
 804b8d3:	f7 db                	neg    %ebx
 804b8d5:	89 18                	mov    %ebx,(%eax)
	return -1;
 804b8d7:	83 cb ff             	or     $0xffffffff,%ebx
}
 804b8da:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804b8dd:	89 d8                	mov    %ebx,%eax
 804b8df:	5b                   	pop    %ebx
 804b8e0:	5e                   	pop    %esi
 804b8e1:	5f                   	pop    %edi
 804b8e2:	5d                   	pop    %ebp
 804b8e3:	c3                   	ret    

0804b8e4 <z_impl_zsock_socket>:
{
 804b8e4:	55                   	push   %ebp
 804b8e5:	89 e5                	mov    %esp,%ebp
 804b8e7:	57                   	push   %edi
 804b8e8:	56                   	push   %esi
 804b8e9:	53                   	push   %ebx
	STRUCT_SECTION_FOREACH(net_socket_register, sock_family) {
 804b8ea:	bb 68 74 06 08       	mov    $0x8067468,%ebx
{
 804b8ef:	83 ec 1c             	sub    $0x1c,%esp
 804b8f2:	8b 75 08             	mov    0x8(%ebp),%esi
 804b8f5:	8b 7d 0c             	mov    0xc(%ebp),%edi
 804b8f8:	8b 55 10             	mov    0x10(%ebp),%edx
	STRUCT_SECTION_FOREACH(net_socket_register, sock_family) {
 804b8fb:	81 fb 78 74 06 08    	cmp    $0x8067478,%ebx
 804b901:	73 38                	jae    804b93b <z_impl_zsock_socket+0x57>
		if (sock_family->family != family &&
 804b903:	8b 03                	mov    (%ebx),%eax
 804b905:	85 c0                	test   %eax,%eax
 804b907:	74 04                	je     804b90d <z_impl_zsock_socket+0x29>
 804b909:	39 f0                	cmp    %esi,%eax
 804b90b:	75 29                	jne    804b936 <z_impl_zsock_socket+0x52>
		if (!sock_family->is_supported(family, type, proto)) {
 804b90d:	50                   	push   %eax
 804b90e:	52                   	push   %edx
 804b90f:	57                   	push   %edi
 804b910:	56                   	push   %esi
 804b911:	89 55 e4             	mov    %edx,-0x1c(%ebp)
 804b914:	ff 53 08             	call   *0x8(%ebx)
 804b917:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 804b91a:	83 c4 10             	add    $0x10,%esp
 804b91d:	84 c0                	test   %al,%al
 804b91f:	74 15                	je     804b936 <z_impl_zsock_socket+0x52>
		return sock_family->handler(family, type, proto);
 804b921:	89 7d 0c             	mov    %edi,0xc(%ebp)
 804b924:	8b 43 0c             	mov    0xc(%ebx),%eax
 804b927:	89 75 08             	mov    %esi,0x8(%ebp)
 804b92a:	89 55 10             	mov    %edx,0x10(%ebp)
}
 804b92d:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804b930:	5b                   	pop    %ebx
 804b931:	5e                   	pop    %esi
 804b932:	5f                   	pop    %edi
 804b933:	5d                   	pop    %ebp
		return sock_family->handler(family, type, proto);
 804b934:	ff e0                	jmp    *%eax
	STRUCT_SECTION_FOREACH(net_socket_register, sock_family) {
 804b936:	83 c3 10             	add    $0x10,%ebx
 804b939:	eb c0                	jmp    804b8fb <z_impl_zsock_socket+0x17>
	errno = EAFNOSUPPORT;
 804b93b:	e8 00 d7 ff ff       	call   8049040 <__errno_location@plt>
 804b940:	c7 00 61 00 00 00    	movl   $0x61,(%eax)
}
 804b946:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804b949:	83 c8 ff             	or     $0xffffffff,%eax
 804b94c:	5b                   	pop    %ebx
 804b94d:	5e                   	pop    %esi
 804b94e:	5f                   	pop    %edi
 804b94f:	5d                   	pop    %ebp
 804b950:	c3                   	ret    

0804b951 <zsock_close_ctx>:
{
 804b951:	55                   	push   %ebp
 804b952:	89 e5                	mov    %esp,%ebp
 804b954:	53                   	push   %ebx
 804b955:	50                   	push   %eax
 804b956:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (net_context_get_state(ctx) == NET_CONTEXT_LISTENING) {
 804b959:	8b 83 98 00 00 00    	mov    0x98(%ebx),%eax
 804b95f:	83 f0 06             	xor    $0x6,%eax
 804b962:	a8 06                	test   $0x6,%al
 804b964:	75 13                	jne    804b979 <zsock_close_ctx+0x28>
		(void)net_context_accept(ctx, NULL, K_NO_WAIT, NULL);
 804b966:	83 ec 0c             	sub    $0xc,%esp
 804b969:	6a 00                	push   $0x0
 804b96b:	6a 00                	push   $0x0
 804b96d:	6a 00                	push   $0x0
 804b96f:	6a 00                	push   $0x0
 804b971:	53                   	push   %ebx
 804b972:	e8 67 8c 00 00       	call   80545de <net_context_accept>
 804b977:	eb 11                	jmp    804b98a <zsock_close_ctx+0x39>
		(void)net_context_recv(ctx, NULL, K_NO_WAIT, NULL);
 804b979:	83 ec 0c             	sub    $0xc,%esp
 804b97c:	6a 00                	push   $0x0
 804b97e:	6a 00                	push   $0x0
 804b980:	6a 00                	push   $0x0
 804b982:	6a 00                	push   $0x0
 804b984:	53                   	push   %ebx
 804b985:	e8 d0 8d 00 00       	call   805475a <net_context_recv>
	zsock_flush_queue(ctx);
 804b98a:	89 d8                	mov    %ebx,%eax
		(void)net_context_recv(ctx, NULL, K_NO_WAIT, NULL);
 804b98c:	83 c4 20             	add    $0x20,%esp
	zsock_flush_queue(ctx);
 804b98f:	e8 dc fc ff ff       	call   804b670 <zsock_flush_queue>
	SET_ERRNO(net_context_put(ctx));
 804b994:	83 ec 0c             	sub    $0xc,%esp
 804b997:	53                   	push   %ebx
 804b998:	e8 28 82 00 00       	call   8053bc5 <net_context_put>
 804b99d:	83 c4 10             	add    $0x10,%esp
 804b9a0:	89 c3                	mov    %eax,%ebx
	return 0;
 804b9a2:	31 c0                	xor    %eax,%eax
	SET_ERRNO(net_context_put(ctx));
 804b9a4:	85 db                	test   %ebx,%ebx
 804b9a6:	79 0c                	jns    804b9b4 <zsock_close_ctx+0x63>
 804b9a8:	e8 93 d6 ff ff       	call   8049040 <__errno_location@plt>
 804b9ad:	f7 db                	neg    %ebx
 804b9af:	89 18                	mov    %ebx,(%eax)
 804b9b1:	83 c8 ff             	or     $0xffffffff,%eax
}
 804b9b4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 804b9b7:	c9                   	leave  
 804b9b8:	c3                   	ret    

0804b9b9 <sock_close_vmeth>:
	return zsock_close_ctx(obj);
 804b9b9:	e9 93 ff ff ff       	jmp    804b951 <zsock_close_ctx>

0804b9be <z_impl_zsock_close>:
{
 804b9be:	55                   	push   %ebp
 804b9bf:	89 e5                	mov    %esp,%ebp
 804b9c1:	56                   	push   %esi
 804b9c2:	53                   	push   %ebx
 804b9c3:	83 ec 14             	sub    $0x14,%esp
 804b9c6:	8b 75 08             	mov    0x8(%ebp),%esi
 804b9c9:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 804b9cf:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804b9d2:	31 c0                	xor    %eax,%eax
	ctx = z_get_fd_obj_and_vtable(sock,
 804b9d4:	8d 45 f0             	lea    -0x10(%ebp),%eax
 804b9d7:	50                   	push   %eax
 804b9d8:	8d 45 ec             	lea    -0x14(%ebp),%eax
 804b9db:	50                   	push   %eax
 804b9dc:	56                   	push   %esi
 804b9dd:	e8 2a e3 ff ff       	call   8049d0c <z_get_fd_obj_and_vtable>
 804b9e2:	83 c4 10             	add    $0x10,%esp
	if (ctx == NULL) {
 804b9e5:	85 c0                	test   %eax,%eax
 804b9e7:	75 10                	jne    804b9f9 <z_impl_zsock_close+0x3b>
		errno = EBADF;
 804b9e9:	e8 52 d6 ff ff       	call   8049040 <__errno_location@plt>
		return -1;
 804b9ee:	83 cb ff             	or     $0xffffffff,%ebx
		errno = EBADF;
 804b9f1:	c7 00 09 00 00 00    	movl   $0x9,(%eax)
		return -1;
 804b9f7:	eb 32                	jmp    804ba2b <z_impl_zsock_close+0x6d>
	(void)k_mutex_lock(lock, K_FOREVER);
 804b9f9:	83 ca ff             	or     $0xffffffff,%edx
 804b9fc:	89 c3                	mov    %eax,%ebx
 804b9fe:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804ba01:	89 d1                	mov    %edx,%ecx
 804ba03:	e8 4b fb ff ff       	call   804b553 <k_mutex_lock.constprop.0.isra.0>
	ret = vtable->fd_vtable.close(ctx);
 804ba08:	83 ec 0c             	sub    $0xc,%esp
 804ba0b:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804ba0e:	53                   	push   %ebx
 804ba0f:	ff 50 08             	call   *0x8(%eax)
 804ba12:	89 c3                	mov    %eax,%ebx
	k_mutex_unlock(lock);
 804ba14:	8b 45 f0             	mov    -0x10(%ebp),%eax
	ret = vtable->fd_vtable.close(ctx);
 804ba17:	83 c4 10             	add    $0x10,%esp
	k_mutex_unlock(lock);
 804ba1a:	e8 40 fc ff ff       	call   804b65f <k_mutex_unlock.isra.0>
	z_free_fd(sock);
 804ba1f:	83 ec 0c             	sub    $0xc,%esp
 804ba22:	56                   	push   %esi
 804ba23:	e8 e7 e3 ff ff       	call   8049e0f <z_free_fd>
 804ba28:	83 c4 10             	add    $0x10,%esp
}
 804ba2b:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804ba2e:	65 2b 05 14 00 00 00 	sub    %gs:0x14,%eax
 804ba35:	74 05                	je     804ba3c <z_impl_zsock_close+0x7e>
 804ba37:	e8 c4 d8 ff ff       	call   8049300 <__stack_chk_fail@plt>
 804ba3c:	8d 65 f8             	lea    -0x8(%ebp),%esp
 804ba3f:	89 d8                	mov    %ebx,%eax
 804ba41:	5b                   	pop    %ebx
 804ba42:	5e                   	pop    %esi
 804ba43:	5d                   	pop    %ebp
 804ba44:	c3                   	ret    

0804ba45 <zsock_shutdown_ctx>:
{
 804ba45:	55                   	push   %ebp
 804ba46:	89 e5                	mov    %esp,%ebp
 804ba48:	57                   	push   %edi
 804ba49:	56                   	push   %esi
 804ba4a:	53                   	push   %ebx
 804ba4b:	83 ec 0c             	sub    $0xc,%esp
 804ba4e:	8b 5d 0c             	mov    0xc(%ebp),%ebx
 804ba51:	8b 75 08             	mov    0x8(%ebp),%esi
	if (how == ZSOCK_SHUT_RD) {
 804ba54:	85 db                	test   %ebx,%ebx
 804ba56:	75 64                	jne    804babc <zsock_shutdown_ctx+0x77>
		if (net_context_get_state(ctx) == NET_CONTEXT_LISTENING) {
 804ba58:	8b 86 98 00 00 00    	mov    0x98(%esi),%eax
 804ba5e:	83 f0 06             	xor    $0x6,%eax
 804ba61:	a8 06                	test   $0x6,%al
 804ba63:	75 13                	jne    804ba78 <zsock_shutdown_ctx+0x33>
			SET_ERRNO(net_context_accept(ctx, NULL, K_NO_WAIT, NULL));
 804ba65:	83 ec 0c             	sub    $0xc,%esp
 804ba68:	6a 00                	push   $0x0
 804ba6a:	6a 00                	push   $0x0
 804ba6c:	6a 00                	push   $0x0
 804ba6e:	6a 00                	push   $0x0
 804ba70:	56                   	push   %esi
 804ba71:	e8 68 8b 00 00       	call   80545de <net_context_accept>
 804ba76:	eb 11                	jmp    804ba89 <zsock_shutdown_ctx+0x44>
			SET_ERRNO(net_context_recv(ctx, NULL, K_NO_WAIT, NULL));
 804ba78:	83 ec 0c             	sub    $0xc,%esp
 804ba7b:	6a 00                	push   $0x0
 804ba7d:	6a 00                	push   $0x0
 804ba7f:	6a 00                	push   $0x0
 804ba81:	6a 00                	push   $0x0
 804ba83:	56                   	push   %esi
 804ba84:	e8 d1 8c 00 00       	call   805475a <net_context_recv>
 804ba89:	83 c4 20             	add    $0x20,%esp
 804ba8c:	89 c7                	mov    %eax,%edi
 804ba8e:	85 c0                	test   %eax,%eax
 804ba90:	79 0b                	jns    804ba9d <zsock_shutdown_ctx+0x58>
 804ba92:	e8 a9 d5 ff ff       	call   8049040 <__errno_location@plt>
 804ba97:	f7 df                	neg    %edi
 804ba99:	89 38                	mov    %edi,(%eax)
 804ba9b:	eb 38                	jmp    804bad5 <zsock_shutdown_ctx+0x90>
 804ba9d:	83 4e 6c 01          	orl    $0x1,0x6c(%esi)
		zsock_flush_queue(ctx);
 804baa1:	89 f0                	mov    %esi,%eax
 804baa3:	e8 c8 fb ff ff       	call   804b670 <zsock_flush_queue>
	return z_impl_k_condvar_signal(condvar);
 804baa8:	83 ec 0c             	sub    $0xc,%esp
		(void)k_condvar_signal(&ctx->cond.recv);
 804baab:	81 c6 88 00 00 00    	add    $0x88,%esi
 804bab1:	56                   	push   %esi
 804bab2:	e8 cf 4c 01 00       	call   8060786 <z_impl_k_condvar_signal>
 804bab7:	83 c4 10             	add    $0x10,%esp
 804baba:	eb 1c                	jmp    804bad8 <zsock_shutdown_ctx+0x93>
			SET_ERRNO(net_context_accept(ctx, NULL, K_NO_WAIT, NULL));
 804babc:	e8 7f d5 ff ff       	call   8049040 <__errno_location@plt>
	} else if (how == ZSOCK_SHUT_WR || how == ZSOCK_SHUT_RDWR) {
 804bac1:	4b                   	dec    %ebx
 804bac2:	83 fb 01             	cmp    $0x1,%ebx
 804bac5:	77 08                	ja     804bacf <zsock_shutdown_ctx+0x8a>
		SET_ERRNO(-ENOTSUP);
 804bac7:	c7 00 5f 00 00 00    	movl   $0x5f,(%eax)
 804bacd:	eb 06                	jmp    804bad5 <zsock_shutdown_ctx+0x90>
		SET_ERRNO(-EINVAL);
 804bacf:	c7 00 16 00 00 00    	movl   $0x16,(%eax)
 804bad5:	83 cb ff             	or     $0xffffffff,%ebx
}
 804bad8:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804badb:	89 d8                	mov    %ebx,%eax
 804badd:	5b                   	pop    %ebx
 804bade:	5e                   	pop    %esi
 804badf:	5f                   	pop    %edi
 804bae0:	5d                   	pop    %ebp
 804bae1:	c3                   	ret    

0804bae2 <sock_shutdown_vmeth>:
	return zsock_shutdown_ctx(obj, how);
 804bae2:	e9 5e ff ff ff       	jmp    804ba45 <zsock_shutdown_ctx>

0804bae7 <zsock_bind_ctx>:
{
 804bae7:	55                   	push   %ebp
 804bae8:	89 e5                	mov    %esp,%ebp
 804baea:	57                   	push   %edi
 804baeb:	56                   	push   %esi
 804baec:	53                   	push   %ebx
 804baed:	83 ec 10             	sub    $0x10,%esp
 804baf0:	8b 75 08             	mov    0x8(%ebp),%esi
	SET_ERRNO(net_context_bind(ctx, addr, addrlen));
 804baf3:	ff 75 10             	push   0x10(%ebp)
 804baf6:	ff 75 0c             	push   0xc(%ebp)
 804baf9:	56                   	push   %esi
 804bafa:	e8 27 81 00 00       	call   8053c26 <net_context_bind>
 804baff:	83 c4 10             	add    $0x10,%esp
 804bb02:	89 c3                	mov    %eax,%ebx
 804bb04:	85 c0                	test   %eax,%eax
 804bb06:	78 32                	js     804bb3a <zsock_bind_ctx+0x53>
static inline
enum net_sock_type net_context_get_type(struct net_context *context)
{
	NET_ASSERT(context);

	return (enum net_sock_type)((context->flags & NET_CONTEXT_TYPE) >> 6);
 804bb08:	0f b7 86 98 00 00 00 	movzwl 0x98(%esi),%eax
	return 0;
 804bb0f:	31 ff                	xor    %edi,%edi
 804bb11:	c1 e8 06             	shr    $0x6,%eax
 804bb14:	83 e0 03             	and    $0x3,%eax
	if (net_context_get_type(ctx) == SOCK_DGRAM) {
 804bb17:	83 f8 02             	cmp    $0x2,%eax
 804bb1a:	75 2a                	jne    804bb46 <zsock_bind_ctx+0x5f>
		SET_ERRNO(net_context_recv(ctx, zsock_received_cb, K_NO_WAIT,
 804bb1c:	83 ec 0c             	sub    $0xc,%esp
 804bb1f:	ff 76 04             	push   0x4(%esi)
 804bb22:	6a 00                	push   $0x0
 804bb24:	6a 00                	push   $0x0
 804bb26:	68 32 b7 04 08       	push   $0x804b732
 804bb2b:	56                   	push   %esi
 804bb2c:	e8 29 8c 00 00       	call   805475a <net_context_recv>
 804bb31:	83 c4 20             	add    $0x20,%esp
 804bb34:	89 c3                	mov    %eax,%ebx
 804bb36:	85 c0                	test   %eax,%eax
 804bb38:	79 0c                	jns    804bb46 <zsock_bind_ctx+0x5f>
 804bb3a:	e8 01 d5 ff ff       	call   8049040 <__errno_location@plt>
 804bb3f:	f7 db                	neg    %ebx
 804bb41:	83 cf ff             	or     $0xffffffff,%edi
 804bb44:	89 18                	mov    %ebx,(%eax)
}
 804bb46:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804bb49:	89 f8                	mov    %edi,%eax
 804bb4b:	5b                   	pop    %ebx
 804bb4c:	5e                   	pop    %esi
 804bb4d:	5f                   	pop    %edi
 804bb4e:	5d                   	pop    %ebp
 804bb4f:	c3                   	ret    

0804bb50 <sock_bind_vmeth>:
	return zsock_bind_ctx(obj, addr, addrlen);
 804bb50:	e9 92 ff ff ff       	jmp    804bae7 <zsock_bind_ctx>

0804bb55 <zsock_connect_ctx>:
{
 804bb55:	55                   	push   %ebp
 804bb56:	89 e5                	mov    %esp,%ebp
 804bb58:	56                   	push   %esi
 804bb59:	8b 55 0c             	mov    0xc(%ebp),%edx
 804bb5c:	8b 4d 10             	mov    0x10(%ebp),%ecx
 804bb5f:	53                   	push   %ebx
 804bb60:	8b 5d 08             	mov    0x8(%ebp),%ebx
		((context->flags >> NET_CONTEXT_STATE_SHIFT) &
 804bb63:	8b 83 98 00 00 00    	mov    0x98(%ebx),%eax
 804bb69:	66 d1 e8             	shr    %ax
 804bb6c:	83 e0 03             	and    $0x3,%eax
	if (net_context_get_state(ctx) == NET_CONTEXT_CONNECTED) {
 804bb6f:	66 83 f8 02          	cmp    $0x2,%ax
 804bb73:	75 07                	jne    804bb7c <zsock_connect_ctx+0x27>
		return 0;
 804bb75:	31 c0                	xor    %eax,%eax
 804bb77:	e9 a3 00 00 00       	jmp    804bc1f <zsock_connect_ctx+0xca>
	} else if (net_context_get_state(ctx) == NET_CONTEXT_CONNECTING) {
 804bb7c:	66 48                	dec    %ax

static inline uintptr_t sock_get_flag(struct net_context *ctx, uintptr_t mask)
{
	return POINTER_TO_UINT(ctx->socket_data) & mask;
 804bb7e:	8b 73 6c             	mov    0x6c(%ebx),%esi
 804bb81:	75 23                	jne    804bba6 <zsock_connect_ctx+0x51>
		if (sock_is_error(ctx)) {
 804bb83:	83 e6 04             	and    $0x4,%esi
 804bb86:	74 11                	je     804bb99 <zsock_connect_ctx+0x44>
			SET_ERRNO(-POINTER_TO_INT(ctx->user_data));
 804bb88:	8b 5b 04             	mov    0x4(%ebx),%ebx
 804bb8b:	85 db                	test   %ebx,%ebx
 804bb8d:	7e e6                	jle    804bb75 <zsock_connect_ctx+0x20>
 804bb8f:	e8 ac d4 ff ff       	call   8049040 <__errno_location@plt>
 804bb94:	e9 81 00 00 00       	jmp    804bc1a <zsock_connect_ctx+0xc5>
			SET_ERRNO(-EALREADY);
 804bb99:	e8 a2 d4 ff ff       	call   8049040 <__errno_location@plt>
 804bb9e:	c7 00 72 00 00 00    	movl   $0x72,(%eax)
 804bba4:	eb 76                	jmp    804bc1c <zsock_connect_ctx+0xc7>
	} else if (sock_is_nonblock(ctx)) {
 804bba6:	83 e6 02             	and    $0x2,%esi
 804bba9:	74 20                	je     804bbcb <zsock_connect_ctx+0x76>
		SET_ERRNO(net_context_connect(ctx, addr, addrlen,
 804bbab:	56                   	push   %esi
 804bbac:	ff 73 04             	push   0x4(%ebx)
 804bbaf:	6a 00                	push   $0x0
 804bbb1:	6a 00                	push   $0x0
 804bbb3:	68 c0 b4 04 08       	push   $0x804b4c0
 804bbb8:	51                   	push   %ecx
 804bbb9:	52                   	push   %edx
 804bbba:	53                   	push   %ebx
 804bbbb:	e8 92 88 00 00       	call   8054452 <net_context_connect>
 804bbc0:	83 c4 20             	add    $0x20,%esp
 804bbc3:	89 c3                	mov    %eax,%ebx
 804bbc5:	85 c0                	test   %eax,%eax
 804bbc7:	79 ac                	jns    804bb75 <zsock_connect_ctx+0x20>
 804bbc9:	eb 48                	jmp    804bc13 <zsock_connect_ctx+0xbe>
		SET_ERRNO(net_context_connect(ctx, addr, addrlen, NULL,
 804bbcb:	50                   	push   %eax
 804bbcc:	6a 00                	push   $0x0
 804bbce:	6a 00                	push   $0x0
 804bbd0:	68 2c 01 00 00       	push   $0x12c
 804bbd5:	6a 00                	push   $0x0
 804bbd7:	51                   	push   %ecx
 804bbd8:	52                   	push   %edx
 804bbd9:	53                   	push   %ebx
 804bbda:	e8 73 88 00 00       	call   8054452 <net_context_connect>
 804bbdf:	83 c4 20             	add    $0x20,%esp
 804bbe2:	89 c6                	mov    %eax,%esi
 804bbe4:	85 c0                	test   %eax,%eax
 804bbe6:	79 0b                	jns    804bbf3 <zsock_connect_ctx+0x9e>
 804bbe8:	e8 53 d4 ff ff       	call   8049040 <__errno_location@plt>
 804bbed:	f7 de                	neg    %esi
 804bbef:	89 30                	mov    %esi,(%eax)
 804bbf1:	eb 29                	jmp    804bc1c <zsock_connect_ctx+0xc7>
		SET_ERRNO(net_context_recv(ctx, zsock_received_cb, K_NO_WAIT,
 804bbf3:	83 ec 0c             	sub    $0xc,%esp
 804bbf6:	ff 73 04             	push   0x4(%ebx)
 804bbf9:	6a 00                	push   $0x0
 804bbfb:	6a 00                	push   $0x0
 804bbfd:	68 32 b7 04 08       	push   $0x804b732
 804bc02:	53                   	push   %ebx
 804bc03:	e8 52 8b 00 00       	call   805475a <net_context_recv>
 804bc08:	83 c4 20             	add    $0x20,%esp
 804bc0b:	89 c3                	mov    %eax,%ebx
	return 0;
 804bc0d:	31 c0                	xor    %eax,%eax
		SET_ERRNO(net_context_recv(ctx, zsock_received_cb, K_NO_WAIT,
 804bc0f:	85 db                	test   %ebx,%ebx
 804bc11:	79 0c                	jns    804bc1f <zsock_connect_ctx+0xca>
 804bc13:	e8 28 d4 ff ff       	call   8049040 <__errno_location@plt>
 804bc18:	f7 db                	neg    %ebx
 804bc1a:	89 18                	mov    %ebx,(%eax)
 804bc1c:	83 c8 ff             	or     $0xffffffff,%eax
}
 804bc1f:	8d 65 f8             	lea    -0x8(%ebp),%esp
 804bc22:	5b                   	pop    %ebx
 804bc23:	5e                   	pop    %esi
 804bc24:	5d                   	pop    %ebp
 804bc25:	c3                   	ret    

0804bc26 <sock_connect_vmeth>:
	return zsock_connect_ctx(obj, addr, addrlen);
 804bc26:	e9 2a ff ff ff       	jmp    804bb55 <zsock_connect_ctx>

0804bc2b <z_impl_zsock_connect>:
{
 804bc2b:	55                   	push   %ebp
 804bc2c:	89 e5                	mov    %esp,%ebp
 804bc2e:	56                   	push   %esi
 804bc2f:	53                   	push   %ebx
 804bc30:	83 ec 14             	sub    $0x14,%esp
 804bc33:	8b 75 0c             	mov    0xc(%ebp),%esi
 804bc36:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 804bc3c:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804bc3f:	31 c0                	xor    %eax,%eax
	ctx = z_get_fd_obj_and_vtable(sock,
 804bc41:	8d 45 f0             	lea    -0x10(%ebp),%eax
 804bc44:	50                   	push   %eax
 804bc45:	8d 45 ec             	lea    -0x14(%ebp),%eax
 804bc48:	50                   	push   %eax
 804bc49:	ff 75 08             	push   0x8(%ebp)
 804bc4c:	e8 bb e0 ff ff       	call   8049d0c <z_get_fd_obj_and_vtable>
 804bc51:	83 c4 10             	add    $0x10,%esp
	VTABLE_CALL(connect, sock, addr, addrlen);
 804bc54:	85 c0                	test   %eax,%eax
 804bc56:	75 0d                	jne    804bc65 <z_impl_zsock_connect+0x3a>
 804bc58:	e8 e3 d3 ff ff       	call   8049040 <__errno_location@plt>
 804bc5d:	c7 00 09 00 00 00    	movl   $0x9,(%eax)
 804bc63:	eb 16                	jmp    804bc7b <z_impl_zsock_connect+0x50>
 804bc65:	89 c3                	mov    %eax,%ebx
 804bc67:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804bc6a:	83 78 18 00          	cmpl   $0x0,0x18(%eax)
 804bc6e:	75 10                	jne    804bc80 <z_impl_zsock_connect+0x55>
 804bc70:	e8 cb d3 ff ff       	call   8049040 <__errno_location@plt>
 804bc75:	c7 00 5f 00 00 00    	movl   $0x5f,(%eax)
 804bc7b:	83 cb ff             	or     $0xffffffff,%ebx
 804bc7e:	eb 26                	jmp    804bca6 <z_impl_zsock_connect+0x7b>
 804bc80:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804bc83:	83 ca ff             	or     $0xffffffff,%edx
 804bc86:	89 d1                	mov    %edx,%ecx
 804bc88:	e8 c6 f8 ff ff       	call   804b553 <k_mutex_lock.constprop.0.isra.0>
 804bc8d:	50                   	push   %eax
 804bc8e:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804bc91:	ff 75 10             	push   0x10(%ebp)
 804bc94:	56                   	push   %esi
 804bc95:	53                   	push   %ebx
 804bc96:	ff 50 18             	call   *0x18(%eax)
 804bc99:	89 c3                	mov    %eax,%ebx
 804bc9b:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804bc9e:	83 c4 10             	add    $0x10,%esp
 804bca1:	e8 b9 f9 ff ff       	call   804b65f <k_mutex_unlock.isra.0>
}
 804bca6:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804bca9:	65 2b 05 14 00 00 00 	sub    %gs:0x14,%eax
 804bcb0:	74 05                	je     804bcb7 <z_impl_zsock_connect+0x8c>
 804bcb2:	e8 49 d6 ff ff       	call   8049300 <__stack_chk_fail@plt>
 804bcb7:	8d 65 f8             	lea    -0x8(%ebp),%esp
 804bcba:	89 d8                	mov    %ebx,%eax
 804bcbc:	5b                   	pop    %ebx
 804bcbd:	5e                   	pop    %esi
 804bcbe:	5d                   	pop    %ebp
 804bcbf:	c3                   	ret    

0804bcc0 <zsock_listen_ctx>:
{
 804bcc0:	55                   	push   %ebp
 804bcc1:	89 e5                	mov    %esp,%ebp
 804bcc3:	56                   	push   %esi
 804bcc4:	8b 75 08             	mov    0x8(%ebp),%esi
 804bcc7:	53                   	push   %ebx
	SET_ERRNO(net_context_listen(ctx, backlog));
 804bcc8:	50                   	push   %eax
 804bcc9:	50                   	push   %eax
 804bcca:	ff 75 0c             	push   0xc(%ebp)
 804bccd:	56                   	push   %esi
 804bcce:	e8 79 82 00 00       	call   8053f4c <net_context_listen>
 804bcd3:	83 c4 10             	add    $0x10,%esp
 804bcd6:	89 c3                	mov    %eax,%ebx
 804bcd8:	85 c0                	test   %eax,%eax
 804bcda:	78 1e                	js     804bcfa <zsock_listen_ctx+0x3a>
	SET_ERRNO(net_context_accept(ctx, zsock_accepted_cb, K_NO_WAIT, ctx));
 804bcdc:	83 ec 0c             	sub    $0xc,%esp
 804bcdf:	56                   	push   %esi
 804bce0:	6a 00                	push   $0x0
 804bce2:	6a 00                	push   $0x0
 804bce4:	68 cf b6 04 08       	push   $0x804b6cf
 804bce9:	56                   	push   %esi
 804bcea:	e8 ef 88 00 00       	call   80545de <net_context_accept>
 804bcef:	83 c4 20             	add    $0x20,%esp
 804bcf2:	89 c3                	mov    %eax,%ebx
	return 0;
 804bcf4:	31 c0                	xor    %eax,%eax
	SET_ERRNO(net_context_accept(ctx, zsock_accepted_cb, K_NO_WAIT, ctx));
 804bcf6:	85 db                	test   %ebx,%ebx
 804bcf8:	79 0c                	jns    804bd06 <zsock_listen_ctx+0x46>
 804bcfa:	e8 41 d3 ff ff       	call   8049040 <__errno_location@plt>
 804bcff:	f7 db                	neg    %ebx
 804bd01:	89 18                	mov    %ebx,(%eax)
 804bd03:	83 c8 ff             	or     $0xffffffff,%eax
}
 804bd06:	8d 65 f8             	lea    -0x8(%ebp),%esp
 804bd09:	5b                   	pop    %ebx
 804bd0a:	5e                   	pop    %esi
 804bd0b:	5d                   	pop    %ebp
 804bd0c:	c3                   	ret    

0804bd0d <sock_listen_vmeth>:
	return zsock_listen_ctx(obj, backlog);
 804bd0d:	e9 ae ff ff ff       	jmp    804bcc0 <zsock_listen_ctx>

0804bd12 <zsock_accept_ctx>:
{
 804bd12:	55                   	push   %ebp
 804bd13:	89 e5                	mov    %esp,%ebp
 804bd15:	57                   	push   %edi
 804bd16:	56                   	push   %esi
 804bd17:	53                   	push   %ebx
 804bd18:	83 ec 1c             	sub    $0x1c,%esp
 804bd1b:	8b 5d 08             	mov    0x8(%ebp),%ebx
	fd = z_reserve_fd();
 804bd1e:	e8 2b e0 ff ff       	call   8049d4e <z_reserve_fd>
	if (fd < 0) {
 804bd23:	85 c0                	test   %eax,%eax
 804bd25:	89 45 e0             	mov    %eax,-0x20(%ebp)
 804bd28:	0f 88 71 01 00 00    	js     804be9f <zsock_accept_ctx+0x18d>
	if (sock_is_nonblock(parent)) {
 804bd2e:	8b 43 6c             	mov    0x6c(%ebx),%eax
 804bd31:	83 e0 02             	and    $0x2,%eax
 804bd34:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 804bd37:	0f 94 c0             	sete   %al
 804bd3a:	31 ff                	xor    %edi,%edi
 804bd3c:	0f b6 c0             	movzbl %al,%eax
 804bd3f:	89 c6                	mov    %eax,%esi
 804bd41:	f7 de                	neg    %esi
 804bd43:	83 d7 00             	adc    $0x0,%edi
 804bd46:	f7 df                	neg    %edi
	ctx = k_fifo_get(&parent->accept_q, timeout);
 804bd48:	83 c3 70             	add    $0x70,%ebx
	return z_impl_k_queue_get(queue, timeout);
 804bd4b:	52                   	push   %edx
 804bd4c:	57                   	push   %edi
 804bd4d:	56                   	push   %esi
 804bd4e:	53                   	push   %ebx
 804bd4f:	e8 e7 37 01 00       	call   805f53b <z_impl_k_queue_get>
 804bd54:	83 c4 10             	add    $0x10,%esp
	if (ctx == NULL) {
 804bd57:	8b 55 e0             	mov    -0x20(%ebp),%edx
 804bd5a:	85 c0                	test   %eax,%eax
 804bd5c:	89 c3                	mov    %eax,%ebx
 804bd5e:	75 2d                	jne    804bd8d <zsock_accept_ctx+0x7b>
		z_free_fd(fd);
 804bd60:	83 ec 0c             	sub    $0xc,%esp
 804bd63:	52                   	push   %edx
 804bd64:	e8 a6 e0 ff ff       	call   8049e0f <z_free_fd>
 804bd69:	83 c4 10             	add    $0x10,%esp
			errno = EAGAIN;
 804bd6c:	e8 cf d2 ff ff       	call   8049040 <__errno_location@plt>
		if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
 804bd71:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
 804bd75:	74 0b                	je     804bd82 <zsock_accept_ctx+0x70>
			errno = EAGAIN;
 804bd77:	c7 00 0b 00 00 00    	movl   $0xb,(%eax)
 804bd7d:	e9 1d 01 00 00       	jmp    804be9f <zsock_accept_ctx+0x18d>
			errno = EINVAL;
 804bd82:	c7 00 16 00 00 00    	movl   $0x16,(%eax)
 804bd88:	e9 12 01 00 00       	jmp    804be9f <zsock_accept_ctx+0x18d>
 804bd8d:	89 55 e4             	mov    %edx,-0x1c(%ebp)
	return z_impl_k_queue_peek_tail(queue);
 804bd90:	83 ec 0c             	sub    $0xc,%esp
	last_pkt = k_fifo_peek_tail(&ctx->recv_q);
 804bd93:	8d 40 70             	lea    0x70(%eax),%eax
 804bd96:	50                   	push   %eax
 804bd97:	e8 63 38 01 00       	call   805f5ff <z_impl_k_queue_peek_tail>
 804bd9c:	83 c4 10             	add    $0x10,%esp
	if (last_pkt) {
 804bd9f:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 804bda2:	85 c0                	test   %eax,%eax
 804bda4:	74 39                	je     804bddf <zsock_accept_ctx+0xcd>
		if (net_pkt_eof(last_pkt)) {
 804bda6:	f6 40 33 02          	testb  $0x2,0x33(%eax)
 804bdaa:	74 33                	je     804bddf <zsock_accept_ctx+0xcd>
			z_free_fd(fd);
 804bdac:	83 ec 0c             	sub    $0xc,%esp
	val = (val & ~mask) | flag;
 804bdaf:	83 4b 6c 01          	orl    $0x1,0x6c(%ebx)
 804bdb3:	52                   	push   %edx
 804bdb4:	e8 56 e0 ff ff       	call   8049e0f <z_free_fd>
 804bdb9:	83 c4 10             	add    $0x10,%esp
			zsock_flush_queue(ctx);
 804bdbc:	89 d8                	mov    %ebx,%eax
 804bdbe:	e8 ad f8 ff ff       	call   804b670 <zsock_flush_queue>
			net_context_put(ctx);
 804bdc3:	83 ec 0c             	sub    $0xc,%esp
 804bdc6:	53                   	push   %ebx
 804bdc7:	e8 f9 7d 00 00       	call   8053bc5 <net_context_put>
 804bdcc:	83 c4 10             	add    $0x10,%esp
			errno = ECONNABORTED;
 804bdcf:	e8 6c d2 ff ff       	call   8049040 <__errno_location@plt>
 804bdd4:	c7 00 67 00 00 00    	movl   $0x67,(%eax)
			return -1;
 804bdda:	e9 c0 00 00 00       	jmp    804be9f <zsock_accept_ctx+0x18d>
	return context->flags & NET_CONTEXT_CLOSING_SOCK;
 804bddf:	8b 83 98 00 00 00    	mov    0x98(%ebx),%eax
	if (net_context_is_closing(ctx)) {
 804bde5:	f6 c4 04             	test   $0x4,%ah
 804bde8:	74 1f                	je     804be09 <zsock_accept_ctx+0xf7>
 804bdea:	89 55 e4             	mov    %edx,-0x1c(%ebp)
		errno = ECONNABORTED;
 804bded:	e8 4e d2 ff ff       	call   8049040 <__errno_location@plt>
		z_free_fd(fd);
 804bdf2:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 804bdf5:	83 ec 0c             	sub    $0xc,%esp
		errno = ECONNABORTED;
 804bdf8:	c7 00 67 00 00 00    	movl   $0x67,(%eax)
		z_free_fd(fd);
 804bdfe:	52                   	push   %edx
 804bdff:	e8 0b e0 ff ff       	call   8049e0f <z_free_fd>
 804be04:	83 c4 10             	add    $0x10,%esp
		zsock_flush_queue(ctx);
 804be07:	eb 69                	jmp    804be72 <zsock_accept_ctx+0x160>
		context->flags &= ~NET_CONTEXT_ACCEPTING_SOCK;
 804be09:	80 e4 fd             	and    $0xfd,%ah
	if (addr != NULL && addrlen != NULL) {
 804be0c:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
 804be10:	66 89 83 98 00 00 00 	mov    %ax,0x98(%ebx)
 804be17:	74 6e                	je     804be87 <zsock_accept_ctx+0x175>
 804be19:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
 804be1d:	74 68                	je     804be87 <zsock_accept_ctx+0x175>
		int len = MIN(*addrlen, sizeof(ctx->remote));
 804be1f:	8b 45 10             	mov    0x10(%ebp),%eax
 804be22:	8b 7d 0c             	mov    0xc(%ebp),%edi
 804be25:	8d 73 2c             	lea    0x2c(%ebx),%esi
 804be28:	8b 08                	mov    (%eax),%ecx
 804be2a:	b8 18 00 00 00       	mov    $0x18,%eax
 804be2f:	39 c1                	cmp    %eax,%ecx
 804be31:	0f 47 c8             	cmova  %eax,%ecx
 804be34:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
		if (ctx->remote.sa_family == AF_INET) {
 804be36:	8b 43 2c             	mov    0x2c(%ebx),%eax
 804be39:	66 83 f8 01          	cmp    $0x1,%ax
 804be3d:	75 0b                	jne    804be4a <zsock_accept_ctx+0x138>
			*addrlen = sizeof(struct sockaddr_in);
 804be3f:	8b 45 10             	mov    0x10(%ebp),%eax
 804be42:	c7 00 08 00 00 00    	movl   $0x8,(%eax)
 804be48:	eb 3d                	jmp    804be87 <zsock_accept_ctx+0x175>
		} else if (ctx->remote.sa_family == AF_INET6) {
 804be4a:	66 83 f8 02          	cmp    $0x2,%ax
 804be4e:	75 0b                	jne    804be5b <zsock_accept_ctx+0x149>
			*addrlen = sizeof(struct sockaddr_in6);
 804be50:	8b 45 10             	mov    0x10(%ebp),%eax
 804be53:	c7 00 18 00 00 00    	movl   $0x18,(%eax)
 804be59:	eb 2c                	jmp    804be87 <zsock_accept_ctx+0x175>
			z_free_fd(fd);
 804be5b:	83 ec 0c             	sub    $0xc,%esp
 804be5e:	52                   	push   %edx
 804be5f:	e8 ab df ff ff       	call   8049e0f <z_free_fd>
 804be64:	83 c4 10             	add    $0x10,%esp
			errno = ENOTSUP;
 804be67:	e8 d4 d1 ff ff       	call   8049040 <__errno_location@plt>
 804be6c:	c7 00 5f 00 00 00    	movl   $0x5f,(%eax)
			zsock_flush_queue(ctx);
 804be72:	89 d8                	mov    %ebx,%eax
 804be74:	e8 f7 f7 ff ff       	call   804b670 <zsock_flush_queue>
			net_context_put(ctx);
 804be79:	83 ec 0c             	sub    $0xc,%esp
 804be7c:	53                   	push   %ebx
 804be7d:	e8 43 7d 00 00       	call   8053bc5 <net_context_put>
 804be82:	83 c4 10             	add    $0x10,%esp
			return -1;
 804be85:	eb 18                	jmp    804be9f <zsock_accept_ctx+0x18d>
	z_finalize_fd(fd, ctx, (const struct fd_op_vtable *)&sock_fd_op_vtable);
 804be87:	50                   	push   %eax
 804be88:	68 00 20 06 08       	push   $0x8062000
 804be8d:	53                   	push   %ebx
 804be8e:	52                   	push   %edx
 804be8f:	89 55 e4             	mov    %edx,-0x1c(%ebp)
 804be92:	e8 39 df ff ff       	call   8049dd0 <z_finalize_fd>
	return fd;
 804be97:	8b 55 e4             	mov    -0x1c(%ebp),%edx
	z_finalize_fd(fd, ctx, (const struct fd_op_vtable *)&sock_fd_op_vtable);
 804be9a:	83 c4 10             	add    $0x10,%esp
	return fd;
 804be9d:	eb 03                	jmp    804bea2 <zsock_accept_ctx+0x190>
		return -1;
 804be9f:	83 ca ff             	or     $0xffffffff,%edx
}
 804bea2:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804bea5:	89 d0                	mov    %edx,%eax
 804bea7:	5b                   	pop    %ebx
 804bea8:	5e                   	pop    %esi
 804bea9:	5f                   	pop    %edi
 804beaa:	5d                   	pop    %ebp
 804beab:	c3                   	ret    

0804beac <sock_accept_vmeth>:
	return zsock_accept_ctx(obj, addr, addrlen);
 804beac:	e9 61 fe ff ff       	jmp    804bd12 <zsock_accept_ctx>

0804beb1 <zsock_sendto_ctx>:
{
 804beb1:	55                   	push   %ebp
 804beb2:	89 e5                	mov    %esp,%ebp
 804beb4:	57                   	push   %edi
 804beb5:	56                   	push   %esi
 804beb6:	53                   	push   %ebx
 804beb7:	83 ec 2c             	sub    $0x2c,%esp
 804beba:	8b 5d 08             	mov    0x8(%ebp),%ebx
 804bebd:	8b 75 0c             	mov    0xc(%ebp),%esi
 804bec0:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 804bec6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 804bec9:	31 c0                	xor    %eax,%eax
 804becb:	8b 7d 18             	mov    0x18(%ebp),%edi
	k_timeout_t timeout = K_FOREVER;
 804bece:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%ebp)
 804bed5:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
	uint32_t retry_timeout = WAIT_BUFS_INITIAL_MS;
 804bedc:	c7 45 d8 0a 00 00 00 	movl   $0xa,-0x28(%ebp)
	if ((flags & ZSOCK_MSG_DONTWAIT) || sock_is_nonblock(ctx)) {
 804bee3:	f6 45 14 40          	testb  $0x40,0x14(%ebp)
 804bee7:	75 06                	jne    804beef <zsock_sendto_ctx+0x3e>
 804bee9:	f6 43 6c 02          	testb  $0x2,0x6c(%ebx)
 804beed:	74 1e                	je     804bf0d <zsock_sendto_ctx+0x5c>
		timeout = K_NO_WAIT;
 804beef:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
 804bef6:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	uint64_t buf_timeout = 0;
 804befd:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
 804bf04:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
	if ((flags & ZSOCK_MSG_DONTWAIT) || sock_is_nonblock(ctx)) {
 804bf0b:	eb 25                	jmp    804bf32 <zsock_sendto_ctx+0x81>
		net_context_get_option(ctx, NET_OPT_SNDTIMEO, &timeout, NULL);
 804bf0d:	8d 45 dc             	lea    -0x24(%ebp),%eax
 804bf10:	6a 00                	push   $0x0
 804bf12:	50                   	push   %eax
 804bf13:	6a 05                	push   $0x5
 804bf15:	53                   	push   %ebx
 804bf16:	e8 a9 8a 00 00       	call   80549c4 <net_context_get_option>
 804bf1b:	58                   	pop    %eax
 804bf1c:	5a                   	pop    %edx
		buf_timeout = sys_clock_timeout_end_calc(MAX_WAIT_BUFS);
 804bf1d:	6a 00                	push   $0x0
 804bf1f:	68 e8 03 00 00       	push   $0x3e8
 804bf24:	e8 f0 4c 01 00       	call   8060c19 <sys_clock_timeout_end_calc>
 804bf29:	83 c4 10             	add    $0x10,%esp
 804bf2c:	89 45 d0             	mov    %eax,-0x30(%ebp)
 804bf2f:	89 55 d4             	mov    %edx,-0x2c(%ebp)
	end = sys_clock_timeout_end_calc(timeout);
 804bf32:	51                   	push   %ecx
 804bf33:	51                   	push   %ecx
 804bf34:	ff 75 e0             	push   -0x20(%ebp)
 804bf37:	ff 75 dc             	push   -0x24(%ebp)
 804bf3a:	e8 da 4c 01 00       	call   8060c19 <sys_clock_timeout_end_calc>
 804bf3f:	59                   	pop    %ecx
	status = net_context_recv(ctx, zsock_received_cb,
 804bf40:	ff 73 04             	push   0x4(%ebx)
 804bf43:	6a 00                	push   $0x0
 804bf45:	6a 00                	push   $0x0
 804bf47:	68 32 b7 04 08       	push   $0x804b732
 804bf4c:	53                   	push   %ebx
	end = sys_clock_timeout_end_calc(timeout);
 804bf4d:	89 45 c8             	mov    %eax,-0x38(%ebp)
 804bf50:	89 55 cc             	mov    %edx,-0x34(%ebp)
	status = net_context_recv(ctx, zsock_received_cb,
 804bf53:	e8 02 88 00 00       	call   805475a <net_context_recv>
 804bf58:	83 c4 20             	add    $0x20,%esp
	if (status < 0) {
 804bf5b:	85 c0                	test   %eax,%eax
 804bf5d:	79 60                	jns    804bfbf <zsock_sendto_ctx+0x10e>
 804bf5f:	89 45 d0             	mov    %eax,-0x30(%ebp)
		errno = -status;
 804bf62:	e8 d9 d0 ff ff       	call   8049040 <__errno_location@plt>
 804bf67:	8b 55 d0             	mov    -0x30(%ebp),%edx
 804bf6a:	f7 da                	neg    %edx
 804bf6c:	89 10                	mov    %edx,(%eax)
		return -1;
 804bf6e:	83 c8 ff             	or     $0xffffffff,%eax
 804bf71:	eb 72                	jmp    804bfe5 <zsock_sendto_ctx+0x134>
			status = net_context_send(ctx, buf, len, NULL, timeout,
 804bf73:	52                   	push   %edx
 804bf74:	50                   	push   %eax
 804bf75:	ff 75 e0             	push   -0x20(%ebp)
 804bf78:	ff 75 dc             	push   -0x24(%ebp)
 804bf7b:	6a 00                	push   $0x0
 804bf7d:	ff 75 10             	push   0x10(%ebp)
 804bf80:	56                   	push   %esi
 804bf81:	53                   	push   %ebx
 804bf82:	e8 c1 86 00 00       	call   8054648 <net_context_send>
 804bf87:	83 c4 20             	add    $0x20,%esp
		if (status < 0) {
 804bf8a:	85 c0                	test   %eax,%eax
 804bf8c:	79 57                	jns    804bfe5 <zsock_sendto_ctx+0x134>
			status = send_check_and_wait(ctx, status, buf_timeout,
 804bf8e:	83 ec 0c             	sub    $0xc,%esp
 804bf91:	8d 55 d8             	lea    -0x28(%ebp),%edx
 804bf94:	52                   	push   %edx
 804bf95:	89 c2                	mov    %eax,%edx
 804bf97:	89 d8                	mov    %ebx,%eax
 804bf99:	ff 75 e0             	push   -0x20(%ebp)
 804bf9c:	ff 75 dc             	push   -0x24(%ebp)
 804bf9f:	ff 75 d4             	push   -0x2c(%ebp)
 804bfa2:	ff 75 d0             	push   -0x30(%ebp)
 804bfa5:	e8 1b f8 ff ff       	call   804b7c5 <send_check_and_wait>
 804bfaa:	83 c4 20             	add    $0x20,%esp
			if (status < 0) {
 804bfad:	85 c0                	test   %eax,%eax
 804bfaf:	78 34                	js     804bfe5 <zsock_sendto_ctx+0x134>
			timeout_recalc(end, &timeout);
 804bfb1:	8b 45 c8             	mov    -0x38(%ebp),%eax
 804bfb4:	8b 55 cc             	mov    -0x34(%ebp),%edx
 804bfb7:	8d 4d dc             	lea    -0x24(%ebp),%ecx
 804bfba:	e8 38 f5 ff ff       	call   804b4f7 <timeout_recalc>
			status = net_context_sendto(ctx, buf, len, dest_addr,
 804bfbf:	8b 43 04             	mov    0x4(%ebx),%eax
		if (dest_addr) {
 804bfc2:	85 ff                	test   %edi,%edi
 804bfc4:	74 ad                	je     804bf73 <zsock_sendto_ctx+0xc2>
			status = net_context_sendto(ctx, buf, len, dest_addr,
 804bfc6:	83 ec 0c             	sub    $0xc,%esp
 804bfc9:	50                   	push   %eax
 804bfca:	ff 75 e0             	push   -0x20(%ebp)
 804bfcd:	ff 75 dc             	push   -0x24(%ebp)
 804bfd0:	6a 00                	push   $0x0
 804bfd2:	ff 75 1c             	push   0x1c(%ebp)
 804bfd5:	57                   	push   %edi
 804bfd6:	ff 75 10             	push   0x10(%ebp)
 804bfd9:	56                   	push   %esi
 804bfda:	53                   	push   %ebx
 804bfdb:	e8 30 87 00 00       	call   8054710 <net_context_sendto>
 804bfe0:	83 c4 30             	add    $0x30,%esp
 804bfe3:	eb a5                	jmp    804bf8a <zsock_sendto_ctx+0xd9>
}
 804bfe5:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 804bfe8:	65 2b 15 14 00 00 00 	sub    %gs:0x14,%edx
 804bfef:	74 05                	je     804bff6 <zsock_sendto_ctx+0x145>
 804bff1:	e8 0a d3 ff ff       	call   8049300 <__stack_chk_fail@plt>
 804bff6:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804bff9:	5b                   	pop    %ebx
 804bffa:	5e                   	pop    %esi
 804bffb:	5f                   	pop    %edi
 804bffc:	5d                   	pop    %ebp
 804bffd:	c3                   	ret    

0804bffe <sock_sendto_vmeth>:
	return zsock_sendto_ctx(obj, buf, len, flags, dest_addr, addrlen);
 804bffe:	e9 ae fe ff ff       	jmp    804beb1 <zsock_sendto_ctx>

0804c003 <sock_write_vmeth>:
{
 804c003:	55                   	push   %ebp
 804c004:	89 e5                	mov    %esp,%ebp
 804c006:	83 ec 10             	sub    $0x10,%esp
	return zsock_sendto_ctx(obj, buffer, count, 0, NULL, 0);
 804c009:	6a 00                	push   $0x0
 804c00b:	6a 00                	push   $0x0
 804c00d:	6a 00                	push   $0x0
 804c00f:	ff 75 10             	push   0x10(%ebp)
 804c012:	ff 75 0c             	push   0xc(%ebp)
 804c015:	ff 75 08             	push   0x8(%ebp)
 804c018:	e8 94 fe ff ff       	call   804beb1 <zsock_sendto_ctx>
 804c01d:	83 c4 20             	add    $0x20,%esp
}
 804c020:	c9                   	leave  
 804c021:	c3                   	ret    

0804c022 <z_impl_zsock_sendto>:
{
 804c022:	55                   	push   %ebp
 804c023:	89 e5                	mov    %esp,%ebp
 804c025:	57                   	push   %edi
 804c026:	56                   	push   %esi
 804c027:	53                   	push   %ebx
 804c028:	83 ec 20             	sub    $0x20,%esp
 804c02b:	8b 75 0c             	mov    0xc(%ebp),%esi
 804c02e:	8b 7d 18             	mov    0x18(%ebp),%edi
 804c031:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 804c037:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 804c03a:	31 c0                	xor    %eax,%eax
	ctx = z_get_fd_obj_and_vtable(sock,
 804c03c:	8d 45 e0             	lea    -0x20(%ebp),%eax
 804c03f:	50                   	push   %eax
 804c040:	8d 45 dc             	lea    -0x24(%ebp),%eax
 804c043:	50                   	push   %eax
 804c044:	ff 75 08             	push   0x8(%ebp)
 804c047:	e8 c0 dc ff ff       	call   8049d0c <z_get_fd_obj_and_vtable>
 804c04c:	83 c4 10             	add    $0x10,%esp
	VTABLE_CALL(sendto, sock, buf, len, flags, dest_addr, addrlen);
 804c04f:	85 c0                	test   %eax,%eax
 804c051:	75 0d                	jne    804c060 <z_impl_zsock_sendto+0x3e>
 804c053:	e8 e8 cf ff ff       	call   8049040 <__errno_location@plt>
 804c058:	c7 00 09 00 00 00    	movl   $0x9,(%eax)
 804c05e:	eb 16                	jmp    804c076 <z_impl_zsock_sendto+0x54>
 804c060:	89 c3                	mov    %eax,%ebx
 804c062:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804c065:	83 78 24 00          	cmpl   $0x0,0x24(%eax)
 804c069:	75 10                	jne    804c07b <z_impl_zsock_sendto+0x59>
 804c06b:	e8 d0 cf ff ff       	call   8049040 <__errno_location@plt>
 804c070:	c7 00 5f 00 00 00    	movl   $0x5f,(%eax)
 804c076:	83 cb ff             	or     $0xffffffff,%ebx
 804c079:	eb 2e                	jmp    804c0a9 <z_impl_zsock_sendto+0x87>
 804c07b:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804c07e:	83 ca ff             	or     $0xffffffff,%edx
 804c081:	89 d1                	mov    %edx,%ecx
 804c083:	e8 cb f4 ff ff       	call   804b553 <k_mutex_lock.constprop.0.isra.0>
 804c088:	50                   	push   %eax
 804c089:	50                   	push   %eax
 804c08a:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804c08d:	ff 75 1c             	push   0x1c(%ebp)
 804c090:	57                   	push   %edi
 804c091:	ff 75 14             	push   0x14(%ebp)
 804c094:	ff 75 10             	push   0x10(%ebp)
 804c097:	56                   	push   %esi
 804c098:	53                   	push   %ebx
 804c099:	ff 50 24             	call   *0x24(%eax)
 804c09c:	89 c3                	mov    %eax,%ebx
 804c09e:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804c0a1:	83 c4 20             	add    $0x20,%esp
 804c0a4:	e8 b6 f5 ff ff       	call   804b65f <k_mutex_unlock.isra.0>
}
 804c0a9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804c0ac:	65 2b 05 14 00 00 00 	sub    %gs:0x14,%eax
 804c0b3:	74 05                	je     804c0ba <z_impl_zsock_sendto+0x98>
 804c0b5:	e8 46 d2 ff ff       	call   8049300 <__stack_chk_fail@plt>
 804c0ba:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804c0bd:	89 d8                	mov    %ebx,%eax
 804c0bf:	5b                   	pop    %ebx
 804c0c0:	5e                   	pop    %esi
 804c0c1:	5f                   	pop    %edi
 804c0c2:	5d                   	pop    %ebp
 804c0c3:	c3                   	ret    

0804c0c4 <zsock_sendmsg_ctx>:
{
 804c0c4:	55                   	push   %ebp
 804c0c5:	89 e5                	mov    %esp,%ebp
 804c0c7:	57                   	push   %edi
 804c0c8:	56                   	push   %esi
 804c0c9:	53                   	push   %ebx
 804c0ca:	83 ec 2c             	sub    $0x2c,%esp
 804c0cd:	8b 45 0c             	mov    0xc(%ebp),%eax
 804c0d0:	8b 5d 08             	mov    0x8(%ebp),%ebx
 804c0d3:	89 45 cc             	mov    %eax,-0x34(%ebp)
 804c0d6:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 804c0dc:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 804c0df:	31 c0                	xor    %eax,%eax
	k_timeout_t timeout = K_FOREVER;
 804c0e1:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%ebp)
 804c0e8:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
	uint32_t retry_timeout = WAIT_BUFS_INITIAL_MS;
 804c0ef:	c7 45 d8 0a 00 00 00 	movl   $0xa,-0x28(%ebp)
	if ((flags & ZSOCK_MSG_DONTWAIT) || sock_is_nonblock(ctx)) {
 804c0f6:	f6 45 10 40          	testb  $0x40,0x10(%ebp)
 804c0fa:	75 06                	jne    804c102 <zsock_sendmsg_ctx+0x3e>
 804c0fc:	f6 43 6c 02          	testb  $0x2,0x6c(%ebx)
 804c100:	74 14                	je     804c116 <zsock_sendmsg_ctx+0x52>
		timeout = K_NO_WAIT;
 804c102:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	uint64_t buf_timeout = 0;
 804c109:	31 f6                	xor    %esi,%esi
 804c10b:	31 ff                	xor    %edi,%edi
		timeout = K_NO_WAIT;
 804c10d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	if ((flags & ZSOCK_MSG_DONTWAIT) || sock_is_nonblock(ctx)) {
 804c114:	eb 23                	jmp    804c139 <zsock_sendmsg_ctx+0x75>
		net_context_get_option(ctx, NET_OPT_SNDTIMEO, &timeout, NULL);
 804c116:	8d 45 dc             	lea    -0x24(%ebp),%eax
 804c119:	6a 00                	push   $0x0
 804c11b:	50                   	push   %eax
 804c11c:	6a 05                	push   $0x5
 804c11e:	53                   	push   %ebx
 804c11f:	e8 a0 88 00 00       	call   80549c4 <net_context_get_option>
 804c124:	59                   	pop    %ecx
 804c125:	5e                   	pop    %esi
		buf_timeout = sys_clock_timeout_end_calc(MAX_WAIT_BUFS);
 804c126:	6a 00                	push   $0x0
 804c128:	68 e8 03 00 00       	push   $0x3e8
 804c12d:	e8 e7 4a 01 00       	call   8060c19 <sys_clock_timeout_end_calc>
 804c132:	83 c4 10             	add    $0x10,%esp
 804c135:	89 c6                	mov    %eax,%esi
 804c137:	89 d7                	mov    %edx,%edi
	end = sys_clock_timeout_end_calc(timeout);
 804c139:	52                   	push   %edx
 804c13a:	52                   	push   %edx
 804c13b:	ff 75 e0             	push   -0x20(%ebp)
 804c13e:	ff 75 dc             	push   -0x24(%ebp)
 804c141:	e8 d3 4a 01 00       	call   8060c19 <sys_clock_timeout_end_calc>
 804c146:	83 c4 10             	add    $0x10,%esp
 804c149:	89 45 d0             	mov    %eax,-0x30(%ebp)
 804c14c:	89 55 d4             	mov    %edx,-0x2c(%ebp)
		status = net_context_sendmsg(ctx, msg, flags, NULL, timeout, NULL);
 804c14f:	50                   	push   %eax
 804c150:	6a 00                	push   $0x0
 804c152:	ff 75 e0             	push   -0x20(%ebp)
 804c155:	ff 75 dc             	push   -0x24(%ebp)
 804c158:	6a 00                	push   $0x0
 804c15a:	ff 75 10             	push   0x10(%ebp)
 804c15d:	ff 75 cc             	push   -0x34(%ebp)
 804c160:	53                   	push   %ebx
 804c161:	e8 63 85 00 00       	call   80546c9 <net_context_sendmsg>
 804c166:	83 c4 20             	add    $0x20,%esp
		if (status < 0) {
 804c169:	85 c0                	test   %eax,%eax
 804c16b:	79 2f                	jns    804c19c <zsock_sendmsg_ctx+0xd8>
				status = send_check_and_wait(ctx, status,
 804c16d:	83 ec 0c             	sub    $0xc,%esp
 804c170:	8d 55 d8             	lea    -0x28(%ebp),%edx
 804c173:	52                   	push   %edx
 804c174:	89 c2                	mov    %eax,%edx
 804c176:	89 d8                	mov    %ebx,%eax
 804c178:	ff 75 e0             	push   -0x20(%ebp)
 804c17b:	ff 75 dc             	push   -0x24(%ebp)
 804c17e:	57                   	push   %edi
 804c17f:	56                   	push   %esi
 804c180:	e8 40 f6 ff ff       	call   804b7c5 <send_check_and_wait>
 804c185:	83 c4 20             	add    $0x20,%esp
				if (status < 0) {
 804c188:	85 c0                	test   %eax,%eax
 804c18a:	78 10                	js     804c19c <zsock_sendmsg_ctx+0xd8>
				timeout_recalc(end, &timeout);
 804c18c:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804c18f:	8b 55 d4             	mov    -0x2c(%ebp),%edx
 804c192:	8d 4d dc             	lea    -0x24(%ebp),%ecx
 804c195:	e8 5d f3 ff ff       	call   804b4f7 <timeout_recalc>
		status = net_context_sendmsg(ctx, msg, flags, NULL, timeout, NULL);
 804c19a:	eb b3                	jmp    804c14f <zsock_sendmsg_ctx+0x8b>
}
 804c19c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 804c19f:	65 2b 15 14 00 00 00 	sub    %gs:0x14,%edx
 804c1a6:	74 05                	je     804c1ad <zsock_sendmsg_ctx+0xe9>
 804c1a8:	e8 53 d1 ff ff       	call   8049300 <__stack_chk_fail@plt>
 804c1ad:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804c1b0:	5b                   	pop    %ebx
 804c1b1:	5e                   	pop    %esi
 804c1b2:	5f                   	pop    %edi
 804c1b3:	5d                   	pop    %ebp
 804c1b4:	c3                   	ret    

0804c1b5 <sock_sendmsg_vmeth>:
	return zsock_sendmsg_ctx(obj, msg, flags);
 804c1b5:	e9 0a ff ff ff       	jmp    804c0c4 <zsock_sendmsg_ctx>

0804c1ba <zsock_wait_data>:
{
 804c1ba:	55                   	push   %ebp
 804c1bb:	89 e5                	mov    %esp,%ebp
 804c1bd:	53                   	push   %ebx
 804c1be:	50                   	push   %eax
 804c1bf:	8b 55 08             	mov    0x8(%ebp),%edx
		return -EINVAL;
 804c1c2:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
	if (ctx->cond.lock == NULL) {
 804c1c7:	83 ba 90 00 00 00 00 	cmpl   $0x0,0x90(%edx)
 804c1ce:	74 28                	je     804c1f8 <zsock_wait_data+0x3e>
	return 0;
 804c1d0:	31 c0                	xor    %eax,%eax
	if (k_fifo_is_empty(&ctx->recv_q)) {
 804c1d2:	83 7a 70 00          	cmpl   $0x0,0x70(%edx)
 804c1d6:	75 20                	jne    804c1f8 <zsock_wait_data+0x3e>
		return k_condvar_wait(&ctx->cond.recv, ctx->cond.lock,
 804c1d8:	8b 4d 0c             	mov    0xc(%ebp),%ecx
 804c1db:	8b 82 90 00 00 00    	mov    0x90(%edx),%eax
 804c1e1:	8b 59 04             	mov    0x4(%ecx),%ebx
 804c1e4:	8b 09                	mov    (%ecx),%ecx
 804c1e6:	81 c2 88 00 00 00    	add    $0x88,%edx
	return z_impl_k_condvar_wait(condvar, mutex, timeout);
 804c1ec:	53                   	push   %ebx
 804c1ed:	51                   	push   %ecx
 804c1ee:	50                   	push   %eax
 804c1ef:	52                   	push   %edx
 804c1f0:	e8 e1 45 01 00       	call   80607d6 <z_impl_k_condvar_wait>
 804c1f5:	83 c4 10             	add    $0x10,%esp
}
 804c1f8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 804c1fb:	c9                   	leave  
 804c1fc:	c3                   	ret    

0804c1fd <zsock_recvfrom_ctx>:
{
 804c1fd:	55                   	push   %ebp
 804c1fe:	89 e5                	mov    %esp,%ebp
 804c200:	57                   	push   %edi
 804c201:	56                   	push   %esi
		return 0;
 804c202:	31 f6                	xor    %esi,%esi
{
 804c204:	53                   	push   %ebx
 804c205:	83 ec 6c             	sub    $0x6c,%esp
 804c208:	8b 45 08             	mov    0x8(%ebp),%eax
 804c20b:	89 45 b4             	mov    %eax,-0x4c(%ebp)
 804c20e:	8b 45 0c             	mov    0xc(%ebp),%eax
 804c211:	89 45 98             	mov    %eax,-0x68(%ebp)
 804c214:	8b 45 18             	mov    0x18(%ebp),%eax
 804c217:	89 45 b0             	mov    %eax,-0x50(%ebp)
 804c21a:	8b 45 1c             	mov    0x1c(%ebp),%eax
 804c21d:	89 45 ac             	mov    %eax,-0x54(%ebp)
 804c220:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 804c226:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 804c229:	31 c0                	xor    %eax,%eax
	if (max_len == 0) {
 804c22b:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
 804c22f:	0f 84 55 05 00 00    	je     804c78a <zsock_recvfrom_ctx+0x58d>
	return (enum net_sock_type)((context->flags & NET_CONTEXT_TYPE) >> 6);
 804c235:	8b 45 b4             	mov    -0x4c(%ebp),%eax
 804c238:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
 804c23e:	89 c2                	mov    %eax,%edx
 804c240:	c1 ea 06             	shr    $0x6,%edx
 804c243:	83 e2 03             	and    $0x3,%edx
	if (sock_type == SOCK_DGRAM) {
 804c246:	83 fa 02             	cmp    $0x2,%edx
 804c249:	0f 85 19 03 00 00    	jne    804c568 <zsock_recvfrom_ctx+0x36b>
	k_timeout_t timeout = K_FOREVER;
 804c24f:	c7 45 b8 ff ff ff ff 	movl   $0xffffffff,-0x48(%ebp)
 804c256:	c7 45 bc ff ff ff ff 	movl   $0xffffffff,-0x44(%ebp)
	if ((flags & ZSOCK_MSG_DONTWAIT) || sock_is_nonblock(ctx)) {
 804c25d:	f6 45 14 40          	testb  $0x40,0x14(%ebp)
 804c261:	75 09                	jne    804c26c <zsock_recvfrom_ctx+0x6f>
 804c263:	8b 45 b4             	mov    -0x4c(%ebp),%eax
 804c266:	f6 40 6c 02          	testb  $0x2,0x6c(%eax)
 804c26a:	74 10                	je     804c27c <zsock_recvfrom_ctx+0x7f>
		timeout = K_NO_WAIT;
 804c26c:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
 804c273:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
	if ((flags & ZSOCK_MSG_DONTWAIT) || sock_is_nonblock(ctx)) {
 804c27a:	eb 24                	jmp    804c2a0 <zsock_recvfrom_ctx+0xa3>
		net_context_get_option(ctx, NET_OPT_RCVTIMEO, &timeout, NULL);
 804c27c:	8d 5d b8             	lea    -0x48(%ebp),%ebx
 804c27f:	6a 00                	push   $0x0
 804c281:	53                   	push   %ebx
 804c282:	6a 04                	push   $0x4
 804c284:	ff 75 b4             	push   -0x4c(%ebp)
 804c287:	e8 38 87 00 00       	call   80549c4 <net_context_get_option>
 804c28c:	58                   	pop    %eax
 804c28d:	5a                   	pop    %edx
		ret = zsock_wait_data(ctx, &timeout);
 804c28e:	53                   	push   %ebx
 804c28f:	ff 75 b4             	push   -0x4c(%ebp)
 804c292:	e8 23 ff ff ff       	call   804c1ba <zsock_wait_data>
 804c297:	83 c4 10             	add    $0x10,%esp
 804c29a:	89 c3                	mov    %eax,%ebx
		if (ret < 0) {
 804c29c:	85 c0                	test   %eax,%eax
 804c29e:	78 4f                	js     804c2ef <zsock_recvfrom_ctx+0xf2>
		res = fifo_wait_non_empty(&ctx->recv_q, timeout);
 804c2a0:	8b 45 b4             	mov    -0x4c(%ebp),%eax
 804c2a3:	8b 5d b8             	mov    -0x48(%ebp),%ebx
 804c2a6:	8b 75 bc             	mov    -0x44(%ebp),%esi
 804c2a9:	8d 50 70             	lea    0x70(%eax),%edx
	if (flags & ZSOCK_MSG_PEEK) {
 804c2ac:	8b 45 14             	mov    0x14(%ebp),%eax
 804c2af:	83 e0 02             	and    $0x2,%eax
 804c2b2:	89 45 a8             	mov    %eax,-0x58(%ebp)
 804c2b5:	74 51                	je     804c308 <zsock_recvfrom_ctx+0x10b>
	struct k_poll_event events[] = {
 804c2b7:	8d 7d d0             	lea    -0x30(%ebp),%edi
 804c2ba:	31 c0                	xor    %eax,%eax
 804c2bc:	b9 04 00 00 00       	mov    $0x4,%ecx
 804c2c1:	89 55 e0             	mov    %edx,-0x20(%ebp)
 804c2c4:	f3 ab                	rep stos %eax,%es:(%edi)
 804c2c6:	89 55 a0             	mov    %edx,-0x60(%ebp)
 804c2c9:	c6 45 dd 04          	movb   $0x4,-0x23(%ebp)
		union { struct { uintptr_t lo, hi; } split; k_timeout_t val; } parm2 = { .val = timeout };
		return (int) arch_syscall_invoke4(parm0.x, parm1.x, parm2.split.lo, parm2.split.hi, K_SYSCALL_K_POLL);
	}
#endif
	compiler_barrier();
	return z_impl_k_poll(events, num_events, timeout);
 804c2cd:	8d 45 d0             	lea    -0x30(%ebp),%eax
 804c2d0:	56                   	push   %esi
 804c2d1:	53                   	push   %ebx
 804c2d2:	6a 01                	push   $0x1
 804c2d4:	50                   	push   %eax
 804c2d5:	e8 be 4c 01 00       	call   8060f98 <z_impl_k_poll>
 804c2da:	83 c4 10             	add    $0x10,%esp
		if (res && res != -EAGAIN && res != -EINTR) {
 804c2dd:	8b 55 a0             	mov    -0x60(%ebp),%edx
 804c2e0:	89 c3                	mov    %eax,%ebx
 804c2e2:	8d 40 04             	lea    0x4(%eax),%eax
 804c2e5:	83 e0 fb             	and    $0xfffffffb,%eax
 804c2e8:	74 13                	je     804c2fd <zsock_recvfrom_ctx+0x100>
 804c2ea:	83 fb f5             	cmp    $0xfffffff5,%ebx
 804c2ed:	74 0e                	je     804c2fd <zsock_recvfrom_ctx+0x100>
			errno = -res;
 804c2ef:	e8 4c cd ff ff       	call   8049040 <__errno_location@plt>
 804c2f4:	f7 db                	neg    %ebx
 804c2f6:	89 18                	mov    %ebx,(%eax)
			return -1;
 804c2f8:	e9 a5 02 00 00       	jmp    804c5a2 <zsock_recvfrom_ctx+0x3a5>
	return z_impl_k_queue_peek_head(queue);
 804c2fd:	83 ec 0c             	sub    $0xc,%esp
 804c300:	52                   	push   %edx
 804c301:	e8 e2 32 01 00       	call   805f5e8 <z_impl_k_queue_peek_head>
 804c306:	eb 09                	jmp    804c311 <zsock_recvfrom_ctx+0x114>
	return z_impl_k_queue_get(queue, timeout);
 804c308:	57                   	push   %edi
 804c309:	56                   	push   %esi
 804c30a:	53                   	push   %ebx
 804c30b:	52                   	push   %edx
 804c30c:	e8 2a 32 01 00       	call   805f53b <z_impl_k_queue_get>
 804c311:	83 c4 10             	add    $0x10,%esp
 804c314:	89 c3                	mov    %eax,%ebx
	if (!pkt) {
 804c316:	85 c0                	test   %eax,%eax
 804c318:	0f 84 87 03 00 00    	je     804c6a5 <zsock_recvfrom_ctx+0x4a8>
 * @param backup The cursor where to backup net_pkt cursor
 */
static inline void net_pkt_cursor_backup(struct net_pkt *pkt,
					 struct net_pkt_cursor *backup)
{
	backup->buf = pkt->cursor.buf;
 804c31e:	8b 40 0c             	mov    0xc(%eax),%eax
	if (src_addr && addrlen) {
 804c321:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
 804c325:	89 45 a0             	mov    %eax,-0x60(%ebp)
	backup->pos = pkt->cursor.pos;
 804c328:	8b 43 10             	mov    0x10(%ebx),%eax
 804c32b:	89 45 9c             	mov    %eax,-0x64(%ebp)
 804c32e:	0f 84 b8 01 00 00    	je     804c4ec <zsock_recvfrom_ctx+0x2ef>
 804c334:	83 7d ac 00          	cmpl   $0x0,-0x54(%ebp)
 804c338:	0f 84 ae 01 00 00    	je     804c4ec <zsock_recvfrom_ctx+0x2ef>
			rv = sock_get_pkt_src_addr(pkt, net_context_get_proto(ctx),
 804c33e:	8b 45 ac             	mov    -0x54(%ebp),%eax
	net_pkt_cursor_init(pkt);
 804c341:	83 ec 0c             	sub    $0xc,%esp
			rv = sock_get_pkt_src_addr(pkt, net_context_get_proto(ctx),
 804c344:	8b 38                	mov    (%eax),%edi
 *
 * @return Network context IP protocol.
 */
static inline uint16_t net_context_get_proto(struct net_context *context)
{
	return context->proto;
 804c346:	8b 45 b4             	mov    -0x4c(%ebp),%eax
 804c349:	66 8b 80 96 00 00 00 	mov    0x96(%eax),%ax
	net_pkt_cursor_init(pkt);
 804c350:	53                   	push   %ebx
 804c351:	66 89 45 b4          	mov    %ax,-0x4c(%ebp)
 804c355:	e8 fa 8b 00 00       	call   8054f54 <net_pkt_cursor_init>
	return pkt->family;
 804c35a:	8a 43 33             	mov    0x33(%ebx),%al
	addr->sa_family = net_pkt_family(pkt);
 804c35d:	8b 4d b0             	mov    -0x50(%ebp),%ecx
	net_pkt_cursor_init(pkt);
 804c360:	83 c4 10             	add    $0x10,%esp
 804c363:	c0 e8 05             	shr    $0x5,%al
	addr->sa_family = net_pkt_family(pkt);
 804c366:	0f b6 c0             	movzbl %al,%eax
 804c369:	66 89 01             	mov    %ax,(%ecx)
 804c36c:	8a 43 33             	mov    0x33(%ebx),%al
 804c36f:	c0 e8 05             	shr    $0x5,%al
	if (IS_ENABLED(CONFIG_NET_IPV4) &&
 804c372:	3c 01                	cmp    $0x1,%al
 804c374:	75 70                	jne    804c3e6 <zsock_recvfrom_ctx+0x1e9>
		NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv4_access,
 804c376:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
			ret = -EINVAL;
 804c37d:	be ea ff ff ff       	mov    $0xffffffea,%esi
		NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv4_access,
 804c382:	c7 45 cc 14 00 00 00 	movl   $0x14,-0x34(%ebp)
		if (addrlen < sizeof(struct sockaddr_in)) {
 804c389:	83 ff 07             	cmp    $0x7,%edi
 804c38c:	0f 86 07 01 00 00    	jbe    804c499 <zsock_recvfrom_ctx+0x29c>
		ipv4_hdr = (struct net_ipv4_hdr *)net_pkt_get_data(
 804c392:	8d 45 c8             	lea    -0x38(%ebp),%eax
 804c395:	51                   	push   %ecx
 804c396:	51                   	push   %ecx
 804c397:	50                   	push   %eax
 804c398:	53                   	push   %ebx
 804c399:	e8 34 95 00 00       	call   80558d2 <net_pkt_get_data>
 804c39e:	83 c4 10             	add    $0x10,%esp
 804c3a1:	89 c6                	mov    %eax,%esi
		if (!ipv4_hdr ||
 804c3a3:	85 c0                	test   %eax,%eax
 804c3a5:	0f 84 df 00 00 00    	je     804c48a <zsock_recvfrom_ctx+0x28d>
 * Packet needs to be set to overwrite mode.
 */
static inline int net_pkt_acknowledge_data(struct net_pkt *pkt,
					   struct net_pkt_data_access *access)
{
	return net_pkt_skip(pkt, access->size);
 804c3ab:	52                   	push   %edx
 804c3ac:	52                   	push   %edx
 804c3ad:	ff 75 cc             	push   -0x34(%ebp)
 804c3b0:	53                   	push   %ebx
 804c3b1:	e8 bb 8f 00 00       	call   8055371 <net_pkt_skip>
 804c3b6:	83 c4 10             	add    $0x10,%esp
 804c3b9:	85 c0                	test   %eax,%eax
 804c3bb:	0f 85 c9 00 00 00    	jne    804c48a <zsock_recvfrom_ctx+0x28d>
		    net_pkt_skip(pkt, net_pkt_ipv4_opts_len(pkt))) {
 804c3c1:	50                   	push   %eax
 804c3c2:	50                   	push   %eax
 804c3c3:	0f b6 43 36          	movzbl 0x36(%ebx),%eax
 804c3c7:	50                   	push   %eax
 804c3c8:	53                   	push   %ebx
 804c3c9:	e8 a3 8f 00 00       	call   8055371 <net_pkt_skip>
 804c3ce:	83 c4 10             	add    $0x10,%esp
		    net_pkt_acknowledge_data(pkt, &ipv4_access) ||
 804c3d1:	85 c0                	test   %eax,%eax
 804c3d3:	0f 85 b1 00 00 00    	jne    804c48a <zsock_recvfrom_ctx+0x28d>
 *  @param src Source IP address.
 */
static inline void net_ipv4_addr_copy_raw(uint8_t *dest,
					  const uint8_t *src)
{
	net_ipaddr_copy((struct in_addr *)dest, (const struct in_addr *)src);
 804c3d9:	8b 46 0c             	mov    0xc(%esi),%eax
 804c3dc:	8b 4d b0             	mov    -0x50(%ebp),%ecx
 804c3df:	89 41 04             	mov    %eax,0x4(%ecx)
		port = &addr4->sin_port;
 804c3e2:	89 c8                	mov    %ecx,%eax
 804c3e4:	eb 7a                	jmp    804c460 <zsock_recvfrom_ctx+0x263>
	} else if (IS_ENABLED(CONFIG_NET_IPV6) &&
 804c3e6:	3c 02                	cmp    $0x2,%al
 804c3e8:	74 0a                	je     804c3f4 <zsock_recvfrom_ctx+0x1f7>
		ret = -ENOTSUP;
 804c3ea:	be a1 ff ff ff       	mov    $0xffffffa1,%esi
 804c3ef:	e9 a5 00 00 00       	jmp    804c499 <zsock_recvfrom_ctx+0x29c>
		NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv6_access,
 804c3f4:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
			ret = -EINVAL;
 804c3fb:	be ea ff ff ff       	mov    $0xffffffea,%esi
		NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv6_access,
 804c400:	c7 45 cc 28 00 00 00 	movl   $0x28,-0x34(%ebp)
		if (addrlen < sizeof(struct sockaddr_in6)) {
 804c407:	83 ff 17             	cmp    $0x17,%edi
 804c40a:	0f 86 89 00 00 00    	jbe    804c499 <zsock_recvfrom_ctx+0x29c>
		ipv6_hdr = (struct net_ipv6_hdr *)net_pkt_get_data(
 804c410:	50                   	push   %eax
 804c411:	50                   	push   %eax
 804c412:	8d 45 c8             	lea    -0x38(%ebp),%eax
 804c415:	50                   	push   %eax
 804c416:	53                   	push   %ebx
 804c417:	e8 b6 94 00 00       	call   80558d2 <net_pkt_get_data>
 804c41c:	83 c4 10             	add    $0x10,%esp
 804c41f:	89 c6                	mov    %eax,%esi
		if (!ipv6_hdr ||
 804c421:	85 c0                	test   %eax,%eax
 804c423:	74 65                	je     804c48a <zsock_recvfrom_ctx+0x28d>
 804c425:	50                   	push   %eax
 804c426:	50                   	push   %eax
 804c427:	ff 75 cc             	push   -0x34(%ebp)
 804c42a:	53                   	push   %ebx
 804c42b:	e8 41 8f 00 00       	call   8055371 <net_pkt_skip>
 804c430:	83 c4 10             	add    $0x10,%esp
 804c433:	85 c0                	test   %eax,%eax
 804c435:	75 53                	jne    804c48a <zsock_recvfrom_ctx+0x28d>
		    net_pkt_skip(pkt, net_pkt_ipv6_ext_len(pkt))) {
 804c437:	50                   	push   %eax
 804c438:	50                   	push   %eax
 804c439:	0f b7 43 36          	movzwl 0x36(%ebx),%eax
 804c43d:	50                   	push   %eax
 804c43e:	53                   	push   %ebx
 804c43f:	e8 2d 8f 00 00       	call   8055371 <net_pkt_skip>
 804c444:	83 c4 10             	add    $0x10,%esp
		    net_pkt_acknowledge_data(pkt, &ipv6_access) ||
 804c447:	85 c0                	test   %eax,%eax
 804c449:	75 3f                	jne    804c48a <zsock_recvfrom_ctx+0x28d>
 804c44b:	8b 45 b0             	mov    -0x50(%ebp),%eax
 804c44e:	83 c6 08             	add    $0x8,%esi
 804c451:	b9 04 00 00 00       	mov    $0x4,%ecx
 804c456:	83 c0 04             	add    $0x4,%eax
 804c459:	89 c7                	mov    %eax,%edi
		port = &addr6->sin6_port;
 804c45b:	8b 45 b0             	mov    -0x50(%ebp),%eax
 804c45e:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	if (IS_ENABLED(CONFIG_NET_UDP) && proto == IPPROTO_UDP) {
 804c460:	66 83 7d b4 11       	cmpw   $0x11,-0x4c(%ebp)
		port = &addr6->sin6_port;
 804c465:	8d 70 02             	lea    0x2(%eax),%esi
	if (IS_ENABLED(CONFIG_NET_UDP) && proto == IPPROTO_UDP) {
 804c468:	75 80                	jne    804c3ea <zsock_recvfrom_ctx+0x1ed>
		NET_PKT_DATA_ACCESS_DEFINE(udp_access, struct net_udp_hdr);
 804c46a:	8d 45 c8             	lea    -0x38(%ebp),%eax
 804c46d:	c7 45 c4 08 00 00 00 	movl   $0x8,-0x3c(%ebp)
 804c474:	89 45 c0             	mov    %eax,-0x40(%ebp)
		udp_hdr = (struct net_udp_hdr *)net_pkt_get_data(pkt,
 804c477:	50                   	push   %eax
 804c478:	50                   	push   %eax
 804c479:	8d 45 c0             	lea    -0x40(%ebp),%eax
 804c47c:	50                   	push   %eax
 804c47d:	53                   	push   %ebx
 804c47e:	e8 4f 94 00 00       	call   80558d2 <net_pkt_get_data>
 804c483:	83 c4 10             	add    $0x10,%esp
		if (!udp_hdr) {
 804c486:	85 c0                	test   %eax,%eax
 804c488:	75 07                	jne    804c491 <zsock_recvfrom_ctx+0x294>
			ret = -ENOBUFS;
 804c48a:	be 97 ff ff ff       	mov    $0xffffff97,%esi
 804c48f:	eb 08                	jmp    804c499 <zsock_recvfrom_ctx+0x29c>
		*port = udp_hdr->src_port;
 804c491:	66 8b 00             	mov    (%eax),%ax
 804c494:	66 89 06             	mov    %ax,(%esi)
	int ret = 0;
 804c497:	31 f6                	xor    %esi,%esi
	pkt->cursor.buf = backup->buf;
 804c499:	8b 45 a0             	mov    -0x60(%ebp),%eax
 804c49c:	89 43 0c             	mov    %eax,0xc(%ebx)
	pkt->cursor.pos = backup->pos;
 804c49f:	8b 45 9c             	mov    -0x64(%ebp),%eax
 804c4a2:	89 43 10             	mov    %eax,0x10(%ebx)
			if (rv < 0) {
 804c4a5:	85 f6                	test   %esi,%esi
 804c4a7:	74 0e                	je     804c4b7 <zsock_recvfrom_ctx+0x2ba>
				errno = -rv;
 804c4a9:	e8 92 cb ff ff       	call   8049040 <__errno_location@plt>
 804c4ae:	f7 de                	neg    %esi
 804c4b0:	89 30                	mov    %esi,(%eax)
				goto fail;
 804c4b2:	e9 96 00 00 00       	jmp    804c54d <zsock_recvfrom_ctx+0x350>
		if (src_addr->sa_family == AF_INET) {
 804c4b7:	8b 45 b0             	mov    -0x50(%ebp),%eax
 804c4ba:	66 8b 00             	mov    (%eax),%ax
 804c4bd:	66 83 f8 01          	cmp    $0x1,%ax
 804c4c1:	75 0b                	jne    804c4ce <zsock_recvfrom_ctx+0x2d1>
			*addrlen = sizeof(struct sockaddr_in);
 804c4c3:	8b 45 ac             	mov    -0x54(%ebp),%eax
 804c4c6:	c7 00 08 00 00 00    	movl   $0x8,(%eax)
 804c4cc:	eb 1e                	jmp    804c4ec <zsock_recvfrom_ctx+0x2ef>
		} else if (src_addr->sa_family == AF_INET6) {
 804c4ce:	66 83 f8 02          	cmp    $0x2,%ax
 804c4d2:	75 0b                	jne    804c4df <zsock_recvfrom_ctx+0x2e2>
			*addrlen = sizeof(struct sockaddr_in6);
 804c4d4:	8b 45 ac             	mov    -0x54(%ebp),%eax
 804c4d7:	c7 00 18 00 00 00    	movl   $0x18,(%eax)
 804c4dd:	eb 0d                	jmp    804c4ec <zsock_recvfrom_ctx+0x2ef>
			errno = ENOTSUP;
 804c4df:	e8 5c cb ff ff       	call   8049040 <__errno_location@plt>
 804c4e4:	c7 00 5f 00 00 00    	movl   $0x5f,(%eax)
			goto fail;
 804c4ea:	eb 61                	jmp    804c54d <zsock_recvfrom_ctx+0x350>
	recv_len = net_pkt_remaining_data(pkt);
 804c4ec:	83 ec 0c             	sub    $0xc,%esp
 804c4ef:	53                   	push   %ebx
 804c4f0:	e8 8f 91 00 00       	call   8055684 <net_pkt_remaining_data>
 804c4f5:	83 c4 0c             	add    $0xc,%esp
	read_len = MIN(recv_len, max_len);
 804c4f8:	39 45 10             	cmp    %eax,0x10(%ebp)
 804c4fb:	89 c6                	mov    %eax,%esi
 804c4fd:	0f 46 75 10          	cmovbe 0x10(%ebp),%esi
	recv_len = net_pkt_remaining_data(pkt);
 804c501:	89 c7                	mov    %eax,%edi
	if (net_pkt_read(pkt, buf, read_len)) {
 804c503:	56                   	push   %esi
 804c504:	ff 75 98             	push   -0x68(%ebp)
 804c507:	53                   	push   %ebx
 804c508:	e8 0d 90 00 00       	call   805551a <net_pkt_read>
 804c50d:	83 c4 10             	add    $0x10,%esp
 804c510:	85 c0                	test   %eax,%eax
 804c512:	74 0d                	je     804c521 <zsock_recvfrom_ctx+0x324>
		errno = ENOBUFS;
 804c514:	e8 27 cb ff ff       	call   8049040 <__errno_location@plt>
 804c519:	c7 00 69 00 00 00    	movl   $0x69,(%eax)
		goto fail;
 804c51f:	eb 2c                	jmp    804c54d <zsock_recvfrom_ctx+0x350>
	if (!(flags & ZSOCK_MSG_PEEK)) {
 804c521:	83 7d a8 00          	cmpl   $0x0,-0x58(%ebp)
 804c525:	75 0e                	jne    804c535 <zsock_recvfrom_ctx+0x338>
		net_pkt_unref(pkt);
 804c527:	83 ec 0c             	sub    $0xc,%esp
 804c52a:	53                   	push   %ebx
 804c52b:	e8 b8 88 00 00       	call   8054de8 <net_pkt_unref>
 804c530:	83 c4 10             	add    $0x10,%esp
 804c533:	eb 0c                	jmp    804c541 <zsock_recvfrom_ctx+0x344>
	pkt->cursor.buf = backup->buf;
 804c535:	8b 45 a0             	mov    -0x60(%ebp),%eax
 804c538:	89 43 0c             	mov    %eax,0xc(%ebx)
	pkt->cursor.pos = backup->pos;
 804c53b:	8b 45 9c             	mov    -0x64(%ebp),%eax
 804c53e:	89 43 10             	mov    %eax,0x10(%ebx)
	return (flags & ZSOCK_MSG_TRUNC) ? recv_len : read_len;
 804c541:	f6 45 14 20          	testb  $0x20,0x14(%ebp)
 804c545:	0f 45 f7             	cmovne %edi,%esi
 804c548:	e9 3d 02 00 00       	jmp    804c78a <zsock_recvfrom_ctx+0x58d>
	return -1;
 804c54d:	83 ce ff             	or     $0xffffffff,%esi
	if (!(flags & ZSOCK_MSG_PEEK)) {
 804c550:	83 7d a8 00          	cmpl   $0x0,-0x58(%ebp)
 804c554:	0f 85 30 02 00 00    	jne    804c78a <zsock_recvfrom_ctx+0x58d>
		net_pkt_unref(pkt);
 804c55a:	83 ec 0c             	sub    $0xc,%esp
 804c55d:	53                   	push   %ebx
 804c55e:	e8 85 88 00 00       	call   8054de8 <net_pkt_unref>
 804c563:	e9 1f 02 00 00       	jmp    804c787 <zsock_recvfrom_ctx+0x58a>
		return 0;
 804c568:	31 f6                	xor    %esi,%esi
	} else if (sock_type == SOCK_STREAM) {
 804c56a:	4a                   	dec    %edx
 804c56b:	0f 85 19 02 00 00    	jne    804c78a <zsock_recvfrom_ctx+0x58d>
	const bool waitall = flags & ZSOCK_MSG_WAITALL;
 804c571:	8b 55 14             	mov    0x14(%ebp),%edx
	k_timeout_t timeout = K_FOREVER;
 804c574:	c7 45 c8 ff ff ff ff 	movl   $0xffffffff,-0x38(%ebp)
 804c57b:	c7 45 cc ff ff ff ff 	movl   $0xffffffff,-0x34(%ebp)
	const bool waitall = flags & ZSOCK_MSG_WAITALL;
 804c582:	c1 ea 08             	shr    $0x8,%edx
 804c585:	89 d1                	mov    %edx,%ecx
 804c587:	83 e1 01             	and    $0x1,%ecx
 804c58a:	88 4d b0             	mov    %cl,-0x50(%ebp)
	if (!net_context_is_used(ctx)) {
 804c58d:	89 c1                	mov    %eax,%ecx
 804c58f:	80 e1 01             	and    $0x1,%cl
 804c592:	88 4d a8             	mov    %cl,-0x58(%ebp)
 804c595:	75 13                	jne    804c5aa <zsock_recvfrom_ctx+0x3ad>
		errno = EBADF;
 804c597:	e8 a4 ca ff ff       	call   8049040 <__errno_location@plt>
 804c59c:	c7 00 09 00 00 00    	movl   $0x9,(%eax)
		return -1;
 804c5a2:	83 ce ff             	or     $0xffffffff,%esi
 804c5a5:	e9 e0 01 00 00       	jmp    804c78a <zsock_recvfrom_ctx+0x58d>
		((context->flags >> NET_CONTEXT_STATE_SHIFT) &
 804c5aa:	66 d1 e8             	shr    %ax
	if (net_context_get_state(ctx) != NET_CONTEXT_CONNECTED) {
 804c5ad:	83 e0 03             	and    $0x3,%eax
 804c5b0:	66 83 f8 02          	cmp    $0x2,%ax
 804c5b4:	74 0d                	je     804c5c3 <zsock_recvfrom_ctx+0x3c6>
		errno = ENOTCONN;
 804c5b6:	e8 85 ca ff ff       	call   8049040 <__errno_location@plt>
 804c5bb:	c7 00 6b 00 00 00    	movl   $0x6b,(%eax)
		return -1;
 804c5c1:	eb df                	jmp    804c5a2 <zsock_recvfrom_ctx+0x3a5>
	if ((flags & ZSOCK_MSG_DONTWAIT) || sock_is_nonblock(ctx)) {
 804c5c3:	f6 45 14 40          	testb  $0x40,0x14(%ebp)
 804c5c7:	75 0a                	jne    804c5d3 <zsock_recvfrom_ctx+0x3d6>
	return POINTER_TO_UINT(ctx->socket_data) & mask;
 804c5c9:	8b 45 b4             	mov    -0x4c(%ebp),%eax
 804c5cc:	8b 40 6c             	mov    0x6c(%eax),%eax
 804c5cf:	a8 02                	test   $0x2,%al
 804c5d1:	74 10                	je     804c5e3 <zsock_recvfrom_ctx+0x3e6>
		timeout = K_NO_WAIT;
 804c5d3:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
 804c5da:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
	if ((flags & ZSOCK_MSG_DONTWAIT) || sock_is_nonblock(ctx)) {
 804c5e1:	eb 17                	jmp    804c5fa <zsock_recvfrom_ctx+0x3fd>
	} else if (!sock_is_eof(ctx) && !sock_is_error(ctx)) {
 804c5e3:	a8 05                	test   $0x5,%al
 804c5e5:	75 13                	jne    804c5fa <zsock_recvfrom_ctx+0x3fd>
		net_context_get_option(ctx, NET_OPT_RCVTIMEO, &timeout, NULL);
 804c5e7:	8d 45 c8             	lea    -0x38(%ebp),%eax
 804c5ea:	6a 00                	push   $0x0
 804c5ec:	50                   	push   %eax
 804c5ed:	6a 04                	push   $0x4
 804c5ef:	ff 75 b4             	push   -0x4c(%ebp)
 804c5f2:	e8 cd 83 00 00       	call   80549c4 <net_context_get_option>
 804c5f7:	83 c4 10             	add    $0x10,%esp
	end = sys_clock_timeout_end_calc(timeout);
 804c5fa:	57                   	push   %edi
	size_t recv_len = 0;
 804c5fb:	31 db                	xor    %ebx,%ebx
	end = sys_clock_timeout_end_calc(timeout);
 804c5fd:	57                   	push   %edi
 804c5fe:	ff 75 cc             	push   -0x34(%ebp)
 804c601:	ff 75 c8             	push   -0x38(%ebp)
 804c604:	e8 10 46 01 00       	call   8060c19 <sys_clock_timeout_end_calc>
 804c609:	83 c4 10             	add    $0x10,%esp
 804c60c:	89 45 a0             	mov    %eax,-0x60(%ebp)
 804c60f:	89 55 a4             	mov    %edx,-0x5c(%ebp)
 804c612:	8b 45 b4             	mov    -0x4c(%ebp),%eax
 804c615:	8b 40 6c             	mov    0x6c(%eax),%eax
		if (sock_is_error(ctx)) {
 804c618:	a8 04                	test   $0x4,%al
 804c61a:	75 6f                	jne    804c68b <zsock_recvfrom_ctx+0x48e>
		if (sock_is_eof(ctx)) {
 804c61c:	a8 01                	test   $0x1,%al
 804c61e:	74 07                	je     804c627 <zsock_recvfrom_ctx+0x42a>
			return 0;
 804c620:	31 f6                	xor    %esi,%esi
 804c622:	e9 63 01 00 00       	jmp    804c78a <zsock_recvfrom_ctx+0x58d>
		if (!K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
 804c627:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804c62a:	0b 45 c8             	or     -0x38(%ebp),%eax
 804c62d:	74 25                	je     804c654 <zsock_recvfrom_ctx+0x457>
			res = zsock_wait_data(ctx, &timeout);
 804c62f:	8d 45 c8             	lea    -0x38(%ebp),%eax
 804c632:	56                   	push   %esi
 804c633:	56                   	push   %esi
 804c634:	50                   	push   %eax
 804c635:	ff 75 b4             	push   -0x4c(%ebp)
 804c638:	e8 7d fb ff ff       	call   804c1ba <zsock_wait_data>
 804c63d:	83 c4 10             	add    $0x10,%esp
 804c640:	89 c6                	mov    %eax,%esi
			if (res < 0) {
 804c642:	85 c0                	test   %eax,%eax
 804c644:	79 0e                	jns    804c654 <zsock_recvfrom_ctx+0x457>
				errno = -res;
 804c646:	e8 f5 c9 ff ff       	call   8049040 <__errno_location@plt>
 804c64b:	f7 de                	neg    %esi
 804c64d:	89 30                	mov    %esi,(%eax)
				return -1;
 804c64f:	e9 4e ff ff ff       	jmp    804c5a2 <zsock_recvfrom_ctx+0x3a5>
		pkt = k_fifo_peek_head(&ctx->recv_q);
 804c654:	8b 45 b4             	mov    -0x4c(%ebp),%eax
 804c657:	83 c0 70             	add    $0x70,%eax
 804c65a:	89 45 ac             	mov    %eax,-0x54(%ebp)
	return z_impl_k_queue_peek_head(queue);
 804c65d:	83 ec 0c             	sub    $0xc,%esp
 804c660:	ff 75 ac             	push   -0x54(%ebp)
 804c663:	e8 80 2f 01 00       	call   805f5e8 <z_impl_k_queue_peek_head>
 804c668:	83 c4 10             	add    $0x10,%esp
 804c66b:	89 c6                	mov    %eax,%esi
		if (!pkt) {
 804c66d:	85 c0                	test   %eax,%eax
 804c66f:	75 44                	jne    804c6b5 <zsock_recvfrom_ctx+0x4b8>
			if (waitall && (recv_len > 0)) {
 804c671:	85 db                	test   %ebx,%ebx
 804c673:	74 0c                	je     804c681 <zsock_recvfrom_ctx+0x484>
 804c675:	80 7d b0 00          	cmpb   $0x0,-0x50(%ebp)
				return recv_len;
 804c679:	89 de                	mov    %ebx,%esi
			if (waitall && (recv_len > 0)) {
 804c67b:	0f 85 09 01 00 00    	jne    804c78a <zsock_recvfrom_ctx+0x58d>
 804c681:	8b 45 b4             	mov    -0x4c(%ebp),%eax
 804c684:	8b 40 6c             	mov    0x6c(%eax),%eax
			} else if (sock_is_error(ctx)) {
 804c687:	a8 04                	test   $0x4,%al
 804c689:	74 12                	je     804c69d <zsock_recvfrom_ctx+0x4a0>
				errno = POINTER_TO_INT(ctx->user_data);
 804c68b:	e8 b0 c9 ff ff       	call   8049040 <__errno_location@plt>
 804c690:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
 804c693:	8b 51 04             	mov    0x4(%ecx),%edx
 804c696:	89 10                	mov    %edx,(%eax)
				return -1;
 804c698:	e9 05 ff ff ff       	jmp    804c5a2 <zsock_recvfrom_ctx+0x3a5>
			} else if (sock_is_eof(ctx)) {
 804c69d:	a8 01                	test   $0x1,%al
 804c69f:	0f 85 7b ff ff ff    	jne    804c620 <zsock_recvfrom_ctx+0x423>
				errno = EAGAIN;
 804c6a5:	e8 96 c9 ff ff       	call   8049040 <__errno_location@plt>
 804c6aa:	c7 00 0b 00 00 00    	movl   $0xb,(%eax)
				return -1;
 804c6b0:	e9 ed fe ff ff       	jmp    804c5a2 <zsock_recvfrom_ctx+0x3a5>
	backup->buf = pkt->cursor.buf;
 804c6b5:	8b 40 0c             	mov    0xc(%eax),%eax
		data_len = net_pkt_remaining_data(pkt);
 804c6b8:	83 ec 0c             	sub    $0xc,%esp
 804c6bb:	89 45 9c             	mov    %eax,-0x64(%ebp)
	backup->pos = pkt->cursor.pos;
 804c6be:	8b 46 10             	mov    0x10(%esi),%eax
 804c6c1:	56                   	push   %esi
 804c6c2:	89 45 94             	mov    %eax,-0x6c(%ebp)
 804c6c5:	e8 ba 8f 00 00       	call   8055684 <net_pkt_remaining_data>
		bool release_pkt = true;
 804c6ca:	8a 55 a8             	mov    -0x58(%ebp),%dl
		data_len = net_pkt_remaining_data(pkt);
 804c6cd:	83 c4 10             	add    $0x10,%esp
 804c6d0:	89 c7                	mov    %eax,%edi
		if (recv_len + read_len > max_len) {
 804c6d2:	8d 04 18             	lea    (%eax,%ebx,1),%eax
 804c6d5:	39 45 10             	cmp    %eax,0x10(%ebp)
 804c6d8:	73 07                	jae    804c6e1 <zsock_recvfrom_ctx+0x4e4>
			read_len = max_len - recv_len;
 804c6da:	8b 7d 10             	mov    0x10(%ebp),%edi
			release_pkt = false;
 804c6dd:	31 d2                	xor    %edx,%edx
			read_len = max_len - recv_len;
 804c6df:	29 df                	sub    %ebx,%edi
		if (net_pkt_read(pkt, (uint8_t *)buf + recv_len, read_len)) {
 804c6e1:	8b 45 98             	mov    -0x68(%ebp),%eax
 804c6e4:	51                   	push   %ecx
 804c6e5:	57                   	push   %edi
 804c6e6:	01 d8                	add    %ebx,%eax
 804c6e8:	88 55 93             	mov    %dl,-0x6d(%ebp)
 804c6eb:	50                   	push   %eax
 804c6ec:	56                   	push   %esi
 804c6ed:	e8 28 8e 00 00       	call   805551a <net_pkt_read>
 804c6f2:	83 c4 10             	add    $0x10,%esp
 804c6f5:	8a 55 93             	mov    -0x6d(%ebp),%dl
 804c6f8:	85 c0                	test   %eax,%eax
 804c6fa:	74 10                	je     804c70c <zsock_recvfrom_ctx+0x50f>
			errno = ENOBUFS;
 804c6fc:	e8 3f c9 ff ff       	call   8049040 <__errno_location@plt>
 804c701:	c7 00 69 00 00 00    	movl   $0x69,(%eax)
			return -1;
 804c707:	e9 96 fe ff ff       	jmp    804c5a2 <zsock_recvfrom_ctx+0x3a5>
		recv_len += read_len;
 804c70c:	01 fb                	add    %edi,%ebx
		if (!(flags & ZSOCK_MSG_PEEK)) {
 804c70e:	8b 7d 14             	mov    0x14(%ebp),%edi
 804c711:	83 e7 02             	and    $0x2,%edi
 804c714:	75 2f                	jne    804c745 <zsock_recvfrom_ctx+0x548>
			if (release_pkt) {
 804c716:	84 d2                	test   %dl,%dl
 804c718:	74 37                	je     804c751 <zsock_recvfrom_ctx+0x554>
	return z_impl_k_queue_get(queue, timeout);
 804c71a:	52                   	push   %edx
 804c71b:	6a 00                	push   $0x0
 804c71d:	6a 00                	push   $0x0
 804c71f:	ff 75 ac             	push   -0x54(%ebp)
 804c722:	e8 14 2e 01 00       	call   805f53b <z_impl_k_queue_get>
 804c727:	83 c4 10             	add    $0x10,%esp
				if (net_pkt_eof(pkt)) {
 804c72a:	f6 46 33 02          	testb  $0x2,0x33(%esi)
 804c72e:	74 07                	je     804c737 <zsock_recvfrom_ctx+0x53a>
	val = (val & ~mask) | flag;
 804c730:	8b 45 b4             	mov    -0x4c(%ebp),%eax
 804c733:	83 48 6c 01          	orl    $0x1,0x6c(%eax)
				net_pkt_unref(pkt);
 804c737:	83 ec 0c             	sub    $0xc,%esp
 804c73a:	56                   	push   %esi
 804c73b:	e8 a8 86 00 00       	call   8054de8 <net_pkt_unref>
 804c740:	83 c4 10             	add    $0x10,%esp
 804c743:	eb 0c                	jmp    804c751 <zsock_recvfrom_ctx+0x554>
	pkt->cursor.buf = backup->buf;
 804c745:	8b 45 9c             	mov    -0x64(%ebp),%eax
 804c748:	89 46 0c             	mov    %eax,0xc(%esi)
	pkt->cursor.pos = backup->pos;
 804c74b:	8b 45 94             	mov    -0x6c(%ebp),%eax
 804c74e:	89 46 10             	mov    %eax,0x10(%esi)
		timeout_recalc(end, &timeout);
 804c751:	8b 45 a0             	mov    -0x60(%ebp),%eax
 804c754:	8b 55 a4             	mov    -0x5c(%ebp),%edx
 804c757:	8d 4d c8             	lea    -0x38(%ebp),%ecx
 804c75a:	e8 98 ed ff ff       	call   804b4f7 <timeout_recalc>
	} while ((recv_len == 0) || (waitall && (recv_len < max_len)));
 804c75f:	85 db                	test   %ebx,%ebx
 804c761:	0f 84 ab fe ff ff    	je     804c612 <zsock_recvfrom_ctx+0x415>
 804c767:	39 5d 10             	cmp    %ebx,0x10(%ebp)
 804c76a:	76 0a                	jbe    804c776 <zsock_recvfrom_ctx+0x579>
 804c76c:	80 7d b0 00          	cmpb   $0x0,-0x50(%ebp)
 804c770:	0f 85 9c fe ff ff    	jne    804c612 <zsock_recvfrom_ctx+0x415>
		net_context_update_recv_wnd(ctx, recv_len);
 804c776:	89 de                	mov    %ebx,%esi
	if (!(flags & ZSOCK_MSG_PEEK)) {
 804c778:	85 ff                	test   %edi,%edi
 804c77a:	75 0e                	jne    804c78a <zsock_recvfrom_ctx+0x58d>
		net_context_update_recv_wnd(ctx, recv_len);
 804c77c:	50                   	push   %eax
 804c77d:	50                   	push   %eax
 804c77e:	53                   	push   %ebx
 804c77f:	ff 75 b4             	push   -0x4c(%ebp)
 804c782:	e8 96 81 00 00       	call   805491d <net_context_update_recv_wnd>
 804c787:	83 c4 10             	add    $0x10,%esp
}
 804c78a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804c78d:	65 2b 05 14 00 00 00 	sub    %gs:0x14,%eax
 804c794:	74 05                	je     804c79b <zsock_recvfrom_ctx+0x59e>
 804c796:	e8 65 cb ff ff       	call   8049300 <__stack_chk_fail@plt>
 804c79b:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804c79e:	89 f0                	mov    %esi,%eax
 804c7a0:	5b                   	pop    %ebx
 804c7a1:	5e                   	pop    %esi
 804c7a2:	5f                   	pop    %edi
 804c7a3:	5d                   	pop    %ebp
 804c7a4:	c3                   	ret    

0804c7a5 <sock_recvfrom_vmeth>:
	return zsock_recvfrom_ctx(obj, buf, max_len, flags,
 804c7a5:	e9 53 fa ff ff       	jmp    804c1fd <zsock_recvfrom_ctx>

0804c7aa <sock_read_vmeth>:
{
 804c7aa:	55                   	push   %ebp
 804c7ab:	89 e5                	mov    %esp,%ebp
 804c7ad:	83 ec 10             	sub    $0x10,%esp
	return zsock_recvfrom_ctx(obj, buffer, count, 0, NULL, 0);
 804c7b0:	6a 00                	push   $0x0
 804c7b2:	6a 00                	push   $0x0
 804c7b4:	6a 00                	push   $0x0
 804c7b6:	ff 75 10             	push   0x10(%ebp)
 804c7b9:	ff 75 0c             	push   0xc(%ebp)
 804c7bc:	ff 75 08             	push   0x8(%ebp)
 804c7bf:	e8 39 fa ff ff       	call   804c1fd <zsock_recvfrom_ctx>
 804c7c4:	83 c4 20             	add    $0x20,%esp
}
 804c7c7:	c9                   	leave  
 804c7c8:	c3                   	ret    

0804c7c9 <z_impl_zsock_recvfrom>:
{
 804c7c9:	55                   	push   %ebp
 804c7ca:	89 e5                	mov    %esp,%ebp
 804c7cc:	57                   	push   %edi
 804c7cd:	56                   	push   %esi
 804c7ce:	53                   	push   %ebx
 804c7cf:	83 ec 30             	sub    $0x30,%esp
 804c7d2:	8b 45 0c             	mov    0xc(%ebp),%eax
 804c7d5:	8b 75 18             	mov    0x18(%ebp),%esi
 804c7d8:	8b 7d 1c             	mov    0x1c(%ebp),%edi
 804c7db:	89 45 d4             	mov    %eax,-0x2c(%ebp)
 804c7de:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 804c7e4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 804c7e7:	31 c0                	xor    %eax,%eax
	ctx = z_get_fd_obj_and_vtable(sock,
 804c7e9:	8d 45 e0             	lea    -0x20(%ebp),%eax
 804c7ec:	50                   	push   %eax
 804c7ed:	8d 45 dc             	lea    -0x24(%ebp),%eax
 804c7f0:	50                   	push   %eax
 804c7f1:	ff 75 08             	push   0x8(%ebp)
 804c7f4:	e8 13 d5 ff ff       	call   8049d0c <z_get_fd_obj_and_vtable>
 804c7f9:	83 c4 10             	add    $0x10,%esp
	VTABLE_CALL(recvfrom, sock, buf, max_len, flags, src_addr, addrlen);
 804c7fc:	85 c0                	test   %eax,%eax
 804c7fe:	75 0d                	jne    804c80d <z_impl_zsock_recvfrom+0x44>
 804c800:	e8 3b c8 ff ff       	call   8049040 <__errno_location@plt>
 804c805:	c7 00 09 00 00 00    	movl   $0x9,(%eax)
 804c80b:	eb 16                	jmp    804c823 <z_impl_zsock_recvfrom+0x5a>
 804c80d:	89 c3                	mov    %eax,%ebx
 804c80f:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804c812:	83 78 28 00          	cmpl   $0x0,0x28(%eax)
 804c816:	75 10                	jne    804c828 <z_impl_zsock_recvfrom+0x5f>
 804c818:	e8 23 c8 ff ff       	call   8049040 <__errno_location@plt>
 804c81d:	c7 00 5f 00 00 00    	movl   $0x5f,(%eax)
 804c823:	83 cb ff             	or     $0xffffffff,%ebx
 804c826:	eb 2e                	jmp    804c856 <z_impl_zsock_recvfrom+0x8d>
 804c828:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804c82b:	83 ca ff             	or     $0xffffffff,%edx
 804c82e:	89 d1                	mov    %edx,%ecx
 804c830:	e8 1e ed ff ff       	call   804b553 <k_mutex_lock.constprop.0.isra.0>
 804c835:	50                   	push   %eax
 804c836:	50                   	push   %eax
 804c837:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804c83a:	57                   	push   %edi
 804c83b:	56                   	push   %esi
 804c83c:	ff 75 14             	push   0x14(%ebp)
 804c83f:	ff 75 10             	push   0x10(%ebp)
 804c842:	ff 75 d4             	push   -0x2c(%ebp)
 804c845:	53                   	push   %ebx
 804c846:	ff 50 28             	call   *0x28(%eax)
 804c849:	89 c3                	mov    %eax,%ebx
 804c84b:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804c84e:	83 c4 20             	add    $0x20,%esp
 804c851:	e8 09 ee ff ff       	call   804b65f <k_mutex_unlock.isra.0>
}
 804c856:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804c859:	65 2b 05 14 00 00 00 	sub    %gs:0x14,%eax
 804c860:	74 05                	je     804c867 <z_impl_zsock_recvfrom+0x9e>
 804c862:	e8 99 ca ff ff       	call   8049300 <__stack_chk_fail@plt>
 804c867:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804c86a:	89 d8                	mov    %ebx,%eax
 804c86c:	5b                   	pop    %ebx
 804c86d:	5e                   	pop    %esi
 804c86e:	5f                   	pop    %edi
 804c86f:	5d                   	pop    %ebp
 804c870:	c3                   	ret    

0804c871 <zsock_poll_internal>:
{
 804c871:	55                   	push   %ebp
 804c872:	89 e5                	mov    %esp,%ebp
 804c874:	57                   	push   %edi
 804c875:	56                   	push   %esi
	const struct fd_op_vtable *offl_vtable = NULL;
 804c876:	31 f6                	xor    %esi,%esi
{
 804c878:	53                   	push   %ebx
 804c879:	81 ec 84 00 00 00    	sub    $0x84,%esp
 804c87f:	8b 45 08             	mov    0x8(%ebp),%eax
 804c882:	89 45 90             	mov    %eax,-0x70(%ebp)
 804c885:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 804c88b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 804c88e:	31 c0                	xor    %eax,%eax
	end = sys_clock_timeout_end_calc(timeout);
 804c890:	ff 75 14             	push   0x14(%ebp)
 804c893:	ff 75 10             	push   0x10(%ebp)
 804c896:	e8 7e 43 01 00       	call   8060c19 <sys_clock_timeout_end_calc>
	bool offload = false;
 804c89b:	c6 45 94 00          	movb   $0x0,-0x6c(%ebp)
	for (pfd = fds, i = nfds; i--; pfd++) {
 804c89f:	8b 7d 90             	mov    -0x70(%ebp),%edi
	end = sys_clock_timeout_end_calc(timeout);
 804c8a2:	83 c4 10             	add    $0x10,%esp
 804c8a5:	89 45 80             	mov    %eax,-0x80(%ebp)
	pev = poll_events;
 804c8a8:	8d 45 a8             	lea    -0x58(%ebp),%eax
 804c8ab:	89 45 9c             	mov    %eax,-0x64(%ebp)
	for (pfd = fds, i = nfds; i--; pfd++) {
 804c8ae:	8b 45 0c             	mov    0xc(%ebp),%eax
	end = sys_clock_timeout_end_calc(timeout);
 804c8b1:	89 55 84             	mov    %edx,-0x7c(%ebp)
	for (pfd = fds, i = nfds; i--; pfd++) {
 804c8b4:	89 45 8c             	mov    %eax,-0x74(%ebp)
	void *offl_ctx = NULL;
 804c8b7:	c7 45 88 00 00 00 00 	movl   $0x0,-0x78(%ebp)
	for (pfd = fds, i = nfds; i--; pfd++) {
 804c8be:	83 7d 8c 00          	cmpl   $0x0,-0x74(%ebp)
 804c8c2:	0f 84 b4 00 00 00    	je     804c97c <zsock_poll_internal+0x10b>
		if (pfd->fd < 0) {
 804c8c8:	8b 07                	mov    (%edi),%eax
 804c8ca:	85 c0                	test   %eax,%eax
 804c8cc:	0f 88 9f 00 00 00    	js     804c971 <zsock_poll_internal+0x100>
	ctx = z_get_fd_obj_and_vtable(sock,
 804c8d2:	52                   	push   %edx
 804c8d3:	8d 55 a4             	lea    -0x5c(%ebp),%edx
 804c8d6:	52                   	push   %edx
 804c8d7:	8d 55 a0             	lea    -0x60(%ebp),%edx
 804c8da:	52                   	push   %edx
 804c8db:	50                   	push   %eax
 804c8dc:	e8 2b d4 ff ff       	call   8049d0c <z_get_fd_obj_and_vtable>
 804c8e1:	83 c4 10             	add    $0x10,%esp
 804c8e4:	89 c3                	mov    %eax,%ebx
		if (ctx == NULL) {
 804c8e6:	85 c0                	test   %eax,%eax
 804c8e8:	0f 84 83 00 00 00    	je     804c971 <zsock_poll_internal+0x100>
		(void)k_mutex_lock(lock, K_FOREVER);
 804c8ee:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 804c8f1:	83 ca ff             	or     $0xffffffff,%edx
 804c8f4:	89 d1                	mov    %edx,%ecx
 804c8f6:	e8 58 ec ff ff       	call   804b553 <k_mutex_lock.constprop.0.isra.0>
		result = z_fdtable_call_ioctl(vtable, ctx,
 804c8fb:	50                   	push   %eax
 804c8fc:	50                   	push   %eax
 804c8fd:	8d 45 e4             	lea    -0x1c(%ebp),%eax
 804c900:	50                   	push   %eax
 804c901:	8d 45 9c             	lea    -0x64(%ebp),%eax
 804c904:	50                   	push   %eax
 804c905:	57                   	push   %edi
 804c906:	68 02 01 00 00       	push   $0x102
 804c90b:	53                   	push   %ebx
 804c90c:	ff 75 a0             	push   -0x60(%ebp)
 804c90f:	e8 91 eb ff ff       	call   804b4a5 <z_fdtable_call_ioctl>
 804c914:	83 c4 20             	add    $0x20,%esp
 804c917:	89 c2                	mov    %eax,%edx
		if (result == -EALREADY) {
 804c919:	83 f8 8e             	cmp    $0xffffff8e,%eax
 804c91c:	75 12                	jne    804c930 <zsock_poll_internal+0xbf>
			timeout = K_NO_WAIT;
 804c91e:	c7 45 10 00 00 00 00 	movl   $0x0,0x10(%ebp)
			result = 0;
 804c925:	31 d2                	xor    %edx,%edx
			timeout = K_NO_WAIT;
 804c927:	c7 45 14 00 00 00 00 	movl   $0x0,0x14(%ebp)
			result = 0;
 804c92e:	eb 15                	jmp    804c945 <zsock_poll_internal+0xd4>
		} else if (result == -EXDEV) {
 804c930:	83 f8 ee             	cmp    $0xffffffee,%eax
 804c933:	75 10                	jne    804c945 <zsock_poll_internal+0xd4>
			if (offl_vtable == NULL || net_socket_is_tls(ctx)) {
 804c935:	85 f6                	test   %esi,%esi
 804c937:	75 06                	jne    804c93f <zsock_poll_internal+0xce>
				offl_vtable = vtable;
 804c939:	89 5d 88             	mov    %ebx,-0x78(%ebp)
 804c93c:	8b 75 a0             	mov    -0x60(%ebp),%esi
			offload = true;
 804c93f:	c6 45 94 01          	movb   $0x1,-0x6c(%ebp)
			result = 0;
 804c943:	31 d2                	xor    %edx,%edx
		k_mutex_unlock(lock);
 804c945:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 804c948:	89 95 7c ff ff ff    	mov    %edx,-0x84(%ebp)
 804c94e:	e8 0c ed ff ff       	call   804b65f <k_mutex_unlock.isra.0>
		if (result < 0) {
 804c953:	8b 95 7c ff ff ff    	mov    -0x84(%ebp),%edx
 804c959:	85 d2                	test   %edx,%edx
 804c95b:	79 14                	jns    804c971 <zsock_poll_internal+0x100>
 804c95d:	89 55 94             	mov    %edx,-0x6c(%ebp)
			errno = -result;
 804c960:	e8 db c6 ff ff       	call   8049040 <__errno_location@plt>
 804c965:	8b 55 94             	mov    -0x6c(%ebp),%edx
 804c968:	f7 da                	neg    %edx
 804c96a:	89 10                	mov    %edx,(%eax)
			return -1;
 804c96c:	e9 98 00 00 00       	jmp    804ca09 <zsock_poll_internal+0x198>
	for (pfd = fds, i = nfds; i--; pfd++) {
 804c971:	ff 4d 8c             	decl   -0x74(%ebp)
 804c974:	83 c7 08             	add    $0x8,%edi
 804c977:	e9 42 ff ff ff       	jmp    804c8be <zsock_poll_internal+0x4d>
	if (offload) {
 804c97c:	80 7d 94 00          	cmpb   $0x0,-0x6c(%ebp)
 804c980:	74 35                	je     804c9b7 <zsock_poll_internal+0x146>
		if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
 804c982:	83 7d 14 ff          	cmpl   $0xffffffff,0x14(%ebp)
 804c986:	8b 55 10             	mov    0x10(%ebp),%edx
 804c989:	75 08                	jne    804c993 <zsock_poll_internal+0x122>
			poll_timeout = SYS_FOREVER_MS;
 804c98b:	83 c8 ff             	or     $0xffffffff,%eax
		if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
 804c98e:	83 fa ff             	cmp    $0xffffffff,%edx
 804c991:	74 03                	je     804c996 <zsock_poll_internal+0x125>
		}
	} else if (mul_ratio) {
		if (result32) {
			return ((uint32_t)t) * (to_hz / from_hz);
 804c993:	6b c2 0a             	imul   $0xa,%edx,%eax
		return z_fdtable_call_ioctl(offl_vtable, offl_ctx,
 804c996:	51                   	push   %ecx
 804c997:	51                   	push   %ecx
 804c998:	50                   	push   %eax
 804c999:	ff 75 0c             	push   0xc(%ebp)
 804c99c:	ff 75 90             	push   -0x70(%ebp)
 804c99f:	68 04 01 00 00       	push   $0x104
 804c9a4:	ff 75 88             	push   -0x78(%ebp)
 804c9a7:	56                   	push   %esi
 804c9a8:	e8 f8 ea ff ff       	call   804b4a5 <z_fdtable_call_ioctl>
 804c9ad:	83 c4 20             	add    $0x20,%esp
 804c9b0:	89 c3                	mov    %eax,%ebx
 804c9b2:	e9 22 01 00 00       	jmp    804cad9 <zsock_poll_internal+0x268>
	timeout_recalc(end, &timeout);
 804c9b7:	8b 45 80             	mov    -0x80(%ebp),%eax
 804c9ba:	8b 55 84             	mov    -0x7c(%ebp),%edx
 804c9bd:	8d 4d 10             	lea    0x10(%ebp),%ecx
 804c9c0:	e8 32 eb ff ff       	call   804b4f7 <timeout_recalc>
		ret = k_poll(poll_events, pev - poll_events, timeout);
 804c9c5:	8b 4d 9c             	mov    -0x64(%ebp),%ecx
 804c9c8:	8d 75 a8             	lea    -0x58(%ebp),%esi
 804c9cb:	8b 45 10             	mov    0x10(%ebp),%eax
 804c9ce:	8b 55 14             	mov    0x14(%ebp),%edx
 804c9d1:	29 f1                	sub    %esi,%ecx
 804c9d3:	c1 f9 02             	sar    $0x2,%ecx
 804c9d6:	69 c9 cd cc cc cc    	imul   $0xcccccccd,%ecx,%ecx
	return z_impl_k_poll(events, num_events, timeout);
 804c9dc:	52                   	push   %edx
 804c9dd:	50                   	push   %eax
 804c9de:	51                   	push   %ecx
 804c9df:	56                   	push   %esi
 804c9e0:	e8 b3 45 01 00       	call   8060f98 <z_impl_k_poll>
 804c9e5:	83 c4 10             	add    $0x10,%esp
 804c9e8:	89 c3                	mov    %eax,%ebx
		if (ret != 0 && ret != -EAGAIN && ret != -EINTR) {
 804c9ea:	8d 40 04             	lea    0x4(%eax),%eax
 804c9ed:	83 e0 fb             	and    $0xfffffffb,%eax
 804c9f0:	0f 95 c2             	setne  %dl
 804c9f3:	83 fb f5             	cmp    $0xfffffff5,%ebx
 804c9f6:	0f 95 c0             	setne  %al
 804c9f9:	20 c2                	and    %al,%dl
 804c9fb:	88 55 94             	mov    %dl,-0x6c(%ebp)
 804c9fe:	74 11                	je     804ca11 <zsock_poll_internal+0x1a0>
			errno = -ret;
 804ca00:	e8 3b c6 ff ff       	call   8049040 <__errno_location@plt>
 804ca05:	f7 db                	neg    %ebx
 804ca07:	89 18                	mov    %ebx,(%eax)
			return -1;
 804ca09:	83 cb ff             	or     $0xffffffff,%ebx
 804ca0c:	e9 c8 00 00 00       	jmp    804cad9 <zsock_poll_internal+0x268>
		for (pfd = fds, i = nfds; i--; pfd++) {
 804ca11:	8b 45 0c             	mov    0xc(%ebp),%eax
		pev = poll_events;
 804ca14:	89 75 9c             	mov    %esi,-0x64(%ebp)
		ret = 0;
 804ca17:	31 db                	xor    %ebx,%ebx
		for (pfd = fds, i = nfds; i--; pfd++) {
 804ca19:	8b 75 90             	mov    -0x70(%ebp),%esi
 804ca1c:	89 45 8c             	mov    %eax,-0x74(%ebp)
 804ca1f:	83 7d 8c 00          	cmpl   $0x0,-0x74(%ebp)
 804ca23:	0f 84 8c 00 00 00    	je     804cab5 <zsock_poll_internal+0x244>
			if (pfd->fd < 0) {
 804ca29:	8b 06                	mov    (%esi),%eax
			pfd->revents = 0;
 804ca2b:	66 c7 46 06 00 00    	movw   $0x0,0x6(%esi)
			if (pfd->fd < 0) {
 804ca31:	85 c0                	test   %eax,%eax
 804ca33:	78 75                	js     804caaa <zsock_poll_internal+0x239>
	ctx = z_get_fd_obj_and_vtable(sock,
 804ca35:	52                   	push   %edx
 804ca36:	8d 55 a4             	lea    -0x5c(%ebp),%edx
 804ca39:	52                   	push   %edx
 804ca3a:	8d 55 a0             	lea    -0x60(%ebp),%edx
 804ca3d:	52                   	push   %edx
 804ca3e:	50                   	push   %eax
 804ca3f:	e8 c8 d2 ff ff       	call   8049d0c <z_get_fd_obj_and_vtable>
 804ca44:	83 c4 10             	add    $0x10,%esp
 804ca47:	89 c7                	mov    %eax,%edi
			if (ctx == NULL) {
 804ca49:	85 c0                	test   %eax,%eax
 804ca4b:	75 08                	jne    804ca55 <zsock_poll_internal+0x1e4>
				pfd->revents = ZSOCK_POLLNVAL;
 804ca4d:	66 c7 46 06 20 00    	movw   $0x20,0x6(%esi)
				ret++;
 804ca53:	eb 4e                	jmp    804caa3 <zsock_poll_internal+0x232>
			(void)k_mutex_lock(lock, K_FOREVER);
 804ca55:	83 ca ff             	or     $0xffffffff,%edx
 804ca58:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 804ca5b:	89 d1                	mov    %edx,%ecx
 804ca5d:	e8 f1 ea ff ff       	call   804b553 <k_mutex_lock.constprop.0.isra.0>
			result = z_fdtable_call_ioctl(vtable, ctx,
 804ca62:	83 ec 0c             	sub    $0xc,%esp
 804ca65:	8d 45 9c             	lea    -0x64(%ebp),%eax
 804ca68:	50                   	push   %eax
 804ca69:	56                   	push   %esi
 804ca6a:	68 03 01 00 00       	push   $0x103
 804ca6f:	57                   	push   %edi
 804ca70:	ff 75 a0             	push   -0x60(%ebp)
 804ca73:	e8 2d ea ff ff       	call   804b4a5 <z_fdtable_call_ioctl>
 804ca78:	83 c4 20             	add    $0x20,%esp
 804ca7b:	89 c7                	mov    %eax,%edi
			k_mutex_unlock(lock);
 804ca7d:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 804ca80:	e8 da eb ff ff       	call   804b65f <k_mutex_unlock.isra.0>
			if (result == -EAGAIN) {
 804ca85:	83 ff f5             	cmp    $0xfffffff5,%edi
 804ca88:	74 1c                	je     804caa6 <zsock_poll_internal+0x235>
			} else if (result != 0) {
 804ca8a:	85 ff                	test   %edi,%edi
 804ca8c:	74 0e                	je     804ca9c <zsock_poll_internal+0x22b>
				errno = -result;
 804ca8e:	e8 ad c5 ff ff       	call   8049040 <__errno_location@plt>
 804ca93:	f7 df                	neg    %edi
 804ca95:	89 38                	mov    %edi,(%eax)
				return -1;
 804ca97:	e9 6d ff ff ff       	jmp    804ca09 <zsock_poll_internal+0x198>
			if (pfd->revents != 0) {
 804ca9c:	66 83 7e 06 00       	cmpw   $0x0,0x6(%esi)
 804caa1:	74 07                	je     804caaa <zsock_poll_internal+0x239>
				ret++;
 804caa3:	43                   	inc    %ebx
 804caa4:	eb 04                	jmp    804caaa <zsock_poll_internal+0x239>
				retry = true;
 804caa6:	c6 45 94 01          	movb   $0x1,-0x6c(%ebp)
		for (pfd = fds, i = nfds; i--; pfd++) {
 804caaa:	ff 4d 8c             	decl   -0x74(%ebp)
 804caad:	83 c6 08             	add    $0x8,%esi
 804cab0:	e9 6a ff ff ff       	jmp    804ca1f <zsock_poll_internal+0x1ae>
			if (ret > 0) {
 804cab5:	85 db                	test   %ebx,%ebx
 804cab7:	75 20                	jne    804cad9 <zsock_poll_internal+0x268>
 804cab9:	80 7d 94 00          	cmpb   $0x0,-0x6c(%ebp)
 804cabd:	74 1a                	je     804cad9 <zsock_poll_internal+0x268>
			timeout_recalc(end, &timeout);
 804cabf:	8b 45 80             	mov    -0x80(%ebp),%eax
 804cac2:	8b 55 84             	mov    -0x7c(%ebp),%edx
 804cac5:	8d 4d 10             	lea    0x10(%ebp),%ecx
 804cac8:	e8 2a ea ff ff       	call   804b4f7 <timeout_recalc>
			if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
 804cacd:	8b 45 14             	mov    0x14(%ebp),%eax
 804cad0:	0b 45 10             	or     0x10(%ebp),%eax
 804cad3:	0f 85 ec fe ff ff    	jne    804c9c5 <zsock_poll_internal+0x154>
}
 804cad9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804cadc:	65 2b 05 14 00 00 00 	sub    %gs:0x14,%eax
 804cae3:	74 05                	je     804caea <zsock_poll_internal+0x279>
 804cae5:	e8 16 c8 ff ff       	call   8049300 <__stack_chk_fail@plt>
 804caea:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804caed:	89 d8                	mov    %ebx,%eax
 804caef:	5b                   	pop    %ebx
 804caf0:	5e                   	pop    %esi
 804caf1:	5f                   	pop    %edi
 804caf2:	5d                   	pop    %ebp
 804caf3:	c3                   	ret    

0804caf4 <z_impl_zsock_poll>:
{
 804caf4:	55                   	push   %ebp
 804caf5:	89 e5                	mov    %esp,%ebp
 804caf7:	53                   	push   %ebx
 804caf8:	50                   	push   %eax
 804caf9:	8b 45 10             	mov    0x10(%ebp),%eax
	if (poll_timeout < 0) {
 804cafc:	85 c0                	test   %eax,%eax
 804cafe:	78 1b                	js     804cb1b <z_impl_zsock_poll+0x27>
		timeout = K_MSEC(poll_timeout);
 804cb00:	99                   	cltd   
		t += off;
 804cb01:	83 c0 09             	add    $0x9,%eax
			return t / ((uint64_t)from_hz / to_hz);
 804cb04:	6a 00                	push   $0x0
		t += off;
 804cb06:	83 d2 00             	adc    $0x0,%edx
			return t / ((uint64_t)from_hz / to_hz);
 804cb09:	6a 0a                	push   $0xa
 804cb0b:	52                   	push   %edx
 804cb0c:	50                   	push   %eax
 804cb0d:	e8 3e ca ff ff       	call   8049550 <__udivdi3>
 804cb12:	83 c4 10             	add    $0x10,%esp
 804cb15:	89 c1                	mov    %eax,%ecx
 804cb17:	89 d3                	mov    %edx,%ebx
 804cb19:	eb 05                	jmp    804cb20 <z_impl_zsock_poll+0x2c>
 804cb1b:	83 c9 ff             	or     $0xffffffff,%ecx
 804cb1e:	89 cb                	mov    %ecx,%ebx
	return zsock_poll_internal(fds, nfds, timeout);
 804cb20:	53                   	push   %ebx
 804cb21:	51                   	push   %ecx
 804cb22:	ff 75 0c             	push   0xc(%ebp)
 804cb25:	ff 75 08             	push   0x8(%ebp)
 804cb28:	e8 44 fd ff ff       	call   804c871 <zsock_poll_internal>
}
 804cb2d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
	return zsock_poll_internal(fds, nfds, timeout);
 804cb30:	83 c4 10             	add    $0x10,%esp
}
 804cb33:	c9                   	leave  
 804cb34:	c3                   	ret    

0804cb35 <zsock_getsockopt_ctx>:
{
 804cb35:	55                   	push   %ebp
 804cb36:	89 e5                	mov    %esp,%ebp
 804cb38:	56                   	push   %esi
 804cb39:	8b 75 0c             	mov    0xc(%ebp),%esi
 804cb3c:	8b 45 08             	mov    0x8(%ebp),%eax
 804cb3f:	53                   	push   %ebx
 804cb40:	8b 55 10             	mov    0x10(%ebp),%edx
 804cb43:	8b 4d 14             	mov    0x14(%ebp),%ecx
 804cb46:	8b 5d 18             	mov    0x18(%ebp),%ebx
	switch (level) {
 804cb49:	83 fe 06             	cmp    $0x6,%esi
 804cb4c:	74 4b                	je     804cb99 <zsock_getsockopt_ctx+0x64>
 804cb4e:	7f 09                	jg     804cb59 <zsock_getsockopt_ctx+0x24>
 804cb50:	85 f6                	test   %esi,%esi
 804cb52:	74 4f                	je     804cba3 <zsock_getsockopt_ctx+0x6e>
 804cb54:	4e                   	dec    %esi
 804cb55:	74 0c                	je     804cb63 <zsock_getsockopt_ctx+0x2e>
 804cb57:	eb 6f                	jmp    804cbc8 <zsock_getsockopt_ctx+0x93>
 804cb59:	83 fe 29             	cmp    $0x29,%esi
 804cb5c:	75 6a                	jne    804cbc8 <zsock_getsockopt_ctx+0x93>
		switch (optname) {
 804cb5e:	83 fa 43             	cmp    $0x43,%edx
 804cb61:	eb 41                	jmp    804cba4 <zsock_getsockopt_ctx+0x6f>
		switch (optname) {
 804cb63:	83 fa 03             	cmp    $0x3,%edx
 804cb66:	74 0e                	je     804cb76 <zsock_getsockopt_ctx+0x41>
 804cb68:	83 fa 26             	cmp    $0x26,%edx
 804cb6b:	75 5b                	jne    804cbc8 <zsock_getsockopt_ctx+0x93>
			int proto = (int)net_context_get_proto(ctx);
 804cb6d:	0f b7 80 96 00 00 00 	movzwl 0x96(%eax),%eax
 804cb74:	eb 0d                	jmp    804cb83 <zsock_getsockopt_ctx+0x4e>
	return (enum net_sock_type)((context->flags & NET_CONTEXT_TYPE) >> 6);
 804cb76:	0f b7 80 98 00 00 00 	movzwl 0x98(%eax),%eax
 804cb7d:	c1 e8 06             	shr    $0x6,%eax
 804cb80:	83 e0 03             	and    $0x3,%eax
			if (*optlen != sizeof(proto)) {
 804cb83:	83 3b 04             	cmpl   $0x4,(%ebx)
 804cb86:	74 0d                	je     804cb95 <zsock_getsockopt_ctx+0x60>
				errno = EINVAL;
 804cb88:	e8 b3 c4 ff ff       	call   8049040 <__errno_location@plt>
 804cb8d:	c7 00 16 00 00 00    	movl   $0x16,(%eax)
				return -1;
 804cb93:	eb 3e                	jmp    804cbd3 <zsock_getsockopt_ctx+0x9e>
			*(int *)optval = proto;
 804cb95:	89 01                	mov    %eax,(%ecx)
			return 0;
 804cb97:	eb 20                	jmp    804cbb9 <zsock_getsockopt_ctx+0x84>
		switch (optname) {
 804cb99:	4a                   	dec    %edx
			return ret;
 804cb9a:	b8 a3 ff ff ff       	mov    $0xffffffa3,%eax
 804cb9f:	75 27                	jne    804cbc8 <zsock_getsockopt_ctx+0x93>
 804cba1:	eb 33                	jmp    804cbd6 <zsock_getsockopt_ctx+0xa1>
		switch (optname) {
 804cba3:	4a                   	dec    %edx
 804cba4:	75 22                	jne    804cbc8 <zsock_getsockopt_ctx+0x93>
				ret = net_context_get_option(ctx,
 804cba6:	53                   	push   %ebx
 804cba7:	51                   	push   %ecx
 804cba8:	6a 08                	push   $0x8
 804cbaa:	50                   	push   %eax
 804cbab:	e8 14 7e 00 00       	call   80549c4 <net_context_get_option>
 804cbb0:	83 c4 10             	add    $0x10,%esp
 804cbb3:	89 c3                	mov    %eax,%ebx
				if (ret < 0) {
 804cbb5:	85 c0                	test   %eax,%eax
 804cbb7:	78 04                	js     804cbbd <zsock_getsockopt_ctx+0x88>
				return 0;
 804cbb9:	31 c0                	xor    %eax,%eax
 804cbbb:	eb 19                	jmp    804cbd6 <zsock_getsockopt_ctx+0xa1>
					errno  = -ret;
 804cbbd:	e8 7e c4 ff ff       	call   8049040 <__errno_location@plt>
 804cbc2:	f7 db                	neg    %ebx
 804cbc4:	89 18                	mov    %ebx,(%eax)
					return -1;
 804cbc6:	eb 0b                	jmp    804cbd3 <zsock_getsockopt_ctx+0x9e>
	errno = ENOPROTOOPT;
 804cbc8:	e8 73 c4 ff ff       	call   8049040 <__errno_location@plt>
 804cbcd:	c7 00 5c 00 00 00    	movl   $0x5c,(%eax)
	return -1;
 804cbd3:	83 c8 ff             	or     $0xffffffff,%eax
}
 804cbd6:	8d 65 f8             	lea    -0x8(%ebp),%esp
 804cbd9:	5b                   	pop    %ebx
 804cbda:	5e                   	pop    %esi
 804cbdb:	5d                   	pop    %ebp
 804cbdc:	c3                   	ret    

0804cbdd <sock_getsockopt_vmeth>:
	return zsock_getsockopt_ctx(obj, level, optname, optval, optlen);
 804cbdd:	e9 53 ff ff ff       	jmp    804cb35 <zsock_getsockopt_ctx>

0804cbe2 <zsock_setsockopt_ctx>:
{
 804cbe2:	55                   	push   %ebp
 804cbe3:	89 e5                	mov    %esp,%ebp
 804cbe5:	56                   	push   %esi
 804cbe6:	8b 45 0c             	mov    0xc(%ebp),%eax
 804cbe9:	8b 55 10             	mov    0x10(%ebp),%edx
 804cbec:	53                   	push   %ebx
 804cbed:	8b 4d 14             	mov    0x14(%ebp),%ecx
 804cbf0:	8b 5d 08             	mov    0x8(%ebp),%ebx
 804cbf3:	8b 75 18             	mov    0x18(%ebp),%esi
	switch (level) {
 804cbf6:	83 f8 06             	cmp    $0x6,%eax
 804cbf9:	0f 84 d6 00 00 00    	je     804ccd5 <zsock_setsockopt_ctx+0xf3>
 804cbff:	7f 10                	jg     804cc11 <zsock_setsockopt_ctx+0x2f>
 804cc01:	85 c0                	test   %eax,%eax
 804cc03:	0f 84 d6 00 00 00    	je     804ccdf <zsock_setsockopt_ctx+0xfd>
 804cc09:	48                   	dec    %eax
 804cc0a:	74 13                	je     804cc1f <zsock_setsockopt_ctx+0x3d>
 804cc0c:	e9 ff 00 00 00       	jmp    804cd10 <zsock_setsockopt_ctx+0x12e>
 804cc11:	83 f8 29             	cmp    $0x29,%eax
 804cc14:	0f 84 df 00 00 00    	je     804ccf9 <zsock_setsockopt_ctx+0x117>
 804cc1a:	e9 f1 00 00 00       	jmp    804cd10 <zsock_setsockopt_ctx+0x12e>
		switch (optname) {
 804cc1f:	31 c0                	xor    %eax,%eax
 804cc21:	83 fa 0d             	cmp    $0xd,%edx
 804cc24:	0f 84 f4 00 00 00    	je     804cd1e <zsock_setsockopt_ctx+0x13c>
 804cc2a:	83 fa 19             	cmp    $0x19,%edx
 804cc2d:	74 08                	je     804cc37 <zsock_setsockopt_ctx+0x55>
 804cc2f:	83 fa 02             	cmp    $0x2,%edx
 804cc32:	e9 a4 00 00 00       	jmp    804ccdb <zsock_setsockopt_ctx+0xf9>
	return ((context->flags & NET_CONTEXT_FAMILY) >> 3);
 804cc37:	8b 93 98 00 00 00    	mov    0x98(%ebx),%edx
 804cc3d:	89 d0                	mov    %edx,%eax
 804cc3f:	66 c1 e8 03          	shr    $0x3,%ax
 804cc43:	83 e0 07             	and    $0x7,%eax
			if (net_context_get_family(ctx) != AF_INET &&
 804cc46:	48                   	dec    %eax
 804cc47:	66 83 f8 01          	cmp    $0x1,%ax
 804cc4b:	76 10                	jbe    804cc5d <zsock_setsockopt_ctx+0x7b>
				errno = EAFNOSUPPORT;
 804cc4d:	e8 ee c3 ff ff       	call   8049040 <__errno_location@plt>
 804cc52:	c7 00 61 00 00 00    	movl   $0x61,(%eax)
				return -1;
 804cc58:	e9 be 00 00 00       	jmp    804cd1b <zsock_setsockopt_ctx+0x139>
			if ((optlen == 0) || (ifreq != NULL &&
 804cc5d:	85 f6                	test   %esi,%esi
 804cc5f:	74 09                	je     804cc6a <zsock_setsockopt_ctx+0x88>
 804cc61:	85 c9                	test   %ecx,%ecx
 804cc63:	74 16                	je     804cc7b <zsock_setsockopt_ctx+0x99>
 804cc65:	80 39 00             	cmpb   $0x0,(%ecx)
 804cc68:	75 0c                	jne    804cc76 <zsock_setsockopt_ctx+0x94>
				ctx->flags &= ~NET_CONTEXT_BOUND_TO_IFACE;
 804cc6a:	80 e6 f7             	and    $0xf7,%dh
 804cc6d:	66 89 93 98 00 00 00 	mov    %dx,0x98(%ebx)
				return 0;
 804cc74:	eb 7f                	jmp    804ccf5 <zsock_setsockopt_ctx+0x113>
			if ((ifreq == NULL) || (optlen != sizeof(*ifreq))) {
 804cc76:	83 fe 30             	cmp    $0x30,%esi
 804cc79:	74 10                	je     804cc8b <zsock_setsockopt_ctx+0xa9>
				errno = EINVAL;
 804cc7b:	e8 c0 c3 ff ff       	call   8049040 <__errno_location@plt>
 804cc80:	c7 00 16 00 00 00    	movl   $0x16,(%eax)
				return -1;
 804cc86:	e9 90 00 00 00       	jmp    804cd1b <zsock_setsockopt_ctx+0x139>
		union { uintptr_t x; const char * val; } parm0 = { .val = name };
		return (const struct device *) arch_syscall_invoke1(parm0.x, K_SYSCALL_DEVICE_GET_BINDING);
	}
#endif
	compiler_barrier();
	return z_impl_device_get_binding(name);
 804cc8b:	83 ec 0c             	sub    $0xc,%esp
 804cc8e:	51                   	push   %ecx
 804cc8f:	e8 d7 1d 01 00       	call   805ea6b <z_impl_device_get_binding>
 804cc94:	83 c4 10             	add    $0x10,%esp
			if (dev == NULL) {
 804cc97:	85 c0                	test   %eax,%eax
 804cc99:	74 10                	je     804ccab <zsock_setsockopt_ctx+0xc9>
			iface = net_if_lookup_by_dev(dev);
 804cc9b:	83 ec 0c             	sub    $0xc,%esp
 804cc9e:	50                   	push   %eax
 804cc9f:	e8 d4 43 00 00       	call   8051078 <net_if_lookup_by_dev>
 804cca4:	83 c4 10             	add    $0x10,%esp
			if (iface == NULL) {
 804cca7:	85 c0                	test   %eax,%eax
 804cca9:	75 0d                	jne    804ccb8 <zsock_setsockopt_ctx+0xd6>
				errno = ENODEV;
 804ccab:	e8 90 c3 ff ff       	call   8049040 <__errno_location@plt>
 804ccb0:	c7 00 13 00 00 00    	movl   $0x13,(%eax)
				return -1;
 804ccb6:	eb 63                	jmp    804cd1b <zsock_setsockopt_ctx+0x139>
static inline void net_context_set_iface(struct net_context *context,
					 struct net_if *iface)
{
	NET_ASSERT(iface);

	context->iface = net_if_get_by_iface(iface);
 804ccb8:	83 ec 0c             	sub    $0xc,%esp
 804ccbb:	50                   	push   %eax
 804ccbc:	e8 c1 5d 00 00       	call   8052a82 <net_if_get_by_iface>
 804ccc1:	83 c4 10             	add    $0x10,%esp
			ctx->flags |= NET_CONTEXT_BOUND_TO_IFACE;
 804ccc4:	66 81 8b 98 00 00 00 	orw    $0x800,0x98(%ebx)
 804cccb:	00 08 
 804cccd:	88 83 9a 00 00 00    	mov    %al,0x9a(%ebx)
			return 0;
 804ccd3:	eb 20                	jmp    804ccf5 <zsock_setsockopt_ctx+0x113>
			return ret;
 804ccd5:	b8 a3 ff ff ff       	mov    $0xffffffa3,%eax
 804ccda:	4a                   	dec    %edx
 804ccdb:	75 33                	jne    804cd10 <zsock_setsockopt_ctx+0x12e>
 804ccdd:	eb 3f                	jmp    804cd1e <zsock_setsockopt_ctx+0x13c>
		switch (optname) {
 804ccdf:	4a                   	dec    %edx
 804cce0:	75 2e                	jne    804cd10 <zsock_setsockopt_ctx+0x12e>
				ret = net_context_set_option(ctx,
 804cce2:	56                   	push   %esi
 804cce3:	51                   	push   %ecx
 804cce4:	6a 08                	push   $0x8
 804cce6:	53                   	push   %ebx
 804cce7:	e8 59 7c 00 00       	call   8054945 <net_context_set_option>
 804ccec:	83 c4 10             	add    $0x10,%esp
 804ccef:	89 c3                	mov    %eax,%ebx
				if (ret < 0) {
 804ccf1:	85 c0                	test   %eax,%eax
 804ccf3:	78 10                	js     804cd05 <zsock_setsockopt_ctx+0x123>
				return 0;
 804ccf5:	31 c0                	xor    %eax,%eax
 804ccf7:	eb 25                	jmp    804cd1e <zsock_setsockopt_ctx+0x13c>
		switch (optname) {
 804ccf9:	31 c0                	xor    %eax,%eax
 804ccfb:	83 fa 1a             	cmp    $0x1a,%edx
 804ccfe:	74 1e                	je     804cd1e <zsock_setsockopt_ctx+0x13c>
 804cd00:	83 fa 43             	cmp    $0x43,%edx
 804cd03:	eb db                	jmp    804cce0 <zsock_setsockopt_ctx+0xfe>
					errno  = -ret;
 804cd05:	e8 36 c3 ff ff       	call   8049040 <__errno_location@plt>
 804cd0a:	f7 db                	neg    %ebx
 804cd0c:	89 18                	mov    %ebx,(%eax)
					return -1;
 804cd0e:	eb 0b                	jmp    804cd1b <zsock_setsockopt_ctx+0x139>
	errno = ENOPROTOOPT;
 804cd10:	e8 2b c3 ff ff       	call   8049040 <__errno_location@plt>
 804cd15:	c7 00 5c 00 00 00    	movl   $0x5c,(%eax)
	return -1;
 804cd1b:	83 c8 ff             	or     $0xffffffff,%eax
}
 804cd1e:	8d 65 f8             	lea    -0x8(%ebp),%esp
 804cd21:	5b                   	pop    %ebx
 804cd22:	5e                   	pop    %esi
 804cd23:	5d                   	pop    %ebp
 804cd24:	c3                   	ret    

0804cd25 <sock_setsockopt_vmeth>:
	return zsock_setsockopt_ctx(obj, level, optname, optval, optlen);
 804cd25:	e9 b8 fe ff ff       	jmp    804cbe2 <zsock_setsockopt_ctx>

0804cd2a <z_impl_zsock_setsockopt>:
{
 804cd2a:	55                   	push   %ebp
 804cd2b:	89 e5                	mov    %esp,%ebp
 804cd2d:	56                   	push   %esi
 804cd2e:	53                   	push   %ebx
 804cd2f:	83 ec 14             	sub    $0x14,%esp
 804cd32:	8b 75 14             	mov    0x14(%ebp),%esi
 804cd35:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 804cd3b:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804cd3e:	31 c0                	xor    %eax,%eax
	ctx = z_get_fd_obj_and_vtable(sock,
 804cd40:	8d 45 f0             	lea    -0x10(%ebp),%eax
 804cd43:	50                   	push   %eax
 804cd44:	8d 45 ec             	lea    -0x14(%ebp),%eax
 804cd47:	50                   	push   %eax
 804cd48:	ff 75 08             	push   0x8(%ebp)
 804cd4b:	e8 bc cf ff ff       	call   8049d0c <z_get_fd_obj_and_vtable>
 804cd50:	83 c4 10             	add    $0x10,%esp
	VTABLE_CALL(setsockopt, sock, level, optname, optval, optlen);
 804cd53:	85 c0                	test   %eax,%eax
 804cd55:	75 0d                	jne    804cd64 <z_impl_zsock_setsockopt+0x3a>
 804cd57:	e8 e4 c2 ff ff       	call   8049040 <__errno_location@plt>
 804cd5c:	c7 00 09 00 00 00    	movl   $0x9,(%eax)
 804cd62:	eb 16                	jmp    804cd7a <z_impl_zsock_setsockopt+0x50>
 804cd64:	89 c3                	mov    %eax,%ebx
 804cd66:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804cd69:	83 78 30 00          	cmpl   $0x0,0x30(%eax)
 804cd6d:	75 10                	jne    804cd7f <z_impl_zsock_setsockopt+0x55>
 804cd6f:	e8 cc c2 ff ff       	call   8049040 <__errno_location@plt>
 804cd74:	c7 00 5f 00 00 00    	movl   $0x5f,(%eax)
 804cd7a:	83 cb ff             	or     $0xffffffff,%ebx
 804cd7d:	eb 2e                	jmp    804cdad <z_impl_zsock_setsockopt+0x83>
 804cd7f:	83 ca ff             	or     $0xffffffff,%edx
 804cd82:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804cd85:	89 d1                	mov    %edx,%ecx
 804cd87:	e8 c7 e7 ff ff       	call   804b553 <k_mutex_lock.constprop.0.isra.0>
 804cd8c:	83 ec 0c             	sub    $0xc,%esp
 804cd8f:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804cd92:	ff 75 18             	push   0x18(%ebp)
 804cd95:	56                   	push   %esi
 804cd96:	ff 75 10             	push   0x10(%ebp)
 804cd99:	ff 75 0c             	push   0xc(%ebp)
 804cd9c:	53                   	push   %ebx
 804cd9d:	ff 50 30             	call   *0x30(%eax)
 804cda0:	89 c3                	mov    %eax,%ebx
 804cda2:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804cda5:	83 c4 20             	add    $0x20,%esp
 804cda8:	e8 b2 e8 ff ff       	call   804b65f <k_mutex_unlock.isra.0>
}
 804cdad:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804cdb0:	65 2b 05 14 00 00 00 	sub    %gs:0x14,%eax
 804cdb7:	74 05                	je     804cdbe <z_impl_zsock_setsockopt+0x94>
 804cdb9:	e8 42 c5 ff ff       	call   8049300 <__stack_chk_fail@plt>
 804cdbe:	8d 65 f8             	lea    -0x8(%ebp),%esp
 804cdc1:	89 d8                	mov    %ebx,%eax
 804cdc3:	5b                   	pop    %ebx
 804cdc4:	5e                   	pop    %esi
 804cdc5:	5d                   	pop    %ebp
 804cdc6:	c3                   	ret    

0804cdc7 <zsock_getpeername_ctx>:
{
 804cdc7:	55                   	push   %ebp
 804cdc8:	89 e5                	mov    %esp,%ebp
 804cdca:	57                   	push   %edi
 804cdcb:	56                   	push   %esi
 804cdcc:	53                   	push   %ebx
 804cdcd:	83 ec 2c             	sub    $0x2c,%esp
 804cdd0:	8b 55 0c             	mov    0xc(%ebp),%edx
 804cdd3:	8b 75 08             	mov    0x8(%ebp),%esi
 804cdd6:	65 8b 0d 14 00 00 00 	mov    %gs:0x14,%ecx
 804cddd:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
 804cde0:	31 c9                	xor    %ecx,%ecx
 804cde2:	8b 45 10             	mov    0x10(%ebp),%eax
	if (addr == NULL || addrlen == NULL) {
 804cde5:	85 d2                	test   %edx,%edx
 804cde7:	0f 84 b6 00 00 00    	je     804cea3 <zsock_getpeername_ctx+0xdc>
 804cded:	85 c0                	test   %eax,%eax
 804cdef:	0f 84 ae 00 00 00    	je     804cea3 <zsock_getpeername_ctx+0xdc>
	if (!(ctx->flags & NET_CONTEXT_REMOTE_ADDR_SET)) {
 804cdf5:	0f b7 9e 98 00 00 00 	movzwl 0x98(%esi),%ebx
 804cdfc:	89 d9                	mov    %ebx,%ecx
 804cdfe:	f6 c7 01             	test   $0x1,%bh
 804ce01:	74 15                	je     804ce18 <zsock_getpeername_ctx+0x51>
	return (enum net_sock_type)((context->flags & NET_CONTEXT_TYPE) >> 6);
 804ce03:	c1 eb 06             	shr    $0x6,%ebx
 804ce06:	83 e3 03             	and    $0x3,%ebx
	if (net_context_get_type(ctx) == SOCK_STREAM &&
 804ce09:	4b                   	dec    %ebx
 804ce0a:	75 1c                	jne    804ce28 <zsock_getpeername_ctx+0x61>
		((context->flags >> NET_CONTEXT_STATE_SHIFT) &
 804ce0c:	66 d1 e9             	shr    %cx
 804ce0f:	83 e1 03             	and    $0x3,%ecx
 804ce12:	66 83 f9 02          	cmp    $0x2,%cx
 804ce16:	74 10                	je     804ce28 <zsock_getpeername_ctx+0x61>
		SET_ERRNO(-ENOTCONN);
 804ce18:	e8 23 c2 ff ff       	call   8049040 <__errno_location@plt>
 804ce1d:	c7 00 6b 00 00 00    	movl   $0x6b,(%eax)
 804ce23:	e9 86 00 00 00       	jmp    804ceae <zsock_getpeername_ctx+0xe7>
	if (IS_ENABLED(CONFIG_NET_IPV4) && ctx->remote.sa_family == AF_INET) {
 804ce28:	8b 4e 2c             	mov    0x2c(%esi),%ecx
 804ce2b:	66 83 f9 01          	cmp    $0x1,%cx
 804ce2f:	75 2e                	jne    804ce5f <zsock_getpeername_ctx+0x98>
		addr4.sin_port = net_sin(&ctx->remote)->sin_port;
 804ce31:	66 8b 4e 2e          	mov    0x2e(%esi),%cx
		memcpy(addr, &addr4, MIN(*addrlen, newlen));
 804ce35:	bb 08 00 00 00       	mov    $0x8,%ebx
 804ce3a:	89 d7                	mov    %edx,%edi
		addr4.sin_family = AF_INET;
 804ce3c:	66 c7 45 cc 01 00    	movw   $0x1,-0x34(%ebp)
		newlen = sizeof(struct sockaddr_in);
 804ce42:	ba 08 00 00 00       	mov    $0x8,%edx
		addr4.sin_port = net_sin(&ctx->remote)->sin_port;
 804ce47:	66 89 4d ce          	mov    %cx,-0x32(%ebp)
		memcpy(&addr4.sin_addr, &net_sin(&ctx->remote)->sin_addr,
 804ce4b:	8b 4e 30             	mov    0x30(%esi),%ecx
 804ce4e:	8d 75 cc             	lea    -0x34(%ebp),%esi
 804ce51:	89 4d d0             	mov    %ecx,-0x30(%ebp)
		memcpy(addr, &addr4, MIN(*addrlen, newlen));
 804ce54:	8b 08                	mov    (%eax),%ecx
 804ce56:	39 d9                	cmp    %ebx,%ecx
 804ce58:	0f 47 cb             	cmova  %ebx,%ecx
 804ce5b:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
 804ce5d:	eb 54                	jmp    804ceb3 <zsock_getpeername_ctx+0xec>
	} else if (IS_ENABLED(CONFIG_NET_IPV6) &&
 804ce5f:	66 83 f9 02          	cmp    $0x2,%cx
 804ce63:	75 3e                	jne    804cea3 <zsock_getpeername_ctx+0xdc>
		addr6.sin6_port = net_sin6(&ctx->remote)->sin6_port;
 804ce65:	66 8b 4e 2e          	mov    0x2e(%esi),%cx
 804ce69:	8d 5d d0             	lea    -0x30(%ebp),%ebx
		addr6.sin6_family = AF_INET6;
 804ce6c:	66 c7 45 cc 02 00    	movw   $0x2,-0x34(%ebp)
 804ce72:	83 c6 30             	add    $0x30,%esi
		struct sockaddr_in6 addr6 = { 0 };
 804ce75:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
 804ce7c:	89 df                	mov    %ebx,%edi
		memcpy(addr, &addr6, MIN(*addrlen, newlen));
 804ce7e:	bb 18 00 00 00       	mov    $0x18,%ebx
		addr6.sin6_port = net_sin6(&ctx->remote)->sin6_port;
 804ce83:	66 89 4d ce          	mov    %cx,-0x32(%ebp)
 804ce87:	b9 04 00 00 00       	mov    $0x4,%ecx
 804ce8c:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
		memcpy(addr, &addr6, MIN(*addrlen, newlen));
 804ce8e:	8b 08                	mov    (%eax),%ecx
 804ce90:	89 d7                	mov    %edx,%edi
 804ce92:	8d 75 cc             	lea    -0x34(%ebp),%esi
		newlen = sizeof(struct sockaddr_in6);
 804ce95:	ba 18 00 00 00       	mov    $0x18,%edx
		memcpy(addr, &addr6, MIN(*addrlen, newlen));
 804ce9a:	39 d9                	cmp    %ebx,%ecx
 804ce9c:	0f 47 cb             	cmova  %ebx,%ecx
 804ce9f:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
 804cea1:	eb 10                	jmp    804ceb3 <zsock_getpeername_ctx+0xec>
		SET_ERRNO(-EINVAL);
 804cea3:	e8 98 c1 ff ff       	call   8049040 <__errno_location@plt>
 804cea8:	c7 00 16 00 00 00    	movl   $0x16,(%eax)
 804ceae:	83 c8 ff             	or     $0xffffffff,%eax
 804ceb1:	eb 04                	jmp    804ceb7 <zsock_getpeername_ctx+0xf0>
	*addrlen = newlen;
 804ceb3:	89 10                	mov    %edx,(%eax)
	return 0;
 804ceb5:	31 c0                	xor    %eax,%eax
}
 804ceb7:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 804ceba:	65 2b 15 14 00 00 00 	sub    %gs:0x14,%edx
 804cec1:	74 05                	je     804cec8 <zsock_getpeername_ctx+0x101>
 804cec3:	e8 38 c4 ff ff       	call   8049300 <__stack_chk_fail@plt>
 804cec8:	83 c4 2c             	add    $0x2c,%esp
 804cecb:	5b                   	pop    %ebx
 804cecc:	5e                   	pop    %esi
 804cecd:	5f                   	pop    %edi
 804cece:	5d                   	pop    %ebp
 804cecf:	c3                   	ret    

0804ced0 <sock_getpeername_vmeth>:
	return zsock_getpeername_ctx(obj, addr, addrlen);
 804ced0:	e9 f2 fe ff ff       	jmp    804cdc7 <zsock_getpeername_ctx>

0804ced5 <zsock_getsockname_ctx>:
{
 804ced5:	55                   	push   %ebp
 804ced6:	89 e5                	mov    %esp,%ebp
 804ced8:	57                   	push   %edi
 804ced9:	56                   	push   %esi
 804ceda:	53                   	push   %ebx
 804cedb:	83 ec 2c             	sub    $0x2c,%esp
 804cede:	8b 4d 08             	mov    0x8(%ebp),%ecx
 804cee1:	8b 55 0c             	mov    0xc(%ebp),%edx
 804cee4:	65 8b 1d 14 00 00 00 	mov    %gs:0x14,%ebx
 804ceeb:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
 804ceee:	31 db                	xor    %ebx,%ebx
 804cef0:	8b 45 10             	mov    0x10(%ebp),%eax
	if (!ctx->conn_handler) {
 804cef3:	83 79 44 00          	cmpl   $0x0,0x44(%ecx)
 804cef7:	74 7d                	je     804cf76 <zsock_getsockname_ctx+0xa1>
	if (IS_ENABLED(CONFIG_NET_IPV4) && ctx->local.family == AF_INET) {
 804cef9:	8b 59 20             	mov    0x20(%ecx),%ebx
 804cefc:	66 83 fb 01          	cmp    $0x1,%bx
 804cf00:	75 30                	jne    804cf32 <zsock_getsockname_ctx+0x5d>
		addr4.sin_port = net_sin_ptr(&ctx->local)->sin_port;
 804cf02:	66 8b 59 22          	mov    0x22(%ecx),%bx
 804cf06:	8b 49 24             	mov    0x24(%ecx),%ecx
 804cf09:	89 d7                	mov    %edx,%edi
		addr4.sin_family = AF_INET;
 804cf0b:	66 c7 45 cc 01 00    	movw   $0x1,-0x34(%ebp)
 804cf11:	8d 75 cc             	lea    -0x34(%ebp),%esi
		newlen = sizeof(struct sockaddr_in);
 804cf14:	ba 08 00 00 00       	mov    $0x8,%edx
 804cf19:	8b 09                	mov    (%ecx),%ecx
		addr4.sin_port = net_sin_ptr(&ctx->local)->sin_port;
 804cf1b:	66 89 5d ce          	mov    %bx,-0x32(%ebp)
		memcpy(addr, &addr4, MIN(*addrlen, newlen));
 804cf1f:	bb 08 00 00 00       	mov    $0x8,%ebx
 804cf24:	89 4d d0             	mov    %ecx,-0x30(%ebp)
 804cf27:	8b 08                	mov    (%eax),%ecx
 804cf29:	39 d9                	cmp    %ebx,%ecx
 804cf2b:	0f 47 cb             	cmova  %ebx,%ecx
 804cf2e:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
 804cf30:	eb 54                	jmp    804cf86 <zsock_getsockname_ctx+0xb1>
	} else if (IS_ENABLED(CONFIG_NET_IPV6) &&
 804cf32:	66 83 fb 02          	cmp    $0x2,%bx
 804cf36:	75 3e                	jne    804cf76 <zsock_getsockname_ctx+0xa1>
		addr6.sin6_port = net_sin6_ptr(&ctx->local)->sin6_port;
 804cf38:	66 8b 59 22          	mov    0x22(%ecx),%bx
 804cf3c:	8b 71 24             	mov    0x24(%ecx),%esi
		struct sockaddr_in6 addr6 = { 0 };
 804cf3f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
 804cf46:	b9 04 00 00 00       	mov    $0x4,%ecx
		addr6.sin6_family = AF_INET6;
 804cf4b:	66 c7 45 cc 02 00    	movw   $0x2,-0x34(%ebp)
		addr6.sin6_port = net_sin6_ptr(&ctx->local)->sin6_port;
 804cf51:	66 89 5d ce          	mov    %bx,-0x32(%ebp)
 804cf55:	8d 5d d0             	lea    -0x30(%ebp),%ebx
 804cf58:	89 df                	mov    %ebx,%edi
		memcpy(addr, &addr6, MIN(*addrlen, newlen));
 804cf5a:	bb 18 00 00 00       	mov    $0x18,%ebx
 804cf5f:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
 804cf61:	8b 08                	mov    (%eax),%ecx
 804cf63:	89 d7                	mov    %edx,%edi
 804cf65:	8d 75 cc             	lea    -0x34(%ebp),%esi
		newlen = sizeof(struct sockaddr_in6);
 804cf68:	ba 18 00 00 00       	mov    $0x18,%edx
		memcpy(addr, &addr6, MIN(*addrlen, newlen));
 804cf6d:	39 d9                	cmp    %ebx,%ecx
 804cf6f:	0f 47 cb             	cmova  %ebx,%ecx
 804cf72:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
 804cf74:	eb 10                	jmp    804cf86 <zsock_getsockname_ctx+0xb1>
		SET_ERRNO(-EINVAL);
 804cf76:	e8 c5 c0 ff ff       	call   8049040 <__errno_location@plt>
 804cf7b:	c7 00 16 00 00 00    	movl   $0x16,(%eax)
 804cf81:	83 c8 ff             	or     $0xffffffff,%eax
 804cf84:	eb 04                	jmp    804cf8a <zsock_getsockname_ctx+0xb5>
	*addrlen = newlen;
 804cf86:	89 10                	mov    %edx,(%eax)
	return 0;
 804cf88:	31 c0                	xor    %eax,%eax
}
 804cf8a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 804cf8d:	65 2b 15 14 00 00 00 	sub    %gs:0x14,%edx
 804cf94:	74 05                	je     804cf9b <zsock_getsockname_ctx+0xc6>
 804cf96:	e8 65 c3 ff ff       	call   8049300 <__stack_chk_fail@plt>
 804cf9b:	83 c4 2c             	add    $0x2c,%esp
 804cf9e:	5b                   	pop    %ebx
 804cf9f:	5e                   	pop    %esi
 804cfa0:	5f                   	pop    %edi
 804cfa1:	5d                   	pop    %ebp
 804cfa2:	c3                   	ret    

0804cfa3 <sock_getsockname_vmeth>:
	return zsock_getsockname_ctx(obj, addr, addrlen);
 804cfa3:	e9 2d ff ff ff       	jmp    804ced5 <zsock_getsockname_ctx>

0804cfa8 <arch_cpu_idle>:
 * arch_busy_wait()
 */
#endif

void arch_cpu_idle(void)
{
 804cfa8:	55                   	push   %ebp
 804cfa9:	89 e5                	mov    %esp,%ebp
 804cfab:	83 ec 08             	sub    $0x8,%esp
	sys_trace_idle();
 804cfae:	e8 62 de ff ff       	call   804ae15 <sys_trace_idle>
	posix_irq_full_unlock();
 804cfb3:	e8 7e 11 00 00       	call   804e136 <posix_irq_full_unlock>
	posix_halt_cpu();
}
 804cfb8:	c9                   	leave  
	posix_halt_cpu();
 804cfb9:	e9 45 06 00 00       	jmp    804d603 <posix_halt_cpu>

0804cfbe <arch_system_halt>:
#include <inttypes.h>
#include <zephyr/logging/log_ctrl.h>
#include <zephyr/arch/posix/posix_soc_if.h>

FUNC_NORETURN void arch_system_halt(unsigned int reason)
{
 804cfbe:	55                   	push   %ebp
 804cfbf:	89 e5                	mov    %esp,%ebp
 804cfc1:	83 ec 14             	sub    $0x14,%esp
	ARG_UNUSED(reason);

	posix_print_error_and_exit("Exiting due to fatal error\n");
 804cfc4:	68 e0 29 06 08       	push   $0x80629e0
 804cfc9:	e8 d6 15 00 00       	call   804e5a4 <posix_print_error_and_exit>
 804cfce:	83 c4 0c             	add    $0xc,%esp
	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
 804cfd1:	6a 15                	push   $0x15
 804cfd3:	68 fc 29 06 08       	push   $0x80629fc
 804cfd8:	68 46 29 06 08       	push   $0x8062946
 804cfdd:	e8 c2 15 00 00       	call   804e5a4 <posix_print_error_and_exit>
 804cfe2:	83 c4 10             	add    $0x10,%esp

0804cfe5 <arch_irq_enable>:
}
#endif

void arch_irq_enable(unsigned int irq)
{
	posix_irq_enable(irq);
 804cfe5:	e9 5e 11 00 00       	jmp    804e148 <posix_irq_enable>

0804cfea <pc_safe_call>:
#endif

static inline void pc_safe_call(int test, const char *test_str)
{
	/* LCOV_EXCL_START */ /* See Note1 */
	if (unlikely(test)) {
 804cfea:	85 c0                	test   %eax,%eax
 804cfec:	74 16                	je     804d004 <pc_safe_call+0x1a>
{
 804cfee:	55                   	push   %ebp
 804cfef:	89 e5                	mov    %esp,%ebp
 804cff1:	83 ec 10             	sub    $0x10,%esp
		posix_print_error_and_exit("POSIX arch: Error on: %s\n",
 804cff4:	52                   	push   %edx
 804cff5:	68 27 2a 06 08       	push   $0x8062a27
 804cffa:	e8 a5 15 00 00       	call   804e5a4 <posix_print_error_and_exit>
 804cfff:	83 c4 10             	add    $0x10,%esp
					   test_str);
	}
	/* LCOV_EXCL_STOP */
}
 804d002:	c9                   	leave  
 804d003:	c3                   	ret    
 804d004:	c3                   	ret    

0804d005 <posix_preexit_cleanup>:
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_threads));
}


static void posix_preexit_cleanup(void)
{
 804d005:	55                   	push   %ebp
 804d006:	89 e5                	mov    %esp,%ebp
 804d008:	83 ec 14             	sub    $0x14,%esp
	/*
	 * Release the mutex so the next allowed thread can run
	 */
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_threads));
 804d00b:	68 20 89 06 08       	push   $0x8068920
 804d010:	e8 eb c1 ff ff       	call   8049200 <pthread_mutex_unlock@plt>
 804d015:	83 c4 10             	add    $0x10,%esp
 804d018:	ba 41 2a 06 08       	mov    $0x8062a41,%edx
 804d01d:	e8 c8 ff ff ff       	call   804cfea <pc_safe_call>

	/* We detach ourselves so nobody needs to join to us */
	pthread_detach(pthread_self());
 804d022:	e8 c9 c3 ff ff       	call   80493f0 <pthread_self@plt>
 804d027:	83 ec 0c             	sub    $0xc,%esp
 804d02a:	50                   	push   %eax
 804d02b:	e8 30 c2 ff ff       	call   8049260 <pthread_detach@plt>
 804d030:	83 c4 10             	add    $0x10,%esp
}
 804d033:	c9                   	leave  
 804d034:	c3                   	ret    

0804d035 <abort_tail>:
{
 804d035:	55                   	push   %ebp
	threads_table[this_th_nbr].running = false;
 804d036:	6b c0 14             	imul   $0x14,%eax,%eax
{
 804d039:	89 e5                	mov    %esp,%ebp
 804d03b:	83 ec 08             	sub    $0x8,%esp
	threads_table[this_th_nbr].running = false;
 804d03e:	03 05 3c 89 06 08    	add    0x806893c,%eax
 804d044:	c6 40 04 00          	movb   $0x0,0x4(%eax)
	threads_table[this_th_nbr].state = ABORTED;
 804d048:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
	posix_preexit_cleanup();
 804d04e:	e8 b2 ff ff ff       	call   804d005 <posix_preexit_cleanup>
	pthread_exit(NULL);
 804d053:	83 ec 0c             	sub    $0xc,%esp
 804d056:	6a 00                	push   $0x0
 804d058:	e8 23 c0 ff ff       	call   8049080 <pthread_exit@plt>

0804d05d <posix_wait_until_allowed>:
{
 804d05d:	55                   	push   %ebp
 804d05e:	89 e5                	mov    %esp,%ebp
 804d060:	56                   	push   %esi
	threads_table[this_th_nbr].running = false;
 804d061:	6b f0 14             	imul   $0x14,%eax,%esi
{
 804d064:	53                   	push   %ebx
 804d065:	89 c3                	mov    %eax,%ebx
	threads_table[this_th_nbr].running = false;
 804d067:	a1 3c 89 06 08       	mov    0x806893c,%eax
 804d06c:	c6 44 30 04 00       	movb   $0x0,0x4(%eax,%esi,1)
	while (this_th_nbr != currently_allowed_thread) {
 804d071:	39 1d 1c 89 06 08    	cmp    %ebx,0x806891c
 804d077:	74 2a                	je     804d0a3 <posix_wait_until_allowed+0x46>
		pthread_cond_wait(&cond_threads, &mtx_threads);
 804d079:	50                   	push   %eax
 804d07a:	50                   	push   %eax
 804d07b:	68 20 89 06 08       	push   $0x8068920
 804d080:	68 20 78 06 08       	push   $0x8067820
 804d085:	e8 a6 c2 ff ff       	call   8049330 <pthread_cond_wait@plt>
		if (threads_table &&
 804d08a:	a1 3c 89 06 08       	mov    0x806893c,%eax
		pthread_cond_wait(&cond_threads, &mtx_threads);
 804d08f:	83 c4 10             	add    $0x10,%esp
		if (threads_table &&
 804d092:	85 c0                	test   %eax,%eax
 804d094:	74 db                	je     804d071 <posix_wait_until_allowed+0x14>
 804d096:	83 3c 30 02          	cmpl   $0x2,(%eax,%esi,1)
 804d09a:	75 d5                	jne    804d071 <posix_wait_until_allowed+0x14>
			abort_tail(this_th_nbr);
 804d09c:	89 d8                	mov    %ebx,%eax
 804d09e:	e8 92 ff ff ff       	call   804d035 <abort_tail>
	threads_table[this_th_nbr].running = true;
 804d0a3:	a1 3c 89 06 08       	mov    0x806893c,%eax
 804d0a8:	c6 44 30 04 01       	movb   $0x1,0x4(%eax,%esi,1)
}
 804d0ad:	8d 65 f8             	lea    -0x8(%ebp),%esp
 804d0b0:	5b                   	pop    %ebx
 804d0b1:	5e                   	pop    %esi
 804d0b2:	5d                   	pop    %ebp
 804d0b3:	c3                   	ret    

0804d0b4 <posix_cleanup_handler>:
	 * and the mutex was already released
	 * Otherwise, release the mutex so other threads which may be
	 * caught waiting for it could terminate
	 */

	if (!terminate) {
 804d0b4:	80 3d ad 8a 06 08 00 	cmpb   $0x0,0x8068aad
 804d0bb:	74 2b                	je     804d0e8 <posix_cleanup_handler+0x34>
{
 804d0bd:	55                   	push   %ebp
 804d0be:	89 e5                	mov    %esp,%ebp
 804d0c0:	83 ec 14             	sub    $0x14,%esp
		ptr->thread_idx,
		__func__);
#endif


	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_threads));
 804d0c3:	68 20 89 06 08       	push   $0x8068920
 804d0c8:	e8 33 c1 ff ff       	call   8049200 <pthread_mutex_unlock@plt>
 804d0cd:	83 c4 10             	add    $0x10,%esp
 804d0d0:	ba 41 2a 06 08       	mov    $0x8062a41,%edx
 804d0d5:	e8 10 ff ff ff       	call   804cfea <pc_safe_call>

	/* We detach ourselves so nobody needs to join to us */
	pthread_detach(pthread_self());
 804d0da:	e8 11 c3 ff ff       	call   80493f0 <pthread_self@plt>
 804d0df:	89 45 08             	mov    %eax,0x8(%ebp)
}
 804d0e2:	c9                   	leave  
	pthread_detach(pthread_self());
 804d0e3:	e9 78 c1 ff ff       	jmp    8049260 <pthread_detach@plt>
 804d0e8:	c3                   	ret    

0804d0e9 <posix_thread_starter>:
 *  It will block the thread until a arch_swap() is called for it
 *
 * Spawned from posix_new_thread() below
 */
static void *posix_thread_starter(void *arg)
{
 804d0e9:	55                   	push   %ebp
 804d0ea:	89 e5                	mov    %esp,%ebp
 804d0ec:	83 ec 54             	sub    $0x54,%esp
 804d0ef:	8b 45 08             	mov    0x8(%ebp),%eax
 804d0f2:	89 45 c4             	mov    %eax,-0x3c(%ebp)
 804d0f5:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 804d0fb:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804d0fe:	31 c0                	xor    %eax,%eax

	/*
	 * We block until all other running threads reach the while loop
	 * in posix_wait_until_allowed() and they release the mutex
	 */
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_threads));
 804d100:	68 20 89 06 08       	push   $0x8068920
 804d105:	e8 e6 c1 ff ff       	call   80492f0 <pthread_mutex_lock@plt>
 804d10a:	83 c4 10             	add    $0x10,%esp
 804d10d:	ba 64 2a 06 08       	mov    $0x8062a64,%edx
 804d112:	e8 d3 fe ff ff       	call   804cfea <pc_safe_call>

	/*
	 * The program may have been finished before this thread ever got to run
	 */
	/* LCOV_EXCL_START */ /* See Note1 */
	if (!threads_table) {
 804d117:	83 3d 3c 89 06 08 00 	cmpl   $0x0,0x806893c
 804d11e:	75 17                	jne    804d137 <posix_thread_starter+0x4e>
		posix_cleanup_handler(arg);
 804d120:	83 ec 0c             	sub    $0xc,%esp
 804d123:	ff 75 c4             	push   -0x3c(%ebp)
 804d126:	e8 89 ff ff ff       	call   804d0b4 <posix_cleanup_handler>
		pthread_exit(NULL);
 804d12b:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 804d132:	e8 49 bf ff ff       	call   8049080 <pthread_exit@plt>
	}
	/* LCOV_EXCL_STOP */

	pthread_cleanup_push(posix_cleanup_handler, arg);
 804d137:	50                   	push   %eax
 804d138:	50                   	push   %eax
 804d139:	8d 45 c8             	lea    -0x38(%ebp),%eax
 804d13c:	6a 00                	push   $0x0
 804d13e:	50                   	push   %eax
 804d13f:	e8 8c c2 ff ff       	call   80493d0 <__sigsetjmp@plt>
 804d144:	83 c4 10             	add    $0x10,%esp
 804d147:	85 c0                	test   %eax,%eax
 804d149:	74 16                	je     804d161 <posix_thread_starter+0x78>
 804d14b:	83 ec 0c             	sub    $0xc,%esp
 804d14e:	ff 75 c4             	push   -0x3c(%ebp)
 804d151:	e8 5e ff ff ff       	call   804d0b4 <posix_cleanup_handler>
 804d156:	83 c4 10             	add    $0x10,%esp
 804d159:	8d 45 c8             	lea    -0x38(%ebp),%eax
 804d15c:	e8 0f c2 ff ff       	call   8049370 <__pthread_unwind_next@plt>
 804d161:	8d 45 c8             	lea    -0x38(%ebp),%eax
 804d164:	e8 27 c2 ff ff       	call   8049390 <__pthread_register_cancel@plt>

	/*
	 * The thread would try to execute immediately, so we block it
	 * until allowed
	 */
	posix_wait_until_allowed(thread_idx);
 804d169:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 804d16c:	e8 ec fe ff ff       	call   804d05d <posix_wait_until_allowed>

	posix_new_thread_pre_start();
 804d171:	e8 76 03 00 00       	call   804d4ec <posix_new_thread_pre_start>

	posix_thread_status_t *ptr = threads_table[thread_idx].t_status;
 804d176:	6b 45 c4 14          	imul   $0x14,-0x3c(%ebp),%eax
 804d17a:	03 05 3c 89 06 08    	add    0x806893c,%eax
 804d180:	8b 40 10             	mov    0x10(%eax),%eax

	z_thread_entry(ptr->entry_point, ptr->arg1, ptr->arg2, ptr->arg3);
 804d183:	ff 70 0c             	push   0xc(%eax)
 804d186:	ff 70 08             	push   0x8(%eax)
 804d189:	ff 70 04             	push   0x4(%eax)
 804d18c:	ff 30                	push   (%eax)
 804d18e:	e8 c2 cd ff ff       	call   8049f55 <z_thread_entry>

0804d193 <posix_swap>:
{
 804d193:	55                   	push   %ebp
 804d194:	89 e5                	mov    %esp,%ebp
 804d196:	53                   	push   %ebx
 804d197:	83 ec 10             	sub    $0x10,%esp
	currently_allowed_thread = next_allowed_th;
 804d19a:	8b 45 08             	mov    0x8(%ebp),%eax
{
 804d19d:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_threads));
 804d1a0:	68 20 78 06 08       	push   $0x8067820
	currently_allowed_thread = next_allowed_th;
 804d1a5:	a3 1c 89 06 08       	mov    %eax,0x806891c
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_threads));
 804d1aa:	e8 01 c2 ff ff       	call   80493b0 <pthread_cond_broadcast@plt>
 804d1af:	83 c4 10             	add    $0x10,%esp
 804d1b2:	ba 85 2a 06 08       	mov    $0x8062a85,%edx
 804d1b7:	e8 2e fe ff ff       	call   804cfea <pc_safe_call>
	if (threads_table[this_th_nbr].state == ABORTING) {
 804d1bc:	6b c3 14             	imul   $0x14,%ebx,%eax
 804d1bf:	03 05 3c 89 06 08    	add    0x806893c,%eax
 804d1c5:	83 38 02             	cmpl   $0x2,(%eax)
		abort_tail(this_th_nbr);
 804d1c8:	89 d8                	mov    %ebx,%eax
	if (threads_table[this_th_nbr].state == ABORTING) {
 804d1ca:	75 05                	jne    804d1d1 <posix_swap+0x3e>
		abort_tail(this_th_nbr);
 804d1cc:	e8 64 fe ff ff       	call   804d035 <abort_tail>
}
 804d1d1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 804d1d4:	c9                   	leave  
		posix_wait_until_allowed(this_th_nbr);
 804d1d5:	e9 83 fe ff ff       	jmp    804d05d <posix_wait_until_allowed>

0804d1da <posix_main_thread_start>:
{
 804d1da:	55                   	push   %ebp
 804d1db:	89 e5                	mov    %esp,%ebp
 804d1dd:	83 ec 14             	sub    $0x14,%esp
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_threads));
 804d1e0:	68 20 78 06 08       	push   $0x8067820
	currently_allowed_thread = next_allowed_th;
 804d1e5:	8b 45 08             	mov    0x8(%ebp),%eax
 804d1e8:	a3 1c 89 06 08       	mov    %eax,0x806891c
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_threads));
 804d1ed:	e8 be c1 ff ff       	call   80493b0 <pthread_cond_broadcast@plt>
 804d1f2:	83 c4 10             	add    $0x10,%esp
 804d1f5:	ba 85 2a 06 08       	mov    $0x8062a85,%edx
 804d1fa:	e8 eb fd ff ff       	call   804cfea <pc_safe_call>
	posix_preexit_cleanup();
 804d1ff:	e8 01 fe ff ff       	call   804d005 <posix_preexit_cleanup>
	pthread_exit(NULL);
 804d204:	83 ec 0c             	sub    $0xc,%esp
 804d207:	6a 00                	push   $0x0
 804d209:	e8 72 be ff ff       	call   8049080 <pthread_exit@plt>

0804d20e <posix_new_thread>:
 * Create a new POSIX thread for the new Zephyr thread.
 * arch_new_thread() picks from the kernel structures what it is that we need
 * to call with what parameters
 */
void posix_new_thread(posix_thread_status_t *ptr)
{
 804d20e:	55                   	push   %ebp
	for (int i = 0; i < threads_table_size; i++) {
 804d20f:	31 d2                	xor    %edx,%edx
{
 804d211:	89 e5                	mov    %esp,%ebp
 804d213:	57                   	push   %edi
 804d214:	56                   	push   %esi
 804d215:	53                   	push   %ebx
 804d216:	83 ec 0c             	sub    $0xc,%esp
 804d219:	8b 75 08             	mov    0x8(%ebp),%esi
	for (int i = 0; i < threads_table_size; i++) {
 804d21c:	a1 40 89 06 08       	mov    0x8068940,%eax
		if ((threads_table[i].state == NOTUSED)
 804d221:	8b 0d 3c 89 06 08    	mov    0x806893c,%ecx
	for (int i = 0; i < threads_table_size; i++) {
 804d227:	39 c2                	cmp    %eax,%edx
 804d229:	7d 0c                	jge    804d237 <posix_new_thread+0x29>
		if ((threads_table[i].state == NOTUSED)
 804d22b:	6b da 14             	imul   $0x14,%edx,%ebx
 804d22e:	83 3c 19 00          	cmpl   $0x0,(%ecx,%ebx,1)
 804d232:	74 50                	je     804d284 <posix_new_thread+0x76>
	for (int i = 0; i < threads_table_size; i++) {
 804d234:	42                   	inc    %edx
 804d235:	eb f0                	jmp    804d227 <posix_new_thread+0x19>
				(threads_table_size + PC_ALLOC_CHUNK_SIZE)
 804d237:	83 c0 40             	add    $0x40,%eax
	threads_table = realloc(threads_table,
 804d23a:	52                   	push   %edx
 804d23b:	6b c0 14             	imul   $0x14,%eax,%eax
 804d23e:	52                   	push   %edx
 804d23f:	50                   	push   %eax
 804d240:	51                   	push   %ecx
 804d241:	e8 7a be ff ff       	call   80490c0 <realloc@plt>
 804d246:	83 c4 10             	add    $0x10,%esp
 804d249:	a3 3c 89 06 08       	mov    %eax,0x806893c
	if (threads_table == NULL) { /* LCOV_EXCL_BR_LINE */
 804d24e:	85 c0                	test   %eax,%eax
 804d250:	75 10                	jne    804d262 <posix_new_thread+0x54>
		posix_print_error_and_exit(NO_MEM_ERR); /* LCOV_EXCL_LINE */
 804d252:	83 ec 0c             	sub    $0xc,%esp
 804d255:	68 ab 2a 06 08       	push   $0x8062aab
 804d25a:	e8 45 13 00 00       	call   804e5a4 <posix_print_error_and_exit>
 804d25f:	83 c4 10             	add    $0x10,%esp
	(void)memset(&threads_table[threads_table_size], 0,
 804d262:	8b 15 40 89 06 08    	mov    0x8068940,%edx
  return __builtin___memset_chk (__dest, __ch, __len,
 804d268:	31 c0                	xor    %eax,%eax
 804d26a:	b9 40 01 00 00       	mov    $0x140,%ecx
 804d26f:	6b da 14             	imul   $0x14,%edx,%ebx
 804d272:	03 1d 3c 89 06 08    	add    0x806893c,%ebx
 804d278:	89 df                	mov    %ebx,%edi
 804d27a:	f3 ab                	rep stos %eax,%es:(%edi)
	threads_table_size += PC_ALLOC_CHUNK_SIZE;
 804d27c:	8d 42 40             	lea    0x40(%edx),%eax
 804d27f:	a3 40 89 06 08       	mov    %eax,0x8068940
	int t_slot;

	t_slot = ttable_get_empty_slot();
	threads_table[t_slot].state = USED;
	threads_table[t_slot].running = false;
	threads_table[t_slot].thead_cnt = thread_create_count++;
 804d284:	8b 0d 38 89 06 08    	mov    0x8068938,%ecx
	threads_table[t_slot].state = USED;
 804d28a:	6b c2 14             	imul   $0x14,%edx,%eax
 804d28d:	03 05 3c 89 06 08    	add    0x806893c,%eax
	threads_table[t_slot].t_status = ptr;
 804d293:	89 70 10             	mov    %esi,0x10(%eax)
	ptr->thread_idx = t_slot;

	PC_SAFE_CALL(pthread_create(&threads_table[t_slot].thread,
 804d296:	83 c0 08             	add    $0x8,%eax
	threads_table[t_slot].state = USED;
 804d299:	c7 40 f8 01 00 00 00 	movl   $0x1,-0x8(%eax)
	threads_table[t_slot].thead_cnt = thread_create_count++;
 804d2a0:	8d 59 01             	lea    0x1(%ecx),%ebx
	threads_table[t_slot].running = false;
 804d2a3:	c6 40 fc 00          	movb   $0x0,-0x4(%eax)
	threads_table[t_slot].thead_cnt = thread_create_count++;
 804d2a7:	89 48 04             	mov    %ecx,0x4(%eax)
	ptr->thread_idx = t_slot;
 804d2aa:	89 56 10             	mov    %edx,0x10(%esi)
	PC_SAFE_CALL(pthread_create(&threads_table[t_slot].thread,
 804d2ad:	52                   	push   %edx
 804d2ae:	68 e9 d0 04 08       	push   $0x804d0e9
 804d2b3:	6a 00                	push   $0x0
 804d2b5:	50                   	push   %eax
	threads_table[t_slot].thead_cnt = thread_create_count++;
 804d2b6:	89 1d 38 89 06 08    	mov    %ebx,0x8068938
	PC_SAFE_CALL(pthread_create(&threads_table[t_slot].thread,
 804d2bc:	e8 cf be ff ff       	call   8049190 <pthread_create@plt>
 804d2c1:	83 c4 10             	add    $0x10,%esp
		__func__,
		threads_table[t_slot].thead_cnt,
		t_slot,
		threads_table[t_slot].thread);

}
 804d2c4:	8d 65 f4             	lea    -0xc(%ebp),%esp
	PC_SAFE_CALL(pthread_create(&threads_table[t_slot].thread,
 804d2c7:	ba d3 2a 06 08       	mov    $0x8062ad3,%edx
}
 804d2cc:	5b                   	pop    %ebx
 804d2cd:	5e                   	pop    %esi
 804d2ce:	5f                   	pop    %edi
 804d2cf:	5d                   	pop    %ebp
	PC_SAFE_CALL(pthread_create(&threads_table[t_slot].thread,
 804d2d0:	e9 15 fd ff ff       	jmp    804cfea <pc_safe_call>

0804d2d5 <posix_init_multithreading>:
/**
 * Called from zephyr_wrapper()
 * prepare whatever needs to be prepared to be able to start threads
 */
void posix_init_multithreading(void)
{
 804d2d5:	55                   	push   %ebp
 804d2d6:	89 e5                	mov    %esp,%ebp
 804d2d8:	83 ec 10             	sub    $0x10,%esp
	thread_create_count = 0;
 804d2db:	c7 05 38 89 06 08 00 	movl   $0x0,0x8068938
 804d2e2:	00 00 00 

	currently_allowed_thread = -1;

	threads_table = calloc(PC_ALLOC_CHUNK_SIZE,
 804d2e5:	6a 14                	push   $0x14
 804d2e7:	6a 40                	push   $0x40
	currently_allowed_thread = -1;
 804d2e9:	c7 05 1c 89 06 08 ff 	movl   $0xffffffff,0x806891c
 804d2f0:	ff ff ff 
	threads_table = calloc(PC_ALLOC_CHUNK_SIZE,
 804d2f3:	e8 08 be ff ff       	call   8049100 <calloc@plt>
 804d2f8:	83 c4 10             	add    $0x10,%esp
 804d2fb:	a3 3c 89 06 08       	mov    %eax,0x806893c
				sizeof(struct threads_table_el));
	if (threads_table == NULL) { /* LCOV_EXCL_BR_LINE */
 804d300:	85 c0                	test   %eax,%eax
 804d302:	75 10                	jne    804d314 <posix_init_multithreading+0x3f>
		posix_print_error_and_exit(NO_MEM_ERR); /* LCOV_EXCL_LINE */
 804d304:	83 ec 0c             	sub    $0xc,%esp
 804d307:	68 ab 2a 06 08       	push   $0x8062aab
 804d30c:	e8 93 12 00 00       	call   804e5a4 <posix_print_error_and_exit>
 804d311:	83 c4 10             	add    $0x10,%esp
	}

	threads_table_size = PC_ALLOC_CHUNK_SIZE;
 804d314:	c7 05 40 89 06 08 40 	movl   $0x40,0x8068940
 804d31b:	00 00 00 


	PC_SAFE_CALL(pthread_mutex_lock(&mtx_threads));
 804d31e:	83 ec 0c             	sub    $0xc,%esp
 804d321:	68 20 89 06 08       	push   $0x8068920
 804d326:	e8 c5 bf ff ff       	call   80492f0 <pthread_mutex_lock@plt>
 804d32b:	83 c4 10             	add    $0x10,%esp
 804d32e:	ba 64 2a 06 08       	mov    $0x8062a64,%edx
}
 804d333:	c9                   	leave  
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_threads));
 804d334:	e9 b1 fc ff ff       	jmp    804cfea <pc_safe_call>

0804d339 <posix_core_clean_up>:
 *
 */
void posix_core_clean_up(void)
{

	if (!threads_table) { /* LCOV_EXCL_BR_LINE */
 804d339:	83 3d 3c 89 06 08 00 	cmpl   $0x0,0x806893c
 804d340:	74 65                	je     804d3a7 <posix_core_clean_up+0x6e>
{
 804d342:	55                   	push   %ebp
 804d343:	89 e5                	mov    %esp,%ebp
 804d345:	53                   	push   %ebx
		return; /* LCOV_EXCL_LINE */
	}

	terminate = true;

	for (int i = 0; i < threads_table_size; i++) {
 804d346:	31 db                	xor    %ebx,%ebx
{
 804d348:	52                   	push   %edx
	terminate = true;
 804d349:	c6 05 ad 8a 06 08 01 	movb   $0x1,0x8068aad
		if (threads_table[i].state != USED) {
 804d350:	a1 3c 89 06 08       	mov    0x806893c,%eax
	for (int i = 0; i < threads_table_size; i++) {
 804d355:	39 1d 40 89 06 08    	cmp    %ebx,0x8068940
 804d35b:	7e 2f                	jle    804d38c <posix_core_clean_up+0x53>
		if (threads_table[i].state != USED) {
 804d35d:	6b d3 14             	imul   $0x14,%ebx,%edx
 804d360:	01 d0                	add    %edx,%eax
 804d362:	83 38 01             	cmpl   $0x1,(%eax)
 804d365:	75 22                	jne    804d389 <posix_core_clean_up+0x50>
			continue;
		}

		/* LCOV_EXCL_START */
		if (pthread_cancel(threads_table[i].thread)) {
 804d367:	83 ec 0c             	sub    $0xc,%esp
 804d36a:	ff 70 08             	push   0x8(%eax)
 804d36d:	e8 0e bf ff ff       	call   8049280 <pthread_cancel@plt>
 804d372:	83 c4 10             	add    $0x10,%esp
 804d375:	85 c0                	test   %eax,%eax
 804d377:	74 10                	je     804d389 <posix_core_clean_up+0x50>
			posix_print_warning(
 804d379:	50                   	push   %eax
 804d37a:	50                   	push   %eax
 804d37b:	53                   	push   %ebx
 804d37c:	68 37 2b 06 08       	push   $0x8062b37
 804d381:	e8 49 12 00 00       	call   804e5cf <posix_print_warning>
 804d386:	83 c4 10             	add    $0x10,%esp
	for (int i = 0; i < threads_table_size; i++) {
 804d389:	43                   	inc    %ebx
 804d38a:	eb c4                	jmp    804d350 <posix_core_clean_up+0x17>
				i);
		}
		/* LCOV_EXCL_STOP */
	}

	free(threads_table);
 804d38c:	83 ec 0c             	sub    $0xc,%esp
 804d38f:	50                   	push   %eax
 804d390:	e8 0b be ff ff       	call   80491a0 <free@plt>
	threads_table = NULL;
}
 804d395:	8b 5d fc             	mov    -0x4(%ebp),%ebx
	free(threads_table);
 804d398:	83 c4 10             	add    $0x10,%esp
	threads_table = NULL;
 804d39b:	c7 05 3c 89 06 08 00 	movl   $0x0,0x806893c
 804d3a2:	00 00 00 
}
 804d3a5:	c9                   	leave  
 804d3a6:	c3                   	ret    
 804d3a7:	c3                   	ret    

0804d3a8 <posix_abort_thread>:


void posix_abort_thread(int thread_idx)
{
 804d3a8:	55                   	push   %ebp
 804d3a9:	89 e5                	mov    %esp,%ebp
	if (threads_table[thread_idx].state != USED) { /* LCOV_EXCL_BR_LINE */
 804d3ab:	6b 45 08 14          	imul   $0x14,0x8(%ebp),%eax
 804d3af:	03 05 3c 89 06 08    	add    0x806893c,%eax
 804d3b5:	83 38 01             	cmpl   $0x1,(%eax)
 804d3b8:	75 06                	jne    804d3c0 <posix_abort_thread+0x18>

	PC_DEBUG("Aborting not scheduled thread [%i] %i\n",
		threads_table[thread_idx].thead_cnt,
		thread_idx);

	threads_table[thread_idx].state = ABORTING;
 804d3ba:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
	 * mutex or awakes on the condition.
	 * Note that even if we would pthread_cancel() the thread here, that
	 * would be the case, but with a pthread_cancel() the mutex state would
	 * be uncontrolled
	 */
}
 804d3c0:	5d                   	pop    %ebp
 804d3c1:	c3                   	ret    

0804d3c2 <z_impl_k_thread_abort>:


#if defined(CONFIG_ARCH_HAS_THREAD_ABORT)
void z_impl_k_thread_abort(k_tid_t thread)
{
 804d3c2:	55                   	push   %ebp
 804d3c3:	89 e5                	mov    %esp,%ebp
 804d3c5:	57                   	push   %edi
 804d3c6:	56                   	push   %esi
 804d3c7:	53                   	push   %ebx
 804d3c8:	83 ec 1c             	sub    $0x1c,%esp
 804d3cb:	8b 75 08             	mov    0x8(%ebp),%esi
	unsigned int key;
	int thread_idx;

	posix_thread_status_t *tstatus =
 804d3ce:	8b 5e 34             	mov    0x34(%esi),%ebx
					(posix_thread_status_t *)
					thread->callee_saved.thread_status;

	thread_idx = tstatus->thread_idx;
 804d3d1:	8b 7b 10             	mov    0x10(%ebx),%edi
	return key == false;
}

static ALWAYS_INLINE unsigned int arch_irq_lock(void)
{
	return posix_irq_lock();
 804d3d4:	e8 46 0d 00 00       	call   804e11f <posix_irq_lock>
 804d3d9:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	key = irq_lock();

	if (_current == thread) {
 804d3dc:	39 35 e8 87 06 08    	cmp    %esi,0x80687e8
 804d3e2:	75 2e                	jne    804d412 <z_impl_k_thread_abort+0x50>
		if (tstatus->aborted == 0) { /* LCOV_EXCL_BR_LINE */
 804d3e4:	83 7b 14 00          	cmpl   $0x0,0x14(%ebx)
 804d3e8:	75 09                	jne    804d3f3 <z_impl_k_thread_abort+0x31>
			tstatus->aborted = 1;
 804d3ea:	c7 43 14 01 00 00 00 	movl   $0x1,0x14(%ebx)
 804d3f1:	eb 10                	jmp    804d403 <z_impl_k_thread_abort+0x41>
		} else {
			posix_print_warning(/* LCOV_EXCL_LINE */
 804d3f3:	50                   	push   %eax
 804d3f4:	50                   	push   %eax
 804d3f5:	57                   	push   %edi
 804d3f6:	68 6b 2b 06 08       	push   $0x8062b6b
 804d3fb:	e8 cf 11 00 00       	call   804e5cf <posix_print_warning>
 804d400:	83 c4 10             	add    $0x10,%esp
				PREFIX"The kernel is trying to abort and swap "
				"out of an already aborted thread %i. This "
				"should NOT have happened\n",
				thread_idx);
		}
		threads_table[thread_idx].state = ABORTING;
 804d403:	6b c7 14             	imul   $0x14,%edi,%eax
 804d406:	03 05 3c 89 06 08    	add    0x806893c,%eax
 804d40c:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
			threads_table[thread_idx].thead_cnt,
			thread_idx,
			__func__);
	}

	z_thread_abort(thread);
 804d412:	83 ec 0c             	sub    $0xc,%esp
 804d415:	56                   	push   %esi
 804d416:	e8 bf 31 01 00       	call   80605da <z_thread_abort>
 804d41b:	83 c4 10             	add    $0x10,%esp

	if (tstatus->aborted == 0) {
 804d41e:	83 7b 14 00          	cmpl   $0x0,0x14(%ebx)
 804d422:	75 13                	jne    804d437 <z_impl_k_thread_abort+0x75>
			__func__,
			threads_table[thread_idx].thead_cnt,
			thread_idx);

		tstatus->aborted = 1;
		posix_abort_thread(thread_idx);
 804d424:	83 ec 0c             	sub    $0xc,%esp
		tstatus->aborted = 1;
 804d427:	c7 43 14 01 00 00 00 	movl   $0x1,0x14(%ebx)
		posix_abort_thread(thread_idx);
 804d42e:	57                   	push   %edi
 804d42f:	e8 74 ff ff ff       	call   804d3a8 <posix_abort_thread>
 804d434:	83 c4 10             	add    $0x10,%esp
			threads_table[thread_idx].thead_cnt,
			thread_idx);
	}

	/* The abort handler might have altered the ready queue. */
	z_reschedule_irqlock(key);
 804d437:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804d43a:	89 45 08             	mov    %eax,0x8(%ebp)
}
 804d43d:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804d440:	5b                   	pop    %ebx
 804d441:	5e                   	pop    %esi
 804d442:	5f                   	pop    %edi
 804d443:	5d                   	pop    %ebp
	z_reschedule_irqlock(key);
 804d444:	e9 4d 2a 01 00       	jmp    805fe96 <z_reschedule_irqlock>

0804d449 <arch_swap>:
#include <zephyr/irq.h>
#include "kswap.h"
#include <zephyr/pm/pm.h>

int arch_swap(unsigned int key)
{
 804d449:	55                   	push   %ebp
 804d44a:	89 e5                	mov    %esp,%ebp
 804d44c:	83 ec 10             	sub    $0x10,%esp
	 * threads => those are all nicely kept by the native OS kernel
	 */
#if CONFIG_INSTRUMENT_THREAD_SWITCHING
	z_thread_mark_switched_out();
#endif
	_current->callee_saved.key = key;
 804d44f:	a1 e8 87 06 08       	mov    0x80687e8,%eax
 804d454:	8b 55 08             	mov    0x8(%ebp),%edx
	_current->callee_saved.retval = -EAGAIN;
 804d457:	c7 40 30 f5 ff ff ff 	movl   $0xfffffff5,0x30(%eax)
	_current->callee_saved.key = key;
 804d45e:	89 50 2c             	mov    %edx,0x2c(%eax)
	 * arch_thread_return_value_set()
	 */

	posix_thread_status_t *ready_thread_ptr =
		(posix_thread_status_t *)
		_kernel.ready_q.cache->callee_saved.thread_status;
 804d461:	8b 15 f4 87 06 08    	mov    0x80687f4,%edx

	posix_thread_status_t *this_thread_ptr  =
 804d467:	8b 40 34             	mov    0x34(%eax),%eax
	posix_thread_status_t *ready_thread_ptr =
 804d46a:	8b 4a 34             	mov    0x34(%edx),%ecx
		(posix_thread_status_t *)
		_current->callee_saved.thread_status;


	_current = _kernel.ready_q.cache;
 804d46d:	89 15 e8 87 06 08    	mov    %edx,0x80687e8
	 * Here a "real" arch would load all processor registers for the thread
	 * to run. In this arch case, we just block this thread until allowed
	 * to run later, and signal to whomever is allowed to run to
	 * continue.
	 */
	posix_swap(ready_thread_ptr->thread_idx,
 804d473:	ff 70 10             	push   0x10(%eax)
 804d476:	ff 71 10             	push   0x10(%ecx)
 804d479:	e8 15 fd ff ff       	call   804d193 <posix_swap>
 804d47e:	58                   	pop    %eax
		this_thread_ptr->thread_idx);

	/* When we continue, _kernel->current points back to this thread */

	irq_unlock(_current->callee_saved.key);
 804d47f:	a1 e8 87 06 08       	mov    0x80687e8,%eax
}


static ALWAYS_INLINE void arch_irq_unlock(unsigned int key)
{
	posix_irq_unlock(key);
 804d484:	ff 70 2c             	push   0x2c(%eax)
 804d487:	e8 a5 0c 00 00       	call   804e131 <posix_irq_unlock>

	return _current->callee_saved.retval;
 804d48c:	a1 e8 87 06 08       	mov    0x80687e8,%eax
 804d491:	83 c4 10             	add    $0x10,%esp
 804d494:	8b 40 30             	mov    0x30(%eax),%eax
}
 804d497:	c9                   	leave  
 804d498:	c3                   	ret    

0804d499 <arch_switch_to_main_thread>:
	ARG_UNUSED(stack_ptr);
	ARG_UNUSED(_main);

	posix_thread_status_t *ready_thread_ptr =
			(posix_thread_status_t *)
			_kernel.ready_q.cache->callee_saved.thread_status;
 804d499:	a1 f4 87 06 08       	mov    0x80687f4,%eax
{
 804d49e:	55                   	push   %ebp
	posix_thread_status_t *ready_thread_ptr =
 804d49f:	8b 50 34             	mov    0x34(%eax),%edx

#ifdef CONFIG_INSTRUMENT_THREAD_SWITCHING
	z_thread_mark_switched_out();
#endif

	_current = _kernel.ready_q.cache;
 804d4a2:	a3 e8 87 06 08       	mov    %eax,0x80687e8
{
 804d4a7:	89 e5                	mov    %esp,%ebp

#ifdef CONFIG_INSTRUMENT_THREAD_SWITCHING
	z_thread_mark_switched_in();
#endif

	posix_main_thread_start(ready_thread_ptr->thread_idx);
 804d4a9:	8b 42 10             	mov    0x10(%edx),%eax
 804d4ac:	89 45 08             	mov    %eax,0x8(%ebp)
} /* LCOV_EXCL_LINE */
 804d4af:	5d                   	pop    %ebp
	posix_main_thread_start(ready_thread_ptr->thread_idx);
 804d4b0:	e9 25 fd ff ff       	jmp    804d1da <posix_main_thread_start>

0804d4b5 <arch_new_thread>:
 * pthreads stack and therefore we ignore the stack size
 */
void arch_new_thread(struct k_thread *thread, k_thread_stack_t *stack,
		     char *stack_ptr, k_thread_entry_t entry,
		     void *p1, void *p2, void *p3)
{
 804d4b5:	55                   	push   %ebp
 804d4b6:	89 e5                	mov    %esp,%ebp
 804d4b8:	8b 45 10             	mov    0x10(%ebp),%eax
	 * "initial stack frame"
	 */
	thread_status = Z_STACK_PTR_TO_FRAME(posix_thread_status_t, stack_ptr);

	/* z_thread_entry() arguments */
	thread_status->entry_point = entry;
 804d4bb:	8b 4d 14             	mov    0x14(%ebp),%ecx
 804d4be:	89 48 e8             	mov    %ecx,-0x18(%eax)
	thread_status->arg1 = p1;
 804d4c1:	8b 4d 18             	mov    0x18(%ebp),%ecx
	thread_status = Z_STACK_PTR_TO_FRAME(posix_thread_status_t, stack_ptr);
 804d4c4:	8d 50 e8             	lea    -0x18(%eax),%edx
	thread_status->arg2 = p2;
	thread_status->arg3 = p3;
#if defined(CONFIG_ARCH_HAS_THREAD_ABORT)
	thread_status->aborted = 0;
 804d4c7:	c7 40 fc 00 00 00 00 	movl   $0x0,-0x4(%eax)
	thread_status->arg1 = p1;
 804d4ce:	89 48 ec             	mov    %ecx,-0x14(%eax)
	thread_status->arg2 = p2;
 804d4d1:	8b 4d 1c             	mov    0x1c(%ebp),%ecx
 804d4d4:	89 48 f0             	mov    %ecx,-0x10(%eax)
	thread_status->arg3 = p3;
 804d4d7:	8b 4d 20             	mov    0x20(%ebp),%ecx
 804d4da:	89 48 f4             	mov    %ecx,-0xc(%eax)
#endif

	thread->callee_saved.thread_status = thread_status;
 804d4dd:	8b 45 08             	mov    0x8(%ebp),%eax
 804d4e0:	89 50 34             	mov    %edx,0x34(%eax)

	posix_new_thread(thread_status);
 804d4e3:	89 55 08             	mov    %edx,0x8(%ebp)
}
 804d4e6:	5d                   	pop    %ebp
	posix_new_thread(thread_status);
 804d4e7:	e9 22 fd ff ff       	jmp    804d20e <posix_new_thread>

0804d4ec <posix_new_thread_pre_start>:

void posix_new_thread_pre_start(void)
{
	posix_irq_full_unlock();
 804d4ec:	e9 45 0c 00 00       	jmp    804e136 <posix_irq_full_unlock>

0804d4f1 <pc_safe_call>:
	if (unlikely(test)) {
 804d4f1:	85 c0                	test   %eax,%eax
 804d4f3:	74 16                	je     804d50b <pc_safe_call+0x1a>
{
 804d4f5:	55                   	push   %ebp
 804d4f6:	89 e5                	mov    %esp,%ebp
 804d4f8:	83 ec 10             	sub    $0x10,%esp
		posix_print_error_and_exit("POSIX arch: Error on: %s\n",
 804d4fb:	52                   	push   %edx
 804d4fc:	68 27 2a 06 08       	push   $0x8062a27
 804d501:	e8 9e 10 00 00       	call   804e5a4 <posix_print_error_and_exit>
 804d506:	83 c4 10             	add    $0x10,%esp
}
 804d509:	c9                   	leave  
 804d50a:	c3                   	ret    
 804d50b:	c3                   	ret    

0804d50c <zephyr_wrapper>:
/**
 * Just a wrapper function to call Zephyr's z_cstart()
 * called from posix_boot_cpu()
 */
static void *zephyr_wrapper(void *a)
{
 804d50c:	55                   	push   %ebp
 804d50d:	89 e5                	mov    %esp,%ebp
 804d50f:	83 ec 14             	sub    $0x14,%esp
	/* Ensure posix_boot_cpu has reached the cond loop */
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
 804d512:	68 44 89 06 08       	push   $0x8068944
 804d517:	e8 d4 bd ff ff       	call   80492f0 <pthread_mutex_lock@plt>
 804d51c:	ba e7 2b 06 08       	mov    $0x8062be7,%edx
 804d521:	83 c4 10             	add    $0x10,%esp
 804d524:	e8 c8 ff ff ff       	call   804d4f1 <pc_safe_call>
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
 804d529:	83 ec 0c             	sub    $0xc,%esp
 804d52c:	68 44 89 06 08       	push   $0x8068944
 804d531:	e8 ca bc ff ff       	call   8049200 <pthread_mutex_unlock@plt>
 804d536:	83 c4 10             	add    $0x10,%esp
 804d539:	ba 04 2c 06 08       	mov    $0x8062c04,%edx
 804d53e:	e8 ae ff ff ff       	call   804d4f1 <pc_safe_call>

		PS_DEBUG("Zephyr init started (%lu)\n",
			zephyr_thread);
#endif

	posix_init_multithreading();
 804d543:	e8 8d fd ff ff       	call   804d2d5 <posix_init_multithreading>

	/* Start Zephyr: */
	z_cstart();
 804d548:	e8 e6 16 01 00       	call   805ec33 <z_cstart>

0804d54d <posix_is_cpu_running>:
	return !cpu_halted;
 804d54d:	a0 e8 73 06 08       	mov    0x80673e8,%al
 804d552:	83 f0 01             	xor    $0x1,%eax
 804d555:	0f b6 c0             	movzbl %al,%eax
}
 804d558:	c3                   	ret    

0804d559 <posix_change_cpu_state_and_wait>:
{
 804d559:	55                   	push   %ebp
 804d55a:	89 e5                	mov    %esp,%ebp
 804d55c:	56                   	push   %esi
 804d55d:	53                   	push   %ebx
 804d55e:	8b 75 08             	mov    0x8(%ebp),%esi
 804d561:	89 f3                	mov    %esi,%ebx
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
 804d563:	83 ec 0c             	sub    $0xc,%esp
 804d566:	68 44 89 06 08       	push   $0x8068944
 804d56b:	e8 80 bd ff ff       	call   80492f0 <pthread_mutex_lock@plt>
 804d570:	ba e7 2b 06 08       	mov    $0x8062be7,%edx
 804d575:	83 c4 10             	add    $0x10,%esp
 804d578:	e8 74 ff ff ff       	call   804d4f1 <pc_safe_call>
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_cpu));
 804d57d:	83 ec 0c             	sub    $0xc,%esp
	cpu_halted = halted;
 804d580:	88 1d e8 73 06 08    	mov    %bl,0x80673e8
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_cpu));
 804d586:	68 60 78 06 08       	push   $0x8067860
 804d58b:	e8 20 be ff ff       	call   80493b0 <pthread_cond_broadcast@plt>
 804d590:	83 c4 10             	add    $0x10,%esp
 804d593:	ba 23 2c 06 08       	mov    $0x8062c23,%edx
 804d598:	e8 54 ff ff ff       	call   804d4f1 <pc_safe_call>
	while (cpu_halted == halted) {
 804d59d:	38 1d e8 73 06 08    	cmp    %bl,0x80673e8
 804d5a3:	75 16                	jne    804d5bb <posix_change_cpu_state_and_wait+0x62>
		pthread_cond_wait(&cond_cpu, &mtx_cpu);
 804d5a5:	50                   	push   %eax
 804d5a6:	50                   	push   %eax
 804d5a7:	68 44 89 06 08       	push   $0x8068944
 804d5ac:	68 60 78 06 08       	push   $0x8067860
 804d5b1:	e8 7a bd ff ff       	call   8049330 <pthread_cond_wait@plt>
 804d5b6:	83 c4 10             	add    $0x10,%esp
 804d5b9:	eb e2                	jmp    804d59d <posix_change_cpu_state_and_wait+0x44>
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
 804d5bb:	83 ec 0c             	sub    $0xc,%esp
 804d5be:	68 44 89 06 08       	push   $0x8068944
 804d5c3:	e8 38 bc ff ff       	call   8049200 <pthread_mutex_unlock@plt>
 804d5c8:	83 c4 10             	add    $0x10,%esp
}
 804d5cb:	8d 65 f8             	lea    -0x8(%ebp),%esp
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
 804d5ce:	ba 04 2c 06 08       	mov    $0x8062c04,%edx
}
 804d5d3:	5b                   	pop    %ebx
 804d5d4:	5e                   	pop    %esi
 804d5d5:	5d                   	pop    %ebp
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
 804d5d6:	e9 16 ff ff ff       	jmp    804d4f1 <pc_safe_call>

0804d5db <posix_interrupt_raised>:
{
 804d5db:	55                   	push   %ebp
 804d5dc:	89 e5                	mov    %esp,%ebp
 804d5de:	83 ec 14             	sub    $0x14,%esp
	posix_change_cpu_state_and_wait(false);
 804d5e1:	6a 00                	push   $0x0
 804d5e3:	e8 71 ff ff ff       	call   804d559 <posix_change_cpu_state_and_wait>
 804d5e8:	83 c4 10             	add    $0x10,%esp
	if (soc_terminate) {
 804d5eb:	80 3d ae 8a 06 08 00 	cmpb   $0x0,0x8068aae
 804d5f2:	74 0d                	je     804d601 <posix_interrupt_raised+0x26>
		posix_exit(0);
 804d5f4:	83 ec 0c             	sub    $0xc,%esp
 804d5f7:	6a 00                	push   $0x0
 804d5f9:	e8 4c 0e 00 00       	call   804e44a <posix_exit>
 804d5fe:	83 c4 10             	add    $0x10,%esp
}
 804d601:	c9                   	leave  
 804d602:	c3                   	ret    

0804d603 <posix_halt_cpu>:
{
 804d603:	55                   	push   %ebp
 804d604:	89 e5                	mov    %esp,%ebp
 804d606:	83 ec 14             	sub    $0x14,%esp
	posix_change_cpu_state_and_wait(true);
 804d609:	6a 01                	push   $0x1
 804d60b:	e8 49 ff ff ff       	call   804d559 <posix_change_cpu_state_and_wait>
 804d610:	83 c4 10             	add    $0x10,%esp
}
 804d613:	c9                   	leave  
	posix_irq_handler();
 804d614:	e9 bc 09 00 00       	jmp    804dfd5 <posix_irq_handler>

0804d619 <posix_boot_cpu>:
 * The HW models will call this function to "boot" the CPU
 * == spawn the Zephyr init thread, which will then spawn
 * anything it wants, and run until the CPU is set back to idle again
 */
void posix_boot_cpu(void)
{
 804d619:	55                   	push   %ebp
 804d61a:	89 e5                	mov    %esp,%ebp
 804d61c:	83 ec 24             	sub    $0x24,%esp
 804d61f:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 804d625:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804d628:	31 c0                	xor    %eax,%eax
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
 804d62a:	68 44 89 06 08       	push   $0x8068944
 804d62f:	e8 bc bc ff ff       	call   80492f0 <pthread_mutex_lock@plt>
 804d634:	83 c4 10             	add    $0x10,%esp
 804d637:	ba e7 2b 06 08       	mov    $0x8062be7,%edx
 804d63c:	e8 b0 fe ff ff       	call   804d4f1 <pc_safe_call>
	cpu_halted = false;

	pthread_t zephyr_thread;

	/* Create a thread for Zephyr init: */
	PC_SAFE_CALL(pthread_create(&zephyr_thread, NULL, zephyr_wrapper, NULL));
 804d641:	8d 45 f0             	lea    -0x10(%ebp),%eax
 804d644:	6a 00                	push   $0x0
 804d646:	68 0c d5 04 08       	push   $0x804d50c
 804d64b:	6a 00                	push   $0x0
 804d64d:	50                   	push   %eax
	cpu_halted = false;
 804d64e:	c6 05 e8 73 06 08 00 	movb   $0x0,0x80673e8
	PC_SAFE_CALL(pthread_create(&zephyr_thread, NULL, zephyr_wrapper, NULL));
 804d655:	e8 36 bb ff ff       	call   8049190 <pthread_create@plt>
 804d65a:	83 c4 10             	add    $0x10,%esp
 804d65d:	ba 45 2c 06 08       	mov    $0x8062c45,%edx
 804d662:	e8 8a fe ff ff       	call   804d4f1 <pc_safe_call>

	/* And we wait until Zephyr has run til completion (has gone to idle) */
	while (cpu_halted == false) {
 804d667:	80 3d e8 73 06 08 00 	cmpb   $0x0,0x80673e8
 804d66e:	75 16                	jne    804d686 <posix_boot_cpu+0x6d>
		pthread_cond_wait(&cond_cpu, &mtx_cpu);
 804d670:	50                   	push   %eax
 804d671:	50                   	push   %eax
 804d672:	68 44 89 06 08       	push   $0x8068944
 804d677:	68 60 78 06 08       	push   $0x8067860
 804d67c:	e8 af bc ff ff       	call   8049330 <pthread_cond_wait@plt>
 804d681:	83 c4 10             	add    $0x10,%esp
 804d684:	eb e1                	jmp    804d667 <posix_boot_cpu+0x4e>
	}
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
 804d686:	83 ec 0c             	sub    $0xc,%esp
 804d689:	68 44 89 06 08       	push   $0x8068944
 804d68e:	e8 6d bb ff ff       	call   8049200 <pthread_mutex_unlock@plt>
 804d693:	83 c4 10             	add    $0x10,%esp
 804d696:	ba 04 2c 06 08       	mov    $0x8062c04,%edx
 804d69b:	e8 51 fe ff ff       	call   804d4f1 <pc_safe_call>

	if (soc_terminate) {
 804d6a0:	80 3d ae 8a 06 08 00 	cmpb   $0x0,0x8068aae
 804d6a7:	74 0d                	je     804d6b6 <posix_boot_cpu+0x9d>
		posix_exit(0);
 804d6a9:	83 ec 0c             	sub    $0xc,%esp
 804d6ac:	6a 00                	push   $0x0
 804d6ae:	e8 97 0d 00 00       	call   804e44a <posix_exit>
 804d6b3:	83 c4 10             	add    $0x10,%esp
	}
}
 804d6b6:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804d6b9:	65 2b 05 14 00 00 00 	sub    %gs:0x14,%eax
 804d6c0:	74 05                	je     804d6c7 <posix_boot_cpu+0xae>
 804d6c2:	e8 39 bc ff ff       	call   8049300 <__stack_chk_fail@plt>
 804d6c7:	c9                   	leave  
 804d6c8:	c3                   	ret    

0804d6c9 <run_native_tasks>:
 * @brief Run the set of special native tasks corresponding to the given level
 *
 * @param level One of _NATIVE_*_LEVEL as defined in soc.h
 */
void run_native_tasks(int level)
{
 804d6c9:	55                   	push   %ebp
 804d6ca:	89 e5                	mov    %esp,%ebp
 804d6cc:	56                   	push   %esi
 804d6cd:	8b 75 08             	mov    0x8(%ebp),%esi
 804d6d0:	53                   	push   %ebx
		__native_tasks_end
	};

	void (**fptr)(void);

	for (fptr = native_pre_tasks[level]; fptr < native_pre_tasks[level+1];
 804d6d1:	8b 1c b5 d4 23 06 08 	mov    0x80623d4(,%esi,4),%ebx
 804d6d8:	39 1c b5 d8 23 06 08 	cmp    %ebx,0x80623d8(,%esi,4)
 804d6df:	76 0d                	jbe    804d6ee <run_native_tasks+0x25>
		fptr++) {
		if (*fptr) { /* LCOV_EXCL_BR_LINE */
 804d6e1:	8b 03                	mov    (%ebx),%eax
 804d6e3:	85 c0                	test   %eax,%eax
 804d6e5:	74 02                	je     804d6e9 <run_native_tasks+0x20>
			(*fptr)();
 804d6e7:	ff d0                	call   *%eax
		fptr++) {
 804d6e9:	83 c3 04             	add    $0x4,%ebx
 804d6ec:	eb ea                	jmp    804d6d8 <run_native_tasks+0xf>
		}
	}
}
 804d6ee:	5b                   	pop    %ebx
 804d6ef:	5e                   	pop    %esi
 804d6f0:	5d                   	pop    %ebp
 804d6f1:	c3                   	ret    

0804d6f2 <posix_soc_clean_up>:
 * Clean up all memory allocated by the SOC and POSIX core
 *
 * This function can be called from both HW and SW threads
 */
void posix_soc_clean_up(void)
{
 804d6f2:	55                   	push   %ebp
 804d6f3:	89 e5                	mov    %esp,%ebp
 804d6f5:	83 ec 08             	sub    $0x8,%esp
	 * If we are being called from a HW thread we can cleanup
	 *
	 * Otherwise (!cpu_halted) we give back control to the HW thread and
	 * tell it to terminate ASAP
	 */
	if (cpu_halted) {
 804d6f8:	80 3d e8 73 06 08 00 	cmpb   $0x0,0x80673e8
 804d6ff:	74 14                	je     804d715 <posix_soc_clean_up+0x23>

		posix_core_clean_up();
 804d701:	e8 33 fc ff ff       	call   804d339 <posix_core_clean_up>
		run_native_tasks(_NATIVE_ON_EXIT_LEVEL);
 804d706:	83 ec 0c             	sub    $0xc,%esp
 804d709:	6a 04                	push   $0x4
 804d70b:	e8 b9 ff ff ff       	call   804d6c9 <run_native_tasks>
 804d710:	83 c4 10             	add    $0x10,%esp
 804d713:	eb 74                	jmp    804d789 <posix_soc_clean_up+0x97>

	} else if (soc_terminate == false) {
 804d715:	80 3d ae 8a 06 08 00 	cmpb   $0x0,0x8068aae
 804d71c:	75 6b                	jne    804d789 <posix_soc_clean_up+0x97>

		soc_terminate = true;

		PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
 804d71e:	83 ec 0c             	sub    $0xc,%esp
		soc_terminate = true;
 804d721:	c6 05 ae 8a 06 08 01 	movb   $0x1,0x8068aae
		PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
 804d728:	68 44 89 06 08       	push   $0x8068944
 804d72d:	e8 be bb ff ff       	call   80492f0 <pthread_mutex_lock@plt>
 804d732:	ba e7 2b 06 08       	mov    $0x8062be7,%edx
 804d737:	83 c4 10             	add    $0x10,%esp
 804d73a:	e8 b2 fd ff ff       	call   804d4f1 <pc_safe_call>

		cpu_halted = true;

		PC_SAFE_CALL(pthread_cond_broadcast(&cond_cpu));
 804d73f:	83 ec 0c             	sub    $0xc,%esp
		cpu_halted = true;
 804d742:	c6 05 e8 73 06 08 01 	movb   $0x1,0x80673e8
		PC_SAFE_CALL(pthread_cond_broadcast(&cond_cpu));
 804d749:	68 60 78 06 08       	push   $0x8067860
 804d74e:	e8 5d bc ff ff       	call   80493b0 <pthread_cond_broadcast@plt>
 804d753:	ba 23 2c 06 08       	mov    $0x8062c23,%edx
 804d758:	83 c4 10             	add    $0x10,%esp
 804d75b:	e8 91 fd ff ff       	call   804d4f1 <pc_safe_call>
		PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
 804d760:	83 ec 0c             	sub    $0xc,%esp
 804d763:	68 44 89 06 08       	push   $0x8068944
 804d768:	e8 93 ba ff ff       	call   8049200 <pthread_mutex_unlock@plt>
 804d76d:	83 c4 10             	add    $0x10,%esp
 804d770:	ba 04 2c 06 08       	mov    $0x8062c04,%edx
 804d775:	e8 77 fd ff ff       	call   804d4f1 <pc_safe_call>

		while (1) {
			sleep(1);
 804d77a:	83 ec 0c             	sub    $0xc,%esp
 804d77d:	6a 01                	push   $0x1
 804d77f:	e8 9c bb ff ff       	call   8049320 <sleep@plt>
 804d784:	83 c4 10             	add    $0x10,%esp
		while (1) {
 804d787:	eb f1                	jmp    804d77a <posix_soc_clean_up+0x88>
			 * won't really wait 1 second
			 */
		}
	}
	/* LCOV_EXCL_STOP */
}
 804d789:	c9                   	leave  
 804d78a:	c3                   	ret    

0804d78b <hwm_signal_end_handler>:
/**
 * Handler for SIGTERM and SIGINT
 */
void hwm_signal_end_handler(int sig)
{
	signaled_end = 1;
 804d78b:	c7 05 5c 89 06 08 01 	movl   $0x1,0x806895c
 804d792:	00 00 00 
}
 804d795:	c3                   	ret    

0804d796 <hwm_set_sig_handler>:
 *
 * Note that SA_RESETHAND requires either _POSIX_C_SOURCE>=200809 or
 * _XOPEN_SOURCE>=500
 */
void hwm_set_sig_handler(void)
{
 804d796:	55                   	push   %ebp
 804d797:	89 e5                	mov    %esp,%ebp
 804d799:	53                   	push   %ebx
 804d79a:	81 ec a0 00 00 00    	sub    $0xa0,%esp
 804d7a0:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 804d7a6:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804d7a9:	31 c0                	xor    %eax,%eax
	struct sigaction act;

	act.sa_handler = hwm_signal_end_handler;
	PC_SAFE_CALL(sigemptyset(&act.sa_mask));
 804d7ab:	8d 85 6c ff ff ff    	lea    -0x94(%ebp),%eax
	act.sa_handler = hwm_signal_end_handler;
 804d7b1:	c7 85 68 ff ff ff 8b 	movl   $0x804d78b,-0x98(%ebp)
 804d7b8:	d7 04 08 
	PC_SAFE_CALL(sigemptyset(&act.sa_mask));
 804d7bb:	50                   	push   %eax
 804d7bc:	e8 8f b8 ff ff       	call   8049050 <sigemptyset@plt>
 804d7c1:	83 c4 10             	add    $0x10,%esp
	if (unlikely(test)) {
 804d7c4:	85 c0                	test   %eax,%eax
 804d7c6:	74 14                	je     804d7dc <hwm_set_sig_handler+0x46>
		posix_print_error_and_exit("POSIX arch: Error on: %s\n",
 804d7c8:	50                   	push   %eax
 804d7c9:	50                   	push   %eax
 804d7ca:	68 80 2c 06 08       	push   $0x8062c80
 804d7cf:	68 27 2a 06 08       	push   $0x8062a27
 804d7d4:	e8 cb 0d 00 00       	call   804e5a4 <posix_print_error_and_exit>
 804d7d9:	83 c4 10             	add    $0x10,%esp

	act.sa_flags = SA_RESETHAND;

	PC_SAFE_CALL(sigaction(SIGTERM, &act, NULL));
 804d7dc:	53                   	push   %ebx
 804d7dd:	8d 9d 68 ff ff ff    	lea    -0x98(%ebp),%ebx
 804d7e3:	6a 00                	push   $0x0
 804d7e5:	53                   	push   %ebx
 804d7e6:	6a 0f                	push   $0xf
	act.sa_flags = SA_RESETHAND;
 804d7e8:	c7 45 ec 00 00 00 80 	movl   $0x80000000,-0x14(%ebp)
	PC_SAFE_CALL(sigaction(SIGTERM, &act, NULL));
 804d7ef:	e8 cc b9 ff ff       	call   80491c0 <sigaction@plt>
 804d7f4:	83 c4 10             	add    $0x10,%esp
	if (unlikely(test)) {
 804d7f7:	85 c0                	test   %eax,%eax
 804d7f9:	74 14                	je     804d80f <hwm_set_sig_handler+0x79>
		posix_print_error_and_exit("POSIX arch: Error on: %s\n",
 804d7fb:	51                   	push   %ecx
 804d7fc:	51                   	push   %ecx
 804d7fd:	68 9a 2c 06 08       	push   $0x8062c9a
 804d802:	68 27 2a 06 08       	push   $0x8062a27
 804d807:	e8 98 0d 00 00       	call   804e5a4 <posix_print_error_and_exit>
 804d80c:	83 c4 10             	add    $0x10,%esp
	PC_SAFE_CALL(sigaction(SIGINT, &act, NULL));
 804d80f:	52                   	push   %edx
 804d810:	6a 00                	push   $0x0
 804d812:	53                   	push   %ebx
 804d813:	6a 02                	push   $0x2
 804d815:	e8 a6 b9 ff ff       	call   80491c0 <sigaction@plt>
 804d81a:	83 c4 10             	add    $0x10,%esp
	if (unlikely(test)) {
 804d81d:	85 c0                	test   %eax,%eax
 804d81f:	74 14                	je     804d835 <hwm_set_sig_handler+0x9f>
		posix_print_error_and_exit("POSIX arch: Error on: %s\n",
 804d821:	50                   	push   %eax
 804d822:	50                   	push   %eax
 804d823:	68 b9 2c 06 08       	push   $0x8062cb9
 804d828:	68 27 2a 06 08       	push   $0x8062a27
 804d82d:	e8 72 0d 00 00       	call   804e5a4 <posix_print_error_and_exit>
 804d832:	83 c4 10             	add    $0x10,%esp
}
 804d835:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804d838:	65 2b 05 14 00 00 00 	sub    %gs:0x14,%eax
 804d83f:	74 05                	je     804d846 <hwm_set_sig_handler+0xb0>
 804d841:	e8 ba ba ff ff       	call   8049300 <__stack_chk_fail@plt>
 804d846:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 804d849:	c9                   	leave  
 804d84a:	c3                   	ret    

0804d84b <hwm_find_next_timer>:
{
	next_timer_index = 0;
	next_timer_time  = *Timer_list[0];

	for (unsigned int i = 1; i < NUMBER_OF_TIMERS ; i++) {
		if (next_timer_time > *Timer_list[i]) {
 804d84b:	8b 15 50 73 06 08    	mov    0x8067350,%edx
 804d851:	a1 54 73 06 08       	mov    0x8067354,%eax
{
 804d856:	55                   	push   %ebp
	next_timer_time  = *Timer_list[0];
 804d857:	8b 0d bc 88 06 08    	mov    0x80688bc,%ecx
	next_timer_index = 0;
 804d85d:	c7 05 60 73 06 08 00 	movl   $0x0,0x8067360
 804d864:	00 00 00 
{
 804d867:	89 e5                	mov    %esp,%ebp
 804d869:	53                   	push   %ebx
	next_timer_time  = *Timer_list[0];
 804d86a:	8b 1d b8 88 06 08    	mov    0x80688b8,%ebx
 804d870:	89 0d 74 88 06 08    	mov    %ecx,0x8068874
		if (next_timer_time > *Timer_list[i]) {
 804d876:	39 da                	cmp    %ebx,%edx
	next_timer_time  = *Timer_list[0];
 804d878:	89 1d 70 88 06 08    	mov    %ebx,0x8068870
		if (next_timer_time > *Timer_list[i]) {
 804d87e:	89 c3                	mov    %eax,%ebx
 804d880:	19 cb                	sbb    %ecx,%ebx
 804d882:	73 15                	jae    804d899 <hwm_find_next_timer+0x4e>
			next_timer_index = i;
 804d884:	c7 05 60 73 06 08 01 	movl   $0x1,0x8067360
 804d88b:	00 00 00 
			next_timer_time = *Timer_list[i];
 804d88e:	89 15 70 88 06 08    	mov    %edx,0x8068870
 804d894:	a3 74 88 06 08       	mov    %eax,0x8068874
		if (next_timer_time > *Timer_list[i]) {
 804d899:	a1 f4 88 06 08       	mov    0x80688f4,%eax
 804d89e:	8b 15 f0 88 06 08    	mov    0x80688f0,%edx
 804d8a4:	3b 15 70 88 06 08    	cmp    0x8068870,%edx
 804d8aa:	89 c1                	mov    %eax,%ecx
 804d8ac:	1b 0d 74 88 06 08    	sbb    0x8068874,%ecx
 804d8b2:	73 15                	jae    804d8c9 <hwm_find_next_timer+0x7e>
			next_timer_index = i;
 804d8b4:	c7 05 60 73 06 08 02 	movl   $0x2,0x8067360
 804d8bb:	00 00 00 
			next_timer_time = *Timer_list[i];
 804d8be:	89 15 70 88 06 08    	mov    %edx,0x8068870
 804d8c4:	a3 74 88 06 08       	mov    %eax,0x8068874
		}
	}
}
 804d8c9:	5b                   	pop    %ebx
 804d8ca:	5d                   	pop    %ebp
 804d8cb:	c3                   	ret    

0804d8cc <hwm_one_event>:

/**
 * Execute the next scheduled HW event/timer
 */
void hwm_one_event(void)
{
 804d8cc:	55                   	push   %ebp
 804d8cd:	89 e5                	mov    %esp,%ebp
 804d8cf:	56                   	push   %esi
 804d8d0:	53                   	push   %ebx
 804d8d1:	83 ec 10             	sub    $0x10,%esp
	if (next_timer_time >= simu_time) { /* LCOV_EXCL_BR_LINE */
 804d8d4:	a1 70 88 06 08       	mov    0x8068870,%eax
 804d8d9:	8b 15 74 88 06 08    	mov    0x8068874,%edx
 804d8df:	8b 0d 78 88 06 08    	mov    0x8068878,%ecx
 804d8e5:	8b 1d 7c 88 06 08    	mov    0x806887c,%ebx
 804d8eb:	89 d6                	mov    %edx,%esi
 804d8ed:	39 c8                	cmp    %ecx,%eax
 804d8ef:	19 de                	sbb    %ebx,%esi
 804d8f1:	72 0d                	jb     804d900 <hwm_one_event+0x34>
		simu_time = next_timer_time;
 804d8f3:	a3 78 88 06 08       	mov    %eax,0x8068878
 804d8f8:	89 15 7c 88 06 08    	mov    %edx,0x806887c
 804d8fe:	eb 19                	jmp    804d919 <hwm_one_event+0x4d>
		posix_print_warning("next_timer_time corrupted (%"PRIu64"<= %"
 804d900:	56                   	push   %esi
 804d901:	56                   	push   %esi
 804d902:	ff 35 60 73 06 08    	push   0x8067360
 804d908:	53                   	push   %ebx
 804d909:	51                   	push   %ecx
 804d90a:	52                   	push   %edx
 804d90b:	50                   	push   %eax
 804d90c:	68 d7 2c 06 08       	push   $0x8062cd7
 804d911:	e8 b9 0c 00 00       	call   804e5cf <posix_print_warning>
 804d916:	83 c4 20             	add    $0x20,%esp
	if (signaled_end || (simu_time > end_of_time)) {
 804d919:	8b 0d 5c 89 06 08    	mov    0x806895c,%ecx
 804d91f:	a1 78 88 06 08       	mov    0x8068878,%eax
 804d924:	8b 15 7c 88 06 08    	mov    0x806887c,%edx
 804d92a:	85 c9                	test   %ecx,%ecx
 804d92c:	75 10                	jne    804d93e <hwm_one_event+0x72>
 804d92e:	8b 0d 44 73 06 08    	mov    0x8067344,%ecx
 804d934:	39 05 40 73 06 08    	cmp    %eax,0x8067340
 804d93a:	19 d1                	sbb    %edx,%ecx
 804d93c:	73 38                	jae    804d976 <hwm_one_event+0xaa>
				((long double)simu_time)/1.0e6L);
 804d93e:	89 45 f0             	mov    %eax,-0x10(%ebp)
 804d941:	89 55 f4             	mov    %edx,-0xc(%ebp)
 804d944:	df 6d f0             	fildll -0x10(%ebp)
 804d947:	85 d2                	test   %edx,%edx
 804d949:	79 06                	jns    804d951 <hwm_one_event+0x85>
 804d94b:	d8 05 ec 23 06 08    	fadds  0x80623ec
		posix_print_trace("\nStopped at %.3Lfs\n",
 804d951:	d8 35 f0 23 06 08    	fdivs  0x80623f0
 804d957:	83 ec 0c             	sub    $0xc,%esp
 804d95a:	db 3c 24             	fstpt  (%esp)
 804d95d:	68 0e 2d 06 08       	push   $0x8062d0e
 804d962:	e8 87 0c 00 00       	call   804e5ee <posix_print_trace>
		posix_exit(0);
 804d967:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 804d96e:	e8 d7 0a 00 00       	call   804e44a <posix_exit>
 804d973:	83 c4 10             	add    $0x10,%esp
	hwm_sleep_until_next_timer();

	switch (next_timer_index) { /* LCOV_EXCL_BR_LINE */
 804d976:	a1 60 73 06 08       	mov    0x8067360,%eax
 804d97b:	83 f8 01             	cmp    $0x1,%eax
 804d97e:	74 10                	je     804d990 <hwm_one_event+0xc4>
 804d980:	83 f8 02             	cmp    $0x2,%eax
 804d983:	74 12                	je     804d997 <hwm_one_event+0xcb>
 804d985:	85 c0                	test   %eax,%eax
 804d987:	75 15                	jne    804d99e <hwm_one_event+0xd2>
	case HWTIMER:
		hwtimer_timer_reached();
 804d989:	e8 53 04 00 00       	call   804dde1 <hwtimer_timer_reached>
		break;
 804d98e:	eb 1e                	jmp    804d9ae <hwm_one_event+0xe2>
	case IRQCNT:
		hw_irq_ctrl_timer_triggered();
 804d990:	e8 9c 0a 00 00       	call   804e431 <hw_irq_ctrl_timer_triggered>
		break;
 804d995:	eb 17                	jmp    804d9ae <hwm_one_event+0xe2>
	case HW_COUNTER:
		hw_counter_triggered();
 804d997:	e8 09 15 00 00       	call   804eea5 <hw_counter_triggered>
		break;
 804d99c:	eb 10                	jmp    804d9ae <hwm_one_event+0xe2>
	default:
		/* LCOV_EXCL_START */
		posix_print_error_and_exit(
 804d99e:	83 ec 0c             	sub    $0xc,%esp
 804d9a1:	68 22 2d 06 08       	push   $0x8062d22
 804d9a6:	e8 f9 0b 00 00       	call   804e5a4 <posix_print_error_and_exit>
 804d9ab:	83 c4 10             	add    $0x10,%esp
		break;
		/* LCOV_EXCL_STOP */
	}

	hwm_find_next_timer();
}
 804d9ae:	8d 65 f8             	lea    -0x8(%ebp),%esp
 804d9b1:	5b                   	pop    %ebx
 804d9b2:	5e                   	pop    %esi
 804d9b3:	5d                   	pop    %ebp
	hwm_find_next_timer();
 804d9b4:	e9 92 fe ff ff       	jmp    804d84b <hwm_find_next_timer>

0804d9b9 <hwm_set_end_of_time>:

/**
 * Set the simulated time when the process will stop
 */
void hwm_set_end_of_time(uint64_t new_end_of_time)
{
 804d9b9:	55                   	push   %ebp
 804d9ba:	89 e5                	mov    %esp,%ebp
	end_of_time = new_end_of_time;
 804d9bc:	8b 45 08             	mov    0x8(%ebp),%eax
 804d9bf:	8b 55 0c             	mov    0xc(%ebp),%edx
}
 804d9c2:	5d                   	pop    %ebp
	end_of_time = new_end_of_time;
 804d9c3:	a3 40 73 06 08       	mov    %eax,0x8067340
 804d9c8:	89 15 44 73 06 08    	mov    %edx,0x8067344
}
 804d9ce:	c3                   	ret    

0804d9cf <hwm_get_time>:
 * Return the current time as known by the device
 */
uint64_t hwm_get_time(void)
{
	return simu_time;
}
 804d9cf:	a1 78 88 06 08       	mov    0x8068878,%eax
 804d9d4:	8b 15 7c 88 06 08    	mov    0x806887c,%edx
 804d9da:	c3                   	ret    

0804d9db <hwm_init>:

/**
 * Function to initialize the HW models
 */
void hwm_init(void)
{
 804d9db:	55                   	push   %ebp
 804d9dc:	89 e5                	mov    %esp,%ebp
 804d9de:	83 ec 08             	sub    $0x8,%esp
	hwm_set_sig_handler();
 804d9e1:	e8 b0 fd ff ff       	call   804d796 <hwm_set_sig_handler>
	hwtimer_init();
 804d9e6:	e8 7c 02 00 00       	call   804dc67 <hwtimer_init>
	hw_counter_init();
 804d9eb:	e8 5d 14 00 00       	call   804ee4d <hw_counter_init>
	hw_irq_ctrl_init();
 804d9f0:	e8 10 08 00 00       	call   804e205 <hw_irq_ctrl_init>

	hwm_find_next_timer();
}
 804d9f5:	c9                   	leave  
	hwm_find_next_timer();
 804d9f6:	e9 50 fe ff ff       	jmp    804d84b <hwm_find_next_timer>

0804d9fb <hwm_cleanup>:
 * Function to free any resources allocated by the HW models
 * Note that this function needs to be designed so it is possible
 * to call it more than once during cleanup
 */
void hwm_cleanup(void)
{
 804d9fb:	55                   	push   %ebp
 804d9fc:	89 e5                	mov    %esp,%ebp
 804d9fe:	83 ec 08             	sub    $0x8,%esp
	hwtimer_cleanup();
 804da01:	e8 9c 03 00 00       	call   804dda2 <hwtimer_cleanup>
	hw_irq_ctrl_cleanup();
}
 804da06:	c9                   	leave  
	hw_irq_ctrl_cleanup();
 804da07:	e9 46 08 00 00       	jmp    804e252 <hw_irq_ctrl_cleanup>

0804da0c <hwtimer_update_timer>:
	real_time_mode = new_rt;
}

static void hwtimer_update_timer(void)
{
	hw_timer_timer = MIN(hw_timer_tick_timer, hw_timer_awake_timer);
 804da0c:	8b 0d b4 88 06 08    	mov    0x80688b4,%ecx
 804da12:	a1 ac 88 06 08       	mov    0x80688ac,%eax
{
 804da17:	55                   	push   %ebp
	hw_timer_timer = MIN(hw_timer_tick_timer, hw_timer_awake_timer);
 804da18:	8b 15 a8 88 06 08    	mov    0x80688a8,%edx
 804da1e:	39 15 b0 88 06 08    	cmp    %edx,0x80688b0
{
 804da24:	89 e5                	mov    %esp,%ebp
 804da26:	53                   	push   %ebx
	hw_timer_timer = MIN(hw_timer_tick_timer, hw_timer_awake_timer);
 804da27:	89 cb                	mov    %ecx,%ebx
 804da29:	19 c3                	sbb    %eax,%ebx
 804da2b:	0f 42 15 b0 88 06 08 	cmovb  0x80688b0,%edx
}
 804da32:	5b                   	pop    %ebx
	hw_timer_timer = MIN(hw_timer_tick_timer, hw_timer_awake_timer);
 804da33:	0f 42 c1             	cmovb  %ecx,%eax
}
 804da36:	5d                   	pop    %ebp
	hw_timer_timer = MIN(hw_timer_tick_timer, hw_timer_awake_timer);
 804da37:	89 15 b8 88 06 08    	mov    %edx,0x80688b8
 804da3d:	a3 bc 88 06 08       	mov    %eax,0x80688bc
}
 804da42:	c3                   	ret    

0804da43 <cmd_realtime_found>:
	real_time_mode = new_rt;
 804da43:	c6 05 e9 73 06 08 01 	movb   $0x1,0x80673e9
static void cmd_realtime_found(char *argv, int offset)
{
	ARG_UNUSED(argv);
	ARG_UNUSED(offset);
	hwtimer_set_real_time_mode(true);
}
 804da4a:	c3                   	ret    

0804da4b <cmd_no_realtime_found>:
	real_time_mode = new_rt;
 804da4b:	c6 05 e9 73 06 08 00 	movb   $0x0,0x80673e9
static void cmd_no_realtime_found(char *argv, int offset)
{
	ARG_UNUSED(argv);
	ARG_UNUSED(offset);
	hwtimer_set_real_time_mode(false);
}
 804da52:	c3                   	ret    

0804da53 <cmd_rtcoffset_found>:

static void cmd_rtcoffset_found(char *argv, int offset)
{
 804da53:	55                   	push   %ebp
 804da54:	89 e5                	mov    %esp,%ebp
 804da56:	83 ec 08             	sub    $0x8,%esp
	ARG_UNUSED(argv);
	ARG_UNUSED(offset);
	hwtimer_set_rtc_offset(args.rtc_offset*1e6);
 804da59:	d9 05 f0 23 06 08    	flds   0x80623f0
 804da5f:	d9 7d fe             	fnstcw -0x2(%ebp)
 804da62:	dc 0d a8 78 06 08    	fmull  0x80678a8
 804da68:	66 8b 45 fe          	mov    -0x2(%ebp),%ax
 804da6c:	80 cc 0c             	or     $0xc,%ah
 804da6f:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
 804da73:	d9 6d fc             	fldcw  -0x4(%ebp)
 804da76:	df 3d 90 88 06 08    	fistpll 0x8068890
 804da7c:	d9 6d fe             	fldcw  -0x2(%ebp)
}
 804da7f:	c9                   	leave  
 804da80:	c3                   	ret    

0804da81 <cmd_rtcreset_found>:
	reset_rtc = true;
 804da81:	c6 05 af 8a 06 08 01 	movb   $0x1,0x8068aaf
static void cmd_rtcreset_found(char *argv, int offset)
{
	ARG_UNUSED(argv);
	ARG_UNUSED(offset);
	hwtimer_reset_rtc();
}
 804da88:	c3                   	ret    

0804da89 <native_add_time_options>:

static void native_add_time_options(void)
{
 804da89:	55                   	push   %ebp
 804da8a:	89 e5                	mov    %esp,%ebp
 804da8c:	83 ec 14             	sub    $0x14,%esp
		(void *)&args.stop_at, cmd_stop_at_found,
		"In simulated seconds, when to stop automatically"},

		ARG_TABLE_ENDMARKER};

	native_add_command_line_opts(timer_options);
 804da8f:	68 00 60 06 08       	push   $0x8066000
 804da94:	e8 52 12 00 00       	call   804eceb <native_add_command_line_opts>
 804da99:	83 c4 10             	add    $0x10,%esp
}
 804da9c:	c9                   	leave  
 804da9d:	c3                   	ret    

0804da9e <cmd_rt_ratio_found>:
	if ((args.rt_ratio <= 0)) {
 804da9e:	dd 05 b8 78 06 08    	fldl   0x80678b8
 804daa4:	d9 ee                	fldz   
 804daa6:	df f1                	fcomip %st(1),%st
 804daa8:	dd d8                	fstp   %st(0)
 804daaa:	72 21                	jb     804dacd <cmd_rt_ratio_found+0x2f>
{
 804daac:	55                   	push   %ebp
 804daad:	89 e5                	mov    %esp,%ebp
 804daaf:	83 ec 14             	sub    $0x14,%esp
		posix_print_error_and_exit("The ratio needs to be > 0. "
 804dab2:	68 3e 2d 06 08       	push   $0x8062d3e
 804dab7:	e8 e8 0a 00 00       	call   804e5a4 <posix_print_error_and_exit>
	clock_ratio = ratio;
 804dabc:	dd 05 b8 78 06 08    	fldl   0x80678b8
		posix_print_error_and_exit("The ratio needs to be > 0. "
 804dac2:	83 c4 10             	add    $0x10,%esp
	clock_ratio = ratio;
 804dac5:	dd 1d 48 73 06 08    	fstpl  0x8067348
}
 804dacb:	c9                   	leave  
 804dacc:	c3                   	ret    
	clock_ratio = ratio;
 804dacd:	dd 05 b8 78 06 08    	fldl   0x80678b8
 804dad3:	dd 1d 48 73 06 08    	fstpl  0x8067348
 804dad9:	c3                   	ret    

0804dada <cmd_rt_drift_found>:
{
 804dada:	55                   	push   %ebp
	if (!(args.rt_drift > -1)) {
 804dadb:	d9 e8                	fld1   
 804dadd:	d9 e0                	fchs   
{
 804dadf:	89 e5                	mov    %esp,%ebp
 804dae1:	83 ec 18             	sub    $0x18,%esp
	if (!(args.rt_drift > -1)) {
 804dae4:	dd 05 b0 78 06 08    	fldl   0x80678b0
 804daea:	df f1                	fcomip %st(1),%st
 804daec:	dd d8                	fstp   %st(0)
 804daee:	77 10                	ja     804db00 <cmd_rt_drift_found+0x26>
		posix_print_error_and_exit("The drift needs to be > -1. "
 804daf0:	83 ec 0c             	sub    $0xc,%esp
 804daf3:	68 7a 2d 06 08       	push   $0x8062d7a
 804daf8:	e8 a7 0a 00 00       	call   804e5a4 <posix_print_error_and_exit>
 804dafd:	83 c4 10             	add    $0x10,%esp
	args.rt_ratio = args.rt_drift + 1;
 804db00:	d9 e8                	fld1   
 804db02:	dc 05 b0 78 06 08    	faddl  0x80678b0
 804db08:	dd 5d f0             	fstpl  -0x10(%ebp)
 804db0b:	dd 45 f0             	fldl   -0x10(%ebp)
 804db0e:	dd 15 b8 78 06 08    	fstl   0x80678b8
	clock_ratio = ratio;
 804db14:	dd 1d 48 73 06 08    	fstpl  0x8067348
}
 804db1a:	c9                   	leave  
 804db1b:	c3                   	ret    

0804db1c <cmd_stop_at_found>:
{
 804db1c:	55                   	push   %ebp
	if (args.stop_at < 0) {
 804db1d:	d9 ee                	fldz   
{
 804db1f:	89 e5                	mov    %esp,%ebp
 804db21:	53                   	push   %ebx
 804db22:	83 ec 14             	sub    $0x14,%esp
	if (args.stop_at < 0) {
 804db25:	dd 05 a0 78 06 08    	fldl   0x80678a0
 804db2b:	d9 c9                	fxch   %st(1)
{
 804db2d:	8b 45 08             	mov    0x8(%ebp),%eax
	if (args.stop_at < 0) {
 804db30:	df f1                	fcomip %st(1),%st
 804db32:	dd d8                	fstp   %st(0)
 804db34:	76 10                	jbe    804db46 <cmd_stop_at_found+0x2a>
		posix_print_error_and_exit("Error: stop-at must be positive "
 804db36:	52                   	push   %edx
 804db37:	52                   	push   %edx
 804db38:	50                   	push   %eax
 804db39:	68 b7 2d 06 08       	push   $0x8062db7
 804db3e:	e8 61 0a 00 00       	call   804e5a4 <posix_print_error_and_exit>
 804db43:	83 c4 10             	add    $0x10,%esp
	hwm_set_end_of_time(args.stop_at*1e6);
 804db46:	d9 05 f0 23 06 08    	flds   0x80623f0
 804db4c:	dc 0d a0 78 06 08    	fmull  0x80678a0
 804db52:	d9 05 f4 23 06 08    	flds   0x80623f4
 804db58:	d9 c9                	fxch   %st(1)
 804db5a:	db f1                	fcomi  %st(1),%st
 804db5c:	73 21                	jae    804db7f <cmd_stop_at_found+0x63>
 804db5e:	dd d9                	fstp   %st(1)
 804db60:	d9 7d f6             	fnstcw -0xa(%ebp)
 804db63:	66 8b 45 f6          	mov    -0xa(%ebp),%ax
 804db67:	80 cc 0c             	or     $0xc,%ah
 804db6a:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
 804db6e:	d9 6d f4             	fldcw  -0xc(%ebp)
 804db71:	df 7d e8             	fistpll -0x18(%ebp)
 804db74:	d9 6d f6             	fldcw  -0xa(%ebp)
 804db77:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804db7a:	8b 55 ec             	mov    -0x14(%ebp),%edx
 804db7d:	eb 27                	jmp    804dba6 <cmd_stop_at_found+0x8a>
 804db7f:	d9 7d f6             	fnstcw -0xa(%ebp)
 804db82:	de e1                	fsubp  %st,%st(1)
 804db84:	66 8b 45 f6          	mov    -0xa(%ebp),%ax
 804db88:	80 cc 0c             	or     $0xc,%ah
 804db8b:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
 804db8f:	d9 6d f4             	fldcw  -0xc(%ebp)
 804db92:	df 7d e8             	fistpll -0x18(%ebp)
 804db95:	d9 6d f6             	fldcw  -0xa(%ebp)
 804db98:	8b 55 ec             	mov    -0x14(%ebp),%edx
 804db9b:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804db9e:	8d 8a 00 00 00 80    	lea    -0x80000000(%edx),%ecx
 804dba4:	89 ca                	mov    %ecx,%edx
 804dba6:	89 45 08             	mov    %eax,0x8(%ebp)
}
 804dba9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
	hwm_set_end_of_time(args.stop_at*1e6);
 804dbac:	89 55 0c             	mov    %edx,0xc(%ebp)
}
 804dbaf:	c9                   	leave  
	hwm_set_end_of_time(args.stop_at*1e6);
 804dbb0:	e9 04 fe ff ff       	jmp    804d9b9 <hwm_set_end_of_time>

0804dbb5 <get_host_us_time>:
{
 804dbb5:	55                   	push   %ebp
 804dbb6:	89 e5                	mov    %esp,%ebp
 804dbb8:	53                   	push   %ebx
 804dbb9:	83 ec 2c             	sub    $0x2c,%esp
 804dbbc:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 804dbc2:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804dbc5:	31 c0                	xor    %eax,%eax
	clock_gettime(CLOCK_MONOTONIC_RAW, tv);
 804dbc7:	8d 45 ec             	lea    -0x14(%ebp),%eax
 804dbca:	50                   	push   %eax
 804dbcb:	6a 04                	push   $0x4
 804dbcd:	e8 ce b4 ff ff       	call   80490a0 <clock_gettime@plt>
	return (uint64_t)tv.tv_sec * 1e6 + tv.tv_nsec / 1000;
 804dbd2:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804dbd5:	db 45 ec             	fildl  -0x14(%ebp)
	clock_gettime(CLOCK_MONOTONIC_RAW, tv);
 804dbd8:	83 c4 10             	add    $0x10,%esp
	return (uint64_t)tv.tv_sec * 1e6 + tv.tv_nsec / 1000;
 804dbdb:	99                   	cltd   
 804dbdc:	85 d2                	test   %edx,%edx
 804dbde:	79 06                	jns    804dbe6 <get_host_us_time+0x31>
 804dbe0:	d8 05 ec 23 06 08    	fadds  0x80623ec
 804dbe6:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804dbe9:	d8 0d f0 23 06 08    	fmuls  0x80623f0
 804dbef:	b9 e8 03 00 00       	mov    $0x3e8,%ecx
 804dbf4:	99                   	cltd   
 804dbf5:	f7 f9                	idiv   %ecx
 804dbf7:	89 45 d8             	mov    %eax,-0x28(%ebp)
 804dbfa:	da 45 d8             	fiaddl -0x28(%ebp)
 804dbfd:	d9 05 f4 23 06 08    	flds   0x80623f4
 804dc03:	d9 c9                	fxch   %st(1)
 804dc05:	db f1                	fcomi  %st(1),%st
 804dc07:	73 21                	jae    804dc2a <get_host_us_time+0x75>
 804dc09:	dd d9                	fstp   %st(1)
 804dc0b:	d9 7d e6             	fnstcw -0x1a(%ebp)
 804dc0e:	66 8b 45 e6          	mov    -0x1a(%ebp),%ax
 804dc12:	80 cc 0c             	or     $0xc,%ah
 804dc15:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
 804dc19:	d9 6d e4             	fldcw  -0x1c(%ebp)
 804dc1c:	df 7d d8             	fistpll -0x28(%ebp)
 804dc1f:	d9 6d e6             	fldcw  -0x1a(%ebp)
 804dc22:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804dc25:	8b 55 dc             	mov    -0x24(%ebp),%edx
 804dc28:	eb 27                	jmp    804dc51 <get_host_us_time+0x9c>
 804dc2a:	d9 7d e6             	fnstcw -0x1a(%ebp)
 804dc2d:	de e1                	fsubp  %st,%st(1)
 804dc2f:	66 8b 45 e6          	mov    -0x1a(%ebp),%ax
 804dc33:	80 cc 0c             	or     $0xc,%ah
 804dc36:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
 804dc3a:	d9 6d e4             	fldcw  -0x1c(%ebp)
 804dc3d:	df 7d d8             	fistpll -0x28(%ebp)
 804dc40:	d9 6d e6             	fldcw  -0x1a(%ebp)
 804dc43:	8b 55 dc             	mov    -0x24(%ebp),%edx
 804dc46:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804dc49:	8d 8a 00 00 00 80    	lea    -0x80000000(%edx),%ecx
 804dc4f:	89 ca                	mov    %ecx,%edx
}
 804dc51:	8b 4d f4             	mov    -0xc(%ebp),%ecx
 804dc54:	65 2b 0d 14 00 00 00 	sub    %gs:0x14,%ecx
 804dc5b:	74 05                	je     804dc62 <get_host_us_time+0xad>
 804dc5d:	e8 9e b6 ff ff       	call   8049300 <__stack_chk_fail@plt>
 804dc62:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 804dc65:	c9                   	leave  
 804dc66:	c3                   	ret    

0804dc67 <hwtimer_init>:
{
 804dc67:	55                   	push   %ebp
 804dc68:	89 e5                	mov    %esp,%ebp
 804dc6a:	53                   	push   %ebx
 804dc6b:	83 ec 24             	sub    $0x24,%esp
 804dc6e:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 804dc74:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804dc77:	31 c0                	xor    %eax,%eax
	silent_ticks = 0;
 804dc79:	c7 05 98 88 06 08 00 	movl   $0x0,0x8068898
 804dc80:	00 00 00 
 804dc83:	c7 05 9c 88 06 08 00 	movl   $0x0,0x806889c
 804dc8a:	00 00 00 
	hw_timer_tick_timer = NEVER;
 804dc8d:	c7 05 b0 88 06 08 ff 	movl   $0xffffffff,0x80688b0
 804dc94:	ff ff ff 
 804dc97:	c7 05 b4 88 06 08 ff 	movl   $0xffffffff,0x80688b4
 804dc9e:	ff ff ff 
	hw_timer_awake_timer = NEVER;
 804dca1:	c7 05 a8 88 06 08 ff 	movl   $0xffffffff,0x80688a8
 804dca8:	ff ff ff 
 804dcab:	c7 05 ac 88 06 08 ff 	movl   $0xffffffff,0x80688ac
 804dcb2:	ff ff ff 
	hwtimer_update_timer();
 804dcb5:	e8 52 fd ff ff       	call   804da0c <hwtimer_update_timer>
	if (real_time_mode) {
 804dcba:	80 3d e9 73 06 08 00 	cmpb   $0x0,0x80673e9
 804dcc1:	74 24                	je     804dce7 <hwtimer_init+0x80>
		boot_time = get_host_us_time();
 804dcc3:	e8 ed fe ff ff       	call   804dbb5 <get_host_us_time>
		last_radj_stime = 0U;
 804dcc8:	c7 05 80 88 06 08 00 	movl   $0x0,0x8068880
 804dccf:	00 00 00 
		last_radj_rtime = boot_time;
 804dcd2:	a3 88 88 06 08       	mov    %eax,0x8068888
 804dcd7:	89 15 8c 88 06 08    	mov    %edx,0x806888c
		last_radj_stime = 0U;
 804dcdd:	c7 05 84 88 06 08 00 	movl   $0x0,0x8068884
 804dce4:	00 00 00 
	if (!reset_rtc) {
 804dce7:	80 3d af 8a 06 08 00 	cmpb   $0x0,0x8068aaf
 804dcee:	0f 85 98 00 00 00    	jne    804dd8c <hwtimer_init+0x125>
		clock_gettime(CLOCK_REALTIME, &tv);
 804dcf4:	50                   	push   %eax
 804dcf5:	50                   	push   %eax
 804dcf6:	8d 45 ec             	lea    -0x14(%ebp),%eax
 804dcf9:	50                   	push   %eax
 804dcfa:	6a 00                	push   $0x0
 804dcfc:	e8 9f b3 ff ff       	call   80490a0 <clock_gettime@plt>
		realhosttime = (uint64_t)tv.tv_sec * 1e6 + tv.tv_nsec / 1000;
 804dd01:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804dd04:	db 45 ec             	fildl  -0x14(%ebp)
		clock_gettime(CLOCK_REALTIME, &tv);
 804dd07:	83 c4 10             	add    $0x10,%esp
		realhosttime = (uint64_t)tv.tv_sec * 1e6 + tv.tv_nsec / 1000;
 804dd0a:	99                   	cltd   
 804dd0b:	85 d2                	test   %edx,%edx
 804dd0d:	79 06                	jns    804dd15 <hwtimer_init+0xae>
 804dd0f:	d8 05 ec 23 06 08    	fadds  0x80623ec
 804dd15:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804dd18:	d8 0d f0 23 06 08    	fmuls  0x80623f0
 804dd1e:	b9 e8 03 00 00       	mov    $0x3e8,%ecx
 804dd23:	99                   	cltd   
 804dd24:	f7 f9                	idiv   %ecx
 804dd26:	89 45 d8             	mov    %eax,-0x28(%ebp)
 804dd29:	da 45 d8             	fiaddl -0x28(%ebp)
 804dd2c:	d9 05 f4 23 06 08    	flds   0x80623f4
 804dd32:	d9 c9                	fxch   %st(1)
 804dd34:	db f1                	fcomi  %st(1),%st
 804dd36:	73 21                	jae    804dd59 <hwtimer_init+0xf2>
 804dd38:	dd d9                	fstp   %st(1)
 804dd3a:	d9 7d e6             	fnstcw -0x1a(%ebp)
 804dd3d:	66 8b 45 e6          	mov    -0x1a(%ebp),%ax
 804dd41:	80 cc 0c             	or     $0xc,%ah
 804dd44:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
 804dd48:	d9 6d e4             	fldcw  -0x1c(%ebp)
 804dd4b:	df 7d d8             	fistpll -0x28(%ebp)
 804dd4e:	d9 6d e6             	fldcw  -0x1a(%ebp)
 804dd51:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804dd54:	8b 55 dc             	mov    -0x24(%ebp),%edx
 804dd57:	eb 27                	jmp    804dd80 <hwtimer_init+0x119>
 804dd59:	d9 7d e6             	fnstcw -0x1a(%ebp)
 804dd5c:	de e1                	fsubp  %st,%st(1)
 804dd5e:	66 8b 45 e6          	mov    -0x1a(%ebp),%ax
 804dd62:	80 cc 0c             	or     $0xc,%ah
 804dd65:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
 804dd69:	d9 6d e4             	fldcw  -0x1c(%ebp)
 804dd6c:	df 7d d8             	fistpll -0x28(%ebp)
 804dd6f:	d9 6d e6             	fldcw  -0x1a(%ebp)
 804dd72:	8b 55 dc             	mov    -0x24(%ebp),%edx
 804dd75:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804dd78:	8d 8a 00 00 00 80    	lea    -0x80000000(%edx),%ecx
 804dd7e:	89 ca                	mov    %ecx,%edx
		rtc_offset += realhosttime;
 804dd80:	01 05 90 88 06 08    	add    %eax,0x8068890
 804dd86:	11 15 94 88 06 08    	adc    %edx,0x8068894
}
 804dd8c:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804dd8f:	65 2b 05 14 00 00 00 	sub    %gs:0x14,%eax
 804dd96:	74 05                	je     804dd9d <hwtimer_init+0x136>
 804dd98:	e8 63 b5 ff ff       	call   8049300 <__stack_chk_fail@plt>
 804dd9d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 804dda0:	c9                   	leave  
 804dda1:	c3                   	ret    

0804dda2 <hwtimer_cleanup>:
}
 804dda2:	c3                   	ret    

0804dda3 <hwtimer_enable>:
{
 804dda3:	55                   	push   %ebp
 804dda4:	89 e5                	mov    %esp,%ebp
 804dda6:	83 ec 08             	sub    $0x8,%esp
	tick_p = period;
 804dda9:	8b 45 08             	mov    0x8(%ebp),%eax
 804ddac:	8b 55 0c             	mov    0xc(%ebp),%edx
 804ddaf:	a3 a0 88 06 08       	mov    %eax,0x80688a0
 804ddb4:	89 15 a4 88 06 08    	mov    %edx,0x80688a4
	hw_timer_tick_timer = hwm_get_time() + tick_p;
 804ddba:	e8 10 fc ff ff       	call   804d9cf <hwm_get_time>
 804ddbf:	03 05 a0 88 06 08    	add    0x80688a0,%eax
 804ddc5:	13 15 a4 88 06 08    	adc    0x80688a4,%edx
 804ddcb:	a3 b0 88 06 08       	mov    %eax,0x80688b0
 804ddd0:	89 15 b4 88 06 08    	mov    %edx,0x80688b4
	hwtimer_update_timer();
 804ddd6:	e8 31 fc ff ff       	call   804da0c <hwtimer_update_timer>
}
 804dddb:	c9                   	leave  
	hwm_find_next_timer();
 804dddc:	e9 6a fa ff ff       	jmp    804d84b <hwm_find_next_timer>

0804dde1 <hwtimer_timer_reached>:
{
 804dde1:	55                   	push   %ebp
 804dde2:	89 e5                	mov    %esp,%ebp
 804dde4:	57                   	push   %edi
 804dde5:	56                   	push   %esi
 804dde6:	83 ec 30             	sub    $0x30,%esp
	uint64_t Now = hw_timer_timer;
 804dde9:	8b 35 b8 88 06 08    	mov    0x80688b8,%esi
 804ddef:	8b 3d bc 88 06 08    	mov    0x80688bc,%edi
{
 804ddf5:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 804ddfb:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804ddfe:	31 c0                	xor    %eax,%eax
	if (hw_timer_awake_timer == Now) {
 804de00:	39 3d ac 88 06 08    	cmp    %edi,0x80688ac
 804de06:	75 31                	jne    804de39 <hwtimer_timer_reached+0x58>
 804de08:	39 35 a8 88 06 08    	cmp    %esi,0x80688a8
 804de0e:	75 29                	jne    804de39 <hwtimer_timer_reached+0x58>
	hw_timer_awake_timer = NEVER;
 804de10:	c7 05 a8 88 06 08 ff 	movl   $0xffffffff,0x80688a8
 804de17:	ff ff ff 
 804de1a:	c7 05 ac 88 06 08 ff 	movl   $0xffffffff,0x80688ac
 804de21:	ff ff ff 
	hwtimer_update_timer();
 804de24:	e8 e3 fb ff ff       	call   804da0c <hwtimer_update_timer>
	hw_irq_ctrl_set_irq(PHONY_HARD_IRQ);
 804de29:	83 ec 0c             	sub    $0xc,%esp
 804de2c:	68 ff ff 00 00       	push   $0xffff
 804de31:	e8 5d 05 00 00       	call   804e393 <hw_irq_ctrl_set_irq>
 804de36:	83 c4 10             	add    $0x10,%esp
	if (hw_timer_tick_timer == Now) {
 804de39:	8b 15 b4 88 06 08    	mov    0x80688b4,%edx
 804de3f:	a1 b0 88 06 08       	mov    0x80688b0,%eax
 804de44:	39 fa                	cmp    %edi,%edx
 804de46:	0f 85 5b 01 00 00    	jne    804dfa7 <hwtimer_timer_reached+0x1c6>
 804de4c:	39 f0                	cmp    %esi,%eax
 804de4e:	0f 85 53 01 00 00    	jne    804dfa7 <hwtimer_timer_reached+0x1c6>
	if (real_time_mode) {
 804de54:	80 3d e9 73 06 08 00 	cmpb   $0x0,0x80673e9
 804de5b:	0f 84 f7 00 00 00    	je     804df58 <hwtimer_timer_reached+0x177>
		uint64_t expected_rt = (hw_timer_tick_timer - last_radj_stime)
 804de61:	2b 05 80 88 06 08    	sub    0x8068880,%eax
 804de67:	1b 15 84 88 06 08    	sbb    0x8068884,%edx
				    / clock_ratio
 804de6d:	89 45 c8             	mov    %eax,-0x38(%ebp)
 804de70:	89 55 cc             	mov    %edx,-0x34(%ebp)
 804de73:	df 6d c8             	fildll -0x38(%ebp)
 804de76:	85 d2                	test   %edx,%edx
 804de78:	79 06                	jns    804de80 <hwtimer_timer_reached+0x9f>
 804de7a:	d8 05 ec 23 06 08    	fadds  0x80623ec
 804de80:	dc 35 48 73 06 08    	fdivl  0x8067348
				    + last_radj_rtime;
 804de86:	83 3d 8c 88 06 08 00 	cmpl   $0x0,0x806888c
 804de8d:	df 2d 88 88 06 08    	fildll 0x8068888
 804de93:	79 06                	jns    804de9b <hwtimer_timer_reached+0xba>
 804de95:	d8 05 ec 23 06 08    	fadds  0x80623ec
 804de9b:	de c1                	faddp  %st,%st(1)
		uint64_t expected_rt = (hw_timer_tick_timer - last_radj_stime)
 804de9d:	d9 05 f4 23 06 08    	flds   0x80623f4
 804dea3:	d9 c9                	fxch   %st(1)
 804dea5:	db f1                	fcomi  %st(1),%st
 804dea7:	73 21                	jae    804deca <hwtimer_timer_reached+0xe9>
 804dea9:	dd d9                	fstp   %st(1)
 804deab:	d9 7d d6             	fnstcw -0x2a(%ebp)
 804deae:	66 8b 45 d6          	mov    -0x2a(%ebp),%ax
 804deb2:	80 cc 0c             	or     $0xc,%ah
 804deb5:	66 89 45 d4          	mov    %ax,-0x2c(%ebp)
 804deb9:	d9 6d d4             	fldcw  -0x2c(%ebp)
 804debc:	df 7d c8             	fistpll -0x38(%ebp)
 804debf:	d9 6d d6             	fldcw  -0x2a(%ebp)
 804dec2:	8b 75 c8             	mov    -0x38(%ebp),%esi
 804dec5:	8b 7d cc             	mov    -0x34(%ebp),%edi
 804dec8:	eb 27                	jmp    804def1 <hwtimer_timer_reached+0x110>
 804deca:	d9 7d d6             	fnstcw -0x2a(%ebp)
 804decd:	de e1                	fsubp  %st,%st(1)
 804decf:	66 8b 45 d6          	mov    -0x2a(%ebp),%ax
 804ded3:	80 cc 0c             	or     $0xc,%ah
 804ded6:	66 89 45 d4          	mov    %ax,-0x2c(%ebp)
 804deda:	d9 6d d4             	fldcw  -0x2c(%ebp)
 804dedd:	df 7d c8             	fistpll -0x38(%ebp)
 804dee0:	d9 6d d6             	fldcw  -0x2a(%ebp)
 804dee3:	8b 7d cc             	mov    -0x34(%ebp),%edi
 804dee6:	8b 75 c8             	mov    -0x38(%ebp),%esi
 804dee9:	8d 87 00 00 00 80    	lea    -0x80000000(%edi),%eax
 804deef:	89 c7                	mov    %eax,%edi
		uint64_t real_time = get_host_us_time();
 804def1:	e8 bf fc ff ff       	call   804dbb5 <get_host_us_time>
		int64_t diff = expected_rt - real_time;
 804def6:	29 c6                	sub    %eax,%esi
 804def8:	19 d7                	sbb    %edx,%edi
		if (diff > 0) { /* we need to slow down */
 804defa:	31 c0                	xor    %eax,%eax
 804defc:	39 f0                	cmp    %esi,%eax
 804defe:	19 f8                	sbb    %edi,%eax
 804df00:	7d 56                	jge    804df58 <hwtimer_timer_reached+0x177>
			requested_time.tv_sec  = diff / 1e6;
 804df02:	d9 7d d6             	fnstcw -0x2a(%ebp)
 804df05:	89 75 c8             	mov    %esi,-0x38(%ebp)
 804df08:	89 7d cc             	mov    %edi,-0x34(%ebp)
 804df0b:	df 6d c8             	fildll -0x38(%ebp)
 804df0e:	d9 05 f0 23 06 08    	flds   0x80623f0
 804df14:	66 8b 45 d6          	mov    -0x2a(%ebp),%ax
 804df18:	d9 c1                	fld    %st(1)
 804df1a:	80 cc 0c             	or     $0xc,%ah
 804df1d:	d8 f1                	fdiv   %st(1),%st
 804df1f:	66 89 45 d4          	mov    %ax,-0x2c(%ebp)
 804df23:	d9 6d d4             	fldcw  -0x2c(%ebp)
 804df26:	db 5d c8             	fistpl -0x38(%ebp)
 804df29:	d9 6d d6             	fldcw  -0x2a(%ebp)
 804df2c:	8b 45 c8             	mov    -0x38(%ebp),%eax
						 requested_time.tv_sec*1e6)*1e3;
 804df2f:	da 4d c8             	fimull -0x38(%ebp)
			requested_time.tv_sec  = diff / 1e6;
 804df32:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			(void) nanosleep(&requested_time, &remaining);
 804df35:	50                   	push   %eax
 804df36:	50                   	push   %eax
			requested_time.tv_nsec = (diff -
 804df37:	de e9                	fsubrp %st,%st(1)
			(void) nanosleep(&requested_time, &remaining);
 804df39:	8d 45 ec             	lea    -0x14(%ebp),%eax
						 requested_time.tv_sec*1e6)*1e3;
 804df3c:	d8 0d f8 23 06 08    	fmuls  0x80623f8
			(void) nanosleep(&requested_time, &remaining);
 804df42:	50                   	push   %eax
 804df43:	8d 45 e4             	lea    -0x1c(%ebp),%eax
 804df46:	50                   	push   %eax
			requested_time.tv_nsec = (diff -
 804df47:	d9 6d d4             	fldcw  -0x2c(%ebp)
 804df4a:	db 5d e8             	fistpl -0x18(%ebp)
 804df4d:	d9 6d d6             	fldcw  -0x2a(%ebp)
			(void) nanosleep(&requested_time, &remaining);
 804df50:	e8 cb b2 ff ff       	call   8049220 <nanosleep@plt>
 804df55:	83 c4 10             	add    $0x10,%esp
	hw_timer_tick_timer += tick_p;
 804df58:	a1 a0 88 06 08       	mov    0x80688a0,%eax
 804df5d:	8b 15 a4 88 06 08    	mov    0x80688a4,%edx
 804df63:	01 05 b0 88 06 08    	add    %eax,0x80688b0
 804df69:	11 15 b4 88 06 08    	adc    %edx,0x80688b4
	hwtimer_update_timer();
 804df6f:	e8 98 fa ff ff       	call   804da0c <hwtimer_update_timer>
	if (silent_ticks > 0) {
 804df74:	a1 98 88 06 08       	mov    0x8068898,%eax
 804df79:	31 c9                	xor    %ecx,%ecx
 804df7b:	8b 15 9c 88 06 08    	mov    0x806889c,%edx
 804df81:	39 c1                	cmp    %eax,%ecx
 804df83:	19 d1                	sbb    %edx,%ecx
 804df85:	7d 13                	jge    804df9a <hwtimer_timer_reached+0x1b9>
		silent_ticks -= 1;
 804df87:	83 c0 ff             	add    $0xffffffff,%eax
 804df8a:	83 d2 ff             	adc    $0xffffffff,%edx
 804df8d:	a3 98 88 06 08       	mov    %eax,0x8068898
 804df92:	89 15 9c 88 06 08    	mov    %edx,0x806889c
 804df98:	eb 0d                	jmp    804dfa7 <hwtimer_timer_reached+0x1c6>
		hw_irq_ctrl_set_irq(TIMER_TICK_IRQ);
 804df9a:	83 ec 0c             	sub    $0xc,%esp
 804df9d:	6a 00                	push   $0x0
 804df9f:	e8 ef 03 00 00       	call   804e393 <hw_irq_ctrl_set_irq>
 804dfa4:	83 c4 10             	add    $0x10,%esp
}
 804dfa7:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804dfaa:	65 2b 05 14 00 00 00 	sub    %gs:0x14,%eax
 804dfb1:	74 05                	je     804dfb8 <hwtimer_timer_reached+0x1d7>
 804dfb3:	e8 48 b3 ff ff       	call   8049300 <__stack_chk_fail@plt>
 804dfb8:	8d 65 f8             	lea    -0x8(%ebp),%esp
 804dfbb:	5e                   	pop    %esi
 804dfbc:	5f                   	pop    %edi
 804dfbd:	5d                   	pop    %ebp
 804dfbe:	c3                   	ret    

0804dfbf <hwtimer_set_silent_ticks>:
{
 804dfbf:	55                   	push   %ebp
 804dfc0:	89 e5                	mov    %esp,%ebp
	silent_ticks = sys_ticks;
 804dfc2:	8b 45 08             	mov    0x8(%ebp),%eax
 804dfc5:	8b 55 0c             	mov    0xc(%ebp),%edx
}
 804dfc8:	5d                   	pop    %ebp
	silent_ticks = sys_ticks;
 804dfc9:	a3 98 88 06 08       	mov    %eax,0x8068898
 804dfce:	89 15 9c 88 06 08    	mov    %edx,0x806889c
}
 804dfd4:	c3                   	ret    

0804dfd5 <posix_irq_handler>:
 * Note that even that this function is executing in a Zephyr thread,  it is
 * effectively the model of the interrupt controller passing context to the IRQ
 * handler and therefore its priority handling
 */
void posix_irq_handler(void)
{
 804dfd5:	55                   	push   %ebp
 804dfd6:	89 e5                	mov    %esp,%ebp
 804dfd8:	57                   	push   %edi
 804dfd9:	56                   	push   %esi
 804dfda:	53                   	push   %ebx
 804dfdb:	83 ec 0c             	sub    $0xc,%esp
	uint64_t irq_lock;
	int irq_nbr;
	static int may_swap;

	irq_lock = hw_irq_ctrl_get_current_lock();
 804dfde:	e8 36 03 00 00       	call   804e319 <hw_irq_ctrl_get_current_lock>

	if (irq_lock) {
 804dfe3:	85 c0                	test   %eax,%eax
 804dfe5:	0f 85 f9 00 00 00    	jne    804e0e4 <posix_irq_handler+0x10f>
		/* "spurious" wakes can happen with interrupts locked */
		return;
	}

	if (_kernel.cpus[0].nested == 0) {
 804dfeb:	a1 e0 87 06 08       	mov    0x80687e0,%eax
 804dff0:	85 c0                	test   %eax,%eax
 804dff2:	75 0a                	jne    804dffe <posix_irq_handler+0x29>
		may_swap = 0;
 804dff4:	c7 05 60 89 06 08 00 	movl   $0x0,0x8068960
 804dffb:	00 00 00 
	}

	_kernel.cpus[0].nested++;
 804dffe:	40                   	inc    %eax
 804dfff:	a3 e0 87 06 08       	mov    %eax,0x80687e0

	while ((irq_nbr = hw_irq_ctrl_get_highest_prio_irq()) != -1) {
 804e004:	e8 7c 02 00 00       	call   804e285 <hw_irq_ctrl_get_highest_prio_irq>
 804e009:	89 c3                	mov    %eax,%ebx
 804e00b:	83 f8 ff             	cmp    $0xffffffff,%eax
 804e00e:	0f 84 9b 00 00 00    	je     804e0af <posix_irq_handler+0xda>
		int last_current_running_prio = hw_irq_ctrl_get_cur_prio();
 804e014:	e8 47 02 00 00       	call   804e260 <hw_irq_ctrl_get_cur_prio>
		int last_running_irq = currently_running_irq;

		hw_irq_ctrl_set_cur_prio(hw_irq_ctrl_get_prio(irq_nbr));
 804e019:	83 ec 0c             	sub    $0xc,%esp
		int last_running_irq = currently_running_irq;
 804e01c:	8b 3d 64 73 06 08    	mov    0x8067364,%edi
		hw_irq_ctrl_set_cur_prio(hw_irq_ctrl_get_prio(irq_nbr));
 804e022:	53                   	push   %ebx
		int last_current_running_prio = hw_irq_ctrl_get_cur_prio();
 804e023:	89 c6                	mov    %eax,%esi
		hw_irq_ctrl_set_cur_prio(hw_irq_ctrl_get_prio(irq_nbr));
 804e025:	e8 4d 02 00 00       	call   804e277 <hw_irq_ctrl_get_prio>
 804e02a:	0f b6 c0             	movzbl %al,%eax
 804e02d:	89 04 24             	mov    %eax,(%esp)
 804e030:	e8 1e 02 00 00       	call   804e253 <hw_irq_ctrl_set_cur_prio>
		hw_irq_ctrl_clear_irq(irq_nbr);
 804e035:	89 1c 24             	mov    %ebx,(%esp)
 804e038:	e8 19 03 00 00       	call   804e356 <hw_irq_ctrl_clear_irq>
 804e03d:	83 c4 10             	add    $0x10,%esp

		currently_running_irq = irq_nbr;
 804e040:	89 1d 64 73 06 08    	mov    %ebx,0x8067364
	sys_trace_isr_enter();
 804e046:	e8 c8 cd ff ff       	call   804ae13 <sys_trace_isr_enter>
	if (irq_vector_table[irq_nbr].func == NULL) { /* LCOV_EXCL_BR_LINE */
 804e04b:	89 d8                	mov    %ebx,%eax
 804e04d:	c1 e0 04             	shl    $0x4,%eax
 804e050:	05 c0 78 06 08       	add    $0x80678c0,%eax
 804e055:	8b 50 08             	mov    0x8(%eax),%edx
 804e058:	85 d2                	test   %edx,%edx
 804e05a:	75 12                	jne    804e06e <posix_irq_handler+0x99>
		posix_print_error_and_exit("Received irq %i without a "
 804e05c:	50                   	push   %eax
 804e05d:	50                   	push   %eax
 804e05e:	53                   	push   %ebx
 804e05f:	68 b6 31 06 08       	push   $0x80631b6
 804e064:	e8 3b 05 00 00       	call   804e5a4 <posix_print_error_and_exit>
 804e069:	83 c4 10             	add    $0x10,%esp
 804e06c:	eb 25                	jmp    804e093 <posix_irq_handler+0xbe>
		if (irq_vector_table[irq_nbr].flags & ISR_FLAG_DIRECT) {
 804e06e:	f6 40 04 01          	testb  $0x1,0x4(%eax)
 804e072:	74 0a                	je     804e07e <posix_irq_handler+0xa9>
			*may_swap |= ((direct_irq_f_ptr)
 804e074:	ff d2                	call   *%edx
 804e076:	09 05 60 89 06 08    	or     %eax,0x8068960
 804e07c:	eb 15                	jmp    804e093 <posix_irq_handler+0xbe>
			((normal_irq_f_ptr)irq_vector_table[irq_nbr].func)
 804e07e:	83 ec 0c             	sub    $0xc,%esp
 804e081:	ff 70 0c             	push   0xc(%eax)
 804e084:	ff d2                	call   *%edx
			*may_swap = 1;
 804e086:	c7 05 60 89 06 08 01 	movl   $0x1,0x8068960
 804e08d:	00 00 00 
			((normal_irq_f_ptr)irq_vector_table[irq_nbr].func)
 804e090:	83 c4 10             	add    $0x10,%esp
	sys_trace_isr_exit();
 804e093:	e8 7c cd ff ff       	call   804ae14 <sys_trace_isr_exit>
		vector_to_irq(irq_nbr, &may_swap);
		currently_running_irq = last_running_irq;

		hw_irq_ctrl_set_cur_prio(last_current_running_prio);
 804e098:	83 ec 0c             	sub    $0xc,%esp
		currently_running_irq = last_running_irq;
 804e09b:	89 3d 64 73 06 08    	mov    %edi,0x8067364
		hw_irq_ctrl_set_cur_prio(last_current_running_prio);
 804e0a1:	56                   	push   %esi
 804e0a2:	e8 ac 01 00 00       	call   804e253 <hw_irq_ctrl_set_cur_prio>
 804e0a7:	83 c4 10             	add    $0x10,%esp
 804e0aa:	e9 55 ff ff ff       	jmp    804e004 <posix_irq_handler+0x2f>
	}

	_kernel.cpus[0].nested--;
 804e0af:	ff 0d e0 87 06 08    	decl   0x80687e0
	/* Call swap if all the following is true:
	 * 1) may_swap was enabled
	 * 2) We are not nesting irq_handler calls (interrupts)
	 * 3) Next thread to run in the ready queue is not this thread
	 */
	if (may_swap
 804e0b5:	83 3d 60 89 06 08 00 	cmpl   $0x0,0x8068960
 804e0bc:	74 26                	je     804e0e4 <posix_irq_handler+0x10f>
		&& (hw_irq_ctrl_get_cur_prio() == 256)
 804e0be:	e8 9d 01 00 00       	call   804e260 <hw_irq_ctrl_get_cur_prio>
 804e0c3:	3d 00 01 00 00       	cmp    $0x100,%eax
 804e0c8:	75 1a                	jne    804e0e4 <posix_irq_handler+0x10f>
		&& (_kernel.ready_q.cache != _current)) {
 804e0ca:	a1 e8 87 06 08       	mov    0x80687e8,%eax
 804e0cf:	39 05 f4 87 06 08    	cmp    %eax,0x80687f4
 804e0d5:	74 0d                	je     804e0e4 <posix_irq_handler+0x10f>

static inline int z_swap_irqlock(unsigned int key)
{
	int ret;
	z_check_stack_sentinel();
	ret = arch_swap(key);
 804e0d7:	83 ec 0c             	sub    $0xc,%esp
 804e0da:	6a 00                	push   $0x0
 804e0dc:	e8 68 f3 ff ff       	call   804d449 <arch_swap>
 804e0e1:	83 c4 10             	add    $0x10,%esp

		(void)z_swap_irqlock(irq_lock);
	}
}
 804e0e4:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804e0e7:	5b                   	pop    %ebx
 804e0e8:	5e                   	pop    %esi
 804e0e9:	5f                   	pop    %edi
 804e0ea:	5d                   	pop    %ebp
 804e0eb:	c3                   	ret    

0804e0ec <posix_irq_handler_im_from_sw>:
 * Thru this function the IRQ controller can raise an immediate  interrupt which
 * will interrupt the SW itself
 * (this function should only be called from the HW model code, from SW threads)
 */
void posix_irq_handler_im_from_sw(void)
{
 804e0ec:	55                   	push   %ebp
 804e0ed:	89 e5                	mov    %esp,%ebp
 804e0ef:	83 ec 08             	sub    $0x8,%esp
	/*
	 * if a higher priority interrupt than the possibly currently running is
	 * pending we go immediately into irq_handler() to vector into its
	 * handler
	 */
	if (hw_irq_ctrl_get_highest_prio_irq() != -1) {
 804e0f2:	e8 8e 01 00 00       	call   804e285 <hw_irq_ctrl_get_highest_prio_irq>
 804e0f7:	40                   	inc    %eax
 804e0f8:	74 23                	je     804e11d <posix_irq_handler_im_from_sw+0x31>
		if (!posix_is_cpu_running()) { /* LCOV_EXCL_BR_LINE */
 804e0fa:	e8 4e f4 ff ff       	call   804d54d <posix_is_cpu_running>
 804e0ff:	85 c0                	test   %eax,%eax
 804e101:	75 14                	jne    804e117 <posix_irq_handler_im_from_sw+0x2b>
			/* LCOV_EXCL_START */
			posix_print_error_and_exit("programming error: %s "
 804e103:	50                   	push   %eax
 804e104:	50                   	push   %eax
 804e105:	68 00 24 06 08       	push   $0x8062400
 804e10a:	68 e4 31 06 08       	push   $0x80631e4
 804e10f:	e8 90 04 00 00       	call   804e5a4 <posix_print_error_and_exit>
 804e114:	83 c4 10             	add    $0x10,%esp
					__func__);
			/* LCOV_EXCL_STOP */
		}
		posix_irq_handler();
	}
}
 804e117:	c9                   	leave  
		posix_irq_handler();
 804e118:	e9 b8 fe ff ff       	jmp    804dfd5 <posix_irq_handler>
}
 804e11d:	c9                   	leave  
 804e11e:	c3                   	ret    

0804e11f <posix_irq_lock>:
 * @return An architecture-dependent lock-out key representing the
 * "interrupt disable state" prior to the call.
 *
 */
unsigned int posix_irq_lock(void)
{
 804e11f:	55                   	push   %ebp
 804e120:	89 e5                	mov    %esp,%ebp
 804e122:	83 ec 14             	sub    $0x14,%esp
	return hw_irq_ctrl_change_lock(true);
 804e125:	6a 01                	push   $0x1
 804e127:	e8 f5 01 00 00       	call   804e321 <hw_irq_ctrl_change_lock>
 804e12c:	83 c4 10             	add    $0x10,%esp
}
 804e12f:	c9                   	leave  
 804e130:	c3                   	ret    

0804e131 <posix_irq_unlock>:
 *
 * This routine can be called from either interrupt, task or fiber level.
 */
void posix_irq_unlock(unsigned int key)
{
	hw_irq_ctrl_change_lock(key);
 804e131:	e9 eb 01 00 00       	jmp    804e321 <hw_irq_ctrl_change_lock>

0804e136 <posix_irq_full_unlock>:
}

void posix_irq_full_unlock(void)
{
 804e136:	55                   	push   %ebp
 804e137:	89 e5                	mov    %esp,%ebp
 804e139:	83 ec 14             	sub    $0x14,%esp
	hw_irq_ctrl_change_lock(false);
 804e13c:	6a 00                	push   $0x0
 804e13e:	e8 de 01 00 00       	call   804e321 <hw_irq_ctrl_change_lock>
 804e143:	83 c4 10             	add    $0x10,%esp
}
 804e146:	c9                   	leave  
 804e147:	c3                   	ret    

0804e148 <posix_irq_enable>:

void posix_irq_enable(unsigned int irq)
{
	hw_irq_ctrl_enable_irq(irq);
 804e148:	e9 9d 02 00 00       	jmp    804e3ea <hw_irq_ctrl_enable_irq>

0804e14d <posix_isr_declare>:
 * @param isr_param_p ISR parameter
 * @param flags_p IRQ options
 */
void posix_isr_declare(unsigned int irq_p, int flags, void isr_p(const void *),
		       const void *isr_param_p)
{
 804e14d:	55                   	push   %ebp
 804e14e:	89 e5                	mov    %esp,%ebp
 804e150:	8b 4d 08             	mov    0x8(%ebp),%ecx
	irq_vector_table[irq_p].irq   = irq_p;
 804e153:	89 ca                	mov    %ecx,%edx
 804e155:	c1 e2 04             	shl    $0x4,%edx
 804e158:	8d 82 c0 78 06 08    	lea    0x80678c0(%edx),%eax
 804e15e:	89 8a c0 78 06 08    	mov    %ecx,0x80678c0(%edx)
	irq_vector_table[irq_p].func  = isr_p;
 804e164:	8b 55 10             	mov    0x10(%ebp),%edx
 804e167:	89 50 08             	mov    %edx,0x8(%eax)
	irq_vector_table[irq_p].param = isr_param_p;
 804e16a:	8b 55 14             	mov    0x14(%ebp),%edx
 804e16d:	89 50 0c             	mov    %edx,0xc(%eax)
	irq_vector_table[irq_p].flags = flags;
 804e170:	8b 55 0c             	mov    0xc(%ebp),%edx
 804e173:	89 50 04             	mov    %edx,0x4(%eax)
}
 804e176:	5d                   	pop    %ebp
 804e177:	c3                   	ret    

0804e178 <posix_irq_priority_set>:
 *
 * Lower values take priority over higher values.
 */
void posix_irq_priority_set(unsigned int irq, unsigned int prio, uint32_t flags)
{
	hw_irq_ctrl_prio_set(irq, prio);
 804e178:	e9 e9 00 00 00       	jmp    804e266 <hw_irq_ctrl_prio_set>

0804e17d <irq_raising_from_hw_now>:
	/*
	 * We always awake the CPU even if the IRQ was masked,
	 * but not if irqs are locked unless this is due to a
	 * PHONY_HARD_IRQ
	 */
	if ((irqs_locked == false) || (lock_ignore)) {
 804e17d:	80 3d b1 8a 06 08 00 	cmpb   $0x0,0x8068ab1
 804e184:	74 09                	je     804e18f <irq_raising_from_hw_now+0x12>
 804e186:	80 3d b0 8a 06 08 00 	cmpb   $0x0,0x8068ab0
 804e18d:	74 0c                	je     804e19b <irq_raising_from_hw_now+0x1e>
		lock_ignore = false;
 804e18f:	c6 05 b0 8a 06 08 00 	movb   $0x0,0x8068ab0
		posix_interrupt_raised();
 804e196:	e9 40 f4 ff ff       	jmp    804d5db <posix_interrupt_raised>
	}
}
 804e19b:	c3                   	ret    

0804e19c <hw_irq_ctrl_irq_raise_prefix>:
{
 804e19c:	89 c1                	mov    %eax,%ecx
	if (irq < N_IRQS) {
 804e19e:	83 f8 1f             	cmp    $0x1f,%eax
 804e1a1:	77 4e                	ja     804e1f1 <hw_irq_ctrl_irq_raise_prefix+0x55>
{
 804e1a3:	55                   	push   %ebp
		irq_premask |= ((uint64_t)1<<irq);
 804e1a4:	31 c0                	xor    %eax,%eax
 804e1a6:	31 d2                	xor    %edx,%edx
 804e1a8:	f6 c1 20             	test   $0x20,%cl
 804e1ab:	0f 94 c0             	sete   %al
 804e1ae:	0f 95 c2             	setne  %dl
 804e1b1:	d3 e2                	shl    %cl,%edx
 804e1b3:	d3 e0                	shl    %cl,%eax
 804e1b5:	09 15 cc 88 06 08    	or     %edx,0x80688cc
{
 804e1bb:	89 e5                	mov    %esp,%ebp
 804e1bd:	56                   	push   %esi
		if (irq_mask & (1 << irq)) {
 804e1be:	be 01 00 00 00       	mov    $0x1,%esi
 804e1c3:	d3 e6                	shl    %cl,%esi
{
 804e1c5:	53                   	push   %ebx
		if (irq_mask & (1 << irq)) {
 804e1c6:	8b 0d c4 88 06 08    	mov    0x80688c4,%ecx
 804e1cc:	89 f3                	mov    %esi,%ebx
 804e1ce:	23 35 c0 88 06 08    	and    0x80688c0,%esi
		irq_premask |= ((uint64_t)1<<irq);
 804e1d4:	09 05 c8 88 06 08    	or     %eax,0x80688c8
		if (irq_mask & (1 << irq)) {
 804e1da:	c1 fb 1f             	sar    $0x1f,%ebx
 804e1dd:	21 d9                	and    %ebx,%ecx
 804e1df:	09 f1                	or     %esi,%ecx
 804e1e1:	74 1d                	je     804e200 <hw_irq_ctrl_irq_raise_prefix+0x64>
			irq_status |= ((uint64_t)1<<irq);
 804e1e3:	09 05 d0 88 06 08    	or     %eax,0x80688d0
 804e1e9:	09 15 d4 88 06 08    	or     %edx,0x80688d4
 804e1ef:	eb 0f                	jmp    804e200 <hw_irq_ctrl_irq_raise_prefix+0x64>
	} else if (irq == PHONY_HARD_IRQ) {
 804e1f1:	3d ff ff 00 00       	cmp    $0xffff,%eax
 804e1f6:	75 0c                	jne    804e204 <hw_irq_ctrl_irq_raise_prefix+0x68>
		lock_ignore = true;
 804e1f8:	c6 05 b0 8a 06 08 01 	movb   $0x1,0x8068ab0
}
 804e1ff:	c3                   	ret    
 804e200:	5b                   	pop    %ebx
 804e201:	5e                   	pop    %esi
 804e202:	5d                   	pop    %ebp
 804e203:	c3                   	ret    
 804e204:	c3                   	ret    

0804e205 <hw_irq_ctrl_init>:
{
 804e205:	55                   	push   %ebp
		irq_prio[i] = 255U;
 804e206:	ba c0 7a 06 08       	mov    $0x8067ac0,%edx
 804e20b:	b9 20 00 00 00       	mov    $0x20,%ecx
 804e210:	b0 ff                	mov    $0xff,%al
	irq_mask = 0U; /* Let's assume all interrupts are disable at boot */
 804e212:	c7 05 c0 88 06 08 00 	movl   $0x0,0x80688c0
 804e219:	00 00 00 
 804e21c:	c7 05 c4 88 06 08 00 	movl   $0x0,0x80688c4
 804e223:	00 00 00 
{
 804e226:	89 e5                	mov    %esp,%ebp
 804e228:	57                   	push   %edi
		irq_prio[i] = 255U;
 804e229:	89 d7                	mov    %edx,%edi
 804e22b:	f3 aa                	rep stos %al,%es:(%edi)
	irqs_locked = false;
 804e22d:	c6 05 b1 8a 06 08 00 	movb   $0x0,0x8068ab1
	irq_premask = 0U;
 804e234:	c7 05 c8 88 06 08 00 	movl   $0x0,0x80688c8
 804e23b:	00 00 00 
}
 804e23e:	5f                   	pop    %edi
	lock_ignore = false;
 804e23f:	c6 05 b0 8a 06 08 00 	movb   $0x0,0x8068ab0
	irq_premask = 0U;
 804e246:	c7 05 cc 88 06 08 00 	movl   $0x0,0x80688cc
 804e24d:	00 00 00 
}
 804e250:	5d                   	pop    %ebp
 804e251:	c3                   	ret    

0804e252 <hw_irq_ctrl_cleanup>:
}
 804e252:	c3                   	ret    

0804e253 <hw_irq_ctrl_set_cur_prio>:
{
 804e253:	55                   	push   %ebp
 804e254:	89 e5                	mov    %esp,%ebp
	currently_running_prio = new;
 804e256:	8b 45 08             	mov    0x8(%ebp),%eax
}
 804e259:	5d                   	pop    %ebp
	currently_running_prio = new;
 804e25a:	a3 68 73 06 08       	mov    %eax,0x8067368
}
 804e25f:	c3                   	ret    

0804e260 <hw_irq_ctrl_get_cur_prio>:
}
 804e260:	a1 68 73 06 08       	mov    0x8067368,%eax
 804e265:	c3                   	ret    

0804e266 <hw_irq_ctrl_prio_set>:
{
 804e266:	55                   	push   %ebp
 804e267:	89 e5                	mov    %esp,%ebp
	irq_prio[irq] = prio;
 804e269:	8b 45 08             	mov    0x8(%ebp),%eax
 804e26c:	8b 55 0c             	mov    0xc(%ebp),%edx
}
 804e26f:	5d                   	pop    %ebp
	irq_prio[irq] = prio;
 804e270:	88 90 c0 7a 06 08    	mov    %dl,0x8067ac0(%eax)
}
 804e276:	c3                   	ret    

0804e277 <hw_irq_ctrl_get_prio>:
{
 804e277:	55                   	push   %ebp
 804e278:	89 e5                	mov    %esp,%ebp
	return irq_prio[irq];
 804e27a:	8b 45 08             	mov    0x8(%ebp),%eax
}
 804e27d:	5d                   	pop    %ebp
	return irq_prio[irq];
 804e27e:	8a 80 c0 7a 06 08    	mov    0x8067ac0(%eax),%al
}
 804e284:	c3                   	ret    

0804e285 <hw_irq_ctrl_get_highest_prio_irq>:
		return -1;
 804e285:	83 ca ff             	or     $0xffffffff,%edx
	if (irqs_locked) {
 804e288:	80 3d b1 8a 06 08 00 	cmpb   $0x0,0x8068ab1
 804e28f:	0f 85 81 00 00 00    	jne    804e316 <hw_irq_ctrl_get_highest_prio_irq+0x91>
{
 804e295:	55                   	push   %ebp
 804e296:	89 e5                	mov    %esp,%ebp
 804e298:	57                   	push   %edi
 804e299:	56                   	push   %esi
 804e29a:	53                   	push   %ebx
	int winner_prio = 256;
 804e29b:	bb 00 01 00 00       	mov    $0x100,%ebx
{
 804e2a0:	83 ec 14             	sub    $0x14,%esp
	return irq_status;
 804e2a3:	8b 3d d4 88 06 08    	mov    0x80688d4,%edi
 804e2a9:	a1 d0 88 06 08       	mov    0x80688d0,%eax
 804e2ae:	89 7d e4             	mov    %edi,-0x1c(%ebp)
		   && (currently_running_prio > (int)irq_prio[irq_nbr])) {
 804e2b1:	8b 3d 68 73 06 08    	mov    0x8067368,%edi
 804e2b7:	89 7d e0             	mov    %edi,-0x20(%ebp)
	while (irq_status != 0U) {
 804e2ba:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
 804e2bd:	09 c1                	or     %eax,%ecx
 804e2bf:	74 4b                	je     804e30c <hw_irq_ctrl_get_highest_prio_irq+0x87>
 */

static ALWAYS_INLINE unsigned int find_lsb_set(uint32_t op)
{
#ifdef CONFIG_TOOLCHAIN_HAS_BUILTIN_FFS
	return __builtin_ffs(op);
 804e2c1:	0f bc c8             	bsf    %eax,%ecx
		int irq_nbr = find_lsb_set(irq_status) - 1;
 804e2c4:	bf ff ff ff ff       	mov    $0xffffffff,%edi
		irq_status &= ~((uint64_t) 1 << irq_nbr);
 804e2c9:	be 01 00 00 00       	mov    $0x1,%esi
		int irq_nbr = find_lsb_set(irq_status) - 1;
 804e2ce:	0f 44 cf             	cmove  %edi,%ecx
		irq_status &= ~((uint64_t) 1 << irq_nbr);
 804e2d1:	31 ff                	xor    %edi,%edi
 804e2d3:	0f a5 f7             	shld   %cl,%esi,%edi
 804e2d6:	d3 e6                	shl    %cl,%esi
 804e2d8:	f6 c1 20             	test   $0x20,%cl
 804e2db:	74 04                	je     804e2e1 <hw_irq_ctrl_get_highest_prio_irq+0x5c>
 804e2dd:	89 f7                	mov    %esi,%edi
 804e2df:	31 f6                	xor    %esi,%esi
 804e2e1:	89 75 e8             	mov    %esi,-0x18(%ebp)
 804e2e4:	8b 75 e8             	mov    -0x18(%ebp),%esi
 804e2e7:	89 7d ec             	mov    %edi,-0x14(%ebp)
 804e2ea:	8b 7d ec             	mov    -0x14(%ebp),%edi
 804e2ed:	f7 d6                	not    %esi
 804e2ef:	21 f0                	and    %esi,%eax
		if ((winner_prio > (int)irq_prio[irq_nbr])
 804e2f1:	0f b6 b1 c0 7a 06 08 	movzbl 0x8067ac0(%ecx),%esi
		irq_status &= ~((uint64_t) 1 << irq_nbr);
 804e2f8:	f7 d7                	not    %edi
 804e2fa:	21 7d e4             	and    %edi,-0x1c(%ebp)
		if ((winner_prio > (int)irq_prio[irq_nbr])
 804e2fd:	39 de                	cmp    %ebx,%esi
 804e2ff:	7d b9                	jge    804e2ba <hw_irq_ctrl_get_highest_prio_irq+0x35>
		   && (currently_running_prio > (int)irq_prio[irq_nbr])) {
 804e301:	3b 75 e0             	cmp    -0x20(%ebp),%esi
 804e304:	0f 4c de             	cmovl  %esi,%ebx
 804e307:	0f 4c d1             	cmovl  %ecx,%edx
 804e30a:	eb ae                	jmp    804e2ba <hw_irq_ctrl_get_highest_prio_irq+0x35>
}
 804e30c:	83 c4 14             	add    $0x14,%esp
 804e30f:	89 d0                	mov    %edx,%eax
 804e311:	5b                   	pop    %ebx
 804e312:	5e                   	pop    %esi
 804e313:	5f                   	pop    %edi
 804e314:	5d                   	pop    %ebp
 804e315:	c3                   	ret    
 804e316:	89 d0                	mov    %edx,%eax
 804e318:	c3                   	ret    

0804e319 <hw_irq_ctrl_get_current_lock>:
	return irqs_locked;
 804e319:	0f b6 05 b1 8a 06 08 	movzbl 0x8068ab1,%eax
}
 804e320:	c3                   	ret    

0804e321 <hw_irq_ctrl_change_lock>:
{
 804e321:	55                   	push   %ebp
 804e322:	89 e5                	mov    %esp,%ebp
 804e324:	53                   	push   %ebx
 804e325:	51                   	push   %ecx
	irqs_locked = new_lock;
 804e326:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
	uint32_t previous_lock = irqs_locked;
 804e32a:	0f b6 1d b1 8a 06 08 	movzbl 0x8068ab1,%ebx
	irqs_locked = new_lock;
 804e331:	0f 95 05 b1 8a 06 08 	setne  0x8068ab1
	if ((previous_lock == true) && (new_lock == false)) {
 804e338:	75 16                	jne    804e350 <hw_irq_ctrl_change_lock+0x2f>
 804e33a:	84 db                	test   %bl,%bl
 804e33c:	74 12                	je     804e350 <hw_irq_ctrl_change_lock+0x2f>
		if (irq_status != 0U) {
 804e33e:	a1 d4 88 06 08       	mov    0x80688d4,%eax
 804e343:	0b 05 d0 88 06 08    	or     0x80688d0,%eax
 804e349:	74 05                	je     804e350 <hw_irq_ctrl_change_lock+0x2f>
			posix_irq_handler_im_from_sw();
 804e34b:	e8 9c fd ff ff       	call   804e0ec <posix_irq_handler_im_from_sw>
}
 804e350:	89 d8                	mov    %ebx,%eax
 804e352:	5a                   	pop    %edx
 804e353:	5b                   	pop    %ebx
 804e354:	5d                   	pop    %ebp
 804e355:	c3                   	ret    

0804e356 <hw_irq_ctrl_clear_irq>:
{
 804e356:	55                   	push   %ebp
 804e357:	89 e5                	mov    %esp,%ebp
 804e359:	57                   	push   %edi
	irq_status  &= ~((uint64_t)1<<irq);
 804e35a:	8b 4d 08             	mov    0x8(%ebp),%ecx
{
 804e35d:	56                   	push   %esi
	irq_status  &= ~((uint64_t)1<<irq);
 804e35e:	89 cf                	mov    %ecx,%edi
 804e360:	c1 ef 05             	shr    $0x5,%edi
 804e363:	83 e7 01             	and    $0x1,%edi
 804e366:	89 fe                	mov    %edi,%esi
 804e368:	d3 e7                	shl    %cl,%edi
 804e36a:	83 f6 01             	xor    $0x1,%esi
 804e36d:	89 f8                	mov    %edi,%eax
 804e36f:	d3 e6                	shl    %cl,%esi
 804e371:	f7 d0                	not    %eax
 804e373:	21 05 d4 88 06 08    	and    %eax,0x80688d4
 804e379:	89 f2                	mov    %esi,%edx
	irq_premask &= ~((uint64_t)1<<irq);
 804e37b:	21 05 cc 88 06 08    	and    %eax,0x80688cc
}
 804e381:	5e                   	pop    %esi
	irq_status  &= ~((uint64_t)1<<irq);
 804e382:	f7 d2                	not    %edx
}
 804e384:	5f                   	pop    %edi
	irq_status  &= ~((uint64_t)1<<irq);
 804e385:	21 15 d0 88 06 08    	and    %edx,0x80688d0
	irq_premask &= ~((uint64_t)1<<irq);
 804e38b:	21 15 c8 88 06 08    	and    %edx,0x80688c8
}
 804e391:	5d                   	pop    %ebp
 804e392:	c3                   	ret    

0804e393 <hw_irq_ctrl_set_irq>:
{
 804e393:	55                   	push   %ebp
 804e394:	89 e5                	mov    %esp,%ebp
 804e396:	83 ec 08             	sub    $0x8,%esp
	hw_irq_ctrl_irq_raise_prefix(irq);
 804e399:	8b 45 08             	mov    0x8(%ebp),%eax
 804e39c:	e8 fb fd ff ff       	call   804e19c <hw_irq_ctrl_irq_raise_prefix>
	if ((irqs_locked == false) || (lock_ignore)) {
 804e3a1:	80 3d b1 8a 06 08 00 	cmpb   $0x0,0x8068ab1
 804e3a8:	74 09                	je     804e3b3 <hw_irq_ctrl_set_irq+0x20>
 804e3aa:	80 3d b0 8a 06 08 00 	cmpb   $0x0,0x8068ab0
 804e3b1:	74 16                	je     804e3c9 <hw_irq_ctrl_set_irq+0x36>
		irq_ctrl_timer = hwm_get_time();
 804e3b3:	e8 17 f6 ff ff       	call   804d9cf <hwm_get_time>
 804e3b8:	a3 50 73 06 08       	mov    %eax,0x8067350
 804e3bd:	89 15 54 73 06 08    	mov    %edx,0x8067354
}
 804e3c3:	c9                   	leave  
		hwm_find_next_timer();
 804e3c4:	e9 82 f4 ff ff       	jmp    804d84b <hwm_find_next_timer>
}
 804e3c9:	c9                   	leave  
 804e3ca:	c3                   	ret    

0804e3cb <hw_irq_ctrl_raise_im_from_sw>:
 * Like hw_irq_ctrl_raise_im() but for SW threads
 *
 * Call only from SW threads
 */
void hw_irq_ctrl_raise_im_from_sw(unsigned int irq)
{
 804e3cb:	55                   	push   %ebp
 804e3cc:	89 e5                	mov    %esp,%ebp
 804e3ce:	83 ec 08             	sub    $0x8,%esp
	hw_irq_ctrl_irq_raise_prefix(irq);
 804e3d1:	8b 45 08             	mov    0x8(%ebp),%eax
 804e3d4:	e8 c3 fd ff ff       	call   804e19c <hw_irq_ctrl_irq_raise_prefix>

	if (irqs_locked == false) {
 804e3d9:	80 3d b1 8a 06 08 00 	cmpb   $0x0,0x8068ab1
 804e3e0:	75 06                	jne    804e3e8 <hw_irq_ctrl_raise_im_from_sw+0x1d>
		posix_irq_handler_im_from_sw();
	}
}
 804e3e2:	c9                   	leave  
		posix_irq_handler_im_from_sw();
 804e3e3:	e9 04 fd ff ff       	jmp    804e0ec <posix_irq_handler_im_from_sw>
}
 804e3e8:	c9                   	leave  
 804e3e9:	c3                   	ret    

0804e3ea <hw_irq_ctrl_enable_irq>:
{
 804e3ea:	55                   	push   %ebp
	irq_mask |= ((uint64_t)1<<irq);
 804e3eb:	31 c0                	xor    %eax,%eax
 804e3ed:	31 d2                	xor    %edx,%edx
{
 804e3ef:	89 e5                	mov    %esp,%ebp
 804e3f1:	8b 4d 08             	mov    0x8(%ebp),%ecx
	irq_mask |= ((uint64_t)1<<irq);
 804e3f4:	f6 c1 20             	test   $0x20,%cl
 804e3f7:	0f 94 c0             	sete   %al
 804e3fa:	0f 95 c2             	setne  %dl
 804e3fd:	d3 e2                	shl    %cl,%edx
 804e3ff:	d3 e0                	shl    %cl,%eax
 804e401:	09 15 c4 88 06 08    	or     %edx,0x80688c4
	if (irq_premask & ((uint64_t)1<<irq)) { /* if IRQ is pending */
 804e407:	8b 15 cc 88 06 08    	mov    0x80688cc,%edx
	irq_mask |= ((uint64_t)1<<irq);
 804e40d:	09 05 c0 88 06 08    	or     %eax,0x80688c0
	if (irq_premask & ((uint64_t)1<<irq)) { /* if IRQ is pending */
 804e413:	a1 c8 88 06 08       	mov    0x80688c8,%eax
 804e418:	0f ad d0             	shrd   %cl,%edx,%eax
 804e41b:	d3 ea                	shr    %cl,%edx
 804e41d:	f6 c1 20             	test   $0x20,%cl
 804e420:	74 02                	je     804e424 <hw_irq_ctrl_enable_irq+0x3a>
 804e422:	89 d0                	mov    %edx,%eax
 804e424:	83 e0 01             	and    $0x1,%eax
 804e427:	74 06                	je     804e42f <hw_irq_ctrl_enable_irq+0x45>
}
 804e429:	5d                   	pop    %ebp
		hw_irq_ctrl_raise_im_from_sw(irq);
 804e42a:	e9 9c ff ff ff       	jmp    804e3cb <hw_irq_ctrl_raise_im_from_sw>
}
 804e42f:	5d                   	pop    %ebp
 804e430:	c3                   	ret    

0804e431 <hw_irq_ctrl_timer_triggered>:

void hw_irq_ctrl_timer_triggered(void)
{
	irq_ctrl_timer = NEVER;
 804e431:	c7 05 50 73 06 08 ff 	movl   $0xffffffff,0x8067350
 804e438:	ff ff ff 
 804e43b:	c7 05 54 73 06 08 ff 	movl   $0xffffffff,0x8067354
 804e442:	ff ff ff 
	irq_raising_from_hw_now();
 804e445:	e9 33 fd ff ff       	jmp    804e17d <irq_raising_from_hw_now>

0804e44a <posix_exit>:
#include <zephyr/sys/time_units.h>
#include "cmdline.h"
#include "irq_ctrl.h"

void posix_exit(int exit_code)
{
 804e44a:	55                   	push   %ebp
 804e44b:	89 e5                	mov    %esp,%ebp
 804e44d:	83 ec 08             	sub    $0x8,%esp
	static int max_exit_code;

	max_exit_code = MAX(exit_code, max_exit_code);
 804e450:	a1 64 89 06 08       	mov    0x8068964,%eax
 804e455:	8b 55 08             	mov    0x8(%ebp),%edx
 804e458:	39 d0                	cmp    %edx,%eax
 804e45a:	0f 4c c2             	cmovl  %edx,%eax
 804e45d:	a3 64 89 06 08       	mov    %eax,0x8068964
	/*
	 * posix_soc_clean_up may not return if this is called from a SW thread,
	 * but instead it would get posix_exit() recalled again
	 * ASAP from the HW thread
	 */
	posix_soc_clean_up();
 804e462:	e8 8b f2 ff ff       	call   804d6f2 <posix_soc_clean_up>
	hwm_cleanup();
 804e467:	e8 8f f5 ff ff       	call   804d9fb <hwm_cleanup>
	native_cleanup_cmd_line();
 804e46c:	e8 55 08 00 00       	call   804ecc6 <native_cleanup_cmd_line>
	exit(max_exit_code);
 804e471:	83 ec 0c             	sub    $0xc,%esp
 804e474:	ff 35 64 89 06 08    	push   0x8068964
 804e47a:	e8 61 af ff ff       	call   80493e0 <exit@plt>

0804e47f <posix_init>:
 * Run all early native_posix initialization steps, including command
 * line parsing and CPU start, until we are ready to let the HW models
 * run via hwm_one_event()
 */
void posix_init(int argc, char *argv[])
{
 804e47f:	55                   	push   %ebp
 804e480:	89 e5                	mov    %esp,%ebp
 804e482:	56                   	push   %esi
 804e483:	53                   	push   %ebx
 804e484:	8b 75 0c             	mov    0xc(%ebp),%esi
	 * Let's ensure that even if we are redirecting to a file, we get stdout
	 * and stderr line buffered (default for console)
	 * Note that glibc ignores size. But just in case we set a reasonable
	 * number in case somebody tries to compile against a different library
	 */
	setvbuf(stdout, NULL, _IOLBF, 512);
 804e487:	68 00 02 00 00       	push   $0x200
{
 804e48c:	8b 5d 08             	mov    0x8(%ebp),%ebx
	setvbuf(stdout, NULL, _IOLBF, 512);
 804e48f:	6a 01                	push   $0x1
 804e491:	6a 00                	push   $0x0
 804e493:	ff 35 04 77 06 08    	push   0x8067704
 804e499:	e8 32 ae ff ff       	call   80492d0 <setvbuf@plt>
 804e49e:	83 c4 10             	add    $0x10,%esp
	setvbuf(stderr, NULL, _IOLBF, 512);
 804e4a1:	68 00 02 00 00       	push   $0x200
 804e4a6:	6a 01                	push   $0x1
 804e4a8:	6a 00                	push   $0x0
 804e4aa:	ff 35 00 77 06 08    	push   0x8067700
 804e4b0:	e8 1b ae ff ff       	call   80492d0 <setvbuf@plt>

	run_native_tasks(_NATIVE_PRE_BOOT_1_LEVEL);
 804e4b5:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 804e4bc:	e8 08 f2 ff ff       	call   804d6c9 <run_native_tasks>
 804e4c1:	58                   	pop    %eax
 804e4c2:	5a                   	pop    %edx

	native_handle_cmd_line(argc, argv);
 804e4c3:	56                   	push   %esi
 804e4c4:	53                   	push   %ebx
 804e4c5:	e8 d0 08 00 00       	call   804ed9a <native_handle_cmd_line>

	run_native_tasks(_NATIVE_PRE_BOOT_2_LEVEL);
 804e4ca:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
 804e4d1:	e8 f3 f1 ff ff       	call   804d6c9 <run_native_tasks>
 804e4d6:	83 c4 10             	add    $0x10,%esp

	hwm_init();
 804e4d9:	e8 fd f4 ff ff       	call   804d9db <hwm_init>

	run_native_tasks(_NATIVE_PRE_BOOT_3_LEVEL);
 804e4de:	83 ec 0c             	sub    $0xc,%esp
 804e4e1:	6a 02                	push   $0x2
 804e4e3:	e8 e1 f1 ff ff       	call   804d6c9 <run_native_tasks>
 804e4e8:	83 c4 10             	add    $0x10,%esp

	posix_boot_cpu();
 804e4eb:	e8 29 f1 ff ff       	call   804d619 <posix_boot_cpu>

	run_native_tasks(_NATIVE_FIRST_SLEEP_LEVEL);
 804e4f0:	c7 45 08 03 00 00 00 	movl   $0x3,0x8(%ebp)
}
 804e4f7:	8d 65 f8             	lea    -0x8(%ebp),%esp
 804e4fa:	5b                   	pop    %ebx
 804e4fb:	5e                   	pop    %esi
 804e4fc:	5d                   	pop    %ebp
	run_native_tasks(_NATIVE_FIRST_SLEEP_LEVEL);
 804e4fd:	e9 c7 f1 ff ff       	jmp    804d6c9 <run_native_tasks>

0804e502 <main>:
 *
 * Not used when building fuzz cases, as libfuzzer has its own main()
 * and calls the "OS" through a per-case fuzz test entry point.
 */
int main(int argc, char *argv[])
{
 804e502:	8d 4c 24 04          	lea    0x4(%esp),%ecx
 804e506:	83 e4 f0             	and    $0xfffffff0,%esp
 804e509:	ff 71 fc             	push   -0x4(%ecx)
 804e50c:	55                   	push   %ebp
 804e50d:	89 e5                	mov    %esp,%ebp
 804e50f:	51                   	push   %ecx
 804e510:	83 ec 0c             	sub    $0xc,%esp
	posix_init(argc, argv);
 804e513:	ff 71 04             	push   0x4(%ecx)
 804e516:	ff 31                	push   (%ecx)
 804e518:	e8 62 ff ff ff       	call   804e47f <posix_init>
 804e51d:	83 c4 10             	add    $0x10,%esp
	while (true) {
		hwm_one_event();
 804e520:	e8 a7 f3 ff ff       	call   804d8cc <hwm_one_event>
	while (true) {
 804e525:	eb f9                	jmp    804e520 <main+0x1e>

0804e527 <trace_disable_color>:
 */
static int is_a_tty[2] = {-1, -1};

void trace_disable_color(char *argv, int offset)
{
	is_a_tty[0] = 0;
 804e527:	c7 05 6c 73 06 08 00 	movl   $0x0,0x806736c
 804e52e:	00 00 00 
	is_a_tty[1] = 0;
 804e531:	c7 05 70 73 06 08 00 	movl   $0x0,0x8067370
 804e538:	00 00 00 
}
 804e53b:	c3                   	ret    

0804e53c <trace_enable_color>:

void trace_enable_color(char *argv, int offset)
{
	is_a_tty[0] = -1;
 804e53c:	c7 05 6c 73 06 08 ff 	movl   $0xffffffff,0x806736c
 804e543:	ff ff ff 
	is_a_tty[1] = -1;
 804e546:	c7 05 70 73 06 08 ff 	movl   $0xffffffff,0x8067370
 804e54d:	ff ff ff 

}
 804e550:	c3                   	ret    

0804e551 <trace_force_color>:

void trace_force_color(char *argv, int offset)
{
	is_a_tty[0] = 1;
 804e551:	c7 05 6c 73 06 08 01 	movl   $0x1,0x806736c
 804e558:	00 00 00 
	is_a_tty[1] = 1;
 804e55b:	c7 05 70 73 06 08 01 	movl   $0x1,0x8067370
 804e562:	00 00 00 
}
 804e565:	c3                   	ret    

0804e566 <decide_about_color>:
{
	return is_a_tty[file_number];
}

static void decide_about_color(void)
{
 804e566:	55                   	push   %ebp
 804e567:	89 e5                	mov    %esp,%ebp
 804e569:	83 ec 08             	sub    $0x8,%esp
	if (is_a_tty[0] == -1) {
 804e56c:	83 3d 6c 73 06 08 ff 	cmpl   $0xffffffff,0x806736c
 804e573:	75 12                	jne    804e587 <decide_about_color+0x21>
		is_a_tty[0] = isatty(STDOUT_FILENO);
 804e575:	83 ec 0c             	sub    $0xc,%esp
 804e578:	6a 01                	push   $0x1
 804e57a:	e8 91 ac ff ff       	call   8049210 <isatty@plt>
 804e57f:	83 c4 10             	add    $0x10,%esp
 804e582:	a3 6c 73 06 08       	mov    %eax,0x806736c
	}
	if (is_a_tty[1] == -1) {
 804e587:	83 3d 70 73 06 08 ff 	cmpl   $0xffffffff,0x8067370
 804e58e:	75 12                	jne    804e5a2 <decide_about_color+0x3c>
		is_a_tty[1] = isatty(STDERR_FILENO);
 804e590:	83 ec 0c             	sub    $0xc,%esp
 804e593:	6a 02                	push   $0x2
 804e595:	e8 76 ac ff ff       	call   8049210 <isatty@plt>
 804e59a:	83 c4 10             	add    $0x10,%esp
 804e59d:	a3 70 73 06 08       	mov    %eax,0x8067370
	}
}
 804e5a2:	c9                   	leave  
 804e5a3:	c3                   	ret    

0804e5a4 <posix_print_error_and_exit>:
{
 804e5a4:	55                   	push   %ebp
 804e5a5:	89 e5                	mov    %esp,%ebp
 804e5a7:	83 ec 08             	sub    $0x8,%esp
	va_start(variable_args, format);
 804e5aa:	8d 45 0c             	lea    0xc(%ebp),%eax

__fortify_function int
vfprintf (FILE *__restrict __stream,
	  const char *__restrict __fmt, __gnuc_va_list __ap)
{
  return __vfprintf_chk (__stream, __USE_FORTIFY_LEVEL - 1, __fmt, __ap);
 804e5ad:	50                   	push   %eax
 804e5ae:	ff 75 08             	push   0x8(%ebp)
 804e5b1:	6a 01                	push   $0x1
 804e5b3:	ff 35 00 77 06 08    	push   0x8067700
 804e5b9:	e8 12 ac ff ff       	call   80491d0 <__vfprintf_chk@plt>
	posix_exit(1);
 804e5be:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
 804e5c5:	e8 80 fe ff ff       	call   804e44a <posix_exit>
 804e5ca:	83 c4 10             	add    $0x10,%esp
}
 804e5cd:	c9                   	leave  
 804e5ce:	c3                   	ret    

0804e5cf <posix_print_warning>:
{
 804e5cf:	55                   	push   %ebp
 804e5d0:	89 e5                	mov    %esp,%ebp
 804e5d2:	83 ec 08             	sub    $0x8,%esp
	va_start(variable_args, format);
 804e5d5:	8d 45 0c             	lea    0xc(%ebp),%eax
 804e5d8:	50                   	push   %eax
 804e5d9:	ff 75 08             	push   0x8(%ebp)
 804e5dc:	6a 01                	push   $0x1
 804e5de:	ff 35 00 77 06 08    	push   0x8067700
 804e5e4:	e8 e7 ab ff ff       	call   80491d0 <__vfprintf_chk@plt>
 804e5e9:	83 c4 10             	add    $0x10,%esp
}
 804e5ec:	c9                   	leave  
 804e5ed:	c3                   	ret    

0804e5ee <posix_print_trace>:
{
 804e5ee:	55                   	push   %ebp
 804e5ef:	89 e5                	mov    %esp,%ebp
 804e5f1:	83 ec 08             	sub    $0x8,%esp
	va_start(variable_args, format);
 804e5f4:	8d 45 0c             	lea    0xc(%ebp),%eax
 804e5f7:	50                   	push   %eax
 804e5f8:	ff 75 08             	push   0x8(%ebp)
 804e5fb:	6a 01                	push   $0x1
 804e5fd:	ff 35 04 77 06 08    	push   0x8067704
 804e603:	e8 c8 ab ff ff       	call   80491d0 <__vfprintf_chk@plt>
 804e608:	83 c4 10             	add    $0x10,%esp
}
 804e60b:	c9                   	leave  
 804e60c:	c3                   	ret    

0804e60d <native_add_tracing_options>:

NATIVE_TASK(decide_about_color, PRE_BOOT_2, 0);

void native_add_tracing_options(void)
{
 804e60d:	55                   	push   %ebp
 804e60e:	89 e5                	mov    %esp,%ebp
 804e610:	83 ec 14             	sub    $0x14,%esp
		"force-color", "force-color", 'b',
		NULL, trace_force_color,
		"Enable color in traces even if printing to files/pipes"},
		ARG_TABLE_ENDMARKER};

	native_add_command_line_opts(trace_options);
 804e613:	68 e0 60 06 08       	push   $0x80660e0
 804e618:	e8 ce 06 00 00       	call   804eceb <native_add_command_line_opts>
 804e61d:	83 c4 10             	add    $0x10,%esp
}
 804e620:	c9                   	leave  
 804e621:	c3                   	ret    

0804e622 <cmd_gen_switch_syntax.constprop.0>:
 * should be used
 *
 * The string is saved in <buf> which has been allocated <size> bytes by the
 * caller
 */
static void cmd_gen_switch_syntax(char *buf, int size,
 804e622:	55                   	push   %ebp
 804e623:	89 e5                	mov    %esp,%ebp
 804e625:	57                   	push   %edi
 804e626:	89 d7                	mov    %edx,%edi
 804e628:	56                   	push   %esi
 804e629:	be 46 00 00 00       	mov    $0x46,%esi
 804e62e:	53                   	push   %ebx
 804e62f:	89 c3                	mov    %eax,%ebx
 804e631:	83 ec 1c             	sub    $0x1c,%esp

	if (size <= 0) {
		return;
	}

	if (args_s_el->is_mandatory == false) {
 804e634:	80 7a 01 00          	cmpb   $0x0,0x1(%edx)
 804e638:	75 09                	jne    804e643 <cmd_gen_switch_syntax.constprop.0+0x21>
		*buf++ = '[';
 804e63a:	c6 00 5b             	movb   $0x5b,(%eax)
 804e63d:	43                   	inc    %ebx
		size--;
 804e63e:	be 45 00 00 00       	mov    $0x45,%esi
	}

	if (args_s_el->is_switch == true) {
 804e643:	80 7f 02 00          	cmpb   $0x0,0x2(%edi)
		ret = snprintf(buf, size, "-%s", args_s_el->option);
 804e647:	8b 47 04             	mov    0x4(%edi),%eax
	if (args_s_el->is_switch == true) {
 804e64a:	74 0a                	je     804e656 <cmd_gen_switch_syntax.constprop.0+0x34>
  return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
 804e64c:	52                   	push   %edx
 804e64d:	52                   	push   %edx
 804e64e:	50                   	push   %eax
 804e64f:	68 d1 32 06 08       	push   $0x80632d1
 804e654:	eb 1b                	jmp    804e671 <cmd_gen_switch_syntax.constprop.0+0x4f>
	} else {
		if (args_s_el->type != 'l') {
 804e656:	80 7f 0c 6c          	cmpb   $0x6c,0xc(%edi)
			ret = snprintf(buf, size, "-%s=<%s>",
 804e65a:	8b 57 08             	mov    0x8(%edi),%edx
		if (args_s_el->type != 'l') {
 804e65d:	74 0a                	je     804e669 <cmd_gen_switch_syntax.constprop.0+0x47>
 804e65f:	51                   	push   %ecx
 804e660:	52                   	push   %edx
 804e661:	50                   	push   %eax
 804e662:	68 d5 32 06 08       	push   $0x80632d5
 804e667:	eb 08                	jmp    804e671 <cmd_gen_switch_syntax.constprop.0+0x4f>
 804e669:	51                   	push   %ecx
 804e66a:	52                   	push   %edx
 804e66b:	50                   	push   %eax
 804e66c:	68 de 32 06 08       	push   $0x80632de
 804e671:	6a ff                	push   $0xffffffff
 804e673:	6a 01                	push   $0x1
 804e675:	56                   	push   %esi
 804e676:	53                   	push   %ebx
 804e677:	e8 e4 ac ff ff       	call   8049360 <__snprintf_chk@plt>
 804e67c:	83 c4 20             	add    $0x20,%esp
			ret = snprintf(buf, size, "-%s <%s>...",
					args_s_el->option, args_s_el->name);
		}
	}

	if (ret < 0) {
 804e67f:	85 c0                	test   %eax,%eax
 804e681:	79 1e                	jns    804e6a1 <cmd_gen_switch_syntax.constprop.0+0x7f>
		posix_print_error_and_exit("Unexpected error in %s %i\n",
 804e683:	51                   	push   %ecx
 804e684:	68 07 01 00 00       	push   $0x107
 804e689:	68 ea 32 06 08       	push   $0x80632ea
 804e68e:	68 28 33 06 08       	push   $0x8063328
 804e693:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 804e696:	e8 09 ff ff ff       	call   804e5a4 <posix_print_error_and_exit>
 804e69b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804e69e:	83 c4 10             	add    $0x10,%esp
					   __FILE__, __LINE__);
	}
	if (size - ret < 0) {
 804e6a1:	29 c6                	sub    %eax,%esi
 804e6a3:	78 20                	js     804e6c5 <cmd_gen_switch_syntax.constprop.0+0xa3>
		 * If we run out of space we can just stop,
		 * this is not critical
		 */
		return;
	}
	buf += ret;
 804e6a5:	01 c3                	add    %eax,%ebx
	size -= ret;

	if (args_s_el->is_mandatory == false) {
 804e6a7:	80 7f 01 00          	cmpb   $0x0,0x1(%edi)
 804e6ab:	75 08                	jne    804e6b5 <cmd_gen_switch_syntax.constprop.0+0x93>
 804e6ad:	52                   	push   %edx
 804e6ae:	68 43 33 06 08       	push   $0x8063343
 804e6b3:	eb 06                	jmp    804e6bb <cmd_gen_switch_syntax.constprop.0+0x99>
 804e6b5:	50                   	push   %eax
 804e6b6:	68 37 3e 06 08       	push   $0x8063e37
 804e6bb:	56                   	push   %esi
 804e6bc:	53                   	push   %ebx
 804e6bd:	e8 be ac ff ff       	call   8049380 <snprintf@plt>
 804e6c2:	83 c4 10             	add    $0x10,%esp
		snprintf(buf, size, "] ");
	} else {
		snprintf(buf, size, " ");
	}
}
 804e6c5:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804e6c8:	5b                   	pop    %ebx
 804e6c9:	5e                   	pop    %esi
 804e6ca:	5f                   	pop    %edi
 804e6cb:	5d                   	pop    %ebp
 804e6cc:	c3                   	ret    

0804e6cd <cmd_is_option>:
{
 804e6cd:	55                   	push   %ebp
 804e6ce:	89 e5                	mov    %esp,%ebp
 804e6d0:	57                   	push   %edi
 804e6d1:	56                   	push   %esi
 804e6d2:	53                   	push   %ebx
 804e6d3:	83 ec 28             	sub    $0x28,%esp
 804e6d6:	8b 75 0c             	mov    0xc(%ebp),%esi
 804e6d9:	8b 7d 08             	mov    0x8(%ebp),%edi
 804e6dc:	8b 5d 10             	mov    0x10(%ebp),%ebx
	size_t to_match_len = strlen(option);
 804e6df:	56                   	push   %esi
 804e6e0:	e8 5b ab ff ff       	call   8049240 <strlen@plt>
	int of = 0;
 804e6e5:	31 c9                	xor    %ecx,%ecx
	size_t to_match_len = strlen(option);
 804e6e7:	83 c4 10             	add    $0x10,%esp
	int of = 0;
 804e6ea:	80 3f 2d             	cmpb   $0x2d,(%edi)
 804e6ed:	0f 94 c1             	sete   %cl
	size_t to_match_len = strlen(option);
 804e6f0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (arg[of] == '-') {
 804e6f3:	80 3c 0f 2d          	cmpb   $0x2d,(%edi,%ecx,1)
 804e6f7:	75 01                	jne    804e6fa <cmd_is_option+0x2d>
		of++;
 804e6f9:	41                   	inc    %ecx
	if (!with_value) {
 804e6fa:	85 db                	test   %ebx,%ebx
 804e6fc:	75 20                	jne    804e71e <cmd_is_option+0x51>
		if (strcmp(&arg[of], option) != 0) {
 804e6fe:	52                   	push   %edx
 804e6ff:	52                   	push   %edx
 804e700:	8d 14 0f             	lea    (%edi,%ecx,1),%edx
 804e703:	56                   	push   %esi
 804e704:	52                   	push   %edx
 804e705:	89 4d e0             	mov    %ecx,-0x20(%ebp)
 804e708:	e8 b3 ac ff ff       	call   80493c0 <strcmp@plt>
 804e70d:	83 c4 10             	add    $0x10,%esp
 804e710:	85 c0                	test   %eax,%eax
 804e712:	75 4a                	jne    804e75e <cmd_is_option+0x91>
			return of + to_match_len;
 804e714:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
 804e717:	8b 4d e0             	mov    -0x20(%ebp),%ecx
 804e71a:	01 cb                	add    %ecx,%ebx
 804e71c:	eb 40                	jmp    804e75e <cmd_is_option+0x91>
 804e71e:	89 cb                	mov    %ecx,%ebx
		if (*option == 0) {
 804e720:	29 ce                	sub    %ecx,%esi
	while (!(arg[of] == 0 && *option == 0)) {
 804e722:	8a 04 1f             	mov    (%edi,%ebx,1),%al
		if (*option == 0) {
 804e725:	8a 0c 1e             	mov    (%esi,%ebx,1),%cl
	while (!(arg[of] == 0 && *option == 0)) {
 804e728:	89 c2                	mov    %eax,%edx
 804e72a:	08 ca                	or     %cl,%dl
 804e72c:	74 1c                	je     804e74a <cmd_is_option+0x7d>
		if (*option == 0) {
 804e72e:	84 c9                	test   %cl,%cl
 804e730:	75 11                	jne    804e743 <cmd_is_option+0x76>
			if ((arg[of] == ':') || (arg[of] == '=')) {
 804e732:	3c 3a                	cmp    $0x3a,%al
 804e734:	74 04                	je     804e73a <cmd_is_option+0x6d>
 804e736:	3c 3d                	cmp    $0x3d,%al
 804e738:	75 22                	jne    804e75c <cmd_is_option+0x8f>
				of++;
 804e73a:	43                   	inc    %ebx
	if (arg[of] == 0) { /* we need a value to follow */
 804e73b:	80 3c 1f 00          	cmpb   $0x0,(%edi,%ebx,1)
 804e73f:	75 1d                	jne    804e75e <cmd_is_option+0x91>
 804e741:	eb 07                	jmp    804e74a <cmd_is_option+0x7d>
		if (arg[of] != *option) {
 804e743:	38 c8                	cmp    %cl,%al
 804e745:	75 15                	jne    804e75c <cmd_is_option+0x8f>
		of++;
 804e747:	43                   	inc    %ebx
		option++;
 804e748:	eb d8                	jmp    804e722 <cmd_is_option+0x55>
		posix_print_error_and_exit("Incorrect option syntax '%s'. The "
 804e74a:	50                   	push   %eax
 804e74b:	50                   	push   %eax
 804e74c:	57                   	push   %edi
 804e74d:	68 46 33 06 08       	push   $0x8063346
 804e752:	e8 4d fe ff ff       	call   804e5a4 <posix_print_error_and_exit>
 804e757:	83 c4 10             	add    $0x10,%esp
 804e75a:	eb 02                	jmp    804e75e <cmd_is_option+0x91>
			return 0;
 804e75c:	31 db                	xor    %ebx,%ebx
}
 804e75e:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804e761:	89 d8                	mov    %ebx,%eax
 804e763:	5b                   	pop    %ebx
 804e764:	5e                   	pop    %esi
 804e765:	5f                   	pop    %edi
 804e766:	5d                   	pop    %ebp
 804e767:	c3                   	ret    

0804e768 <cmd_is_help_option>:
{
 804e768:	55                   	push   %ebp
 804e769:	89 e5                	mov    %esp,%ebp
 804e76b:	53                   	push   %ebx
 804e76c:	53                   	push   %ebx
 804e76d:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (arg[0] == '-') {
 804e770:	80 3b 2d             	cmpb   $0x2d,(%ebx)
 804e773:	75 0c                	jne    804e781 <cmd_is_help_option+0x19>
	if (arg[0] == '-') {
 804e775:	80 7b 01 2d          	cmpb   $0x2d,0x1(%ebx)
 804e779:	74 03                	je     804e77e <cmd_is_help_option+0x16>
		arg++;
 804e77b:	43                   	inc    %ebx
 804e77c:	eb 03                	jmp    804e781 <cmd_is_help_option+0x19>
		arg++;
 804e77e:	83 c3 02             	add    $0x2,%ebx
	if ((strcasecmp(arg, "?") == 0) ||
 804e781:	51                   	push   %ecx
 804e782:	51                   	push   %ecx
 804e783:	68 a0 33 06 08       	push   $0x80633a0
 804e788:	53                   	push   %ebx
 804e789:	e8 02 ab ff ff       	call   8049290 <strcasecmp@plt>
 804e78e:	83 c4 10             	add    $0x10,%esp
 804e791:	89 c2                	mov    %eax,%edx
		return 1;
 804e793:	b8 01 00 00 00       	mov    $0x1,%eax
	if ((strcasecmp(arg, "?") == 0) ||
 804e798:	85 d2                	test   %edx,%edx
 804e79a:	74 33                	je     804e7cf <cmd_is_help_option+0x67>
	    (strcasecmp(arg, "h") == 0) ||
 804e79c:	52                   	push   %edx
 804e79d:	52                   	push   %edx
 804e79e:	68 1b 3b 06 08       	push   $0x8063b1b
 804e7a3:	53                   	push   %ebx
 804e7a4:	e8 e7 aa ff ff       	call   8049290 <strcasecmp@plt>
 804e7a9:	83 c4 10             	add    $0x10,%esp
 804e7ac:	89 c2                	mov    %eax,%edx
		return 1;
 804e7ae:	b8 01 00 00 00       	mov    $0x1,%eax
	if ((strcasecmp(arg, "?") == 0) ||
 804e7b3:	85 d2                	test   %edx,%edx
 804e7b5:	74 18                	je     804e7cf <cmd_is_help_option+0x67>
	    (strcasecmp(arg, "help") == 0)) {
 804e7b7:	50                   	push   %eax
 804e7b8:	50                   	push   %eax
 804e7b9:	68 40 34 06 08       	push   $0x8063440
 804e7be:	53                   	push   %ebx
 804e7bf:	e8 cc aa ff ff       	call   8049290 <strcasecmp@plt>
 804e7c4:	83 c4 10             	add    $0x10,%esp
	    (strcasecmp(arg, "h") == 0) ||
 804e7c7:	85 c0                	test   %eax,%eax
 804e7c9:	0f 94 c0             	sete   %al
 804e7cc:	0f b6 c0             	movzbl %al,%eax
}
 804e7cf:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 804e7d2:	c9                   	leave  
 804e7d3:	c3                   	ret    

0804e7d4 <cmd_read_option_value>:
{
 804e7d4:	55                   	push   %ebp
 804e7d5:	89 e5                	mov    %esp,%ebp
 804e7d7:	57                   	push   %edi
 804e7d8:	56                   	push   %esi
 804e7d9:	53                   	push   %ebx
 804e7da:	83 ec 1c             	sub    $0x1c,%esp
 804e7dd:	8b 45 10             	mov    0x10(%ebp),%eax
 804e7e0:	8b 5d 08             	mov    0x8(%ebp),%ebx
 804e7e3:	65 8b 15 14 00 00 00 	mov    %gs:0x14,%edx
 804e7ea:	89 55 e4             	mov    %edx,-0x1c(%ebp)
 804e7ed:	31 d2                	xor    %edx,%edx
 804e7ef:	8b 75 0c             	mov    0xc(%ebp),%esi
 804e7f2:	8b 7d 14             	mov    0x14(%ebp),%edi
	char *endptr = NULL;
 804e7f5:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	switch (type) {
 804e7fc:	3c 64                	cmp    $0x64,%al
 804e7fe:	0f 84 18 01 00 00    	je     804e91c <cmd_read_option_value+0x148>
 804e804:	7f 26                	jg     804e82c <cmd_read_option_value+0x58>
 804e806:	3c 55                	cmp    $0x55,%al
 804e808:	0f 84 ee 00 00 00    	je     804e8fc <cmd_read_option_value+0x128>
 804e80e:	3c 62                	cmp    $0x62,%al
 804e810:	74 44                	je     804e856 <cmd_read_option_value+0x82>
 804e812:	3c 49                	cmp    $0x49,%al
 804e814:	0f 85 15 01 00 00    	jne    804e92f <cmd_read_option_value+0x15b>
		*(int64_t *)dest = strtoll(str, &endptr, 0);
 804e81a:	50                   	push   %eax
 804e81b:	8d 45 e0             	lea    -0x20(%ebp),%eax
 804e81e:	6a 00                	push   $0x0
 804e820:	50                   	push   %eax
 804e821:	53                   	push   %ebx
 804e822:	e8 49 a9 ff ff       	call   8049170 <strtoll@plt>
 804e827:	e9 e6 00 00 00       	jmp    804e912 <cmd_read_option_value+0x13e>
	switch (type) {
 804e82c:	3c 73                	cmp    $0x73,%al
 804e82e:	0f 84 a7 00 00 00    	je     804e8db <cmd_read_option_value+0x107>
 804e834:	3c 75                	cmp    $0x75,%al
 804e836:	0f 84 b1 00 00 00    	je     804e8ed <cmd_read_option_value+0x119>
 804e83c:	3c 69                	cmp    $0x69,%al
 804e83e:	0f 85 eb 00 00 00    	jne    804e92f <cmd_read_option_value+0x15b>
		*(int32_t *)dest = strtol(str, &endptr, 0);
 804e844:	50                   	push   %eax
 804e845:	8d 45 e0             	lea    -0x20(%ebp),%eax
 804e848:	6a 00                	push   $0x0
 804e84a:	50                   	push   %eax
 804e84b:	53                   	push   %ebx
 804e84c:	e8 2f a9 ff ff       	call   8049180 <strtol@plt>
 804e851:	e9 b5 00 00 00       	jmp    804e90b <cmd_read_option_value+0x137>
		if (strcasecmp(str, "false") == 0) {
 804e856:	50                   	push   %eax
 804e857:	50                   	push   %eax
 804e858:	68 a2 33 06 08       	push   $0x80633a2
 804e85d:	53                   	push   %ebx
 804e85e:	e8 2d aa ff ff       	call   8049290 <strcasecmp@plt>
 804e863:	83 c4 10             	add    $0x10,%esp
 804e866:	85 c0                	test   %eax,%eax
 804e868:	75 08                	jne    804e872 <cmd_read_option_value+0x9e>
			*(bool *)dest = false;
 804e86a:	c6 06 00             	movb   $0x0,(%esi)
			endptr = (char *)str + 5;
 804e86d:	8d 43 05             	lea    0x5(%ebx),%eax
 804e870:	eb 1a                	jmp    804e88c <cmd_read_option_value+0xb8>
		} else if (strcmp(str, "0") == 0) {
 804e872:	50                   	push   %eax
 804e873:	50                   	push   %eax
 804e874:	68 0e 3f 06 08       	push   $0x8063f0e
 804e879:	53                   	push   %ebx
 804e87a:	e8 41 ab ff ff       	call   80493c0 <strcmp@plt>
 804e87f:	83 c4 10             	add    $0x10,%esp
 804e882:	85 c0                	test   %eax,%eax
 804e884:	75 0e                	jne    804e894 <cmd_read_option_value+0xc0>
			*(bool *)dest = false;
 804e886:	c6 06 00             	movb   $0x0,(%esi)
			endptr = (char *)str + 1;
 804e889:	8d 43 01             	lea    0x1(%ebx),%eax
 804e88c:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (!error && endptr && *endptr != 0) {
 804e88f:	e9 ae 00 00 00       	jmp    804e942 <cmd_read_option_value+0x16e>
		} else if (strcasecmp(str, "true") == 0) {
 804e894:	51                   	push   %ecx
 804e895:	51                   	push   %ecx
 804e896:	68 a8 33 06 08       	push   $0x80633a8
 804e89b:	53                   	push   %ebx
 804e89c:	e8 ef a9 ff ff       	call   8049290 <strcasecmp@plt>
 804e8a1:	83 c4 10             	add    $0x10,%esp
 804e8a4:	85 c0                	test   %eax,%eax
 804e8a6:	75 08                	jne    804e8b0 <cmd_read_option_value+0xdc>
			*(bool *)dest = true;
 804e8a8:	c6 06 01             	movb   $0x1,(%esi)
			endptr = (char *)str + 4;
 804e8ab:	8d 43 04             	lea    0x4(%ebx),%eax
 804e8ae:	eb dc                	jmp    804e88c <cmd_read_option_value+0xb8>
		} else if (strcmp(str, "1") == 0) {
 804e8b0:	52                   	push   %edx
 804e8b1:	52                   	push   %edx
 804e8b2:	68 ad 33 06 08       	push   $0x80633ad
 804e8b7:	53                   	push   %ebx
 804e8b8:	e8 03 ab ff ff       	call   80493c0 <strcmp@plt>
 804e8bd:	83 c4 10             	add    $0x10,%esp
 804e8c0:	85 c0                	test   %eax,%eax
 804e8c2:	74 12                	je     804e8d6 <cmd_read_option_value+0x102>
		posix_print_error_and_exit("Error reading value of %s '%s'. Use"
 804e8c4:	50                   	push   %eax
 804e8c5:	53                   	push   %ebx
 804e8c6:	57                   	push   %edi
 804e8c7:	68 af 33 06 08       	push   $0x80633af
 804e8cc:	e8 d3 fc ff ff       	call   804e5a4 <posix_print_error_and_exit>
 804e8d1:	83 c4 10             	add    $0x10,%esp
 804e8d4:	eb 7c                	jmp    804e952 <cmd_read_option_value+0x17e>
			*(bool *)dest = true;
 804e8d6:	c6 06 01             	movb   $0x1,(%esi)
			endptr = (char *)str + 1;
 804e8d9:	eb ae                	jmp    804e889 <cmd_read_option_value+0xb5>
		endptr = (char *)str + strlen(str);
 804e8db:	83 ec 0c             	sub    $0xc,%esp
		*(char **)dest = (char *)str;
 804e8de:	89 1e                	mov    %ebx,(%esi)
		endptr = (char *)str + strlen(str);
 804e8e0:	53                   	push   %ebx
 804e8e1:	e8 5a a9 ff ff       	call   8049240 <strlen@plt>
 804e8e6:	83 c4 10             	add    $0x10,%esp
 804e8e9:	01 d8                	add    %ebx,%eax
 804e8eb:	eb 9f                	jmp    804e88c <cmd_read_option_value+0xb8>
		*(uint32_t *)dest = strtoul(str, &endptr, 0);
 804e8ed:	50                   	push   %eax
 804e8ee:	8d 45 e0             	lea    -0x20(%ebp),%eax
 804e8f1:	6a 00                	push   $0x0
 804e8f3:	50                   	push   %eax
 804e8f4:	53                   	push   %ebx
 804e8f5:	e8 36 a9 ff ff       	call   8049230 <strtoul@plt>
 804e8fa:	eb 0f                	jmp    804e90b <cmd_read_option_value+0x137>
		*(uint64_t *)dest = strtoull(str, &endptr, 0);
 804e8fc:	50                   	push   %eax
 804e8fd:	8d 45 e0             	lea    -0x20(%ebp),%eax
 804e900:	6a 00                	push   $0x0
 804e902:	50                   	push   %eax
 804e903:	53                   	push   %ebx
 804e904:	e8 a7 a8 ff ff       	call   80491b0 <strtoull@plt>
 804e909:	eb 07                	jmp    804e912 <cmd_read_option_value+0x13e>
		*(int32_t *)dest = strtol(str, &endptr, 0);
 804e90b:	89 06                	mov    %eax,(%esi)
 804e90d:	83 c4 10             	add    $0x10,%esp
 804e910:	eb 30                	jmp    804e942 <cmd_read_option_value+0x16e>
		*(int64_t *)dest = strtoll(str, &endptr, 0);
 804e912:	89 06                	mov    %eax,(%esi)
 804e914:	83 c4 10             	add    $0x10,%esp
 804e917:	89 56 04             	mov    %edx,0x4(%esi)
	if (!error && endptr && *endptr != 0) {
 804e91a:	eb 26                	jmp    804e942 <cmd_read_option_value+0x16e>
		*(double *)dest = strtod(str, &endptr);
 804e91c:	8d 45 e0             	lea    -0x20(%ebp),%eax
 804e91f:	51                   	push   %ecx
 804e920:	51                   	push   %ecx
 804e921:	50                   	push   %eax
 804e922:	53                   	push   %ebx
 804e923:	e8 b8 a7 ff ff       	call   80490e0 <strtod@plt>
 804e928:	83 c4 10             	add    $0x10,%esp
 804e92b:	dd 1e                	fstpl  (%esi)
	if (!error && endptr && *endptr != 0) {
 804e92d:	eb 13                	jmp    804e942 <cmd_read_option_value+0x16e>
	switch (type) {
 804e92f:	0f be c0             	movsbl %al,%eax
		posix_print_error_and_exit(CMD_TYPE_ERROR, type);
 804e932:	52                   	push   %edx
 804e933:	52                   	push   %edx
 804e934:	50                   	push   %eax
 804e935:	68 f1 33 06 08       	push   $0x80633f1
 804e93a:	e8 65 fc ff ff       	call   804e5a4 <posix_print_error_and_exit>
 804e93f:	83 c4 10             	add    $0x10,%esp
	if (!error && endptr && *endptr != 0) {
 804e942:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804e945:	85 c0                	test   %eax,%eax
 804e947:	74 09                	je     804e952 <cmd_read_option_value+0x17e>
 804e949:	80 38 00             	cmpb   $0x0,(%eax)
 804e94c:	0f 85 72 ff ff ff    	jne    804e8c4 <cmd_read_option_value+0xf0>
}
 804e952:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804e955:	65 2b 05 14 00 00 00 	sub    %gs:0x14,%eax
 804e95c:	74 05                	je     804e963 <cmd_read_option_value+0x18f>
 804e95e:	e8 9d a9 ff ff       	call   8049300 <__stack_chk_fail@plt>
 804e963:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804e966:	5b                   	pop    %ebx
 804e967:	5e                   	pop    %esi
 804e968:	5f                   	pop    %edi
 804e969:	5d                   	pop    %ebp
 804e96a:	c3                   	ret    

0804e96b <cmd_args_set_defaults>:
{
 804e96b:	55                   	push   %ebp
 804e96c:	89 e5                	mov    %esp,%ebp
 804e96e:	53                   	push   %ebx
 804e96f:	51                   	push   %ecx
 804e970:	8b 45 08             	mov    0x8(%ebp),%eax
 804e973:	8d 58 04             	lea    0x4(%eax),%ebx
	while (args_struct[count].option != NULL) {
 804e976:	83 3b 00             	cmpl   $0x0,(%ebx)
 804e979:	0f 84 8c 00 00 00    	je     804ea0b <cmd_args_set_defaults+0xa0>
		if (args_struct[count].dest == NULL) {
 804e97f:	8b 53 0c             	mov    0xc(%ebx),%edx
 804e982:	85 d2                	test   %edx,%edx
 804e984:	74 7d                	je     804ea03 <cmd_args_set_defaults+0x98>
		switch (args_struct[count].type) {
 804e986:	0f be 43 08          	movsbl 0x8(%ebx),%eax
 804e98a:	3c 64                	cmp    $0x64,%al
 804e98c:	74 5b                	je     804e9e9 <cmd_args_set_defaults+0x7e>
 804e98e:	7f 26                	jg     804e9b6 <cmd_args_set_defaults+0x4b>
 804e990:	3c 55                	cmp    $0x55,%al
 804e992:	74 46                	je     804e9da <cmd_args_set_defaults+0x6f>
 804e994:	7f 17                	jg     804e9ad <cmd_args_set_defaults+0x42>
 804e996:	84 c0                	test   %al,%al
 804e998:	74 69                	je     804ea03 <cmd_args_set_defaults+0x98>
 804e99a:	3c 49                	cmp    $0x49,%al
 804e99c:	75 55                	jne    804e9f3 <cmd_args_set_defaults+0x88>
			*(int64_t *)args_struct[count].dest = INT64_MAX;
 804e99e:	c7 02 ff ff ff ff    	movl   $0xffffffff,(%edx)
 804e9a4:	c7 42 04 ff ff ff 7f 	movl   $0x7fffffff,0x4(%edx)
			break;
 804e9ab:	eb 56                	jmp    804ea03 <cmd_args_set_defaults+0x98>
		switch (args_struct[count].type) {
 804e9ad:	3c 62                	cmp    $0x62,%al
 804e9af:	75 42                	jne    804e9f3 <cmd_args_set_defaults+0x88>
			*(bool *)args_struct[count].dest = false;
 804e9b1:	c6 02 00             	movb   $0x0,(%edx)
			break;
 804e9b4:	eb 4d                	jmp    804ea03 <cmd_args_set_defaults+0x98>
		switch (args_struct[count].type) {
 804e9b6:	3c 73                	cmp    $0x73,%al
 804e9b8:	74 10                	je     804e9ca <cmd_args_set_defaults+0x5f>
 804e9ba:	3c 75                	cmp    $0x75,%al
 804e9bc:	74 14                	je     804e9d2 <cmd_args_set_defaults+0x67>
 804e9be:	3c 69                	cmp    $0x69,%al
 804e9c0:	75 31                	jne    804e9f3 <cmd_args_set_defaults+0x88>
			*(int32_t *)args_struct[count].dest = INT32_MAX;
 804e9c2:	c7 02 ff ff ff 7f    	movl   $0x7fffffff,(%edx)
			break;
 804e9c8:	eb 39                	jmp    804ea03 <cmd_args_set_defaults+0x98>
			*(char **)args_struct[count].dest = NULL;
 804e9ca:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
			break;
 804e9d0:	eb 31                	jmp    804ea03 <cmd_args_set_defaults+0x98>
			*(uint32_t *)args_struct[count].dest = UINT32_MAX;
 804e9d2:	c7 02 ff ff ff ff    	movl   $0xffffffff,(%edx)
			break;
 804e9d8:	eb 29                	jmp    804ea03 <cmd_args_set_defaults+0x98>
			*(uint64_t *)args_struct[count].dest = UINT64_MAX;
 804e9da:	c7 02 ff ff ff ff    	movl   $0xffffffff,(%edx)
 804e9e0:	c7 42 04 ff ff ff ff 	movl   $0xffffffff,0x4(%edx)
			break;
 804e9e7:	eb 1a                	jmp    804ea03 <cmd_args_set_defaults+0x98>
			*(double *)args_struct[count].dest = (double)NAN;
 804e9e9:	d9 05 20 24 06 08    	flds   0x8062420
 804e9ef:	dd 1a                	fstpl  (%edx)
			break;
 804e9f1:	eb 10                	jmp    804ea03 <cmd_args_set_defaults+0x98>
			posix_print_error_and_exit(CMD_TYPE_ERROR,
 804e9f3:	52                   	push   %edx
 804e9f4:	52                   	push   %edx
 804e9f5:	50                   	push   %eax
 804e9f6:	68 f1 33 06 08       	push   $0x80633f1
 804e9fb:	e8 a4 fb ff ff       	call   804e5a4 <posix_print_error_and_exit>
 804ea00:	83 c4 10             	add    $0x10,%esp
		count++;
 804ea03:	83 c3 1c             	add    $0x1c,%ebx
 804ea06:	e9 6b ff ff ff       	jmp    804e976 <cmd_args_set_defaults+0xb>
}
 804ea0b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 804ea0e:	c9                   	leave  
 804ea0f:	c3                   	ret    

0804ea10 <cmd_print_switches_help>:

/**
 * Print short list of available switches
 */
void cmd_print_switches_help(struct args_struct_t args_struct[])
{
 804ea10:	55                   	push   %ebp
 804ea11:	89 e5                	mov    %esp,%ebp
 804ea13:	57                   	push   %edi
 804ea14:	56                   	push   %esi
	int count = 0;
	int printed_in_line = strlen(_HELP_SWITCH) + 1;
 804ea15:	be 19 00 00 00       	mov    $0x19,%esi
{
 804ea1a:	53                   	push   %ebx
 804ea1b:	83 ec 5c             	sub    $0x5c,%esp
 804ea1e:	8b 5d 08             	mov    0x8(%ebp),%ebx
 804ea21:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 804ea27:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 804ea2a:	31 c0                	xor    %eax,%eax
  return __fprintf_chk (__stream, __USE_FORTIFY_LEVEL - 1, __fmt,
 804ea2c:	68 16 34 06 08       	push   $0x8063416
 804ea31:	68 2f 34 06 08       	push   $0x806342f
 804ea36:	6a 01                	push   $0x1
 804ea38:	ff 35 04 77 06 08    	push   0x8067704
 804ea3e:	e8 6d a6 ff ff       	call   80490b0 <__fprintf_chk@plt>
 804ea43:	83 c4 10             	add    $0x10,%esp

	fprintf(stdout, "%s ", _HELP_SWITCH);

	while (args_struct[count].option != NULL) {
 804ea46:	83 7b 04 00          	cmpl   $0x0,0x4(%ebx)
 804ea4a:	74 5c                	je     804eaa8 <cmd_print_switches_help+0x98>
		char stringy[_MAX_STRINGY_LEN];

		cmd_gen_switch_syntax(stringy, _MAX_STRINGY_LEN,
 804ea4c:	8d 7d 9e             	lea    -0x62(%ebp),%edi
 804ea4f:	89 da                	mov    %ebx,%edx
 804ea51:	89 f8                	mov    %edi,%eax
 804ea53:	e8 ca fb ff ff       	call   804e622 <cmd_gen_switch_syntax.constprop.0>
				      &args_struct[count]);

		if (printed_in_line + strlen(stringy) > _MAX_LINE_WIDTH) {
 804ea58:	83 ec 0c             	sub    $0xc,%esp
 804ea5b:	57                   	push   %edi
 804ea5c:	e8 df a7 ff ff       	call   8049240 <strlen@plt>
 804ea61:	83 c4 10             	add    $0x10,%esp
 804ea64:	01 f0                	add    %esi,%eax
 804ea66:	83 f8 64             	cmp    $0x64,%eax
 804ea69:	76 18                	jbe    804ea83 <cmd_print_switches_help+0x73>
 804ea6b:	52                   	push   %edx
			fprintf(stdout, "\n");
			printed_in_line = 0;
 804ea6c:	31 f6                	xor    %esi,%esi
 804ea6e:	68 af 34 06 08       	push   $0x80634af
 804ea73:	6a 01                	push   $0x1
 804ea75:	ff 35 04 77 06 08    	push   0x8067704
 804ea7b:	e8 30 a6 ff ff       	call   80490b0 <__fprintf_chk@plt>
 804ea80:	83 c4 10             	add    $0x10,%esp
 804ea83:	57                   	push   %edi
 804ea84:	83 c3 1c             	add    $0x1c,%ebx
 804ea87:	68 d2 32 06 08       	push   $0x80632d2
 804ea8c:	6a 01                	push   $0x1
 804ea8e:	ff 35 04 77 06 08    	push   0x8067704
 804ea94:	e8 17 a6 ff ff       	call   80490b0 <__fprintf_chk@plt>
		}

		fprintf(stdout, "%s", stringy);
		printed_in_line += strlen(stringy);
 804ea99:	89 3c 24             	mov    %edi,(%esp)
 804ea9c:	e8 9f a7 ff ff       	call   8049240 <strlen@plt>
 804eaa1:	83 c4 10             	add    $0x10,%esp
 804eaa4:	01 c6                	add    %eax,%esi
		count++;
 804eaa6:	eb 9e                	jmp    804ea46 <cmd_print_switches_help+0x36>
 804eaa8:	50                   	push   %eax
 804eaa9:	68 af 34 06 08       	push   $0x80634af
 804eaae:	6a 01                	push   $0x1
 804eab0:	ff 35 04 77 06 08    	push   0x8067704
 804eab6:	e8 f5 a5 ff ff       	call   80490b0 <__fprintf_chk@plt>
 804eabb:	83 c4 10             	add    $0x10,%esp
	}

	fprintf(stdout, "\n");
}
 804eabe:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804eac1:	65 2b 05 14 00 00 00 	sub    %gs:0x14,%eax
 804eac8:	74 05                	je     804eacf <cmd_print_switches_help+0xbf>
 804eaca:	e8 31 a8 ff ff       	call   8049300 <__stack_chk_fail@plt>
 804eacf:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804ead2:	5b                   	pop    %ebx
 804ead3:	5e                   	pop    %esi
 804ead4:	5f                   	pop    %edi
 804ead5:	5d                   	pop    %ebp
 804ead6:	c3                   	ret    

0804ead7 <cmd_print_long_help>:

/**
 * Print the long help message of the program
 */
void cmd_print_long_help(struct args_struct_t args_struct[])
{
 804ead7:	55                   	push   %ebp
 804ead8:	89 e5                	mov    %esp,%ebp
 804eada:	57                   	push   %edi
 804eadb:	56                   	push   %esi
 804eadc:	53                   	push   %ebx
 804eadd:	83 ec 78             	sub    $0x78,%esp
 804eae0:	8b 5d 08             	mov    0x8(%ebp),%ebx
 804eae3:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 804eae9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 804eaec:	31 c0                	xor    %eax,%eax
	int ret;
	int count = 0;
	int printed_in_line = 0;
	char stringy[_MAX_STRINGY_LEN];

	cmd_print_switches_help(args_struct);
 804eaee:	53                   	push   %ebx
 804eaef:	e8 1c ff ff ff       	call   804ea10 <cmd_print_switches_help>
 804eaf4:	5a                   	pop    %edx
 804eaf5:	59                   	pop    %ecx
 804eaf6:	68 33 34 06 08       	push   $0x8063433
 804eafb:	68 16 34 06 08       	push   $0x8063416
 804eb00:	6a 1d                	push   $0x1d
 804eb02:	68 45 34 06 08       	push   $0x8063445
 804eb07:	6a 01                	push   $0x1
 804eb09:	ff 35 04 77 06 08    	push   0x8067704
 804eb0f:	e8 9c a5 ff ff       	call   80490b0 <__fprintf_chk@plt>
 804eb14:	83 c4 20             	add    $0x20,%esp

	fprintf(stdout, "\n %-*s:%s\n", _LONG_HELP_ALIGN-1,
		_HELP_SWITCH, _HELP_DESCR);

	while (args_struct[count].option != NULL) {
 804eb17:	83 7b 04 00          	cmpl   $0x0,0x4(%ebx)
 804eb1b:	0f 84 a5 00 00 00    	je     804ebc6 <cmd_print_long_help+0xef>
		int printed_right;
		char *toprint;
		int total_to_print;

		cmd_gen_switch_syntax(stringy, _MAX_STRINGY_LEN,
 804eb21:	8d 75 9e             	lea    -0x62(%ebp),%esi
 804eb24:	89 da                	mov    %ebx,%edx
 804eb26:	89 f0                	mov    %esi,%eax
 804eb28:	e8 f5 fa ff ff       	call   804e622 <cmd_gen_switch_syntax.constprop.0>
 804eb2d:	83 ec 0c             	sub    $0xc,%esp
 804eb30:	56                   	push   %esi
 804eb31:	6a 1d                	push   $0x1d
 804eb33:	68 50 34 06 08       	push   $0x8063450
 804eb38:	6a 01                	push   $0x1
 804eb3a:	ff 35 04 77 06 08    	push   0x8067704
 804eb40:	e8 6b a5 ff ff       	call   80490b0 <__fprintf_chk@plt>
				      &args_struct[count]);

		ret = fprintf(stdout, " %-*s:", _LONG_HELP_ALIGN-1, stringy);
		printed_in_line = ret;
		printed_right = 0;
		toprint = args_struct[count].descript;
 804eb45:	8b 7b 18             	mov    0x18(%ebx),%edi
 804eb48:	83 c4 14             	add    $0x14,%esp
 804eb4b:	89 c6                	mov    %eax,%esi
		total_to_print = strlen(toprint);
 804eb4d:	57                   	push   %edi
 804eb4e:	e8 ed a6 ff ff       	call   8049240 <strlen@plt>
 804eb53:	89 3c 24             	mov    %edi,(%esp)
 804eb56:	89 45 94             	mov    %eax,-0x6c(%ebp)
		ret = fprintf(stdout, "%.*s\n",
 804eb59:	b8 64 00 00 00       	mov    $0x64,%eax
 804eb5e:	29 f0                	sub    %esi,%eax
 804eb60:	50                   	push   %eax
 804eb61:	68 57 34 06 08       	push   $0x8063457
 804eb66:	6a 01                	push   $0x1
 804eb68:	ff 35 04 77 06 08    	push   0x8067704
 804eb6e:	e8 3d a5 ff ff       	call   80490b0 <__fprintf_chk@plt>
 804eb73:	83 c4 20             	add    $0x20,%esp
				_MAX_LINE_WIDTH - printed_in_line,
				&toprint[printed_right]);
		printed_right += ret - 1;
 804eb76:	8d 70 ff             	lea    -0x1(%eax),%esi

		while (printed_right < total_to_print) {
 804eb79:	3b 75 94             	cmp    -0x6c(%ebp),%esi
 804eb7c:	7d 40                	jge    804ebbe <cmd_print_long_help+0xe7>
 804eb7e:	83 ec 0c             	sub    $0xc,%esp
 804eb81:	68 b0 34 06 08       	push   $0x80634b0
 804eb86:	6a 1e                	push   $0x1e
 804eb88:	68 5d 34 06 08       	push   $0x806345d
 804eb8d:	6a 01                	push   $0x1
 804eb8f:	ff 35 04 77 06 08    	push   0x8067704
 804eb95:	e8 16 a5 ff ff       	call   80490b0 <__fprintf_chk@plt>
 804eb9a:	83 c4 14             	add    $0x14,%esp
			fprintf(stdout, "%*s", _LONG_HELP_ALIGN, "");
			ret = fprintf(stdout, "%.*s\n",
 804eb9d:	8d 04 37             	lea    (%edi,%esi,1),%eax
 804eba0:	50                   	push   %eax
 804eba1:	6a 46                	push   $0x46
 804eba3:	68 57 34 06 08       	push   $0x8063457
 804eba8:	6a 01                	push   $0x1
 804ebaa:	ff 35 04 77 06 08    	push   0x8067704
 804ebb0:	e8 fb a4 ff ff       	call   80490b0 <__fprintf_chk@plt>
 804ebb5:	83 c4 20             	add    $0x20,%esp
				      _MAX_LINE_WIDTH - _LONG_HELP_ALIGN,
				      &toprint[printed_right]);
			printed_right += ret - 1;
 804ebb8:	8d 74 06 ff          	lea    -0x1(%esi,%eax,1),%esi
 804ebbc:	eb bb                	jmp    804eb79 <cmd_print_long_help+0xa2>
		}
		count++;
 804ebbe:	83 c3 1c             	add    $0x1c,%ebx
 804ebc1:	e9 51 ff ff ff       	jmp    804eb17 <cmd_print_long_help+0x40>
 804ebc6:	50                   	push   %eax
 804ebc7:	68 af 34 06 08       	push   $0x80634af
 804ebcc:	6a 01                	push   $0x1
 804ebce:	ff 35 04 77 06 08    	push   0x8067704
 804ebd4:	e8 d7 a4 ff ff       	call   80490b0 <__fprintf_chk@plt>
 804ebd9:	83 c4 0c             	add    $0xc,%esp
 804ebdc:	68 61 34 06 08       	push   $0x8063461
 804ebe1:	6a 01                	push   $0x1
 804ebe3:	ff 35 04 77 06 08    	push   0x8067704
 804ebe9:	e8 c2 a4 ff ff       	call   80490b0 <__fprintf_chk@plt>
 804ebee:	83 c4 10             	add    $0x10,%esp
	}
	fprintf(stdout, "\n");
	fprintf(stdout, "Note that which options are available depends on the "
		"enabled features/drivers\n\n");
}
 804ebf1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804ebf4:	65 2b 05 14 00 00 00 	sub    %gs:0x14,%eax
 804ebfb:	74 05                	je     804ec02 <cmd_print_long_help+0x12b>
 804ebfd:	e8 fe a6 ff ff       	call   8049300 <__stack_chk_fail@plt>
 804ec02:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804ec05:	5b                   	pop    %ebx
 804ec06:	5e                   	pop    %esi
 804ec07:	5f                   	pop    %edi
 804ec08:	5d                   	pop    %ebp
 804ec09:	c3                   	ret    

0804ec0a <cmd_parse_one_arg>:
 * Try to find if this argument is in the list (and it is not manual)
 * if it does, try to parse it, set its dest accordingly, and return true
 * if it is not found, return false
 */
bool cmd_parse_one_arg(char *argv, struct args_struct_t args_struct[])
{
 804ec0a:	55                   	push   %ebp
 804ec0b:	89 e5                	mov    %esp,%ebp
 804ec0d:	57                   	push   %edi
 804ec0e:	56                   	push   %esi
 804ec0f:	53                   	push   %ebx
 804ec10:	83 ec 18             	sub    $0x18,%esp
 804ec13:	8b 7d 08             	mov    0x8(%ebp),%edi
 804ec16:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	int count = 0;
	int ret;

	if (cmd_is_help_option(argv)) {
 804ec19:	57                   	push   %edi
 804ec1a:	e8 49 fb ff ff       	call   804e768 <cmd_is_help_option>
 804ec1f:	83 c4 10             	add    $0x10,%esp
 804ec22:	85 c0                	test   %eax,%eax
 804ec24:	74 22                	je     804ec48 <cmd_parse_one_arg+0x3e>
		cmd_print_long_help(args_struct);
 804ec26:	83 ec 0c             	sub    $0xc,%esp
 804ec29:	53                   	push   %ebx
 804ec2a:	e8 a8 fe ff ff       	call   804ead7 <cmd_print_long_help>
		posix_exit(0);
 804ec2f:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 804ec36:	e8 0f f8 ff ff       	call   804e44a <posix_exit>
 804ec3b:	83 c4 10             	add    $0x10,%esp
 804ec3e:	eb 08                	jmp    804ec48 <cmd_parse_one_arg+0x3e>
	}

	while (args_struct[count].option != NULL) {
		if (args_struct[count].manual) {
 804ec40:	80 3b 00             	cmpb   $0x0,(%ebx)
 804ec43:	74 0c                	je     804ec51 <cmd_parse_one_arg+0x47>
 804ec45:	83 c3 1c             	add    $0x1c,%ebx
	while (args_struct[count].option != NULL) {
 804ec48:	8b 53 04             	mov    0x4(%ebx),%edx
 804ec4b:	85 d2                	test   %edx,%edx
 804ec4d:	75 f1                	jne    804ec40 <cmd_parse_one_arg+0x36>
 804ec4f:	eb 6b                	jmp    804ecbc <cmd_parse_one_arg+0xb2>
			count++;
			continue;
		}
		ret = cmd_is_option(argv, args_struct[count].option,
 804ec51:	51                   	push   %ecx
				    !args_struct[count].is_switch);
 804ec52:	8a 43 02             	mov    0x2(%ebx),%al
 804ec55:	83 f0 01             	xor    $0x1,%eax
		ret = cmd_is_option(argv, args_struct[count].option,
 804ec58:	0f b6 c0             	movzbl %al,%eax
 804ec5b:	50                   	push   %eax
 804ec5c:	52                   	push   %edx
 804ec5d:	57                   	push   %edi
 804ec5e:	e8 6a fa ff ff       	call   804e6cd <cmd_is_option>
 804ec63:	83 c4 10             	add    $0x10,%esp
 804ec66:	89 c6                	mov    %eax,%esi
		if (ret) {
 804ec68:	85 c0                	test   %eax,%eax
 804ec6a:	74 d9                	je     804ec45 <cmd_parse_one_arg+0x3b>
	if (arg_element->dest != NULL) {
 804ec6c:	8b 53 10             	mov    0x10(%ebx),%edx
 804ec6f:	85 d2                	test   %edx,%edx
 804ec71:	74 33                	je     804eca6 <cmd_parse_one_arg+0x9c>
		if (arg_element->is_switch) {
 804ec73:	80 7b 02 00          	cmpb   $0x0,0x2(%ebx)
			if (arg_element->type == 'b') {
 804ec77:	0f be 43 0c          	movsbl 0xc(%ebx),%eax
		if (arg_element->is_switch) {
 804ec7b:	74 18                	je     804ec95 <cmd_parse_one_arg+0x8b>
			if (arg_element->type == 'b') {
 804ec7d:	3c 62                	cmp    $0x62,%al
 804ec7f:	75 05                	jne    804ec86 <cmd_parse_one_arg+0x7c>
				*(bool *)arg_element->dest = true;
 804ec81:	c6 02 01             	movb   $0x1,(%edx)
 804ec84:	eb 20                	jmp    804eca6 <cmd_parse_one_arg+0x9c>
				posix_print_error_and_exit(CMD_ERR_BOOL_SWI);
 804ec86:	83 ec 0c             	sub    $0xc,%esp
 804ec89:	68 b1 34 06 08       	push   $0x80634b1
 804ec8e:	e8 11 f9 ff ff       	call   804e5a4 <posix_print_error_and_exit>
 804ec93:	eb 0e                	jmp    804eca3 <cmd_parse_one_arg+0x99>
			cmd_read_option_value(&argv[offset],
 804ec95:	ff 73 04             	push   0x4(%ebx)
 804ec98:	50                   	push   %eax
 804ec99:	8d 04 37             	lea    (%edi,%esi,1),%eax
 804ec9c:	52                   	push   %edx
 804ec9d:	50                   	push   %eax
 804ec9e:	e8 31 fb ff ff       	call   804e7d4 <cmd_read_option_value>
 804eca3:	83 c4 10             	add    $0x10,%esp
	if (arg_element->call_when_found) {
 804eca6:	8b 53 14             	mov    0x14(%ebx),%edx
			cmd_handle_this_matched_arg(argv,
						    ret,
						    &args_struct[count]);
			return true;
 804eca9:	b0 01                	mov    $0x1,%al
	if (arg_element->call_when_found) {
 804ecab:	85 d2                	test   %edx,%edx
 804ecad:	74 0f                	je     804ecbe <cmd_parse_one_arg+0xb4>
		arg_element->call_when_found(argv, offset);
 804ecaf:	50                   	push   %eax
 804ecb0:	50                   	push   %eax
 804ecb1:	56                   	push   %esi
 804ecb2:	57                   	push   %edi
 804ecb3:	ff d2                	call   *%edx
			return true;
 804ecb5:	b0 01                	mov    $0x1,%al
		arg_element->call_when_found(argv, offset);
 804ecb7:	83 c4 10             	add    $0x10,%esp
 804ecba:	eb 02                	jmp    804ecbe <cmd_parse_one_arg+0xb4>
		}
		count++;
	}
	return false;
 804ecbc:	31 c0                	xor    %eax,%eax
}
 804ecbe:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804ecc1:	5b                   	pop    %ebx
 804ecc2:	5e                   	pop    %esi
 804ecc3:	5f                   	pop    %edi
 804ecc4:	5d                   	pop    %ebp
 804ecc5:	c3                   	ret    

0804ecc6 <native_cleanup_cmd_line>:
static int args_aval;
#define ARGS_ALLOC_CHUNK_SIZE 20

void native_cleanup_cmd_line(void)
{
	if (args_struct != NULL) { /* LCOV_EXCL_BR_LINE */
 804ecc6:	a1 70 89 06 08       	mov    0x8068970,%eax
 804eccb:	85 c0                	test   %eax,%eax
 804eccd:	74 1b                	je     804ecea <native_cleanup_cmd_line+0x24>
{
 804eccf:	55                   	push   %ebp
 804ecd0:	89 e5                	mov    %esp,%ebp
 804ecd2:	83 ec 14             	sub    $0x14,%esp
		free(args_struct);
 804ecd5:	50                   	push   %eax
 804ecd6:	e8 c5 a4 ff ff       	call   80491a0 <free@plt>
 804ecdb:	83 c4 10             	add    $0x10,%esp
		args_struct = NULL;
 804ecde:	c7 05 70 89 06 08 00 	movl   $0x0,0x8068970
 804ece5:	00 00 00 
	}
}
 804ece8:	c9                   	leave  
 804ece9:	c3                   	ret    
 804ecea:	c3                   	ret    

0804eceb <native_add_command_line_opts>:
 *
 * Each option to be added is described in one entry of the input <args>
 * This input must be terminated with an entry containing ARG_TABLE_ENDMARKER.
 */
void native_add_command_line_opts(struct args_struct_t *args)
{
 804eceb:	55                   	push   %ebp
	int count = 0;
 804ecec:	31 c0                	xor    %eax,%eax
{
 804ecee:	89 e5                	mov    %esp,%ebp
 804ecf0:	57                   	push   %edi
 804ecf1:	56                   	push   %esi
 804ecf2:	53                   	push   %ebx
 804ecf3:	83 ec 0c             	sub    $0xc,%esp

	while (args[count].option != NULL) {
 804ecf6:	6b f0 1c             	imul   $0x1c,%eax,%esi
 804ecf9:	8b 7d 08             	mov    0x8(%ebp),%edi
 804ecfc:	89 c3                	mov    %eax,%ebx
		count++;
 804ecfe:	8d 40 01             	lea    0x1(%eax),%eax
	while (args[count].option != NULL) {
 804ed01:	83 7c 37 04 00       	cmpl   $0x0,0x4(%edi,%esi,1)
 804ed06:	75 ee                	jne    804ecf6 <native_add_command_line_opts+0xb>
	}
	count++; /*for the end marker*/

	if (used_args + count >= args_aval) {
 804ed08:	8b 0d 6c 89 06 08    	mov    0x806896c,%ecx
 804ed0e:	8b 15 68 89 06 08    	mov    0x8068968,%edx
 804ed14:	01 c1                	add    %eax,%ecx
 804ed16:	39 d1                	cmp    %edx,%ecx
 804ed18:	7c 42                	jl     804ed5c <native_add_command_line_opts+0x71>
		if (growby < ARGS_ALLOC_CHUNK_SIZE) {
			growby = ARGS_ALLOC_CHUNK_SIZE;
		}

		struct args_struct_t *new_args_struct = realloc(args_struct,
				      (args_aval + growby)*
 804ed1a:	b9 14 00 00 00       	mov    $0x14,%ecx
 804ed1f:	39 c8                	cmp    %ecx,%eax
 804ed21:	0f 4c c1             	cmovl  %ecx,%eax
 804ed24:	8d 3c 10             	lea    (%eax,%edx,1),%edi
		struct args_struct_t *new_args_struct = realloc(args_struct,
 804ed27:	50                   	push   %eax
 804ed28:	50                   	push   %eax
 804ed29:	6b c7 1c             	imul   $0x1c,%edi,%eax
 804ed2c:	50                   	push   %eax
 804ed2d:	ff 35 70 89 06 08    	push   0x8068970
 804ed33:	e8 88 a3 ff ff       	call   80490c0 <realloc@plt>
				      sizeof(struct args_struct_t));
		args_aval += growby;
 804ed38:	89 3d 68 89 06 08    	mov    %edi,0x8068968
		struct args_struct_t *new_args_struct = realloc(args_struct,
 804ed3e:	83 c4 10             	add    $0x10,%esp
		/* LCOV_EXCL_START */
		if (new_args_struct == NULL) {
 804ed41:	85 c0                	test   %eax,%eax
 804ed43:	75 12                	jne    804ed57 <native_add_command_line_opts+0x6c>
			posix_print_error_and_exit("Could not allocate memory");
 804ed45:	83 ec 0c             	sub    $0xc,%esp
 804ed48:	68 fc 34 06 08       	push   $0x80634fc
 804ed4d:	e8 52 f8 ff ff       	call   804e5a4 <posix_print_error_and_exit>
 804ed52:	83 c4 10             	add    $0x10,%esp
 804ed55:	eb 05                	jmp    804ed5c <native_add_command_line_opts+0x71>
		} else {
			args_struct = new_args_struct;
 804ed57:	a3 70 89 06 08       	mov    %eax,0x8068970
		}
		/* LCOV_EXCL_STOP */
	}

	memcpy(&args_struct[used_args], args,
 804ed5c:	8b 15 6c 89 06 08    	mov    0x806896c,%edx
 804ed62:	8d 4e 1c             	lea    0x1c(%esi),%ecx
  return __builtin___memcpy_chk (__dest, __src, __len,
 804ed65:	8b 75 08             	mov    0x8(%ebp),%esi
 804ed68:	6b c2 1c             	imul   $0x1c,%edx,%eax
 804ed6b:	03 05 70 89 06 08    	add    0x8068970,%eax
		count*sizeof(struct args_struct_t));

	used_args += count - 1;
 804ed71:	01 da                	add    %ebx,%edx
 804ed73:	89 c7                	mov    %eax,%edi
 804ed75:	89 15 6c 89 06 08    	mov    %edx,0x806896c
 804ed7b:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
	/*
	 * -1 as the end marker should be overwritten next time something
	 * is added
	 */
}
 804ed7d:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804ed80:	5b                   	pop    %ebx
 804ed81:	5e                   	pop    %esi
 804ed82:	5f                   	pop    %edi
 804ed83:	5d                   	pop    %ebp
 804ed84:	c3                   	ret    

0804ed85 <native_add_testargs_option>:

void native_add_testargs_option(void)
{
 804ed85:	55                   	push   %ebp
 804ed86:	89 e5                	mov    %esp,%ebp
 804ed88:	83 ec 14             	sub    $0x14,%esp
		(void *)NULL, NULL,
		"Any argument that follows will be ignored by the top level, "
		"and made available for possible tests"},
		ARG_TABLE_ENDMARKER};

	native_add_command_line_opts(testargs_options);
 804ed8b:	68 60 61 06 08       	push   $0x8066160
 804ed90:	e8 56 ff ff ff       	call   804eceb <native_add_command_line_opts>
 804ed95:	83 c4 10             	add    $0x10,%esp
}
 804ed98:	c9                   	leave  
 804ed99:	c3                   	ret    

0804ed9a <native_handle_cmd_line>:
 * Handle possible command line arguments.
 *
 * We also store them for later use by possible test applications
 */
void native_handle_cmd_line(int argc, char *argv[])
{
 804ed9a:	55                   	push   %ebp
 804ed9b:	89 e5                	mov    %esp,%ebp
 804ed9d:	57                   	push   %edi
	s_argv = argv;
	s_argc = argc;

	cmd_args_set_defaults(args_struct);

	for (i = 1; i < argc; i++) {
 804ed9e:	bf 01 00 00 00       	mov    $0x1,%edi
{
 804eda3:	56                   	push   %esi
 804eda4:	53                   	push   %ebx
 804eda5:	83 ec 1c             	sub    $0x1c,%esp
 804eda8:	8b 5d 08             	mov    0x8(%ebp),%ebx
 804edab:	8b 75 0c             	mov    0xc(%ebp),%esi
	native_add_tracing_options();
 804edae:	e8 5a f8 ff ff       	call   804e60d <native_add_tracing_options>
	native_add_testargs_option();
 804edb3:	e8 cd ff ff ff       	call   804ed85 <native_add_testargs_option>
	cmd_args_set_defaults(args_struct);
 804edb8:	83 ec 0c             	sub    $0xc,%esp
 804edbb:	ff 35 70 89 06 08    	push   0x8068970
	s_argv = argv;
 804edc1:	89 35 78 89 06 08    	mov    %esi,0x8068978
	s_argc = argc;
 804edc7:	89 1d 80 89 06 08    	mov    %ebx,0x8068980
	cmd_args_set_defaults(args_struct);
 804edcd:	e8 99 fb ff ff       	call   804e96b <cmd_args_set_defaults>
 804edd2:	83 c4 10             	add    $0x10,%esp
	for (i = 1; i < argc; i++) {
 804edd5:	39 df                	cmp    %ebx,%edi
 804edd7:	7d 6c                	jge    804ee45 <native_handle_cmd_line+0xab>

		if ((cmd_is_option(argv[i], "testargs", 0))) {
 804edd9:	50                   	push   %eax
 804edda:	6a 00                	push   $0x0
 804eddc:	68 16 35 06 08       	push   $0x8063516
 804ede1:	ff 34 be             	push   (%esi,%edi,4)
 804ede4:	e8 e4 f8 ff ff       	call   804e6cd <cmd_is_option>
 804ede9:	83 c4 10             	add    $0x10,%esp
 804edec:	85 c0                	test   %eax,%eax
 804edee:	8d 47 01             	lea    0x1(%edi),%eax
 804edf1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 804edf4:	74 13                	je     804ee09 <native_handle_cmd_line+0x6f>
			test_argc = argc - i - 1;
 804edf6:	29 fb                	sub    %edi,%ebx
			test_argv = &argv[i+1];
 804edf8:	8d 04 86             	lea    (%esi,%eax,4),%eax
			test_argc = argc - i - 1;
 804edfb:	4b                   	dec    %ebx
			test_argv = &argv[i+1];
 804edfc:	a3 74 89 06 08       	mov    %eax,0x8068974
			test_argc = argc - i - 1;
 804ee01:	89 1d 7c 89 06 08    	mov    %ebx,0x806897c
			break;
 804ee07:	eb 3c                	jmp    804ee45 <native_handle_cmd_line+0xab>
		}

		if (!cmd_parse_one_arg(argv[i], args_struct)) {
 804ee09:	51                   	push   %ecx
 804ee0a:	51                   	push   %ecx
 804ee0b:	ff 35 70 89 06 08    	push   0x8068970
 804ee11:	ff 34 be             	push   (%esi,%edi,4)
 804ee14:	e8 f1 fd ff ff       	call   804ec0a <cmd_parse_one_arg>
 804ee19:	83 c4 10             	add    $0x10,%esp
 804ee1c:	84 c0                	test   %al,%al
 804ee1e:	75 20                	jne    804ee40 <native_handle_cmd_line+0xa6>
			cmd_print_switches_help(args_struct);
 804ee20:	83 ec 0c             	sub    $0xc,%esp
 804ee23:	ff 35 70 89 06 08    	push   0x8068970
 804ee29:	e8 e2 fb ff ff       	call   804ea10 <cmd_print_switches_help>
 804ee2e:	58                   	pop    %eax
 804ee2f:	5a                   	pop    %edx
	posix_print_error_and_exit("Incorrect option '%s'. Did you misspell it?"
 804ee30:	ff 34 be             	push   (%esi,%edi,4)
 804ee33:	68 1f 35 06 08       	push   $0x806351f
 804ee38:	e8 67 f7 ff ff       	call   804e5a4 <posix_print_error_and_exit>
 804ee3d:	83 c4 10             	add    $0x10,%esp
	for (i = 1; i < argc; i++) {
 804ee40:	8b 7d e4             	mov    -0x1c(%ebp),%edi
 804ee43:	eb 90                	jmp    804edd5 <native_handle_cmd_line+0x3b>
			print_invalid_opt_error(argv[i]);
		}
	}
}
 804ee45:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804ee48:	5b                   	pop    %ebx
 804ee49:	5e                   	pop    %esi
 804ee4a:	5f                   	pop    %edi
 804ee4b:	5d                   	pop    %ebp
 804ee4c:	c3                   	ret    

0804ee4d <hw_counter_init>:
/**
 * Initialize the counter with prescaler of HW
 */
void hw_counter_init(void)
{
	hw_counter_timer = NEVER;
 804ee4d:	c7 05 f0 88 06 08 ff 	movl   $0xffffffff,0x80688f0
 804ee54:	ff ff ff 
 804ee57:	c7 05 f4 88 06 08 ff 	movl   $0xffffffff,0x80688f4
 804ee5e:	ff ff ff 
	counter_target = NEVER;
 804ee61:	c7 05 e0 88 06 08 ff 	movl   $0xffffffff,0x80688e0
 804ee68:	ff ff ff 
 804ee6b:	c7 05 e4 88 06 08 ff 	movl   $0xffffffff,0x80688e4
 804ee72:	ff ff ff 
	counter_value = 0;
 804ee75:	c7 05 e8 88 06 08 00 	movl   $0x0,0x80688e8
 804ee7c:	00 00 00 
 804ee7f:	c7 05 ec 88 06 08 00 	movl   $0x0,0x80688ec
 804ee86:	00 00 00 
	counter_running = false;
 804ee89:	c6 05 b2 8a 06 08 00 	movb   $0x0,0x8068ab2
	counter_period = NEVER;
 804ee90:	c7 05 d8 88 06 08 ff 	movl   $0xffffffff,0x80688d8
 804ee97:	ff ff ff 
 804ee9a:	c7 05 dc 88 06 08 ff 	movl   $0xffffffff,0x80688dc
 804eea1:	ff ff ff 
}
 804eea4:	c3                   	ret    

0804eea5 <hw_counter_triggered>:

void hw_counter_triggered(void)
{
	if (!counter_running) {
 804eea5:	80 3d b2 8a 06 08 00 	cmpb   $0x0,0x8068ab2
 804eeac:	75 15                	jne    804eec3 <hw_counter_triggered+0x1e>
		hw_counter_timer = NEVER;
 804eeae:	c7 05 f0 88 06 08 ff 	movl   $0xffffffff,0x80688f0
 804eeb5:	ff ff ff 
 804eeb8:	c7 05 f4 88 06 08 ff 	movl   $0xffffffff,0x80688f4
 804eebf:	ff ff ff 
		return;
 804eec2:	c3                   	ret    
{
 804eec3:	55                   	push   %ebp
 804eec4:	89 e5                	mov    %esp,%ebp
 804eec6:	83 ec 08             	sub    $0x8,%esp
	}

	hw_counter_timer = hwm_get_time() + counter_period;
 804eec9:	e8 01 eb ff ff       	call   804d9cf <hwm_get_time>
 804eece:	03 05 d8 88 06 08    	add    0x80688d8,%eax
 804eed4:	13 15 dc 88 06 08    	adc    0x80688dc,%edx
 804eeda:	a3 f0 88 06 08       	mov    %eax,0x80688f0
	counter_value = counter_value + 1;
 804eedf:	a1 e8 88 06 08       	mov    0x80688e8,%eax
	hw_counter_timer = hwm_get_time() + counter_period;
 804eee4:	89 15 f4 88 06 08    	mov    %edx,0x80688f4
	counter_value = counter_value + 1;
 804eeea:	8b 15 ec 88 06 08    	mov    0x80688ec,%edx
 804eef0:	83 c0 01             	add    $0x1,%eax
 804eef3:	83 d2 00             	adc    $0x0,%edx
 804eef6:	a3 e8 88 06 08       	mov    %eax,0x80688e8
 804eefb:	89 15 ec 88 06 08    	mov    %edx,0x80688ec

	if (counter_value == counter_target) {
 804ef01:	3b 15 e4 88 06 08    	cmp    0x80688e4,%edx
 804ef07:	75 15                	jne    804ef1e <hw_counter_triggered+0x79>
 804ef09:	3b 05 e0 88 06 08    	cmp    0x80688e0,%eax
 804ef0f:	75 0d                	jne    804ef1e <hw_counter_triggered+0x79>
		hw_irq_ctrl_set_irq(COUNTER_EVENT_IRQ);
 804ef11:	83 ec 0c             	sub    $0xc,%esp
 804ef14:	6a 02                	push   $0x2
 804ef16:	e8 78 f4 ff ff       	call   804e393 <hw_irq_ctrl_set_irq>
 804ef1b:	83 c4 10             	add    $0x10,%esp
	}
}
 804ef1e:	c9                   	leave  
 804ef1f:	c3                   	ret    

0804ef20 <z_impl_sys_rand32_get>:
static const struct device *const entropy_dev =
	DEVICE_DT_GET(DT_CHOSEN(zephyr_entropy));

#if defined(CONFIG_ENTROPY_DEVICE_RANDOM_GENERATOR)
uint32_t z_impl_sys_rand32_get(void)
{
 804ef20:	55                   	push   %ebp
 804ef21:	89 e5                	mov    %esp,%ebp
 804ef23:	83 ec 1c             	sub    $0x1c,%esp
 804ef26:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 804ef2c:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804ef2f:	31 c0                	xor    %eax,%eax
	const struct entropy_driver_api *api =
		(const struct entropy_driver_api *)dev->api;

	__ASSERT(api->get_entropy != NULL,
		"Callback pointer should not be NULL");
	return api->get_entropy(dev, buffer, length);
 804ef31:	8d 45 f0             	lea    -0x10(%ebp),%eax
 804ef34:	6a 04                	push   $0x4
 804ef36:	50                   	push   %eax
 804ef37:	a1 34 74 06 08       	mov    0x8067434,%eax
 804ef3c:	68 2c 74 06 08       	push   $0x806742c
 804ef41:	ff 10                	call   *(%eax)
 804ef43:	83 c4 10             	add    $0x10,%esp
	__ASSERT(device_is_ready(entropy_dev), "Entropy device %s not ready",
		 entropy_dev->name);

	ret = entropy_get_entropy(entropy_dev, (uint8_t *)&random_num,
				  sizeof(random_num));
	if (unlikely(ret < 0)) {
 804ef46:	85 c0                	test   %eax,%eax
 804ef48:	79 08                	jns    804ef52 <z_impl_sys_rand32_get+0x32>
	return sys_clock_cycle_get_32();
 804ef4a:	e8 90 fa 00 00       	call   805e9df <sys_clock_cycle_get_32>
		 * 32-bit of data.  There's not much that can be done in this
		 * situation.  An __ASSERT() isn't used here as the HWRNG might
		 * still be gathering entropy during early boot situations.
		 */

		random_num = k_cycle_get_32();
 804ef4f:	89 45 f0             	mov    %eax,-0x10(%ebp)
	}

	return random_num;
 804ef52:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
 804ef55:	8b 55 f4             	mov    -0xc(%ebp),%edx
 804ef58:	65 2b 15 14 00 00 00 	sub    %gs:0x14,%edx
 804ef5f:	74 05                	je     804ef66 <z_impl_sys_rand32_get+0x46>
 804ef61:	e8 9a a3 ff ff       	call   8049300 <__stack_chk_fail@plt>
 804ef66:	c9                   	leave  
 804ef67:	c3                   	ret    

0804ef68 <fixed_data_unref>:
}

static void fixed_data_unref(struct net_buf *buf, uint8_t *data)
{
	/* Nothing needed for fixed-size data pools */
}
 804ef68:	c3                   	ret    

0804ef69 <net_buf_id>:
{
 804ef69:	55                   	push   %ebp
 804ef6a:	89 e5                	mov    %esp,%ebp
 804ef6c:	8b 45 08             	mov    0x8(%ebp),%eax
}
 804ef6f:	5d                   	pop    %ebp
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
 804ef70:	0f b6 50 0a          	movzbl 0xa(%eax),%edx
	ptrdiff_t offset = (uint8_t *)buf - (uint8_t *)pool->__bufs;
 804ef74:	6b d2 2c             	imul   $0x2c,%edx,%edx
	size_t struct_size = ROUND_UP(sizeof(struct net_buf) + pool->user_data_size,
 804ef77:	0f b6 8a 1c 76 06 08 	movzbl 0x806761c(%edx),%ecx
	ptrdiff_t offset = (uint8_t *)buf - (uint8_t *)pool->__bufs;
 804ef7e:	2b 82 28 76 06 08    	sub    0x8067628(%edx),%eax
	return offset / struct_size;
 804ef84:	31 d2                	xor    %edx,%edx
	size_t struct_size = ROUND_UP(sizeof(struct net_buf) + pool->user_data_size,
 804ef86:	83 c1 1b             	add    $0x1b,%ecx
 804ef89:	83 e1 fc             	and    $0xfffffffc,%ecx
	return offset / struct_size;
 804ef8c:	f7 f1                	div    %ecx
}
 804ef8e:	c3                   	ret    

0804ef8f <fixed_data_alloc>:
{
 804ef8f:	55                   	push   %ebp
 804ef90:	89 e5                	mov    %esp,%ebp
 804ef92:	53                   	push   %ebx
 804ef93:	83 ec 10             	sub    $0x10,%esp
 804ef96:	8b 55 08             	mov    0x8(%ebp),%edx
 804ef99:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
 804ef9c:	0f b6 42 0a          	movzbl 0xa(%edx),%eax
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;
 804efa0:	6b c0 2c             	imul   $0x2c,%eax,%eax
 804efa3:	8b 80 24 76 06 08    	mov    0x8067624(%eax),%eax
 804efa9:	8b 58 04             	mov    0x4(%eax),%ebx
	*size = MIN(fixed->data_size, *size);
 804efac:	8b 01                	mov    (%ecx),%eax
 804efae:	3b 03                	cmp    (%ebx),%eax
 804efb0:	0f 47 03             	cmova  (%ebx),%eax
 804efb3:	89 01                	mov    %eax,(%ecx)
	return fixed->data_pool + fixed->data_size * net_buf_id(buf);
 804efb5:	52                   	push   %edx
 804efb6:	e8 ae ff ff ff       	call   804ef69 <net_buf_id>
 804efbb:	83 c4 10             	add    $0x10,%esp
 804efbe:	0f af 03             	imul   (%ebx),%eax
 804efc1:	03 43 04             	add    0x4(%ebx),%eax
}
 804efc4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 804efc7:	c9                   	leave  
 804efc8:	c3                   	ret    

0804efc9 <net_buf_alloc_len>:
					int line)
#else
struct net_buf *net_buf_alloc_len(struct net_buf_pool *pool, size_t size,
				  k_timeout_t timeout)
#endif
{
 804efc9:	55                   	push   %ebp
 804efca:	89 e5                	mov    %esp,%ebp
 804efcc:	57                   	push   %edi
 804efcd:	56                   	push   %esi
 804efce:	53                   	push   %ebx
 804efcf:	83 ec 24             	sub    $0x24,%esp
 804efd2:	8b 75 10             	mov    0x10(%ebp),%esi
 804efd5:	8b 7d 14             	mov    0x14(%ebp),%edi
	uint64_t end = sys_clock_timeout_end_calc(timeout);
 804efd8:	57                   	push   %edi
 804efd9:	56                   	push   %esi
 804efda:	e8 3a 1c 01 00       	call   8060c19 <sys_clock_timeout_end_calc>
 804efdf:	83 c4 10             	add    $0x10,%esp
 804efe2:	89 55 e4             	mov    %edx,-0x1c(%ebp)
 804efe5:	89 45 e0             	mov    %eax,-0x20(%ebp)
	return posix_irq_lock();
 804efe8:	e8 32 f1 ff ff       	call   804e11f <posix_irq_lock>
	key = k_spin_lock(&pool->lock);

	/* If there are uninitialized buffers we're guaranteed to succeed
	 * with the allocation one way or another.
	 */
	if (pool->uninit_count) {
 804efed:	8b 4d 08             	mov    0x8(%ebp),%ecx
 804eff0:	89 c2                	mov    %eax,%edx
 804eff2:	66 8b 41 1a          	mov    0x1a(%ecx),%ax
 804eff6:	66 85 c0             	test   %ax,%ax
 804eff9:	0f 84 8e 00 00 00    	je     804f08d <net_buf_alloc_len+0xc4>

		/* If this is not the first access to the pool, we can
		 * be opportunistic and try to fetch a previously used
		 * buffer from the LIFO with K_NO_WAIT.
		 */
		if (pool->uninit_count < pool->buf_count) {
 804efff:	66 3b 41 18          	cmp    0x18(%ecx),%ax
 804f003:	73 31                	jae    804f036 <net_buf_alloc_len+0x6d>
 804f005:	89 55 dc             	mov    %edx,-0x24(%ebp)
	return z_impl_k_queue_get(queue, timeout);
 804f008:	52                   	push   %edx
 804f009:	6a 00                	push   $0x0
 804f00b:	6a 00                	push   $0x0
 804f00d:	51                   	push   %ecx
 804f00e:	89 4d 08             	mov    %ecx,0x8(%ebp)
 804f011:	e8 25 05 01 00       	call   805f53b <z_impl_k_queue_get>
 804f016:	83 c4 10             	add    $0x10,%esp
			buf = k_lifo_get(&pool->free, K_NO_WAIT);
			if (buf) {
 804f019:	8b 4d 08             	mov    0x8(%ebp),%ecx
 804f01c:	8b 55 dc             	mov    -0x24(%ebp),%edx
 804f01f:	85 c0                	test   %eax,%eax
 804f021:	89 c3                	mov    %eax,%ebx
 804f023:	74 11                	je     804f036 <net_buf_alloc_len+0x6d>
	posix_irq_unlock(key);
 804f025:	83 ec 0c             	sub    $0xc,%esp
 804f028:	52                   	push   %edx
 804f029:	e8 03 f1 ff ff       	call   804e131 <posix_irq_unlock>
 804f02e:	83 c4 10             	add    $0x10,%esp
				k_spin_unlock(&pool->lock, key);
				goto success;
 804f031:	e9 82 00 00 00       	jmp    804f0b8 <net_buf_alloc_len+0xef>
			}
		}

		uninit_count = pool->uninit_count--;
 804f036:	66 8b 41 1a          	mov    0x1a(%ecx),%ax
 804f03a:	83 ec 0c             	sub    $0xc,%esp
 804f03d:	89 4d 08             	mov    %ecx,0x8(%ebp)
 804f040:	8d 58 ff             	lea    -0x1(%eax),%ebx
 804f043:	89 45 dc             	mov    %eax,-0x24(%ebp)
 804f046:	66 89 59 1a          	mov    %bx,0x1a(%ecx)
 804f04a:	52                   	push   %edx
 804f04b:	e8 e1 f0 ff ff       	call   804e131 <posix_irq_unlock>
	size_t struct_size = ROUND_UP(sizeof(struct net_buf) + pool->user_data_size,
 804f050:	8b 4d 08             	mov    0x8(%ebp),%ecx
		k_spin_unlock(&pool->lock, key);

		buf = pool_get_uninit(pool, uninit_count);
 804f053:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804f056:	83 c4 10             	add    $0x10,%esp
	size_t byte_offset = (pool->buf_count - uninit_count) * struct_size;
 804f059:	0f b7 51 18          	movzwl 0x18(%ecx),%edx
		buf = pool_get_uninit(pool, uninit_count);
 804f05d:	0f b7 c0             	movzwl %ax,%eax
	size_t struct_size = ROUND_UP(sizeof(struct net_buf) + pool->user_data_size,
 804f060:	0f b6 59 1c          	movzbl 0x1c(%ecx),%ebx
	size_t byte_offset = (pool->buf_count - uninit_count) * struct_size;
 804f064:	29 c2                	sub    %eax,%edx
	return pool - _net_buf_pool_list;
 804f066:	89 c8                	mov    %ecx,%eax
	size_t struct_size = ROUND_UP(sizeof(struct net_buf) + pool->user_data_size,
 804f068:	83 c3 1b             	add    $0x1b,%ebx
	return pool - _net_buf_pool_list;
 804f06b:	2d 00 76 06 08       	sub    $0x8067600,%eax
	size_t struct_size = ROUND_UP(sizeof(struct net_buf) + pool->user_data_size,
 804f070:	83 e3 fc             	and    $0xfffffffc,%ebx
	return pool - _net_buf_pool_list;
 804f073:	c1 f8 02             	sar    $0x2,%eax
	size_t byte_offset = (pool->buf_count - uninit_count) * struct_size;
 804f076:	0f af da             	imul   %edx,%ebx
	buf = (struct net_buf *)(((uint8_t *)pool->__bufs) + byte_offset);
 804f079:	03 59 28             	add    0x28(%ecx),%ebx
	return pool - _net_buf_pool_list;
 804f07c:	69 c0 a3 8b 2e ba    	imul   $0xba2e8ba3,%eax,%eax
	buf->pool_id = pool_id(pool);
 804f082:	88 43 0a             	mov    %al,0xa(%ebx)
	buf->user_data_size = pool->user_data_size;
 804f085:	8a 41 1c             	mov    0x1c(%ecx),%al
 804f088:	88 43 0b             	mov    %al,0xb(%ebx)
		goto success;
 804f08b:	eb 2b                	jmp    804f0b8 <net_buf_alloc_len+0xef>
 804f08d:	83 ec 0c             	sub    $0xc,%esp
 804f090:	89 4d 08             	mov    %ecx,0x8(%ebp)
 804f093:	52                   	push   %edx
 804f094:	e8 98 f0 ff ff       	call   804e131 <posix_irq_unlock>
 804f099:	83 c4 0c             	add    $0xc,%esp
 804f09c:	8b 4d 08             	mov    0x8(%ebp),%ecx
 804f09f:	ff 75 14             	push   0x14(%ebp)
 804f0a2:	ff 75 10             	push   0x10(%ebp)
 804f0a5:	51                   	push   %ecx
 804f0a6:	e8 90 04 01 00       	call   805f53b <z_impl_k_queue_get>
 804f0ab:	83 c4 10             	add    $0x10,%esp
 804f0ae:	89 c3                	mov    %eax,%ebx
		buf = k_lifo_get(&pool->free, timeout);
	}
#else
	buf = k_lifo_get(&pool->free, timeout);
#endif
	if (!buf) {
 804f0b0:	85 c0                	test   %eax,%eax
 804f0b2:	0f 84 9e 00 00 00    	je     804f156 <net_buf_alloc_len+0x18d>
	}

success:
	NET_BUF_DBG("allocated buf %p", buf);

	if (size) {
 804f0b8:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
 804f0bc:	74 71                	je     804f12f <net_buf_alloc_len+0x166>
#if __ASSERT_ON
		size_t req_size = size;
#endif
		if (!K_TIMEOUT_EQ(timeout, K_NO_WAIT) &&
 804f0be:	8b 45 14             	mov    0x14(%ebp),%eax
 804f0c1:	0b 45 10             	or     0x10(%ebp),%eax
 804f0c4:	74 2b                	je     804f0f1 <net_buf_alloc_len+0x128>
 804f0c6:	83 7d 14 ff          	cmpl   $0xffffffff,0x14(%ebp)
 804f0ca:	75 06                	jne    804f0d2 <net_buf_alloc_len+0x109>
 804f0cc:	83 7d 10 ff          	cmpl   $0xffffffff,0x10(%ebp)
 804f0d0:	74 1f                	je     804f0f1 <net_buf_alloc_len+0x128>
		    !K_TIMEOUT_EQ(timeout, K_FOREVER)) {
			int64_t remaining = end - sys_clock_tick_get();
 804f0d2:	e8 f3 1a 01 00       	call   8060bca <sys_clock_tick_get>
 804f0d7:	8b 75 e0             	mov    -0x20(%ebp),%esi
 804f0da:	8b 7d e4             	mov    -0x1c(%ebp),%edi
 804f0dd:	29 c6                	sub    %eax,%esi
 804f0df:	19 d7                	sbb    %edx,%edi
 804f0e1:	31 d2                	xor    %edx,%edx
 804f0e3:	31 c0                	xor    %eax,%eax
 804f0e5:	89 f9                	mov    %edi,%ecx
 804f0e7:	39 d6                	cmp    %edx,%esi
 804f0e9:	19 c1                	sbb    %eax,%ecx
 804f0eb:	0f 4c f2             	cmovl  %edx,%esi
 804f0ee:	0f 4c f8             	cmovl  %eax,%edi
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
 804f0f1:	0f b6 43 0a          	movzbl 0xa(%ebx),%eax
	return pool->alloc->cb->alloc(buf, size, timeout);
 804f0f5:	8d 55 0c             	lea    0xc(%ebp),%edx
 804f0f8:	6b c0 2c             	imul   $0x2c,%eax,%eax
 804f0fb:	8b 80 24 76 06 08    	mov    0x8067624(%eax),%eax
 804f101:	8b 00                	mov    (%eax),%eax
 804f103:	57                   	push   %edi
 804f104:	56                   	push   %esi
 804f105:	52                   	push   %edx
 804f106:	53                   	push   %ebx
 804f107:	ff 10                	call   *(%eax)
			} else {
				timeout = Z_TIMEOUT_TICKS(remaining);
			}
		}

		buf->__buf = data_alloc(buf, &size, timeout);
 804f109:	89 43 14             	mov    %eax,0x14(%ebx)
	return pool->alloc->cb->alloc(buf, size, timeout);
 804f10c:	83 c4 10             	add    $0x10,%esp
		if (!buf->__buf) {
 804f10f:	85 c0                	test   %eax,%eax
 804f111:	75 23                	jne    804f136 <net_buf_alloc_len+0x16d>
 */
static inline void net_buf_destroy(struct net_buf *buf)
{
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);

	k_lifo_put(&pool->free, buf);
 804f113:	50                   	push   %eax
 804f114:	50                   	push   %eax
 804f115:	53                   	push   %ebx
 804f116:	0f b6 43 0a          	movzbl 0xa(%ebx),%eax
			NET_BUF_ERR("%s():%d: Failed to allocate data",
				    func, line);
			net_buf_destroy(buf);
			return NULL;
 804f11a:	31 db                	xor    %ebx,%ebx
 804f11c:	6b c0 2c             	imul   $0x2c,%eax,%eax
 804f11f:	05 00 76 06 08       	add    $0x8067600,%eax
 804f124:	50                   	push   %eax
 804f125:	e8 f2 03 01 00       	call   805f51c <k_queue_prepend>
 804f12a:	83 c4 10             	add    $0x10,%esp
}
 804f12d:	eb 27                	jmp    804f156 <net_buf_alloc_len+0x18d>

#if __ASSERT_ON
		NET_BUF_ASSERT(req_size <= size);
#endif
	} else {
		buf->__buf = NULL;
 804f12f:	c7 43 14 00 00 00 00 	movl   $0x0,0x14(%ebx)
	}

	buf->ref   = 1U;
	buf->flags = 0U;
	buf->frags = NULL;
	buf->size  = size;
 804f136:	8b 45 0c             	mov    0xc(%ebp),%eax
	buf->frags = NULL;
 804f139:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
	buf->ref   = 1U;
 804f140:	66 c7 43 08 01 00    	movw   $0x1,0x8(%ebx)
	buf->size  = size;
 804f146:	66 89 43 12          	mov    %ax,0x12(%ebx)
	buf->data = buf->__buf;
 804f14a:	8b 43 14             	mov    0x14(%ebx),%eax
	buf->len  = 0U;
 804f14d:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
	buf->data = buf->__buf;
 804f153:	89 43 0c             	mov    %eax,0xc(%ebx)
#if defined(CONFIG_NET_BUF_POOL_USAGE)
	atomic_dec(&pool->avail_count);
	__ASSERT_NO_MSG(atomic_get(&pool->avail_count) >= 0);
#endif
	return buf;
}
 804f156:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804f159:	89 d8                	mov    %ebx,%eax
 804f15b:	5b                   	pop    %ebx
 804f15c:	5e                   	pop    %esi
 804f15d:	5f                   	pop    %edi
 804f15e:	5d                   	pop    %ebp
 804f15f:	c3                   	ret    

0804f160 <net_buf_alloc_fixed>:
				       line);
}
#else
struct net_buf *net_buf_alloc_fixed(struct net_buf_pool *pool,
				    k_timeout_t timeout)
{
 804f160:	55                   	push   %ebp
 804f161:	89 e5                	mov    %esp,%ebp
 804f163:	83 ec 08             	sub    $0x8,%esp
 804f166:	8b 45 08             	mov    0x8(%ebp),%eax
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;

	return net_buf_alloc_len(pool, fixed->data_size, timeout);
 804f169:	ff 75 10             	push   0x10(%ebp)
 804f16c:	ff 75 0c             	push   0xc(%ebp)
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;
 804f16f:	8b 50 24             	mov    0x24(%eax),%edx
	return net_buf_alloc_len(pool, fixed->data_size, timeout);
 804f172:	8b 52 04             	mov    0x4(%edx),%edx
 804f175:	ff 32                	push   (%edx)
 804f177:	50                   	push   %eax
 804f178:	e8 4c fe ff ff       	call   804efc9 <net_buf_alloc_len>
 804f17d:	83 c4 10             	add    $0x10,%esp
}
 804f180:	c9                   	leave  
 804f181:	c3                   	ret    

0804f182 <net_buf_unref>:
#if defined(CONFIG_NET_BUF_LOG)
void net_buf_unref_debug(struct net_buf *buf, const char *func, int line)
#else
void net_buf_unref(struct net_buf *buf)
#endif
{
 804f182:	55                   	push   %ebp
 804f183:	89 e5                	mov    %esp,%ebp
 804f185:	56                   	push   %esi
 804f186:	53                   	push   %ebx
 804f187:	8b 5d 08             	mov    0x8(%ebp),%ebx
	__ASSERT_NO_MSG(buf);

	while (buf) {
 804f18a:	85 db                	test   %ebx,%ebx
 804f18c:	74 6e                	je     804f1fc <net_buf_unref+0x7a>
		}
#endif
		NET_BUF_DBG("buf %p ref %u pool_id %u frags %p", buf, buf->ref,
			    buf->pool_id, buf->frags);

		if (--buf->ref > 0) {
 804f18e:	fe 4b 08             	decb   0x8(%ebx)
		struct net_buf *frags = buf->frags;
 804f191:	8b 73 04             	mov    0x4(%ebx),%esi
		if (--buf->ref > 0) {
 804f194:	75 66                	jne    804f1fc <net_buf_unref+0x7a>
			return;
		}

		if (buf->__buf) {
 804f196:	8b 53 14             	mov    0x14(%ebx),%edx
 804f199:	85 d2                	test   %edx,%edx
 804f19b:	74 26                	je     804f1c3 <net_buf_unref+0x41>
	if (buf->flags & NET_BUF_EXTERNAL_DATA) {
 804f19d:	f6 43 09 01          	testb  $0x1,0x9(%ebx)
 804f1a1:	75 19                	jne    804f1bc <net_buf_unref+0x3a>
	pool->alloc->cb->unref(buf, data);
 804f1a3:	51                   	push   %ecx
 804f1a4:	51                   	push   %ecx
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
 804f1a5:	0f b6 43 0a          	movzbl 0xa(%ebx),%eax
	pool->alloc->cb->unref(buf, data);
 804f1a9:	6b c0 2c             	imul   $0x2c,%eax,%eax
 804f1ac:	8b 80 24 76 06 08    	mov    0x8067624(%eax),%eax
 804f1b2:	8b 00                	mov    (%eax),%eax
 804f1b4:	52                   	push   %edx
 804f1b5:	53                   	push   %ebx
 804f1b6:	ff 50 08             	call   *0x8(%eax)
 804f1b9:	83 c4 10             	add    $0x10,%esp
			data_unref(buf, buf->__buf);
			buf->__buf = NULL;
 804f1bc:	c7 43 14 00 00 00 00 	movl   $0x0,0x14(%ebx)
		}

		buf->data = NULL;
		buf->frags = NULL;

		pool = net_buf_pool_get(buf->pool_id);
 804f1c3:	0f b6 43 0a          	movzbl 0xa(%ebx),%eax
		buf->data = NULL;
 804f1c7:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
		buf->frags = NULL;
 804f1ce:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
#if defined(CONFIG_NET_BUF_POOL_USAGE)
		atomic_inc(&pool->avail_count);
		__ASSERT_NO_MSG(atomic_get(&pool->avail_count) <= pool->buf_count);
#endif

		if (pool->destroy) {
 804f1d5:	6b c0 2c             	imul   $0x2c,%eax,%eax
 804f1d8:	05 00 76 06 08       	add    $0x8067600,%eax
 804f1dd:	8b 50 20             	mov    0x20(%eax),%edx
 804f1e0:	85 d2                	test   %edx,%edx
 804f1e2:	74 08                	je     804f1ec <net_buf_unref+0x6a>
			pool->destroy(buf);
 804f1e4:	83 ec 0c             	sub    $0xc,%esp
 804f1e7:	53                   	push   %ebx
 804f1e8:	ff d2                	call   *%edx
 804f1ea:	eb 09                	jmp    804f1f5 <net_buf_unref+0x73>
	k_lifo_put(&pool->free, buf);
 804f1ec:	52                   	push   %edx
 804f1ed:	52                   	push   %edx
 804f1ee:	53                   	push   %ebx
 804f1ef:	50                   	push   %eax
 804f1f0:	e8 27 03 01 00       	call   805f51c <k_queue_prepend>
 804f1f5:	83 c4 10             	add    $0x10,%esp
{
 804f1f8:	89 f3                	mov    %esi,%ebx
 804f1fa:	eb 8e                	jmp    804f18a <net_buf_unref+0x8>
			net_buf_destroy(buf);
		}

		buf = frags;
	}
}
 804f1fc:	8d 65 f8             	lea    -0x8(%ebp),%esp
 804f1ff:	5b                   	pop    %ebx
 804f200:	5e                   	pop    %esi
 804f201:	5d                   	pop    %ebp
 804f202:	c3                   	ret    

0804f203 <net_buf_frag_last>:

	return clone;
}

struct net_buf *net_buf_frag_last(struct net_buf *buf)
{
 804f203:	55                   	push   %ebp
 804f204:	89 e5                	mov    %esp,%ebp
 804f206:	8b 45 08             	mov    0x8(%ebp),%eax
	__ASSERT_NO_MSG(buf);

	while (buf->frags) {
 804f209:	89 c2                	mov    %eax,%edx
 804f20b:	8b 40 04             	mov    0x4(%eax),%eax
 804f20e:	85 c0                	test   %eax,%eax
 804f210:	75 f7                	jne    804f209 <net_buf_frag_last+0x6>
		buf = buf->frags;
	}

	return buf;
}
 804f212:	89 d0                	mov    %edx,%eax
 804f214:	5d                   	pop    %ebp
 804f215:	c3                   	ret    

0804f216 <net_buf_frag_insert>:

void net_buf_frag_insert(struct net_buf *parent, struct net_buf *frag)
{
 804f216:	55                   	push   %ebp
 804f217:	89 e5                	mov    %esp,%ebp
 804f219:	56                   	push   %esi
 804f21a:	8b 55 08             	mov    0x8(%ebp),%edx
 804f21d:	8b 4d 0c             	mov    0xc(%ebp),%ecx
 804f220:	53                   	push   %ebx
	__ASSERT_NO_MSG(parent);
	__ASSERT_NO_MSG(frag);

	if (parent->frags) {
 804f221:	8b 5a 04             	mov    0x4(%edx),%ebx
 804f224:	85 db                	test   %ebx,%ebx
 804f226:	74 0e                	je     804f236 <net_buf_frag_insert+0x20>
 804f228:	89 c8                	mov    %ecx,%eax
	while (buf->frags) {
 804f22a:	89 c6                	mov    %eax,%esi
 804f22c:	8b 40 04             	mov    0x4(%eax),%eax
 804f22f:	85 c0                	test   %eax,%eax
 804f231:	75 f7                	jne    804f22a <net_buf_frag_insert+0x14>
		net_buf_frag_last(frag)->frags = parent->frags;
 804f233:	89 5e 04             	mov    %ebx,0x4(%esi)
	}
	/* Take ownership of the fragment reference */
	parent->frags = frag;
 804f236:	89 4a 04             	mov    %ecx,0x4(%edx)
}
 804f239:	5b                   	pop    %ebx
 804f23a:	5e                   	pop    %esi
 804f23b:	5d                   	pop    %ebp
 804f23c:	c3                   	ret    

0804f23d <net_buf_simple_add>:
{
	memcpy(clone, original, sizeof(struct net_buf_simple));
}

void *net_buf_simple_add(struct net_buf_simple *buf, size_t len)
{
 804f23d:	55                   	push   %ebp
 804f23e:	89 e5                	mov    %esp,%ebp
 804f240:	8b 4d 08             	mov    0x8(%ebp),%ecx
	return buf->data + buf->len;
 804f243:	0f b7 41 04          	movzwl 0x4(%ecx),%eax
 804f247:	89 c2                	mov    %eax,%edx

	NET_BUF_SIMPLE_DBG("buf %p len %zu", buf, len);

	__ASSERT_NO_MSG(net_buf_simple_tailroom(buf) >= len);

	buf->len += len;
 804f249:	03 55 0c             	add    0xc(%ebp),%edx
 804f24c:	03 01                	add    (%ecx),%eax
 804f24e:	66 89 51 04          	mov    %dx,0x4(%ecx)
	return tail;
}
 804f252:	5d                   	pop    %ebp
 804f253:	c3                   	ret    

0804f254 <net_buf_simple_add_be16>:

	sys_put_le16(val, net_buf_simple_add(buf, sizeof(val)));
}

void net_buf_simple_add_be16(struct net_buf_simple *buf, uint16_t val)
{
 804f254:	55                   	push   %ebp
 804f255:	89 e5                	mov    %esp,%ebp
 804f257:	8b 4d 08             	mov    0x8(%ebp),%ecx
 804f25a:	0f b7 51 04          	movzwl 0x4(%ecx),%edx
 804f25e:	89 d0                	mov    %edx,%eax
 804f260:	03 11                	add    (%ecx),%edx
	buf->len += len;
 804f262:	83 c0 02             	add    $0x2,%eax
 804f265:	66 89 41 04          	mov    %ax,0x4(%ecx)
 *  @param val 16-bit integer in host endianness.
 *  @param dst Destination memory address to store the result.
 */
static inline void sys_put_be16(uint16_t val, uint8_t dst[2])
{
	dst[0] = val >> 8;
 804f269:	8b 45 0c             	mov    0xc(%ebp),%eax
 804f26c:	86 e0                	xchg   %ah,%al
 804f26e:	66 89 02             	mov    %ax,(%edx)
	NET_BUF_SIMPLE_DBG("buf %p val %u", buf, val);

	sys_put_be16(val, net_buf_simple_add(buf, sizeof(val)));
}
 804f271:	5d                   	pop    %ebp
 804f272:	c3                   	ret    

0804f273 <net_buf_simple_pull>:

	sys_put_be64(val, net_buf_simple_push(buf, sizeof(val)));
}

void *net_buf_simple_pull(struct net_buf_simple *buf, size_t len)
{
 804f273:	55                   	push   %ebp
 804f274:	89 e5                	mov    %esp,%ebp
 804f276:	8b 55 08             	mov    0x8(%ebp),%edx
 804f279:	8b 45 0c             	mov    0xc(%ebp),%eax
	NET_BUF_SIMPLE_DBG("buf %p len %zu", buf, len);

	__ASSERT_NO_MSG(buf->len >= len);

	buf->len -= len;
 804f27c:	66 29 42 04          	sub    %ax,0x4(%edx)
	return buf->data += len;
 804f280:	03 02                	add    (%edx),%eax
 804f282:	89 02                	mov    %eax,(%edx)
}
 804f284:	5d                   	pop    %ebp
 804f285:	c3                   	ret    

0804f286 <net_buf_simple_pull_mem>:

void *net_buf_simple_pull_mem(struct net_buf_simple *buf, size_t len)
{
 804f286:	55                   	push   %ebp
 804f287:	89 e5                	mov    %esp,%ebp
 804f289:	8b 45 08             	mov    0x8(%ebp),%eax
 804f28c:	8b 55 0c             	mov    0xc(%ebp),%edx
	void *data = buf->data;
 804f28f:	8b 08                	mov    (%eax),%ecx

	NET_BUF_SIMPLE_DBG("buf %p len %zu", buf, len);

	__ASSERT_NO_MSG(buf->len >= len);

	buf->len -= len;
 804f291:	66 29 50 04          	sub    %dx,0x4(%eax)
	buf->data += len;
 804f295:	01 ca                	add    %ecx,%edx
 804f297:	89 10                	mov    %edx,(%eax)

	return data;
}
 804f299:	89 c8                	mov    %ecx,%eax
 804f29b:	5d                   	pop    %ebp
 804f29c:	c3                   	ret    

0804f29d <net_buf_simple_max_len>:
{
	return buf->size - net_buf_simple_headroom(buf) - buf->len;
}

uint16_t net_buf_simple_max_len(struct net_buf_simple *buf)
{
 804f29d:	55                   	push   %ebp
 804f29e:	89 e5                	mov    %esp,%ebp
 804f2a0:	8b 45 08             	mov    0x8(%ebp),%eax
	return buf->size - net_buf_simple_headroom(buf);
}
 804f2a3:	5d                   	pop    %ebp
	return buf->data - buf->__buf;
 804f2a4:	8b 10                	mov    (%eax),%edx
 804f2a6:	2b 50 08             	sub    0x8(%eax),%edx
	return buf->size - net_buf_simple_headroom(buf);
 804f2a9:	66 8b 40 06          	mov    0x6(%eax),%ax
 804f2ad:	29 d0                	sub    %edx,%eax
}
 804f2af:	c3                   	ret    

0804f2b0 <net_ipv4_is_addr_mcast>:
	return (ntohl(UNALIGNED_GET(&addr->s_addr)) & 0xF0000000) == 0xE0000000;
 804f2b0:	8b 00                	mov    (%eax),%eax
 804f2b2:	25 f0 00 00 00       	and    $0xf0,%eax
 804f2b7:	3d e0 00 00 00       	cmp    $0xe0,%eax
 804f2bc:	0f 94 c0             	sete   %al
}
 804f2bf:	c3                   	ret    

0804f2c0 <ethernet_flags>:

	return ret;
}

enum net_l2_flags ethernet_flags(struct net_if *iface)
{
 804f2c0:	55                   	push   %ebp
 804f2c1:	89 e5                	mov    %esp,%ebp
 *
 * @return a pointer to the iface L2 data
 */
static inline void *net_if_l2_data(struct net_if *iface)
{
	return iface->if_dev->l2_data;
 804f2c3:	8b 45 08             	mov    0x8(%ebp),%eax
	struct ethernet_context *ctx = net_if_l2_data(iface);

	return ctx->ethernet_l2_flags;
}
 804f2c6:	5d                   	pop    %ebp
 804f2c7:	8b 00                	mov    (%eax),%eax
	return ctx->ethernet_l2_flags;
 804f2c9:	8b 40 08             	mov    0x8(%eax),%eax
 804f2cc:	8a 40 18             	mov    0x18(%eax),%al
}
 804f2cf:	c3                   	ret    

0804f2d0 <ethernet_enable>:
{
 804f2d0:	55                   	push   %ebp
 804f2d1:	89 e5                	mov    %esp,%ebp
 804f2d3:	56                   	push   %esi
 804f2d4:	8b 75 08             	mov    0x8(%ebp),%esi
 804f2d7:	8b 45 0c             	mov    0xc(%ebp),%eax
 804f2da:	53                   	push   %ebx
 *
 * @return a pointer to the device driver instance
 */
static inline const struct device *net_if_get_device(struct net_if *iface)
{
	return iface->if_dev->dev;
 804f2db:	8b 16                	mov    (%esi),%edx
 804f2dd:	8b 12                	mov    (%edx),%edx
	const struct ethernet_api *eth =
 804f2df:	8b 5a 08             	mov    0x8(%edx),%ebx
	if (!eth) {
 804f2e2:	85 db                	test   %ebx,%ebx
 804f2e4:	74 33                	je     804f319 <ethernet_enable+0x49>
	if (!state) {
 804f2e6:	84 c0                	test   %al,%al
 804f2e8:	75 1d                	jne    804f307 <ethernet_enable+0x37>
		net_arp_clear_cache(iface);
 804f2ea:	83 ec 0c             	sub    $0xc,%esp
 804f2ed:	56                   	push   %esi
 804f2ee:	e8 7a 0e 00 00       	call   805016d <net_arp_clear_cache>
		if (eth->stop) {
 804f2f3:	8b 43 08             	mov    0x8(%ebx),%eax
		net_arp_clear_cache(iface);
 804f2f6:	83 c4 10             	add    $0x10,%esp
		if (eth->stop) {
 804f2f9:	85 c0                	test   %eax,%eax
 804f2fb:	75 04                	jne    804f301 <ethernet_enable+0x31>
	int ret = 0;
 804f2fd:	31 c0                	xor    %eax,%eax
 804f2ff:	eb 1d                	jmp    804f31e <ethernet_enable+0x4e>
 804f301:	8b 16                	mov    (%esi),%edx
			ret = eth->stop(net_if_get_device(iface));
 804f303:	8b 12                	mov    (%edx),%edx
 804f305:	eb 07                	jmp    804f30e <ethernet_enable+0x3e>
		if (eth->start) {
 804f307:	8b 43 04             	mov    0x4(%ebx),%eax
 804f30a:	85 c0                	test   %eax,%eax
 804f30c:	74 ef                	je     804f2fd <ethernet_enable+0x2d>
			ret = eth->start(net_if_get_device(iface));
 804f30e:	89 55 08             	mov    %edx,0x8(%ebp)
}
 804f311:	8d 65 f8             	lea    -0x8(%ebp),%esp
 804f314:	5b                   	pop    %ebx
 804f315:	5e                   	pop    %esi
 804f316:	5d                   	pop    %ebp
			ret = eth->start(net_if_get_device(iface));
 804f317:	ff e0                	jmp    *%eax
		return -ENOENT;
 804f319:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
}
 804f31e:	8d 65 f8             	lea    -0x8(%ebp),%esp
 804f321:	5b                   	pop    %ebx
 804f322:	5e                   	pop    %esi
 804f323:	5d                   	pop    %ebp
 804f324:	c3                   	ret    

0804f325 <net_eth_is_addr_broadcast>:
	    addr->addr[4] == 0xff &&
	    addr->addr[5] == 0xff) {
		return true;
	}

	return false;
 804f325:	31 d2                	xor    %edx,%edx
	if (addr->addr[0] == 0xff &&
 804f327:	80 38 ff             	cmpb   $0xff,(%eax)
 804f32a:	75 1f                	jne    804f34b <net_eth_is_addr_broadcast+0x26>
 804f32c:	80 78 01 ff          	cmpb   $0xff,0x1(%eax)
 804f330:	75 19                	jne    804f34b <net_eth_is_addr_broadcast+0x26>
	    addr->addr[1] == 0xff &&
 804f332:	80 78 02 ff          	cmpb   $0xff,0x2(%eax)
 804f336:	75 13                	jne    804f34b <net_eth_is_addr_broadcast+0x26>
	    addr->addr[2] == 0xff &&
 804f338:	80 78 03 ff          	cmpb   $0xff,0x3(%eax)
 804f33c:	75 0d                	jne    804f34b <net_eth_is_addr_broadcast+0x26>
	    addr->addr[3] == 0xff &&
 804f33e:	80 78 04 ff          	cmpb   $0xff,0x4(%eax)
 804f342:	75 07                	jne    804f34b <net_eth_is_addr_broadcast+0x26>
	    addr->addr[4] == 0xff &&
 804f344:	80 78 05 ff          	cmpb   $0xff,0x5(%eax)
 804f348:	0f 94 c2             	sete   %dl
}
 804f34b:	89 d0                	mov    %edx,%eax
 804f34d:	c3                   	ret    

0804f34e <carrier_on_off>:

NET_L2_INIT(ETHERNET_L2, ethernet_recv, ethernet_send, ethernet_enable,
	    ethernet_flags);

static void carrier_on_off(struct k_work *work)
{
 804f34e:	55                   	push   %ebp
 804f34f:	89 e5                	mov    %esp,%ebp
 804f351:	53                   	push   %ebx
 804f352:	8b 4d 08             	mov    0x8(%ebp),%ecx
	struct ethernet_context *ctx = CONTAINER_OF(work, struct ethernet_context,
						    carrier_work);
	bool eth_carrier_up;

	if (ctx->iface == NULL) {
 804f355:	83 79 10 00          	cmpl   $0x0,0x10(%ecx)
 804f359:	74 32                	je     804f38d <carrier_on_off+0x3f>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
 804f35b:	8b 51 fc             	mov    -0x4(%ecx),%edx
 */
static inline bool atomic_test_bit(const atomic_t *target, int bit)
{
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));

	return (1 & (val >> (bit & (ATOMIC_BITS - 1)))) != 0;
 804f35e:	83 e2 01             	and    $0x1,%edx
		return;
	}

	eth_carrier_up = atomic_test_bit(&ctx->flags, ETH_CARRIER_UP);

	if (eth_carrier_up == ctx->is_net_carrier_up) {
 804f361:	8a 41 15             	mov    0x15(%ecx),%al
 804f364:	89 c3                	mov    %eax,%ebx
 804f366:	83 e3 01             	and    $0x1,%ebx
 804f369:	38 d3                	cmp    %dl,%bl
 804f36b:	74 20                	je     804f38d <carrier_on_off+0x3f>
		return;
	}

	ctx->is_net_carrier_up = eth_carrier_up;
 804f36d:	83 e0 fe             	and    $0xfffffffe,%eax
 804f370:	09 d0                	or     %edx,%eax
 804f372:	88 41 15             	mov    %al,0x15(%ecx)

	NET_DBG("Carrier %s for interface %p", eth_carrier_up ? "ON" : "OFF",
		ctx->iface);

	if (eth_carrier_up) {
		ethernet_mgmt_raise_carrier_on_event(ctx->iface);
 804f375:	8b 41 10             	mov    0x10(%ecx),%eax
		net_if_carrier_on(ctx->iface);
 804f378:	89 45 08             	mov    %eax,0x8(%ebp)
	if (eth_carrier_up) {
 804f37b:	84 d2                	test   %dl,%dl
 804f37d:	74 07                	je     804f386 <carrier_on_off+0x38>
	} else {
		ethernet_mgmt_raise_carrier_off_event(ctx->iface);
		net_if_carrier_off(ctx->iface);
	}
}
 804f37f:	5b                   	pop    %ebx
 804f380:	5d                   	pop    %ebp
		net_if_carrier_on(ctx->iface);
 804f381:	e9 8e 37 00 00       	jmp    8052b14 <net_if_carrier_on>
}
 804f386:	5b                   	pop    %ebx
 804f387:	5d                   	pop    %ebp
		net_if_carrier_off(ctx->iface);
 804f388:	e9 b8 37 00 00       	jmp    8052b45 <net_if_carrier_off>
}
 804f38d:	5b                   	pop    %ebx
 804f38e:	5d                   	pop    %ebp
 804f38f:	c3                   	ret    

0804f390 <net_eth_get_hw_capabilities.isra.0>:
 804f390:	8b 10                	mov    (%eax),%edx
enum ethernet_hw_caps net_eth_get_hw_capabilities(struct net_if *iface)
{
	const struct ethernet_api *eth =
		(struct ethernet_api *)net_if_get_device(iface)->api;

	if (!eth->get_capabilities) {
 804f392:	8b 42 08             	mov    0x8(%edx),%eax
 804f395:	8b 40 0c             	mov    0xc(%eax),%eax
 804f398:	85 c0                	test   %eax,%eax
 804f39a:	74 0e                	je     804f3aa <net_eth_get_hw_capabilities.isra.0+0x1a>
enum ethernet_hw_caps net_eth_get_hw_capabilities(struct net_if *iface)
 804f39c:	55                   	push   %ebp
 804f39d:	89 e5                	mov    %esp,%ebp
 804f39f:	83 ec 14             	sub    $0x14,%esp
		return (enum ethernet_hw_caps)0;
	}

	return eth->get_capabilities(net_if_get_device(iface));
 804f3a2:	52                   	push   %edx
 804f3a3:	ff d0                	call   *%eax
 804f3a5:	83 c4 10             	add    $0x10,%esp
}
 804f3a8:	c9                   	leave  
 804f3a9:	c3                   	ret    
		return (enum ethernet_hw_caps)0;
 804f3aa:	31 c0                	xor    %eax,%eax
}
 804f3ac:	c3                   	ret    

0804f3ad <ethernet_recv>:
{
 804f3ad:	55                   	push   %ebp
 804f3ae:	89 e5                	mov    %esp,%ebp
 804f3b0:	57                   	push   %edi
 804f3b1:	56                   	push   %esi
 804f3b2:	53                   	push   %ebx
 804f3b3:	83 ec 1c             	sub    $0x1c,%esp
 804f3b6:	8b 5d 0c             	mov    0xc(%ebp),%ebx
 804f3b9:	8b 4d 08             	mov    0x8(%ebp),%ecx
	return pkt->frags->data;
 804f3bc:	8b 73 08             	mov    0x8(%ebx),%esi
 804f3bf:	8b 7e 0c             	mov    0xc(%esi),%edi
	if (hdr == NULL || pkt->buffer->len < hdr_len) {
 804f3c2:	85 ff                	test   %edi,%edi
 804f3c4:	74 2f                	je     804f3f5 <ethernet_recv+0x48>
 804f3c6:	66 83 7e 10 0d       	cmpw   $0xd,0x10(%esi)
 804f3cb:	76 28                	jbe    804f3f5 <ethernet_recv+0x48>
	type = ntohs(hdr->type);
 804f3cd:	66 8b 47 0c          	mov    0xc(%edi),%ax
 804f3d1:	86 e0                	xchg   %ah,%al
 804f3d3:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
	switch (type) {
 804f3d7:	66 3d dd 86          	cmp    $0x86dd,%ax
 804f3db:	74 36                	je     804f413 <ethernet_recv+0x66>
 804f3dd:	77 0e                	ja     804f3ed <ethernet_recv+0x40>
 804f3df:	66 3d 00 08          	cmp    $0x800,%ax
 804f3e3:	74 1a                	je     804f3ff <ethernet_recv+0x52>
 804f3e5:	66 3d 06 08          	cmp    $0x806,%ax
 804f3e9:	74 14                	je     804f3ff <ethernet_recv+0x52>
 804f3eb:	eb 08                	jmp    804f3f5 <ethernet_recv+0x48>
 804f3ed:	66 81 7d e6 8e 88    	cmpw   $0x888e,-0x1a(%ebp)
 804f3f3:	74 32                	je     804f427 <ethernet_recv+0x7a>
 804f3f5:	b8 02 00 00 00       	mov    $0x2,%eax
 804f3fa:	e9 71 01 00 00       	jmp    804f570 <ethernet_recv+0x1c3>
	pkt->family = family;
 804f3ff:	8a 43 33             	mov    0x33(%ebx),%al
		family = AF_INET;
 804f402:	66 c7 45 e4 01 00    	movw   $0x1,-0x1c(%ebp)
 804f408:	83 e0 1f             	and    $0x1f,%eax
 804f40b:	83 c8 20             	or     $0x20,%eax
 804f40e:	88 43 33             	mov    %al,0x33(%ebx)
		break;
 804f411:	eb 1a                	jmp    804f42d <ethernet_recv+0x80>
 804f413:	8a 43 33             	mov    0x33(%ebx),%al
		family = AF_INET6;
 804f416:	66 c7 45 e4 02 00    	movw   $0x2,-0x1c(%ebp)
 804f41c:	83 e0 1f             	and    $0x1f,%eax
 804f41f:	83 c8 40             	or     $0x40,%eax
 804f422:	88 43 33             	mov    %al,0x33(%ebx)
		break;
 804f425:	eb 06                	jmp    804f42d <ethernet_recv+0x80>
	switch (type) {
 804f427:	66 c7 45 e4 00 00    	movw   $0x0,-0x1c(%ebp)
	lladdr->addr = hdr->src.addr;
 804f42d:	8d 47 06             	lea    0x6(%edi),%eax
	lladdr->len = sizeof(struct net_eth_addr);
 804f430:	66 c7 43 24 06 03    	movw   $0x306,0x24(%ebx)
	lladdr->addr = hdr->src.addr;
 804f436:	89 43 20             	mov    %eax,0x20(%ebx)
	pkt->ll_proto_type = type;
 804f439:	66 8b 45 e6          	mov    -0x1a(%ebp),%ax
	lladdr->addr = hdr->dst.addr;
 804f43d:	89 7b 28             	mov    %edi,0x28(%ebx)
 804f440:	66 89 43 30          	mov    %ax,0x30(%ebx)
	if (!net_eth_is_addr_broadcast((struct net_eth_addr *)lladdr->addr) &&
 804f444:	89 f8                	mov    %edi,%eax
	lladdr->len = sizeof(struct net_eth_addr);
 804f446:	66 c7 43 2c 06 03    	movw   $0x306,0x2c(%ebx)
	if (!net_eth_is_addr_broadcast((struct net_eth_addr *)lladdr->addr) &&
 804f44c:	e8 d4 fe ff ff       	call   804f325 <net_eth_is_addr_broadcast>
 804f451:	84 c0                	test   %al,%al
 804f453:	75 3f                	jne    804f494 <ethernet_recv+0xe7>
	if (addr->addr[0] == 0x33 &&
 804f455:	8a 07                	mov    (%edi),%al
 804f457:	3c 33                	cmp    $0x33,%al
 804f459:	75 06                	jne    804f461 <ethernet_recv+0xb4>
 804f45b:	80 7f 01 33          	cmpb   $0x33,0x1(%edi)
 804f45f:	eb 0e                	jmp    804f46f <ethernet_recv+0xc2>
	if (addr->addr[0] == 0x01 &&
 804f461:	fe c8                	dec    %al
 804f463:	75 0c                	jne    804f471 <ethernet_recv+0xc4>
 804f465:	80 7f 01 00          	cmpb   $0x0,0x1(%edi)
 804f469:	75 06                	jne    804f471 <ethernet_recv+0xc4>
	    addr->addr[1] == 0x00 &&
 804f46b:	80 7f 02 5e          	cmpb   $0x5e,0x2(%edi)
 804f46f:	74 23                	je     804f494 <ethernet_recv+0xe7>
 *
 * @return a pointer to the network link address
 */
static inline struct net_linkaddr *net_if_get_link_addr(struct net_if *iface)
{
	return &iface->if_dev->link_addr;
 804f471:	8b 01                	mov    (%ecx),%eax
{
	if (!lladdr1 || !lladdr2) {
		return false;
	}

	if (lladdr1->len != lladdr2->len) {
 804f473:	80 78 14 06          	cmpb   $0x6,0x14(%eax)
 804f477:	0f 85 78 ff ff ff    	jne    804f3f5 <ethernet_recv+0x48>
		return false;
	}

	return !memcmp(lladdr1->addr, lladdr2->addr, lladdr1->len);
 804f47d:	51                   	push   %ecx
 804f47e:	6a 06                	push   $0x6
 804f480:	57                   	push   %edi
 804f481:	ff 70 10             	push   0x10(%eax)
 804f484:	e8 e7 9b ff ff       	call   8049070 <memcmp@plt>
 804f489:	83 c4 10             	add    $0x10,%esp
		    (struct net_eth_addr *)lladdr->addr) &&
 804f48c:	85 c0                	test   %eax,%eax
 804f48e:	0f 85 61 ff ff ff    	jne    804f3f5 <ethernet_recv+0x48>
 *
 * @return New beginning of the buffer data.
 */
static inline void *net_buf_pull(struct net_buf *buf, size_t len)
{
	return net_buf_simple_pull(&buf->b, len);
 804f494:	83 c6 0c             	add    $0xc,%esi
 804f497:	52                   	push   %edx
 804f498:	52                   	push   %edx
 804f499:	6a 0e                	push   $0xe
 804f49b:	56                   	push   %esi
 804f49c:	e8 d2 fd ff ff       	call   804f273 <net_buf_simple_pull>
 804f4a1:	83 c4 10             	add    $0x10,%esp
	if (IS_ENABLED(CONFIG_NET_IPV4) && type == NET_ETH_PTYPE_IP &&
 804f4a4:	66 81 7d e6 00 08    	cmpw   $0x800,-0x1a(%ebp)
 804f4aa:	74 07                	je     804f4b3 <ethernet_recv+0x106>
	ethernet_update_rx_stats(iface, hdr, net_pkt_get_len(pkt) + hdr_len);
 804f4ac:	8b 4b 08             	mov    0x8(%ebx),%ecx
	switch (type) {
 804f4af:	89 c8                	mov    %ecx,%eax
 804f4b1:	eb 4f                	jmp    804f502 <ethernet_recv+0x155>
	if (net_eth_is_addr_broadcast(&hdr->dst) &&
 804f4b3:	89 f8                	mov    %edi,%eax
 804f4b5:	e8 6b fe ff ff       	call   804f325 <net_eth_is_addr_broadcast>
 804f4ba:	84 c0                	test   %al,%al
 804f4bc:	74 ee                	je     804f4ac <ethernet_recv+0xff>
	return pkt->frags->data;
 804f4be:	8b 43 08             	mov    0x8(%ebx),%eax
 804f4c1:	8b 40 0c             	mov    0xc(%eax),%eax
	    !(net_ipv4_is_addr_mcast((struct in_addr *)NET_IPV4_HDR(pkt)->dst) ||
 804f4c4:	8d 70 10             	lea    0x10(%eax),%esi
 804f4c7:	89 45 e0             	mov    %eax,-0x20(%ebp)
 804f4ca:	89 f0                	mov    %esi,%eax
 804f4cc:	e8 df fd ff ff       	call   804f2b0 <net_ipv4_is_addr_mcast>
	if (net_eth_is_addr_broadcast(&hdr->dst) &&
 804f4d1:	84 c0                	test   %al,%al
 804f4d3:	75 d7                	jne    804f4ac <ethernet_recv+0xff>
	return pkt->iface;
 804f4d5:	8b 4b 18             	mov    0x18(%ebx),%ecx
 804f4d8:	89 4d dc             	mov    %ecx,-0x24(%ebp)
 */
#if defined(CONFIG_NET_NATIVE_IPV4)
static inline bool net_ipv4_is_addr_bcast(struct net_if *iface,
					  const struct in_addr *addr)
{
	if (net_ipv4_addr_cmp(addr, net_ipv4_broadcast_address())) {
 804f4db:	e8 94 42 00 00       	call   8053774 <net_ipv4_broadcast_address>
 804f4e0:	8b 55 e0             	mov    -0x20(%ebp),%edx
 804f4e3:	8b 00                	mov    (%eax),%eax
 804f4e5:	39 42 10             	cmp    %eax,0x10(%edx)
 804f4e8:	74 c2                	je     804f4ac <ethernet_recv+0xff>
		return true;
	}

	return net_if_ipv4_is_addr_bcast(iface, addr);
 804f4ea:	8b 4d dc             	mov    -0x24(%ebp),%ecx
 804f4ed:	50                   	push   %eax
 804f4ee:	50                   	push   %eax
 804f4ef:	56                   	push   %esi
 804f4f0:	51                   	push   %ecx
 804f4f1:	e8 a3 30 00 00       	call   8052599 <net_if_ipv4_is_addr_bcast>
 804f4f6:	83 c4 10             	add    $0x10,%esp
	    !(net_ipv4_is_addr_mcast((struct in_addr *)NET_IPV4_HDR(pkt)->dst) ||
 804f4f9:	84 c0                	test   %al,%al
 804f4fb:	75 af                	jne    804f4ac <ethernet_recv+0xff>
 804f4fd:	e9 f3 fe ff ff       	jmp    804f3f5 <ethernet_recv+0x48>
 */
static inline size_t net_buf_frags_len(struct net_buf *buf)
{
	size_t bytes = 0;

	while (buf) {
 804f502:	85 c0                	test   %eax,%eax
 804f504:	74 05                	je     804f50b <ethernet_recv+0x15e>
		bytes += buf->len;
		buf = buf->frags;
 804f506:	8b 40 04             	mov    0x4(%eax),%eax
 804f509:	eb f7                	jmp    804f502 <ethernet_recv+0x155>
	if (IS_ENABLED(CONFIG_NET_ARP) &&
 804f50b:	66 83 7d e4 01       	cmpw   $0x1,-0x1c(%ebp)
 804f510:	75 1a                	jne    804f52c <ethernet_recv+0x17f>
 804f512:	66 81 7d e6 06 08    	cmpw   $0x806,-0x1a(%ebp)
 804f518:	75 12                	jne    804f52c <ethernet_recv+0x17f>
		return net_arp_input(pkt, hdr);
 804f51a:	89 7d 0c             	mov    %edi,0xc(%ebp)
 804f51d:	89 5d 08             	mov    %ebx,0x8(%ebp)
}
 804f520:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804f523:	5b                   	pop    %ebx
 804f524:	5e                   	pop    %esi
 804f525:	5f                   	pop    %edi
 804f526:	5d                   	pop    %ebp
		return net_arp_input(pkt, hdr);
 804f527:	e9 c2 09 00 00       	jmp    804feee <net_arp_input>
	return pkt->family;
 804f52c:	8a 43 33             	mov    0x33(%ebx),%al
	return pkt->frags->data;
 804f52f:	8b 51 0c             	mov    0xc(%ecx),%edx
	return pkt->family;
 804f532:	c0 e8 05             	shr    $0x5,%al
	if (net_pkt_family(pkt) == AF_INET) {
 804f535:	fe c8                	dec    %al
 804f537:	75 08                	jne    804f541 <ethernet_recv+0x194>
	return pkt->frags->data;
 804f539:	66 8b 42 02          	mov    0x2(%edx),%ax
 804f53d:	86 e0                	xchg   %ah,%al
 804f53f:	eb 09                	jmp    804f54a <ethernet_recv+0x19d>
		len = ntohs(NET_IPV6_HDR(pkt)->len) + NET_IPV6H_LEN;
 804f541:	66 8b 42 04          	mov    0x4(%edx),%ax
 804f545:	86 e0                	xchg   %ah,%al
 804f547:	83 c0 28             	add    $0x28,%eax
	if (len < NET_ETH_MINIMAL_FRAME_SIZE - sizeof(struct net_eth_hdr)) {
 804f54a:	66 83 f8 2d          	cmp    $0x2d,%ax
 804f54e:	76 14                	jbe    804f564 <ethernet_recv+0x1b7>
	return NET_CONTINUE;
 804f550:	b8 01 00 00 00       	mov    $0x1,%eax
 804f555:	eb 19                	jmp    804f570 <ethernet_recv+0x1c3>
				frag->len = len;
 804f557:	66 89 41 10          	mov    %ax,0x10(%ecx)
				len = 0U;
 804f55b:	31 c0                	xor    %eax,%eax
		for (frag = pkt->frags; frag; frag = frag->frags) {
 804f55d:	8b 49 04             	mov    0x4(%ecx),%ecx
 804f560:	85 c9                	test   %ecx,%ecx
 804f562:	74 ec                	je     804f550 <ethernet_recv+0x1a3>
			if (frag->len < len) {
 804f564:	8b 51 10             	mov    0x10(%ecx),%edx
 804f567:	66 39 d0             	cmp    %dx,%ax
 804f56a:	76 eb                	jbe    804f557 <ethernet_recv+0x1aa>
				len -= frag->len;
 804f56c:	29 d0                	sub    %edx,%eax
 804f56e:	eb ed                	jmp    804f55d <ethernet_recv+0x1b0>
}
 804f570:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804f573:	5b                   	pop    %ebx
 804f574:	5e                   	pop    %esi
 804f575:	5f                   	pop    %edi
 804f576:	5d                   	pop    %ebp
 804f577:	c3                   	ret    

0804f578 <net_eth_broadcast_addr>:
}
 804f578:	b8 30 24 06 08       	mov    $0x8062430,%eax
 804f57d:	c3                   	ret    

0804f57e <net_eth_ipv4_mcast_to_mac_addr>:
{
 804f57e:	55                   	push   %ebp
 804f57f:	89 e5                	mov    %esp,%ebp
 804f581:	53                   	push   %ebx
 804f582:	8b 45 0c             	mov    0xc(%ebp),%eax
 804f585:	8b 4d 08             	mov    0x8(%ebp),%ecx
	mac_addr->addr[0] = 0x01;
 804f588:	66 c7 00 01 00       	movw   $0x1,(%eax)
	mac_addr->addr[2] = 0x5e;
 804f58d:	c6 40 02 5e          	movb   $0x5e,0x2(%eax)
	mac_addr->addr[3] = ipv4_addr->s4_addr[1];
 804f591:	8a 51 01             	mov    0x1(%ecx),%dl
 804f594:	88 50 03             	mov    %dl,0x3(%eax)
	mac_addr->addr[4] = ipv4_addr->s4_addr[2];
 804f597:	8a 59 02             	mov    0x2(%ecx),%bl
	mac_addr->addr[3] &= 0x7f;
 804f59a:	83 e2 7f             	and    $0x7f,%edx
	mac_addr->addr[4] = ipv4_addr->s4_addr[2];
 804f59d:	88 58 04             	mov    %bl,0x4(%eax)
	mac_addr->addr[5] = ipv4_addr->s4_addr[3];
 804f5a0:	8a 49 03             	mov    0x3(%ecx),%cl
	mac_addr->addr[3] &= 0x7f;
 804f5a3:	88 50 03             	mov    %dl,0x3(%eax)
	mac_addr->addr[5] = ipv4_addr->s4_addr[3];
 804f5a6:	88 48 05             	mov    %cl,0x5(%eax)
}
 804f5a9:	5b                   	pop    %ebx
 804f5aa:	5d                   	pop    %ebp
 804f5ab:	c3                   	ret    

0804f5ac <ethernet_send>:
{
 804f5ac:	55                   	push   %ebp
		ret = -ENOENT;
 804f5ad:	ba fe ff ff ff       	mov    $0xfffffffe,%edx
{
 804f5b2:	89 e5                	mov    %esp,%ebp
 804f5b4:	57                   	push   %edi
 804f5b5:	56                   	push   %esi
 804f5b6:	53                   	push   %ebx
 804f5b7:	83 ec 1c             	sub    $0x1c,%esp
	return iface->if_dev->dev;
 804f5ba:	8b 45 08             	mov    0x8(%ebp),%eax
 804f5bd:	8b 75 0c             	mov    0xc(%ebp),%esi
 804f5c0:	8b 00                	mov    (%eax),%eax
	const struct ethernet_api *api = net_if_get_device(iface)->api;
 804f5c2:	8b 00                	mov    (%eax),%eax
 804f5c4:	8b 40 08             	mov    0x8(%eax),%eax
 804f5c7:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (!api) {
 804f5ca:	85 c0                	test   %eax,%eax
 804f5cc:	0f 84 37 02 00 00    	je     804f809 <ethernet_send+0x25d>
	return pkt->family;
 804f5d2:	8a 46 33             	mov    0x33(%esi),%al
 804f5d5:	89 c2                	mov    %eax,%edx
 804f5d7:	c0 ea 05             	shr    $0x5,%dl
	} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
 804f5da:	80 fa 01             	cmp    $0x1,%dl
 804f5dd:	0f 85 86 00 00 00    	jne    804f669 <ethernet_send+0xbd>
	return pkt->frags->data;
 804f5e3:	8b 46 08             	mov    0x8(%esi),%eax
	return pkt->iface;
 804f5e6:	8b 7e 18             	mov    0x18(%esi),%edi
	return pkt->frags->data;
 804f5e9:	8b 58 0c             	mov    0xc(%eax),%ebx
	if (net_ipv4_addr_cmp(addr, net_ipv4_broadcast_address())) {
 804f5ec:	e8 83 41 00 00       	call   8053774 <net_ipv4_broadcast_address>
 804f5f1:	8b 00                	mov    (%eax),%eax
 804f5f3:	39 43 10             	cmp    %eax,0x10(%ebx)
 804f5f6:	0f 84 01 02 00 00    	je     804f7fd <ethernet_send+0x251>
				   (struct in_addr *)NET_IPV4_HDR(pkt)->dst) ||
 804f5fc:	83 c3 10             	add    $0x10,%ebx
	return net_if_ipv4_is_addr_bcast(iface, addr);
 804f5ff:	50                   	push   %eax
 804f600:	50                   	push   %eax
 804f601:	53                   	push   %ebx
 804f602:	57                   	push   %edi
 804f603:	e8 91 2f 00 00       	call   8052599 <net_if_ipv4_is_addr_bcast>
 804f608:	83 c4 10             	add    $0x10,%esp
	if (net_ipv4_is_addr_bcast(net_pkt_iface(pkt),
 804f60b:	84 c0                	test   %al,%al
 804f60d:	0f 85 ea 01 00 00    	jne    804f7fd <ethernet_send+0x251>
 804f613:	8b 46 08             	mov    0x8(%esi),%eax
	    net_ipv4_is_addr_mcast((struct in_addr *)NET_IPV4_HDR(pkt)->dst)) {
 804f616:	8b 50 0c             	mov    0xc(%eax),%edx
 804f619:	83 c2 10             	add    $0x10,%edx
 804f61c:	89 d0                	mov    %edx,%eax
 804f61e:	e8 8d fc ff ff       	call   804f2b0 <net_ipv4_is_addr_mcast>
				   (struct in_addr *)NET_IPV4_HDR(pkt)->dst) ||
 804f623:	84 c0                	test   %al,%al
 804f625:	0f 85 d2 01 00 00    	jne    804f7fd <ethernet_send+0x251>
		arp_pkt = net_arp_prepare(pkt, (struct in_addr *)NET_IPV4_HDR(pkt)->dst, NULL);
 804f62b:	50                   	push   %eax
 804f62c:	6a 00                	push   $0x0
 804f62e:	52                   	push   %edx
 804f62f:	56                   	push   %esi
 804f630:	e8 e6 05 00 00       	call   804fc1b <net_arp_prepare>
 804f635:	83 c4 10             	add    $0x10,%esp
				ret = -ENOMEM;
 804f638:	ba f4 ff ff ff       	mov    $0xfffffff4,%edx
		arp_pkt = net_arp_prepare(pkt, (struct in_addr *)NET_IPV4_HDR(pkt)->dst, NULL);
 804f63d:	89 c3                	mov    %eax,%ebx
		if (!arp_pkt) {
 804f63f:	85 c0                	test   %eax,%eax
 804f641:	0f 84 c2 01 00 00    	je     804f809 <ethernet_send+0x25d>
		if (pkt != arp_pkt) {
 804f647:	39 c6                	cmp    %eax,%esi
 804f649:	0f 84 b0 01 00 00    	je     804f7ff <ethernet_send+0x253>
			net_pkt_unref(pkt);
 804f64f:	83 ec 0c             	sub    $0xc,%esp
 804f652:	56                   	push   %esi
 804f653:	e8 90 57 00 00       	call   8054de8 <net_pkt_unref>
	pkt->family = family;
 804f658:	8a 43 33             	mov    0x33(%ebx),%al
 804f65b:	83 c4 10             	add    $0x10,%esp
 804f65e:	83 e0 1f             	and    $0x1f,%eax
 804f661:	83 c8 20             	or     $0x20,%eax
 804f664:	88 43 33             	mov    %al,0x33(%ebx)
 804f667:	eb 10                	jmp    804f679 <ethernet_send+0xcd>
	} else if (IS_ENABLED(CONFIG_NET_IPV6) &&
 804f669:	80 fa 02             	cmp    $0x2,%dl
 804f66c:	74 12                	je     804f680 <ethernet_send+0xd4>
 804f66e:	83 e0 1f             	and    $0x1f,%eax
}
 804f671:	89 f3                	mov    %esi,%ebx
	pkt->family = family;
 804f673:	83 c8 20             	or     $0x20,%eax
 804f676:	88 46 33             	mov    %al,0x33(%esi)
		ptype = htons(NET_ETH_PTYPE_ARP);
 804f679:	bf 08 06 00 00       	mov    $0x608,%edi
}
 804f67e:	eb 07                	jmp    804f687 <ethernet_send+0xdb>
 804f680:	89 f3                	mov    %esi,%ebx
		ptype = htons(NET_ETH_PTYPE_IPV6);
 804f682:	bf 86 dd ff ff       	mov    $0xffffdd86,%edi
	if (!net_pkt_lladdr_dst(pkt)->addr) {
 804f687:	83 7b 28 00          	cmpl   $0x0,0x28(%ebx)
 804f68b:	75 0b                	jne    804f698 <ethernet_send+0xec>
		net_pkt_lladdr_dst(pkt)->addr = (uint8_t *)broadcast_eth_addr.addr;
 804f68d:	c7 43 28 30 24 06 08 	movl   $0x8062430,0x28(%ebx)
		net_pkt_lladdr_dst(pkt)->len = sizeof(struct net_eth_addr);
 804f694:	c6 43 2c 06          	movb   $0x6,0x2c(%ebx)
	hdr_frag = net_pkt_get_frag(pkt, hdr_len, NET_BUF_TIMEOUT);
 804f698:	6a 00                	push   $0x0
 804f69a:	6a 0a                	push   $0xa
 804f69c:	6a 0e                	push   $0xe
 804f69e:	53                   	push   %ebx
 804f69f:	e8 dd 56 00 00       	call   8054d81 <net_pkt_get_frag>
 804f6a4:	83 c4 10             	add    $0x10,%esp
		ret = -ENOMEM;
 804f6a7:	ba f4 ff ff ff       	mov    $0xfffffff4,%edx
	hdr_frag = net_pkt_get_frag(pkt, hdr_len, NET_BUF_TIMEOUT);
 804f6ac:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (!hdr_frag) {
 804f6af:	85 c0                	test   %eax,%eax
 804f6b1:	0f 84 52 01 00 00    	je     804f809 <ethernet_send+0x25d>
		hdr = (struct net_eth_hdr *)(hdr_frag->data);
 804f6b7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804f6ba:	8b 50 0c             	mov    0xc(%eax),%edx
		if (ptype == htons(NET_ETH_PTYPE_ARP) ||
 804f6bd:	66 81 ff 08 06       	cmp    $0x608,%di
 804f6c2:	74 55                	je     804f719 <ethernet_send+0x16d>
	return pkt->family;
 804f6c4:	8a 43 33             	mov    0x33(%ebx),%al
 804f6c7:	c0 e8 05             	shr    $0x5,%al
	if (net_pkt_family(pkt) == AF_INET &&
 804f6ca:	3c 01                	cmp    $0x1,%al
 804f6cc:	75 28                	jne    804f6f6 <ethernet_send+0x14a>
	return pkt->frags->data;
 804f6ce:	8b 43 08             	mov    0x8(%ebx),%eax
	    net_ipv4_is_addr_mcast((struct in_addr *)NET_IPV4_HDR(pkt)->dst)) {
 804f6d1:	8b 48 0c             	mov    0xc(%eax),%ecx
 804f6d4:	83 c1 10             	add    $0x10,%ecx
 804f6d7:	89 c8                	mov    %ecx,%eax
 804f6d9:	e8 d2 fb ff ff       	call   804f2b0 <net_ipv4_is_addr_mcast>
	if (net_pkt_family(pkt) == AF_INET &&
 804f6de:	84 c0                	test   %al,%al
 804f6e0:	74 37                	je     804f719 <ethernet_send+0x16d>
		net_eth_ipv4_mcast_to_mac_addr(
 804f6e2:	50                   	push   %eax
 804f6e3:	50                   	push   %eax
 804f6e4:	52                   	push   %edx
 804f6e5:	51                   	push   %ecx
 804f6e6:	89 55 dc             	mov    %edx,-0x24(%ebp)
 804f6e9:	e8 90 fe ff ff       	call   804f57e <net_eth_ipv4_mcast_to_mac_addr>
 804f6ee:	8b 55 dc             	mov    -0x24(%ebp),%edx
 804f6f1:	83 c4 10             	add    $0x10,%esp
		return true;
 804f6f4:	eb 32                	jmp    804f728 <ethernet_send+0x17c>
	if (net_pkt_family(pkt) == AF_INET6 &&
 804f6f6:	3c 02                	cmp    $0x2,%al
 804f6f8:	75 1f                	jne    804f719 <ethernet_send+0x16d>
 804f6fa:	8b 43 08             	mov    0x8(%ebx),%eax
	return addr->s6_addr[0] == 0xFF;
 804f6fd:	8b 40 0c             	mov    0xc(%eax),%eax
 804f700:	80 78 18 ff          	cmpb   $0xff,0x18(%eax)
 804f704:	75 13                	jne    804f719 <ethernet_send+0x16d>
 804f706:	66 c7 02 33 33       	movw   $0x3333,(%edx)
 804f70b:	8b 43 08             	mov    0x8(%ebx),%eax
 804f70e:	8b 40 0c             	mov    0xc(%eax),%eax
 804f711:	8b 40 24             	mov    0x24(%eax),%eax
 804f714:	89 42 02             	mov    %eax,0x2(%edx)
		return true;
 804f717:	eb 0f                	jmp    804f728 <ethernet_send+0x17c>
 804f719:	8b 43 28             	mov    0x28(%ebx),%eax
 804f71c:	8b 08                	mov    (%eax),%ecx
 804f71e:	89 0a                	mov    %ecx,(%edx)
 804f720:	66 8b 40 04          	mov    0x4(%eax),%ax
 804f724:	66 89 42 04          	mov    %ax,0x4(%edx)
 804f728:	8b 43 20             	mov    0x20(%ebx),%eax
 804f72b:	8b 08                	mov    (%eax),%ecx
 804f72d:	89 4a 06             	mov    %ecx,0x6(%edx)
 804f730:	66 8b 40 04          	mov    0x4(%eax),%ax
		hdr->type = ptype;
 804f734:	66 89 7a 0c          	mov    %di,0xc(%edx)
 804f738:	66 89 42 0a          	mov    %ax,0xa(%edx)
	return net_buf_simple_add(&buf->b, len);
 804f73c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804f73f:	51                   	push   %ecx
 804f740:	83 c0 0c             	add    $0xc,%eax
 804f743:	51                   	push   %ecx
 804f744:	6a 0e                	push   $0xe
 804f746:	50                   	push   %eax
 804f747:	e8 f1 fa ff ff       	call   804f23d <net_buf_simple_add>
 804f74c:	58                   	pop    %eax
 804f74d:	5a                   	pop    %edx
	net_pkt_frag_insert(pkt, hdr_frag);
 804f74e:	ff 75 e4             	push   -0x1c(%ebp)
 804f751:	53                   	push   %ebx
 804f752:	e8 e7 56 00 00       	call   8054e3e <net_pkt_frag_insert>
	net_pkt_cursor_init(pkt);
 804f757:	89 1c 24             	mov    %ebx,(%esp)
 804f75a:	e8 f5 57 00 00       	call   8054f54 <net_pkt_cursor_init>
 804f75f:	59                   	pop    %ecx
 804f760:	58                   	pop    %eax
			      struct net_if *iface,
			      struct net_pkt *pkt)
{
	net_capture_pkt(iface, pkt);

	return send_fn(dev, pkt);
 804f761:	53                   	push   %ebx
 804f762:	8b 45 08             	mov    0x8(%ebp),%eax
 804f765:	8b 00                	mov    (%eax),%eax
 804f767:	ff 30                	push   (%eax)
 804f769:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804f76c:	ff 50 18             	call   *0x18(%eax)
 804f76f:	83 c4 10             	add    $0x10,%esp
	if (ret != 0) {
 804f772:	85 c0                	test   %eax,%eax
 804f774:	74 48                	je     804f7be <ethernet_send+0x212>
 804f776:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	buf = pkt->buffer;
 804f779:	8b 43 08             	mov    0x8(%ebx),%eax
	net_pkt_frag_unref(buf);
 804f77c:	83 ec 0c             	sub    $0xc,%esp
	pkt->buffer = buf->frags;
 804f77f:	8b 48 04             	mov    0x4(%eax),%ecx
 804f782:	89 4b 08             	mov    %ecx,0x8(%ebx)
	buf->frags = NULL;
 804f785:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	net_pkt_frag_unref(buf);
 804f78c:	50                   	push   %eax
 804f78d:	e8 45 56 00 00       	call   8054dd7 <net_pkt_frag_unref>
 804f792:	83 c4 10             	add    $0x10,%esp
		if (IS_ENABLED(CONFIG_NET_ARP) && ptype == htons(NET_ETH_PTYPE_ARP)) {
 804f795:	66 81 ff 08 06       	cmp    $0x608,%di
 804f79a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 804f79d:	75 6a                	jne    804f809 <ethernet_send+0x25d>
			net_pkt_ref(orig_pkt);
 804f79f:	83 ec 0c             	sub    $0xc,%esp
 804f7a2:	56                   	push   %esi
 804f7a3:	e8 09 56 00 00       	call   8054db1 <net_pkt_ref>
 804f7a8:	58                   	pop    %eax
 804f7a9:	8b 43 08             	mov    0x8(%ebx),%eax
 804f7ac:	5a                   	pop    %edx
				(struct in_addr *)NET_IPV4_HDR(pkt)->dst)) {
 804f7ad:	8b 40 0c             	mov    0xc(%eax),%eax
 804f7b0:	83 c0 10             	add    $0x10,%eax
			if (net_arp_clear_pending(iface,
 804f7b3:	50                   	push   %eax
 804f7b4:	ff 75 08             	push   0x8(%ebp)
 804f7b7:	e8 97 0a 00 00       	call   8050253 <net_arp_clear_pending>
			net_pkt_unref(pkt);
 804f7bc:	eb 2f                	jmp    804f7ed <ethernet_send+0x241>
	ret = net_pkt_get_len(pkt);
 804f7be:	8b 43 08             	mov    0x8(%ebx),%eax
	size_t bytes = 0;
 804f7c1:	31 d2                	xor    %edx,%edx
	if (ret != 0) {
 804f7c3:	89 c1                	mov    %eax,%ecx
	while (buf) {
 804f7c5:	85 c9                	test   %ecx,%ecx
 804f7c7:	74 0b                	je     804f7d4 <ethernet_send+0x228>
		bytes += buf->len;
 804f7c9:	0f b7 71 10          	movzwl 0x10(%ecx),%esi
		buf = buf->frags;
 804f7cd:	8b 49 04             	mov    0x4(%ecx),%ecx
		bytes += buf->len;
 804f7d0:	01 f2                	add    %esi,%edx
		buf = buf->frags;
 804f7d2:	eb f1                	jmp    804f7c5 <ethernet_send+0x219>
	pkt->buffer = buf->frags;
 804f7d4:	8b 48 04             	mov    0x4(%eax),%ecx
	net_pkt_frag_unref(buf);
 804f7d7:	83 ec 0c             	sub    $0xc,%esp
	ret = net_pkt_get_len(pkt);
 804f7da:	89 55 e4             	mov    %edx,-0x1c(%ebp)
	pkt->buffer = buf->frags;
 804f7dd:	89 4b 08             	mov    %ecx,0x8(%ebx)
	buf->frags = NULL;
 804f7e0:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	net_pkt_frag_unref(buf);
 804f7e7:	50                   	push   %eax
 804f7e8:	e8 ea 55 00 00       	call   8054dd7 <net_pkt_frag_unref>
	net_pkt_unref(pkt);
 804f7ed:	89 1c 24             	mov    %ebx,(%esp)
 804f7f0:	e8 f3 55 00 00       	call   8054de8 <net_pkt_unref>
 804f7f5:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 804f7f8:	83 c4 10             	add    $0x10,%esp
 804f7fb:	eb 0c                	jmp    804f809 <ethernet_send+0x25d>
				ret = -ENOMEM;
 804f7fd:	89 f3                	mov    %esi,%ebx
				ptype = htons(NET_ETH_PTYPE_IP);
 804f7ff:	bf 08 00 00 00       	mov    $0x8,%edi
 804f804:	e9 7e fe ff ff       	jmp    804f687 <ethernet_send+0xdb>
}
 804f809:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804f80c:	89 d0                	mov    %edx,%eax
 804f80e:	5b                   	pop    %ebx
 804f80f:	5e                   	pop    %esi
 804f810:	5f                   	pop    %edi
 804f811:	5d                   	pop    %ebp
 804f812:	c3                   	ret    

0804f813 <ethernet_init>:
	return net_mgmt(NET_REQUEST_ETHERNET_SET_PROMISC_MODE, iface,
			&params, sizeof(struct ethernet_req_params));
}

void ethernet_init(struct net_if *iface)
{
 804f813:	55                   	push   %ebp
 804f814:	89 e5                	mov    %esp,%ebp
 804f816:	56                   	push   %esi
 804f817:	8b 75 08             	mov    0x8(%ebp),%esi
 804f81a:	53                   	push   %ebx
	return iface->if_dev->l2_data;
 804f81b:	8b 06                	mov    (%esi),%eax
 804f81d:	8b 58 08             	mov    0x8(%eax),%ebx
	int i;
#endif

	NET_DBG("Initializing Ethernet L2 %p for iface %p", ctx, iface);

	ctx->ethernet_l2_flags = NET_L2_MULTICAST;
 804f820:	c6 43 18 01          	movb   $0x1,0x18(%ebx)
	ctx->iface = iface;
 804f824:	89 73 14             	mov    %esi,0x14(%ebx)
	k_work_init(&ctx->carrier_work, carrier_on_off);
 804f827:	50                   	push   %eax
 804f828:	50                   	push   %eax
 804f829:	8d 43 04             	lea    0x4(%ebx),%eax
 804f82c:	68 4e f3 04 08       	push   $0x804f34e
 804f831:	50                   	push   %eax
 804f832:	e8 c0 02 01 00       	call   805faf7 <k_work_init>

	if (net_eth_get_hw_capabilities(iface) & ETHERNET_PROMISC_MODE) {
 804f837:	8b 06                	mov    (%esi),%eax
	k_work_init(&ctx->carrier_work, carrier_on_off);
 804f839:	83 c4 10             	add    $0x10,%esp
	if (net_eth_get_hw_capabilities(iface) & ETHERNET_PROMISC_MODE) {
 804f83c:	e8 4f fb ff ff       	call   804f390 <net_eth_get_hw_capabilities.isra.0>
 804f841:	0f ba e0 0a          	bt     $0xa,%eax
 804f845:	73 04                	jae    804f84b <ethernet_init+0x38>
		ctx->ethernet_l2_flags |= NET_L2_PROMISC_MODE;
 804f847:	80 4b 18 04          	orb    $0x4,0x18(%ebx)
			break;
		}
	}
#endif

	net_arp_init();
 804f84b:	e8 37 0a 00 00       	call   8050287 <net_arp_init>

	ctx->is_init = true;
 804f850:	80 4b 19 02          	orb    $0x2,0x19(%ebx)
}
 804f854:	8d 65 f8             	lea    -0x8(%ebp),%esp
 804f857:	5b                   	pop    %ebx
 804f858:	5e                   	pop    %esi
 804f859:	5d                   	pop    %ebp
 804f85a:	c3                   	ret    

0804f85b <sys_slist_prepend>:
 *
 * @return A pointer on the first node of the list (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_head(sys_slist_t *list)
{
	return list->head;
 804f85b:	8b 08                	mov    (%eax),%ecx
	parent->next = child;
 804f85d:	89 0a                	mov    %ecx,(%edx)
 * @param node A pointer on the node to prepend
 */
static inline void sys_slist_prepend(sys_slist_t *list,
				     sys_snode_t *node);

Z_GENLIST_PREPEND(slist, snode)
 804f85f:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
	list->head = node;
 804f863:	89 10                	mov    %edx,(%eax)
Z_GENLIST_PREPEND(slist, snode)
 804f865:	75 03                	jne    804f86a <sys_slist_prepend+0xf>
	list->tail = node;
 804f867:	89 50 04             	mov    %edx,0x4(%eax)
Z_GENLIST_PREPEND(slist, snode)
 804f86a:	c3                   	ret    

0804f86b <sys_slist_remove>:
 */
static inline void sys_slist_remove(sys_slist_t *list,
				    sys_snode_t *prev_node,
				    sys_snode_t *node);

Z_GENLIST_REMOVE(slist, snode)
 804f86b:	55                   	push   %ebp
 804f86c:	89 e5                	mov    %esp,%ebp
 804f86e:	53                   	push   %ebx
	return node->next;
 804f86f:	8b 19                	mov    (%ecx),%ebx
Z_GENLIST_REMOVE(slist, snode)
 804f871:	85 d2                	test   %edx,%edx
 804f873:	75 0c                	jne    804f881 <sys_slist_remove+0x16>
	list->head = node;
 804f875:	89 18                	mov    %ebx,(%eax)
Z_GENLIST_REMOVE(slist, snode)
 804f877:	3b 48 04             	cmp    0x4(%eax),%ecx
 804f87a:	75 0f                	jne    804f88b <sys_slist_remove+0x20>
	list->tail = node;
 804f87c:	89 58 04             	mov    %ebx,0x4(%eax)
}
 804f87f:	eb 0a                	jmp    804f88b <sys_slist_remove+0x20>
	parent->next = child;
 804f881:	89 1a                	mov    %ebx,(%edx)
Z_GENLIST_REMOVE(slist, snode)
 804f883:	3b 48 04             	cmp    0x4(%eax),%ecx
 804f886:	75 03                	jne    804f88b <sys_slist_remove+0x20>
	list->tail = node;
 804f888:	89 50 04             	mov    %edx,0x4(%eax)
Z_GENLIST_REMOVE(slist, snode)
 804f88b:	5b                   	pop    %ebx
 804f88c:	5d                   	pop    %ebp
	parent->next = child;
 804f88d:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
Z_GENLIST_REMOVE(slist, snode)
 804f893:	c3                   	ret    

0804f894 <k_uptime_get_32>:
 *    @kconfig{CONFIG_SYS_CLOCK_TICKS_PER_SEC} config option
 *
 * @return The low 32 bits of the current uptime, in milliseconds.
 */
static inline uint32_t k_uptime_get_32(void)
{
 804f894:	55                   	push   %ebp
 804f895:	89 e5                	mov    %esp,%ebp
 804f897:	83 ec 08             	sub    $0x8,%esp
	return z_impl_k_uptime_ticks();
 804f89a:	e8 75 13 01 00       	call   8060c14 <z_impl_k_uptime_ticks>
		} else {
			return t * ((uint64_t)to_hz / from_hz);
 804f89f:	ba 0a 00 00 00       	mov    $0xa,%edx
	return (uint32_t)k_uptime_get();
}
 804f8a4:	c9                   	leave  
 804f8a5:	f7 e2                	mul    %edx
 804f8a7:	c3                   	ret    

0804f8a8 <arp_entry_get_last_from_table>:
	return list->tail;
 804f8a8:	8b 0d 9c 89 06 08    	mov    0x806899c,%ecx
	/* We assume last entry is the oldest one,
	 * so is the preferred one to be taken out.
	 */

	node = sys_slist_peek_tail(&arp_table);
	if (!node) {
 804f8ae:	85 c9                	test   %ecx,%ecx
 804f8b0:	74 29                	je     804f8db <arp_entry_get_last_from_table+0x33>
	return list->head;
 804f8b2:	a1 98 89 06 08       	mov    0x8068998,%eax
 */
static inline bool sys_slist_find_and_remove(sys_slist_t *list,
					     sys_snode_t *node);

/** @} */
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
 804f8b7:	31 d2                	xor    %edx,%edx
 804f8b9:	85 c0                	test   %eax,%eax
 804f8bb:	74 1e                	je     804f8db <arp_entry_get_last_from_table+0x33>
 804f8bd:	39 c1                	cmp    %eax,%ecx
 804f8bf:	75 14                	jne    804f8d5 <arp_entry_get_last_from_table+0x2d>
{
 804f8c1:	55                   	push   %ebp
 804f8c2:	b8 98 89 06 08       	mov    $0x8068998,%eax
 804f8c7:	89 e5                	mov    %esp,%ebp
 804f8c9:	83 ec 08             	sub    $0x8,%esp
 804f8cc:	e8 9a ff ff ff       	call   804f86b <sys_slist_remove>
	}

	sys_slist_find_and_remove(&arp_table, node);

	return CONTAINER_OF(node, struct arp_entry, node);
}
 804f8d1:	89 c8                	mov    %ecx,%eax
 804f8d3:	c9                   	leave  
 804f8d4:	c3                   	ret    
	return node->next;
 804f8d5:	89 c2                	mov    %eax,%edx
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
 804f8d7:	8b 00                	mov    (%eax),%eax
 804f8d9:	eb de                	jmp    804f8b9 <arp_entry_get_last_from_table+0x11>
 804f8db:	89 c8                	mov    %ecx,%eax
 804f8dd:	c3                   	ret    

0804f8de <k_mutex_lock.constprop.0.isra.0>:
static inline int k_mutex_lock(struct k_mutex * mutex, k_timeout_t timeout)
 804f8de:	55                   	push   %ebp
 804f8df:	89 e5                	mov    %esp,%ebp
 804f8e1:	83 ec 0c             	sub    $0xc,%esp
	return z_impl_k_mutex_lock(mutex, timeout);
 804f8e4:	52                   	push   %edx
 804f8e5:	50                   	push   %eax
 804f8e6:	68 84 89 06 08       	push   $0x8068984
 804f8eb:	e8 a8 f8 00 00       	call   805f198 <z_impl_k_mutex_lock>
 804f8f0:	83 c4 10             	add    $0x10,%esp
}
 804f8f3:	c9                   	leave  
 804f8f4:	c3                   	ret    

0804f8f5 <k_mutex_unlock.constprop.0.isra.0>:
static inline int k_mutex_unlock(struct k_mutex * mutex)
 804f8f5:	55                   	push   %ebp
 804f8f6:	89 e5                	mov    %esp,%ebp
 804f8f8:	83 ec 14             	sub    $0x14,%esp
	return z_impl_k_mutex_unlock(mutex);
 804f8fb:	68 84 89 06 08       	push   $0x8068984
 804f900:	e8 a1 f9 00 00       	call   805f2a6 <z_impl_k_mutex_unlock>
 804f905:	83 c4 10             	add    $0x10,%esp
}
 804f908:	c9                   	leave  
 804f909:	c3                   	ret    

0804f90a <if_get_addr.isra.0>:
					  struct in_addr *addr)
{
	struct net_if_ipv4 *ipv4 = iface->config.ip.ipv4;
	int i;

	if (!ipv4) {
 804f90a:	85 c0                	test   %eax,%eax
 804f90c:	75 01                	jne    804f90f <if_get_addr.isra.0+0x5>
 804f90e:	c3                   	ret    
		return NULL;
	}

	for (i = 0; i < NET_IF_MAX_IPV4_ADDR; i++) {
		if (ipv4->unicast[i].is_used &&
 804f90f:	f6 40 2f 02          	testb  $0x2,0x2f(%eax)
 804f913:	74 1b                	je     804f930 <if_get_addr.isra.0+0x26>
 804f915:	66 83 38 01          	cmpw   $0x1,(%eax)
 804f919:	75 15                	jne    804f930 <if_get_addr.isra.0+0x26>
		    ipv4->unicast[i].address.family == AF_INET &&
 804f91b:	80 78 2d 01          	cmpb   $0x1,0x2d(%eax)
 804f91f:	75 0f                	jne    804f930 <if_get_addr.isra.0+0x26>
		    ipv4->unicast[i].addr_state == NET_ADDR_PREFERRED &&
 804f921:	85 d2                	test   %edx,%edx
 804f923:	74 07                	je     804f92c <if_get_addr.isra.0+0x22>
		    (!addr ||
 804f925:	8b 48 04             	mov    0x4(%eax),%ecx
 804f928:	39 0a                	cmp    %ecx,(%edx)
 804f92a:	75 04                	jne    804f930 <if_get_addr.isra.0+0x26>
		     net_ipv4_addr_cmp(addr,
				       &ipv4->unicast[i].address.in_addr))) {
			return &ipv4->unicast[i].address.in_addr;
 804f92c:	83 c0 04             	add    $0x4,%eax
 804f92f:	c3                   	ret    
		}
	}

	return NULL;
 804f930:	31 c0                	xor    %eax,%eax
}
 804f932:	c3                   	ret    

0804f933 <arp_entry_find.isra.0>:
static struct arp_entry *arp_entry_find(sys_slist_t *list,
 804f933:	55                   	push   %ebp
 804f934:	89 e5                	mov    %esp,%ebp
 804f936:	56                   	push   %esi
 804f937:	53                   	push   %ebx
 804f938:	8b 5d 08             	mov    0x8(%ebp),%ebx
	SYS_SLIST_FOR_EACH_CONTAINER(list, entry, node) {
 804f93b:	85 c0                	test   %eax,%eax
 804f93d:	75 04                	jne    804f943 <arp_entry_find.isra.0+0x10>
	return NULL;
 804f93f:	31 c0                	xor    %eax,%eax
 804f941:	eb 16                	jmp    804f959 <arp_entry_find.isra.0+0x26>
		if (entry->iface == iface &&
 804f943:	39 50 08             	cmp    %edx,0x8(%eax)
 804f946:	75 07                	jne    804f94f <arp_entry_find.isra.0+0x1c>
 804f948:	8b 31                	mov    (%ecx),%esi
 804f94a:	39 70 0c             	cmp    %esi,0xc(%eax)
 804f94d:	74 0a                	je     804f959 <arp_entry_find.isra.0+0x26>
		if (previous) {
 804f94f:	85 db                	test   %ebx,%ebx
 804f951:	74 02                	je     804f955 <arp_entry_find.isra.0+0x22>
			*previous = &entry->node;
 804f953:	89 03                	mov    %eax,(%ebx)
	return node->next;
 804f955:	8b 00                	mov    (%eax),%eax
 804f957:	eb e2                	jmp    804f93b <arp_entry_find.isra.0+0x8>
}
 804f959:	5b                   	pop    %ebx
 804f95a:	5e                   	pop    %esi
 804f95b:	5d                   	pop    %ebp
 804f95c:	c3                   	ret    

0804f95d <arp_update>:
static void arp_update(struct net_if *iface,
		       struct in_addr *src,
		       struct net_eth_addr *hwaddr,
		       bool gratuitous,
		       bool force)
{
 804f95d:	55                   	push   %ebp
 804f95e:	89 e5                	mov    %esp,%ebp
 804f960:	57                   	push   %edi
 804f961:	89 d7                	mov    %edx,%edi
 804f963:	56                   	push   %esi
 804f964:	53                   	push   %ebx
 804f965:	89 cb                	mov    %ecx,%ebx
 804f967:	83 ec 2c             	sub    $0x2c,%esp
 804f96a:	89 45 d4             	mov    %eax,-0x2c(%ebp)
 804f96d:	8b 45 08             	mov    0x8(%ebp),%eax
 804f970:	89 45 d0             	mov    %eax,-0x30(%ebp)
 804f973:	8b 45 0c             	mov    0xc(%ebp),%eax
 804f976:	89 45 cc             	mov    %eax,-0x34(%ebp)
	struct arp_entry *entry;
	struct net_pkt *pkt;

	NET_DBG("src %s", net_sprint_ipv4_addr(src));

	k_mutex_lock(&arp_mutex, K_FOREVER);
 804f979:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 804f97f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 804f982:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 804f987:	89 c2                	mov    %eax,%edx
 804f989:	e8 50 ff ff ff       	call   804f8de <k_mutex_lock.constprop.0.isra.0>
	entry = arp_entry_find(&arp_pending_entries, iface, dst, &prev);
 804f98e:	83 ec 0c             	sub    $0xc,%esp
 804f991:	8d 45 e0             	lea    -0x20(%ebp),%eax
 804f994:	8b 55 d4             	mov    -0x2c(%ebp),%edx
 804f997:	50                   	push   %eax
 804f998:	a1 a0 89 06 08       	mov    0x80689a0,%eax
 804f99d:	89 f9                	mov    %edi,%ecx
	sys_snode_t *prev = NULL;
 804f99f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	entry = arp_entry_find(&arp_pending_entries, iface, dst, &prev);
 804f9a6:	e8 88 ff ff ff       	call   804f933 <arp_entry_find.isra.0>
 804f9ab:	83 c4 10             	add    $0x10,%esp
 804f9ae:	89 c6                	mov    %eax,%esi
	if (entry) {
 804f9b0:	85 c0                	test   %eax,%eax
 804f9b2:	74 0f                	je     804f9c3 <arp_update+0x66>
		sys_slist_remove(&arp_pending_entries, prev, &entry->node);
 804f9b4:	8b 55 e0             	mov    -0x20(%ebp),%edx
 804f9b7:	89 c1                	mov    %eax,%ecx
 804f9b9:	b8 a0 89 06 08       	mov    $0x80689a0,%eax
 804f9be:	e8 a8 fe ff ff       	call   804f86b <sys_slist_remove>
	if (sys_slist_is_empty(&arp_pending_entries)) {
 804f9c3:	83 3d a0 89 06 08 00 	cmpl   $0x0,0x80689a0
 804f9ca:	75 10                	jne    804f9dc <arp_update+0x7f>
		k_work_cancel_delayable(&arp_request_timer);
 804f9cc:	83 ec 0c             	sub    $0xc,%esp
 804f9cf:	68 e0 7a 06 08       	push   $0x8067ae0
 804f9d4:	e8 25 03 01 00       	call   805fcfe <k_work_cancel_delayable>
 804f9d9:	83 c4 10             	add    $0x10,%esp

	entry = arp_entry_get_pending(iface, src);
	if (!entry) {
 804f9dc:	85 f6                	test   %esi,%esi
 804f9de:	0f 85 e2 00 00 00    	jne    804fac6 <arp_update+0x169>
		if (IS_ENABLED(CONFIG_NET_ARP_GRATUITOUS) && gratuitous) {
 804f9e4:	80 7d d0 00          	cmpb   $0x0,-0x30(%ebp)
 804f9e8:	74 31                	je     804fa1b <arp_update+0xbe>
	entry = arp_entry_find(&arp_table, iface, src, &prev);
 804f9ea:	83 ec 0c             	sub    $0xc,%esp
 804f9ed:	8d 45 e0             	lea    -0x20(%ebp),%eax
 804f9f0:	8b 55 d4             	mov    -0x2c(%ebp),%edx
 804f9f3:	89 f9                	mov    %edi,%ecx
 804f9f5:	50                   	push   %eax
 804f9f6:	a1 98 89 06 08       	mov    0x8068998,%eax
	sys_snode_t *prev = NULL;
 804f9fb:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	entry = arp_entry_find(&arp_table, iface, src, &prev);
 804fa02:	e8 2c ff ff ff       	call   804f933 <arp_entry_find.isra.0>
 804fa07:	83 c4 10             	add    $0x10,%esp
	if (entry) {
 804fa0a:	85 c0                	test   %eax,%eax
 804fa0c:	74 0d                	je     804fa1b <arp_update+0xbe>
 804fa0e:	8b 13                	mov    (%ebx),%edx
 804fa10:	89 50 10             	mov    %edx,0x10(%eax)
 804fa13:	66 8b 53 04          	mov    0x4(%ebx),%dx
 804fa17:	66 89 50 14          	mov    %dx,0x14(%eax)
			arp_gratuitous(iface, src, hwaddr);
		}

		if (force) {
 804fa1b:	80 7d cc 00          	cmpb   $0x0,-0x34(%ebp)
 804fa1f:	0f 84 84 00 00 00    	je     804faa9 <arp_update+0x14c>
			sys_snode_t *prev = NULL;
			struct arp_entry *entry;

			entry = arp_entry_find(&arp_table, iface, src, &prev);
 804fa25:	83 ec 0c             	sub    $0xc,%esp
 804fa28:	8d 45 e0             	lea    -0x20(%ebp),%eax
 804fa2b:	8b 55 d4             	mov    -0x2c(%ebp),%edx
 804fa2e:	89 f9                	mov    %edi,%ecx
 804fa30:	50                   	push   %eax
 804fa31:	a1 98 89 06 08       	mov    0x8068998,%eax
			sys_snode_t *prev = NULL;
 804fa36:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			entry = arp_entry_find(&arp_table, iface, src, &prev);
 804fa3d:	e8 f1 fe ff ff       	call   804f933 <arp_entry_find.isra.0>
 804fa42:	83 c4 10             	add    $0x10,%esp
			if (entry) {
 804fa45:	85 c0                	test   %eax,%eax
 804fa47:	74 0f                	je     804fa58 <arp_update+0xfb>
 804fa49:	8b 13                	mov    (%ebx),%edx
 804fa4b:	89 50 10             	mov    %edx,0x10(%eax)
 804fa4e:	66 8b 53 04          	mov    0x4(%ebx),%dx
 804fa52:	66 89 50 14          	mov    %dx,0x14(%eax)
 804fa56:	eb 51                	jmp    804faa9 <arp_update+0x14c>
	return list->head;
 804fa58:	8b 35 a8 89 06 08    	mov    0x80689a8,%esi
	if (!node) {
 804fa5e:	85 f6                	test   %esi,%esi
 804fa60:	75 0d                	jne    804fa6f <arp_update+0x112>
				 * was set.
				 */
				entry = arp_entry_get_free();
				if (!entry) {
					/* Then let's take one from table? */
					entry = arp_entry_get_last_from_table();
 804fa62:	e8 41 fe ff ff       	call   804f8a8 <arp_entry_get_last_from_table>
 804fa67:	89 c6                	mov    %eax,%esi
				}

				if (entry) {
 804fa69:	85 c0                	test   %eax,%eax
 804fa6b:	74 3c                	je     804faa9 <arp_update+0x14c>
 804fa6d:	eb 0e                	jmp    804fa7d <arp_update+0x120>
	sys_slist_remove(&arp_free_entries, NULL, node);
 804fa6f:	89 f1                	mov    %esi,%ecx
 804fa71:	31 d2                	xor    %edx,%edx
 804fa73:	b8 a8 89 06 08       	mov    $0x80689a8,%eax
 804fa78:	e8 ee fd ff ff       	call   804f86b <sys_slist_remove>
					entry->req_start = k_uptime_get_32();
 804fa7d:	e8 12 fe ff ff       	call   804f894 <k_uptime_get_32>
					entry->iface = iface;
					net_ipaddr_copy(&entry->ip, src);
					memcpy(&entry->eth, hwaddr, sizeof(entry->eth));
					sys_slist_prepend(&arp_table, &entry->node);
 804fa82:	89 f2                	mov    %esi,%edx
					entry->req_start = k_uptime_get_32();
 804fa84:	89 46 04             	mov    %eax,0x4(%esi)
					entry->iface = iface;
 804fa87:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 804fa8a:	89 46 08             	mov    %eax,0x8(%esi)
					net_ipaddr_copy(&entry->ip, src);
 804fa8d:	8b 07                	mov    (%edi),%eax
 804fa8f:	89 46 0c             	mov    %eax,0xc(%esi)
 804fa92:	8b 03                	mov    (%ebx),%eax
 804fa94:	89 46 10             	mov    %eax,0x10(%esi)
 804fa97:	66 8b 43 04          	mov    0x4(%ebx),%ax
 804fa9b:	66 89 46 14          	mov    %ax,0x14(%esi)
					sys_slist_prepend(&arp_table, &entry->node);
 804fa9f:	b8 98 89 06 08       	mov    $0x8068998,%eax
 804faa4:	e8 b2 fd ff ff       	call   804f85b <sys_slist_prepend>
				}
			}
		}

		k_mutex_unlock(&arp_mutex);
 804faa9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804faac:	65 2b 05 14 00 00 00 	sub    %gs:0x14,%eax
 804fab3:	74 05                	je     804faba <arp_update+0x15d>
 804fab5:	e8 46 98 ff ff       	call   8049300 <__stack_chk_fail@plt>

		net_if_queue_tx(iface, pkt);
	}

	k_mutex_unlock(&arp_mutex);
}
 804faba:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804fabd:	5b                   	pop    %ebx
 804fabe:	5e                   	pop    %esi
 804fabf:	5f                   	pop    %edi
 804fac0:	5d                   	pop    %ebp
		k_mutex_unlock(&arp_mutex);
 804fac1:	e9 2f fe ff ff       	jmp    804f8f5 <k_mutex_unlock.constprop.0.isra.0>
 804fac6:	8b 03                	mov    (%ebx),%eax
	sys_slist_prepend(&arp_table, &entry->node);
 804fac8:	89 f2                	mov    %esi,%edx
 804faca:	89 46 10             	mov    %eax,0x10(%esi)
 804facd:	66 8b 43 04          	mov    0x4(%ebx),%ax
 804fad1:	66 89 46 14          	mov    %ax,0x14(%esi)
 804fad5:	b8 98 89 06 08       	mov    $0x8068998,%eax
 804fada:	e8 7c fd ff ff       	call   804f85b <sys_slist_prepend>
	while (!k_fifo_is_empty(&entry->pending_queue)) {
 804fadf:	83 7e 18 00          	cmpl   $0x0,0x18(%esi)
 804fae3:	74 c4                	je     804faa9 <arp_update+0x14c>
	return z_impl_k_queue_get(queue, timeout);
 804fae5:	50                   	push   %eax
		pkt = k_fifo_get(&entry->pending_queue, K_FOREVER);
 804fae6:	8d 46 18             	lea    0x18(%esi),%eax
 804fae9:	6a ff                	push   $0xffffffff
 804faeb:	6a ff                	push   $0xffffffff
 804faed:	50                   	push   %eax
 804faee:	e8 48 fa 00 00       	call   805f53b <z_impl_k_queue_get>
 804faf3:	5a                   	pop    %edx
 804faf4:	59                   	pop    %ecx
	return pkt->frags->data;
 804faf5:	8b 50 08             	mov    0x8(%eax),%edx
		net_pkt_lladdr_dst(pkt)->len = sizeof(struct net_eth_addr);
 804faf8:	c6 40 2c 06          	movb   $0x6,0x2c(%eax)
		net_pkt_lladdr_dst(pkt)->addr =
 804fafc:	8b 52 0c             	mov    0xc(%edx),%edx
 804faff:	89 50 28             	mov    %edx,0x28(%eax)
		net_if_queue_tx(iface, pkt);
 804fb02:	50                   	push   %eax
 804fb03:	ff 75 d4             	push   -0x2c(%ebp)
 804fb06:	e8 4a 2e 00 00       	call   8052955 <net_if_queue_tx>
 804fb0b:	83 c4 10             	add    $0x10,%esp
 804fb0e:	eb cf                	jmp    804fadf <arp_update+0x182>

0804fb10 <arp_entry_cleanup>:
{
 804fb10:	55                   	push   %ebp
 804fb11:	89 e5                	mov    %esp,%ebp
 804fb13:	57                   	push   %edi
 804fb14:	89 c7                	mov    %eax,%edi
 804fb16:	51                   	push   %ecx
	if (pending) {
 804fb17:	84 d2                	test   %dl,%dl
 804fb19:	75 21                	jne    804fb3c <arp_entry_cleanup+0x2c>
  return __builtin___memset_chk (__dest, __ch, __len,
 804fb1b:	8d 57 10             	lea    0x10(%edi),%edx
	entry->iface = NULL;
 804fb1e:	c7 47 08 00 00 00 00 	movl   $0x0,0x8(%edi)
 804fb25:	b9 06 00 00 00       	mov    $0x6,%ecx
 804fb2a:	31 c0                	xor    %eax,%eax
 804fb2c:	c7 47 0c 00 00 00 00 	movl   $0x0,0xc(%edi)
 804fb33:	89 d7                	mov    %edx,%edi
 804fb35:	f3 aa                	rep stos %al,%es:(%edi)
}
 804fb37:	8b 7d fc             	mov    -0x4(%ebp),%edi
 804fb3a:	c9                   	leave  
 804fb3b:	c3                   	ret    
		while (!k_fifo_is_empty(&entry->pending_queue)) {
 804fb3c:	83 7f 18 00          	cmpl   $0x0,0x18(%edi)
 804fb40:	74 d9                	je     804fb1b <arp_entry_cleanup+0xb>
 804fb42:	50                   	push   %eax
			pkt = k_fifo_get(&entry->pending_queue, K_FOREVER);
 804fb43:	8d 47 18             	lea    0x18(%edi),%eax
 804fb46:	6a ff                	push   $0xffffffff
 804fb48:	6a ff                	push   $0xffffffff
 804fb4a:	50                   	push   %eax
 804fb4b:	e8 eb f9 00 00       	call   805f53b <z_impl_k_queue_get>
			net_pkt_unref(pkt);
 804fb50:	89 04 24             	mov    %eax,(%esp)
 804fb53:	e8 90 52 00 00       	call   8054de8 <net_pkt_unref>
 804fb58:	83 c4 10             	add    $0x10,%esp
 804fb5b:	eb df                	jmp    804fb3c <arp_entry_cleanup+0x2c>

0804fb5d <arp_request_timeout>:
{
 804fb5d:	55                   	push   %ebp
 804fb5e:	89 e5                	mov    %esp,%ebp
 804fb60:	57                   	push   %edi
 804fb61:	56                   	push   %esi
 804fb62:	53                   	push   %ebx
 804fb63:	83 ec 0c             	sub    $0xc,%esp
	uint32_t current = k_uptime_get_32();
 804fb66:	e8 29 fd ff ff       	call   804f894 <k_uptime_get_32>
 804fb6b:	89 c7                	mov    %eax,%edi
	k_mutex_lock(&arp_mutex, K_FOREVER);
 804fb6d:	83 c8 ff             	or     $0xffffffff,%eax
 804fb70:	89 c2                	mov    %eax,%edx
 804fb72:	e8 67 fd ff ff       	call   804f8de <k_mutex_lock.constprop.0.isra.0>
 804fb77:	8b 1d a0 89 06 08    	mov    0x80689a0,%ebx
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&arp_pending_entries,
 804fb7d:	85 db                	test   %ebx,%ebx
 804fb7f:	0f 84 8a 00 00 00    	je     804fc0f <arp_request_timeout+0xb2>
	return node->next;
 804fb85:	8b 33                	mov    (%ebx),%esi
			    ARP_REQUEST_TIMEOUT - current) > 0) {
 804fb87:	8b 53 04             	mov    0x4(%ebx),%edx
 804fb8a:	29 fa                	sub    %edi,%edx
 804fb8c:	8d 82 d0 07 00 00    	lea    0x7d0(%edx),%eax
		if ((int32_t)(entry->req_start +
 804fb92:	85 c0                	test   %eax,%eax
 804fb94:	7f 49                	jg     804fbdf <arp_request_timeout+0x82>
		arp_entry_cleanup(entry, true);
 804fb96:	ba 01 00 00 00       	mov    $0x1,%edx
 804fb9b:	89 d8                	mov    %ebx,%eax
 804fb9d:	e8 6e ff ff ff       	call   804fb10 <arp_entry_cleanup>
		sys_slist_remove(&arp_pending_entries, NULL, &entry->node);
 804fba2:	b8 a0 89 06 08       	mov    $0x80689a0,%eax
 804fba7:	89 d9                	mov    %ebx,%ecx
 804fba9:	31 d2                	xor    %edx,%edx
 804fbab:	e8 bb fc ff ff       	call   804f86b <sys_slist_remove>
	parent->next = child;
 804fbb0:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
	return list->tail;
 804fbb6:	a1 ac 89 06 08       	mov    0x80689ac,%eax
Z_GENLIST_APPEND(slist, snode)
 804fbbb:	85 c0                	test   %eax,%eax
 804fbbd:	75 0e                	jne    804fbcd <arp_request_timeout+0x70>
	list->tail = node;
 804fbbf:	89 1d ac 89 06 08    	mov    %ebx,0x80689ac
	list->head = node;
 804fbc5:	89 1d a8 89 06 08    	mov    %ebx,0x80689a8
}
 804fbcb:	eb 08                	jmp    804fbd5 <arp_request_timeout+0x78>
	parent->next = child;
 804fbcd:	89 18                	mov    %ebx,(%eax)
	list->tail = node;
 804fbcf:	89 1d ac 89 06 08    	mov    %ebx,0x80689ac
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&arp_pending_entries,
 804fbd5:	85 f6                	test   %esi,%esi
 804fbd7:	74 36                	je     804fc0f <arp_request_timeout+0xb2>
	return node->next;
 804fbd9:	89 f3                	mov    %esi,%ebx
 804fbdb:	8b 36                	mov    (%esi),%esi
 804fbdd:	eb a8                	jmp    804fb87 <arp_request_timeout+0x2a>
		k_work_reschedule(&arp_request_timer,
 804fbdf:	81 fa 30 f8 ff ff    	cmp    $0xfffff830,%edx
 804fbe5:	ba 00 00 00 00       	mov    $0x0,%edx
			return t / ((uint64_t)from_hz / to_hz);
 804fbea:	6a 00                	push   $0x0
 804fbec:	0f 44 c2             	cmove  %edx,%eax
		t += off;
 804fbef:	31 d2                	xor    %edx,%edx
			return t / ((uint64_t)from_hz / to_hz);
 804fbf1:	6a 0a                	push   $0xa
 804fbf3:	52                   	push   %edx
		t += off;
 804fbf4:	83 c0 09             	add    $0x9,%eax
			return t / ((uint64_t)from_hz / to_hz);
 804fbf7:	50                   	push   %eax
 804fbf8:	e8 53 99 ff ff       	call   8049550 <__udivdi3>
 804fbfd:	83 c4 0c             	add    $0xc,%esp
 804fc00:	52                   	push   %edx
 804fc01:	50                   	push   %eax
 804fc02:	68 e0 7a 06 08       	push   $0x8067ae0
 804fc07:	e8 d4 00 01 00       	call   805fce0 <k_work_reschedule>
 804fc0c:	83 c4 10             	add    $0x10,%esp
}
 804fc0f:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804fc12:	5b                   	pop    %ebx
 804fc13:	5e                   	pop    %esi
 804fc14:	5f                   	pop    %edi
 804fc15:	5d                   	pop    %ebp
	k_mutex_unlock(&arp_mutex);
 804fc16:	e9 da fc ff ff       	jmp    804f8f5 <k_mutex_unlock.constprop.0.isra.0>

0804fc1b <net_arp_prepare>:
{
 804fc1b:	55                   	push   %ebp
 804fc1c:	89 e5                	mov    %esp,%ebp
 804fc1e:	57                   	push   %edi
 804fc1f:	56                   	push   %esi
 804fc20:	53                   	push   %ebx
 804fc21:	83 ec 2c             	sub    $0x2c,%esp
 804fc24:	8b 45 08             	mov    0x8(%ebp),%eax
 804fc27:	89 45 d4             	mov    %eax,-0x2c(%ebp)
 804fc2a:	8b 45 0c             	mov    0xc(%ebp),%eax
 804fc2d:	89 45 cc             	mov    %eax,-0x34(%ebp)
 804fc30:	8b 45 10             	mov    0x10(%ebp),%eax
 804fc33:	89 45 c8             	mov    %eax,-0x38(%ebp)
 804fc36:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 804fc3c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 804fc3f:	31 c0                	xor    %eax,%eax
	if (!pkt || !pkt->buffer) {
 804fc41:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
 804fc45:	75 07                	jne    804fc4e <net_arp_prepare+0x33>
		return NULL;
 804fc47:	31 db                	xor    %ebx,%ebx
 804fc49:	e9 cd 00 00 00       	jmp    804fd1b <net_arp_prepare+0x100>
	if (!pkt || !pkt->buffer) {
 804fc4e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 804fc51:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
 804fc55:	74 f0                	je     804fc47 <net_arp_prepare+0x2c>
	if (!current_ip && !is_ipv4_ll_used &&
 804fc57:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
 804fc5b:	75 2d                	jne    804fc8a <net_arp_prepare+0x6f>
	    !net_if_ipv4_addr_mask_cmp(net_pkt_iface(pkt), request_ip)) {
 804fc5d:	53                   	push   %ebx
 804fc5e:	53                   	push   %ebx
 804fc5f:	ff 75 cc             	push   -0x34(%ebp)
 804fc62:	ff 70 18             	push   0x18(%eax)
 804fc65:	e8 a9 28 00 00       	call   8052513 <net_if_ipv4_addr_mask_cmp>
 804fc6a:	83 c4 10             	add    $0x10,%esp
	if (!current_ip && !is_ipv4_ll_used &&
 804fc6d:	84 c0                	test   %al,%al
 804fc6f:	75 19                	jne    804fc8a <net_arp_prepare+0x6f>
		struct net_if_ipv4 *ipv4 = net_pkt_iface(pkt)->config.ip.ipv4;
 804fc71:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 804fc74:	8b 40 18             	mov    0x18(%eax),%eax
 804fc77:	8b 40 08             	mov    0x8(%eax),%eax
		if (ipv4) {
 804fc7a:	85 c0                	test   %eax,%eax
 804fc7c:	74 0c                	je     804fc8a <net_arp_prepare+0x6f>
			addr = &ipv4->gw;
 804fc7e:	8d 78 48             	lea    0x48(%eax),%edi
			if (net_ipv4_is_addr_unspecified(addr)) {
 804fc81:	83 78 48 00          	cmpl   $0x0,0x48(%eax)
			addr = &ipv4->gw;
 804fc85:	89 7d cc             	mov    %edi,-0x34(%ebp)
			if (net_ipv4_is_addr_unspecified(addr)) {
 804fc88:	74 bd                	je     804fc47 <net_arp_prepare+0x2c>
	k_mutex_lock(&arp_mutex, K_FOREVER);
 804fc8a:	83 c8 ff             	or     $0xffffffff,%eax
 804fc8d:	89 c2                	mov    %eax,%edx
 804fc8f:	e8 4a fc ff ff       	call   804f8de <k_mutex_lock.constprop.0.isra.0>
	return pkt->iface;
 804fc94:	8b 45 d4             	mov    -0x2c(%ebp),%eax
	entry = arp_entry_find(&arp_table, iface, dst, &prev);
 804fc97:	83 ec 0c             	sub    $0xc,%esp
 804fc9a:	8b 4d cc             	mov    -0x34(%ebp),%ecx
 804fc9d:	8b 35 98 89 06 08    	mov    0x8068998,%esi
	sys_snode_t *prev = NULL;
 804fca3:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
 804fcaa:	8b 50 18             	mov    0x18(%eax),%edx
	entry = arp_entry_find(&arp_table, iface, dst, &prev);
 804fcad:	8d 45 e0             	lea    -0x20(%ebp),%eax
 804fcb0:	50                   	push   %eax
 804fcb1:	89 f0                	mov    %esi,%eax
 804fcb3:	e8 7b fc ff ff       	call   804f933 <arp_entry_find.isra.0>
 804fcb8:	83 c4 10             	add    $0x10,%esp
 804fcbb:	89 c3                	mov    %eax,%ebx
	if (entry) {
 804fcbd:	85 c0                	test   %eax,%eax
 804fcbf:	74 1c                	je     804fcdd <net_arp_prepare+0xc2>
		if (&entry->node != sys_slist_peek_head(&arp_table)) {
 804fcc1:	39 f0                	cmp    %esi,%eax
 804fcc3:	74 6b                	je     804fd30 <net_arp_prepare+0x115>
			sys_slist_remove(&arp_table, prev, &entry->node);
 804fcc5:	8b 55 e0             	mov    -0x20(%ebp),%edx
 804fcc8:	89 c1                	mov    %eax,%ecx
 804fcca:	b8 98 89 06 08       	mov    $0x8068998,%eax
 804fccf:	e8 97 fb ff ff       	call   804f86b <sys_slist_remove>
			sys_slist_prepend(&arp_table, &entry->node);
 804fcd4:	89 da                	mov    %ebx,%edx
 804fcd6:	e8 80 fb ff ff       	call   804f85b <sys_slist_prepend>
 804fcdb:	eb 53                	jmp    804fd30 <net_arp_prepare+0x115>
	return arp_entry_find(&arp_pending_entries, iface, dst, NULL);
 804fcdd:	83 ec 0c             	sub    $0xc,%esp
 804fce0:	8b 4d cc             	mov    -0x34(%ebp),%ecx
 804fce3:	a1 a0 89 06 08       	mov    0x80689a0,%eax
 804fce8:	6a 00                	push   $0x0
 804fcea:	e8 44 fc ff ff       	call   804f933 <arp_entry_find.isra.0>
 804fcef:	83 c4 10             	add    $0x10,%esp
 804fcf2:	89 c6                	mov    %eax,%esi
		if (!entry) {
 804fcf4:	85 c0                	test   %eax,%eax
 804fcf6:	74 5d                	je     804fd55 <net_arp_prepare+0x13a>
						  net_pkt_ref(pkt))) {
 804fcf8:	83 ec 0c             	sub    $0xc,%esp
 804fcfb:	ff 75 d4             	push   -0x2c(%ebp)
			    k_queue_unique_append(&entry->pending_queue._queue,
 804fcfe:	83 c6 18             	add    $0x18,%esi
						  net_pkt_ref(pkt))) {
 804fd01:	e8 ab 50 00 00       	call   8054db1 <net_pkt_ref>
 804fd06:	5a                   	pop    %edx
 804fd07:	59                   	pop    %ecx
			    k_queue_unique_append(&entry->pending_queue._queue,
 804fd08:	50                   	push   %eax
 804fd09:	56                   	push   %esi
 804fd0a:	e8 a8 f8 00 00       	call   805f5b7 <k_queue_unique_append>
 804fd0f:	83 c4 10             	add    $0x10,%esp
			if (!net_pkt_ipv4_auto(pkt) &&
 804fd12:	84 c0                	test   %al,%al
 804fd14:	74 60                	je     804fd76 <net_arp_prepare+0x15b>
				k_mutex_unlock(&arp_mutex);
 804fd16:	e8 da fb ff ff       	call   804f8f5 <k_mutex_unlock.constprop.0.isra.0>
}
 804fd1b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804fd1e:	65 2b 05 14 00 00 00 	sub    %gs:0x14,%eax
 804fd25:	0f 84 b9 01 00 00    	je     804fee4 <net_arp_prepare+0x2c9>
 804fd2b:	e8 d0 95 ff ff       	call   8049300 <__stack_chk_fail@plt>
	k_mutex_unlock(&arp_mutex);
 804fd30:	e8 c0 fb ff ff       	call   804f8f5 <k_mutex_unlock.constprop.0.isra.0>
	return &iface->if_dev->link_addr;
 804fd35:	8b 43 08             	mov    0x8(%ebx),%eax
	net_pkt_lladdr_src(pkt)->addr =
 804fd38:	8b 7d d4             	mov    -0x2c(%ebp),%edi
	net_pkt_lladdr_dst(pkt)->addr = (uint8_t *)&entry->eth;
 804fd3b:	83 c3 10             	add    $0x10,%ebx
		(uint8_t *)net_if_get_link_addr(entry->iface)->addr;
 804fd3e:	8b 00                	mov    (%eax),%eax
 804fd40:	8b 40 10             	mov    0x10(%eax),%eax
	net_pkt_lladdr_dst(pkt)->addr = (uint8_t *)&entry->eth;
 804fd43:	89 5f 28             	mov    %ebx,0x28(%edi)
	return pkt;
 804fd46:	89 fb                	mov    %edi,%ebx
	net_pkt_lladdr_src(pkt)->len = sizeof(struct net_eth_addr);
 804fd48:	c6 47 24 06          	movb   $0x6,0x24(%edi)
	net_pkt_lladdr_src(pkt)->addr =
 804fd4c:	89 47 20             	mov    %eax,0x20(%edi)
	net_pkt_lladdr_dst(pkt)->len = sizeof(struct net_eth_addr);
 804fd4f:	c6 47 2c 06          	movb   $0x6,0x2c(%edi)
	return pkt;
 804fd53:	eb c6                	jmp    804fd1b <net_arp_prepare+0x100>
	return list->head;
 804fd55:	8b 1d a8 89 06 08    	mov    0x80689a8,%ebx
	if (!node) {
 804fd5b:	85 db                	test   %ebx,%ebx
 804fd5d:	75 09                	jne    804fd68 <net_arp_prepare+0x14d>
				entry = arp_entry_get_last_from_table();
 804fd5f:	e8 44 fb ff ff       	call   804f8a8 <arp_entry_get_last_from_table>
 804fd64:	89 c3                	mov    %eax,%ebx
 804fd66:	eb 0e                	jmp    804fd76 <net_arp_prepare+0x15b>
	sys_slist_remove(&arp_free_entries, NULL, node);
 804fd68:	89 d9                	mov    %ebx,%ecx
 804fd6a:	31 d2                	xor    %edx,%edx
 804fd6c:	b8 a8 89 06 08       	mov    $0x80689a8,%eax
 804fd71:	e8 f5 fa ff ff       	call   804f86b <sys_slist_remove>
 804fd76:	8b 45 d4             	mov    -0x2c(%ebp),%eax
	if (current_ip) {
 804fd79:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
 804fd7d:	8b 78 18             	mov    0x18(%eax),%edi
 804fd80:	89 c6                	mov    %eax,%esi
 804fd82:	75 1f                	jne    804fda3 <net_arp_prepare+0x188>
		pkt = net_pkt_alloc_with_buffer(iface,
 804fd84:	50                   	push   %eax
 804fd85:	50                   	push   %eax
 804fd86:	6a 00                	push   $0x0
 804fd88:	6a 0a                	push   $0xa
 804fd8a:	6a 00                	push   $0x0
 804fd8c:	6a 00                	push   $0x0
 804fd8e:	6a 1c                	push   $0x1c
 804fd90:	57                   	push   %edi
 804fd91:	e8 71 55 00 00       	call   8055307 <net_pkt_alloc_with_buffer>
 804fd96:	83 c4 20             	add    $0x20,%esp
 804fd99:	89 c6                	mov    %eax,%esi
		if (!pkt) {
 804fd9b:	85 c0                	test   %eax,%eax
 804fd9d:	0f 84 35 01 00 00    	je     804fed8 <net_arp_prepare+0x2bd>
	return net_buf_simple_add(&buf->b, len);
 804fda3:	50                   	push   %eax
 804fda4:	50                   	push   %eax
 804fda5:	6a 1c                	push   $0x1c
 804fda7:	8b 46 08             	mov    0x8(%esi),%eax
 804fdaa:	83 c0 0c             	add    $0xc,%eax
 804fdad:	50                   	push   %eax
 804fdae:	e8 8a f4 ff ff       	call   804f23d <net_buf_simple_add>
	return pkt->frags->data;
 804fdb3:	8b 46 08             	mov    0x8(%esi),%eax
 804fdb6:	83 c4 10             	add    $0x10,%esp
 804fdb9:	8b 40 0c             	mov    0xc(%eax),%eax
 804fdbc:	89 45 d0             	mov    %eax,-0x30(%ebp)
	if (entry) {
 804fdbf:	85 db                	test   %ebx,%ebx
 804fdc1:	0f 84 88 00 00 00    	je     804fe4f <net_arp_prepare+0x234>
			k_fifo_put(&entry->pending_queue, net_pkt_ref(pending));
 804fdc7:	83 ec 0c             	sub    $0xc,%esp
 804fdca:	ff 75 d4             	push   -0x2c(%ebp)
 804fdcd:	e8 df 4f 00 00       	call   8054db1 <net_pkt_ref>
 804fdd2:	5a                   	pop    %edx
 804fdd3:	59                   	pop    %ecx
 804fdd4:	50                   	push   %eax
 804fdd5:	8d 43 18             	lea    0x18(%ebx),%eax
 804fdd8:	50                   	push   %eax
 804fdd9:	e8 1f f7 00 00       	call   805f4fd <k_queue_append>
	return pkt->iface;
 804fdde:	8b 46 18             	mov    0x18(%esi),%eax
		net_ipaddr_copy(&entry->ip, next_addr);
 804fde1:	8b 4d cc             	mov    -0x34(%ebp),%ecx
			k_fifo_put(&entry->pending_queue, net_pkt_ref(pending));
 804fde4:	83 c4 10             	add    $0x10,%esp
		entry->iface = net_pkt_iface(pkt);
 804fde7:	89 43 08             	mov    %eax,0x8(%ebx)
		net_ipaddr_copy(&entry->ip, next_addr);
 804fdea:	8b 11                	mov    (%ecx),%edx
 804fdec:	89 53 0c             	mov    %edx,0xc(%ebx)
			(uint8_t *)net_if_get_link_addr(entry->iface)->addr;
 804fdef:	8b 00                	mov    (%eax),%eax
 804fdf1:	8b 40 10             	mov    0x10(%eax),%eax
		net_pkt_lladdr_src(pkt)->addr =
 804fdf4:	89 46 20             	mov    %eax,0x20(%esi)
	parent->next = child;
 804fdf7:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
	return list->tail;
 804fdfd:	a1 a4 89 06 08       	mov    0x80689a4,%eax
Z_GENLIST_APPEND(slist, snode)
 804fe02:	85 c0                	test   %eax,%eax
 804fe04:	75 0e                	jne    804fe14 <net_arp_prepare+0x1f9>
	list->tail = node;
 804fe06:	89 1d a4 89 06 08    	mov    %ebx,0x80689a4
	list->head = node;
 804fe0c:	89 1d a0 89 06 08    	mov    %ebx,0x80689a0
}
 804fe12:	eb 08                	jmp    804fe1c <net_arp_prepare+0x201>
	parent->next = child;
 804fe14:	89 18                	mov    %ebx,(%eax)
	list->tail = node;
 804fe16:	89 1d a4 89 06 08    	mov    %ebx,0x80689a4
	entry->req_start = k_uptime_get_32();
 804fe1c:	e8 73 fa ff ff       	call   804f894 <k_uptime_get_32>
}

static inline k_ticks_t k_work_delayable_remaining_get(
	const struct k_work_delayable *dwork)
{
	return z_timeout_remaining(&dwork->timeout);
 804fe21:	83 ec 0c             	sub    $0xc,%esp
 804fe24:	89 43 04             	mov    %eax,0x4(%ebx)
 804fe27:	68 f0 7a 06 08       	push   $0x8067af0
 804fe2c:	e8 68 0c 01 00       	call   8060a99 <z_timeout_remaining>
 804fe31:	83 c4 10             	add    $0x10,%esp
	if (!k_work_delayable_remaining_get(&arp_request_timer)) {
 804fe34:	09 c2                	or     %eax,%edx
 804fe36:	75 1f                	jne    804fe57 <net_arp_prepare+0x23c>
		k_work_reschedule(&arp_request_timer,
 804fe38:	50                   	push   %eax
 804fe39:	6a 00                	push   $0x0
 804fe3b:	68 c8 00 00 00       	push   $0xc8
 804fe40:	68 e0 7a 06 08       	push   $0x8067ae0
 804fe45:	e8 96 fe 00 00       	call   805fce0 <k_work_reschedule>
 804fe4a:	83 c4 10             	add    $0x10,%esp
 804fe4d:	eb 08                	jmp    804fe57 <net_arp_prepare+0x23c>
			(uint8_t *)net_if_get_link_addr(iface)->addr;
 804fe4f:	8b 07                	mov    (%edi),%eax
 804fe51:	8b 40 10             	mov    0x10(%eax),%eax
		net_pkt_lladdr_src(pkt)->addr =
 804fe54:	89 46 20             	mov    %eax,0x20(%esi)
	net_pkt_lladdr_src(pkt)->len = sizeof(struct net_eth_addr);
 804fe57:	c6 46 24 06          	movb   $0x6,0x24(%esi)
	net_pkt_lladdr_dst(pkt)->addr = (uint8_t *)net_eth_broadcast_addr();
 804fe5b:	e8 18 f7 ff ff       	call   804f578 <net_eth_broadcast_addr>
	net_pkt_lladdr_dst(pkt)->len = sizeof(struct net_eth_addr);
 804fe60:	c6 46 2c 06          	movb   $0x6,0x2c(%esi)
 804fe64:	b9 06 00 00 00       	mov    $0x6,%ecx
	net_pkt_lladdr_dst(pkt)->addr = (uint8_t *)net_eth_broadcast_addr();
 804fe69:	89 46 28             	mov    %eax,0x28(%esi)
	hdr->hwtype = htons(NET_ARP_HTYPE_ETH);
 804fe6c:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804fe6f:	8d 50 12             	lea    0x12(%eax),%edx
 804fe72:	c7 00 00 01 08 00    	movl   $0x80100,(%eax)
	hdr->hwlen = sizeof(struct net_eth_addr);
 804fe78:	c7 40 04 06 04 00 01 	movl   $0x1000406,0x4(%eax)
 804fe7f:	89 d7                	mov    %edx,%edi
 804fe81:	31 c0                	xor    %eax,%eax
 804fe83:	f3 aa                	rep stos %al,%es:(%edi)
	net_ipaddr_copy((struct in_addr *)dest, (const struct in_addr *)src);
 804fe85:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804fe88:	8b 7d d0             	mov    -0x30(%ebp),%edi
 804fe8b:	8b 00                	mov    (%eax),%eax
 804fe8d:	89 47 18             	mov    %eax,0x18(%edi)
  return __builtin___memcpy_chk (__dest, __src, __len,
 804fe90:	8b 46 20             	mov    0x20(%esi),%eax
 804fe93:	8b 10                	mov    (%eax),%edx
 804fe95:	89 57 08             	mov    %edx,0x8(%edi)
 804fe98:	66 8b 40 04          	mov    0x4(%eax),%ax
 804fe9c:	66 89 47 0c          	mov    %ax,0xc(%edi)
	} else if (!entry) {
 804fea0:	85 db                	test   %ebx,%ebx
 804fea2:	75 0e                	jne    804feb2 <net_arp_prepare+0x297>
	return pkt->frags->data;
 804fea4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 804fea7:	8b 40 08             	mov    0x8(%eax),%eax
		my_addr = (struct in_addr *)NET_IPV4_HDR(pending)->src;
 804feaa:	8b 40 0c             	mov    0xc(%eax),%eax
 804fead:	83 c0 0c             	add    $0xc,%eax
	if (my_addr) {
 804feb0:	eb 12                	jmp    804fec4 <net_arp_prepare+0x2a9>
		my_addr = if_get_addr(entry->iface, current_ip);
 804feb2:	8b 43 08             	mov    0x8(%ebx),%eax
 804feb5:	8b 55 c8             	mov    -0x38(%ebp),%edx
 804feb8:	8b 40 08             	mov    0x8(%eax),%eax
 804febb:	e8 4a fa ff ff       	call   804f90a <if_get_addr.isra.0>
	if (my_addr) {
 804fec0:	85 c0                	test   %eax,%eax
 804fec2:	74 0a                	je     804fece <net_arp_prepare+0x2b3>
 804fec4:	8b 00                	mov    (%eax),%eax
 804fec6:	8b 4d d0             	mov    -0x30(%ebp),%ecx
 804fec9:	89 41 0e             	mov    %eax,0xe(%ecx)
}
 804fecc:	eb 0a                	jmp    804fed8 <net_arp_prepare+0x2bd>
  return __builtin___memset_chk (__dest, __ch, __len,
 804fece:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804fed1:	c7 40 0e 00 00 00 00 	movl   $0x0,0xe(%eax)
		k_mutex_unlock(&arp_mutex);
 804fed8:	e8 18 fa ff ff       	call   804f8f5 <k_mutex_unlock.constprop.0.isra.0>
		return req;
 804fedd:	89 f3                	mov    %esi,%ebx
 804fedf:	e9 37 fe ff ff       	jmp    804fd1b <net_arp_prepare+0x100>
}
 804fee4:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804fee7:	89 d8                	mov    %ebx,%eax
 804fee9:	5b                   	pop    %ebx
 804feea:	5e                   	pop    %esi
 804feeb:	5f                   	pop    %edi
 804feec:	5d                   	pop    %ebp
 804feed:	c3                   	ret    

0804feee <net_arp_input>:
	return true;
}

enum net_verdict net_arp_input(struct net_pkt *pkt,
			       struct net_eth_hdr *eth_hdr)
{
 804feee:	55                   	push   %ebp
	size_t bytes = 0;
 804feef:	31 d2                	xor    %edx,%edx
 804fef1:	89 e5                	mov    %esp,%ebp
 804fef3:	57                   	push   %edi
 804fef4:	56                   	push   %esi
 804fef5:	53                   	push   %ebx
 804fef6:	83 ec 1c             	sub    $0x1c,%esp
 804fef9:	8b 5d 08             	mov    0x8(%ebp),%ebx
	struct net_eth_addr *dst_hw_addr;
	struct net_arp_hdr *arp_hdr;
	struct net_pkt *reply;
	struct in_addr *addr;

	if (net_pkt_get_len(pkt) < (sizeof(struct net_arp_hdr) -
 804fefc:	8b 4b 08             	mov    0x8(%ebx),%ecx
{
 804feff:	89 c8                	mov    %ecx,%eax
	while (buf) {
 804ff01:	85 c0                	test   %eax,%eax
 804ff03:	74 0b                	je     804ff10 <net_arp_input+0x22>
		bytes += buf->len;
 804ff05:	0f b7 70 10          	movzwl 0x10(%eax),%esi
		buf = buf->frags;
 804ff09:	8b 40 04             	mov    0x4(%eax),%eax
		bytes += buf->len;
 804ff0c:	01 f2                	add    %esi,%edx
		buf = buf->frags;
 804ff0e:	eb f1                	jmp    804ff01 <net_arp_input+0x13>
 804ff10:	8b 79 0c             	mov    0xc(%ecx),%edi
	if (net_pkt_get_len(pkt) < (sizeof(struct net_arp_hdr) -
 804ff13:	8b 45 0c             	mov    0xc(%ebp),%eax
 804ff16:	29 f8                	sub    %edi,%eax
 804ff18:	83 c0 1c             	add    $0x1c,%eax
 804ff1b:	39 d0                	cmp    %edx,%eax
 804ff1d:	76 0a                	jbe    804ff29 <net_arp_input+0x3b>
				    (net_pkt_ip_data(pkt) - (uint8_t *)eth_hdr))) {
		NET_DBG("Invalid ARP header (len %zu, min %zu bytes) %p",
			net_pkt_get_len(pkt), sizeof(struct net_arp_hdr) -
			(net_pkt_ip_data(pkt) - (uint8_t *)eth_hdr), pkt);
		return NET_DROP;
 804ff1f:	b8 02 00 00 00       	mov    $0x2,%eax
 804ff24:	e9 3c 02 00 00       	jmp    8050165 <net_arp_input+0x277>
	if (ntohs(arp_hdr->hwtype) != NET_ARP_HTYPE_ETH ||
 804ff29:	66 81 3f 00 01       	cmpw   $0x100,(%edi)
 804ff2e:	75 ef                	jne    804ff1f <net_arp_input+0x31>
 804ff30:	66 83 7f 02 08       	cmpw   $0x8,0x2(%edi)
 804ff35:	75 e8                	jne    804ff1f <net_arp_input+0x31>
	    ntohs(arp_hdr->protocol) != NET_ETH_PTYPE_IP ||
 804ff37:	80 7f 04 06          	cmpb   $0x6,0x4(%edi)
 804ff3b:	75 e2                	jne    804ff1f <net_arp_input+0x31>
	    arp_hdr->hwlen != sizeof(struct net_eth_addr) ||
 804ff3d:	80 7f 05 04          	cmpb   $0x4,0x5(%edi)
 804ff41:	75 dc                	jne    804ff1f <net_arp_input+0x31>
	    arp_hdr->protolen != NET_ARP_IPV4_PTYPE_SIZE ||
 804ff43:	80 7f 0e 7f          	cmpb   $0x7f,0xe(%edi)
 804ff47:	74 d6                	je     804ff1f <net_arp_input+0x31>
	arp_hdr = NET_ARP_HDR(pkt);
	if (!arp_hdr_check(arp_hdr)) {
		return NET_DROP;
	}

	switch (ntohs(arp_hdr->opcode)) {
 804ff49:	66 8b 47 06          	mov    0x6(%edi),%ax
 804ff4d:	89 c2                	mov    %eax,%edx
 804ff4f:	86 f2                	xchg   %dh,%dl
 804ff51:	66 3d 00 01          	cmp    $0x100,%ax
 804ff55:	74 0f                	je     804ff66 <net_arp_input+0x78>
 804ff57:	66 83 fa 02          	cmp    $0x2,%dx
 804ff5b:	0f 84 ac 01 00 00    	je     805010d <net_arp_input+0x21f>
 804ff61:	e9 f1 01 00 00       	jmp    8050157 <net_arp_input+0x269>
	case NET_ARP_REQUEST:
		/* If ARP request sender hw address is our address,
		 * we must drop the packet.
		 */
		if (memcmp(&arp_hdr->src_hwaddr,
 804ff66:	50                   	push   %eax
 804ff67:	8d 77 08             	lea    0x8(%edi),%esi
 804ff6a:	6a 06                	push   $0x6
 804ff6c:	8b 43 18             	mov    0x18(%ebx),%eax
			   net_if_get_link_addr(net_pkt_iface(pkt))->addr,
 804ff6f:	8b 00                	mov    (%eax),%eax
		if (memcmp(&arp_hdr->src_hwaddr,
 804ff71:	ff 70 10             	push   0x10(%eax)
 804ff74:	56                   	push   %esi
 804ff75:	e8 f6 90 ff ff       	call   8049070 <memcmp@plt>
 804ff7a:	83 c4 10             	add    $0x10,%esp
 804ff7d:	85 c0                	test   %eax,%eax
 804ff7f:	74 9e                	je     804ff1f <net_arp_input+0x31>
			return NET_DROP;
		}

		if (IS_ENABLED(CONFIG_NET_ARP_GRATUITOUS)) {
			if (memcmp(&eth_hdr->dst,
				   net_eth_broadcast_addr(),
 804ff81:	e8 f2 f5 ff ff       	call   804f578 <net_eth_broadcast_addr>
			if (memcmp(&eth_hdr->dst,
 804ff86:	51                   	push   %ecx
 804ff87:	6a 06                	push   $0x6
 804ff89:	50                   	push   %eax
 804ff8a:	ff 75 0c             	push   0xc(%ebp)
 804ff8d:	e8 de 90 ff ff       	call   8049070 <memcmp@plt>
 804ff92:	83 c4 10             	add    $0x10,%esp
 804ff95:	85 c0                	test   %eax,%eax
 804ff97:	75 46                	jne    804ffdf <net_arp_input+0xf1>
				   sizeof(struct net_eth_addr)) == 0 &&
			    memcmp(&arp_hdr->dst_hwaddr,
				   net_eth_broadcast_addr(),
 804ff99:	e8 da f5 ff ff       	call   804f578 <net_eth_broadcast_addr>
			    memcmp(&arp_hdr->dst_hwaddr,
 804ff9e:	52                   	push   %edx
 804ff9f:	6a 06                	push   $0x6
 804ffa1:	50                   	push   %eax
 804ffa2:	8d 47 12             	lea    0x12(%edi),%eax
 804ffa5:	50                   	push   %eax
 804ffa6:	e8 c5 90 ff ff       	call   8049070 <memcmp@plt>
 804ffab:	83 c4 10             	add    $0x10,%esp
				   sizeof(struct net_eth_addr)) == 0 &&
 804ffae:	85 c0                	test   %eax,%eax
 804ffb0:	75 2d                	jne    804ffdf <net_arp_input+0xf1>
				   sizeof(struct net_eth_addr)) == 0 &&
			    memcmp(&arp_hdr->dst_ipaddr, &arp_hdr->src_ipaddr,
 804ffb2:	8d 57 0e             	lea    0xe(%edi),%edx
 804ffb5:	50                   	push   %eax
 804ffb6:	8d 47 18             	lea    0x18(%edi),%eax
 804ffb9:	6a 04                	push   $0x4
 804ffbb:	52                   	push   %edx
 804ffbc:	50                   	push   %eax
 804ffbd:	89 55 e4             	mov    %edx,-0x1c(%ebp)
 804ffc0:	e8 ab 90 ff ff       	call   8049070 <memcmp@plt>
 804ffc5:	83 c4 10             	add    $0x10,%esp
				   sizeof(struct net_eth_addr)) == 0 &&
 804ffc8:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 804ffcb:	85 c0                	test   %eax,%eax
 804ffcd:	75 10                	jne    804ffdf <net_arp_input+0xf1>
				   sizeof(struct in_addr)) == 0) {
				/* If the IP address is in our cache,
				 * then update it here.
				 */
				arp_update(net_pkt_iface(pkt),
 804ffcf:	8b 43 18             	mov    0x18(%ebx),%eax
 804ffd2:	51                   	push   %ecx
 804ffd3:	51                   	push   %ecx
 804ffd4:	89 f1                	mov    %esi,%ecx
 804ffd6:	6a 00                	push   $0x0
 804ffd8:	6a 01                	push   $0x1
 804ffda:	e9 51 01 00 00       	jmp    8050130 <net_arp_input+0x242>
		}

		/* Discard ARP request if Ethernet address is broadcast
		 * and Source IP address is Multicast address.
		 */
		if (memcmp(&eth_hdr->dst, net_eth_broadcast_addr(),
 804ffdf:	e8 94 f5 ff ff       	call   804f578 <net_eth_broadcast_addr>
 804ffe4:	52                   	push   %edx
 804ffe5:	6a 06                	push   $0x6
 804ffe7:	50                   	push   %eax
 804ffe8:	ff 75 0c             	push   0xc(%ebp)
 804ffeb:	e8 80 90 ff ff       	call   8049070 <memcmp@plt>
 804fff0:	83 c4 10             	add    $0x10,%esp
 804fff3:	85 c0                	test   %eax,%eax
 804fff5:	75 13                	jne    805000a <net_arp_input+0x11c>
	return (ntohl(UNALIGNED_GET(&addr->s_addr)) & 0xF0000000) == 0xE0000000;
 804fff7:	8b 47 0e             	mov    0xe(%edi),%eax
 804fffa:	25 f0 00 00 00       	and    $0xf0,%eax
			   sizeof(struct net_eth_addr)) == 0 &&
 804ffff:	3d e0 00 00 00       	cmp    $0xe0,%eax
 8050004:	0f 84 15 ff ff ff    	je     804ff1f <net_arp_input+0x31>
	return pkt->iface;
 805000a:	8b 43 18             	mov    0x18(%ebx),%eax
			return NET_DROP;
		}

		/* Someone wants to know our ll address */
		addr = if_get_addr(net_pkt_iface(pkt),
				   (struct in_addr *)arp_hdr->dst_ipaddr);
 805000d:	8d 57 18             	lea    0x18(%edi),%edx
 8050010:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		addr = if_get_addr(net_pkt_iface(pkt),
 8050013:	8b 40 08             	mov    0x8(%eax),%eax
 8050016:	e8 ef f8 ff ff       	call   804f90a <if_get_addr.isra.0>
		if (!addr) {
 805001b:	85 c0                	test   %eax,%eax
 805001d:	0f 84 fc fe ff ff    	je     804ff1f <net_arp_input+0x31>
	if (addr->addr[0] == 0x00 &&
 8050023:	80 7f 12 00          	cmpb   $0x0,0x12(%edi)
 8050027:	75 36                	jne    805005f <net_arp_input+0x171>
 8050029:	80 7f 13 00          	cmpb   $0x0,0x13(%edi)
 805002d:	75 30                	jne    805005f <net_arp_input+0x171>
	    addr->addr[1] == 0x00 &&
 805002f:	80 7f 14 00          	cmpb   $0x0,0x14(%edi)
 8050033:	75 2a                	jne    805005f <net_arp_input+0x171>
	    addr->addr[2] == 0x00 &&
 8050035:	80 7f 15 00          	cmpb   $0x0,0x15(%edi)
 8050039:	75 24                	jne    805005f <net_arp_input+0x171>
	    addr->addr[3] == 0x00 &&
 805003b:	80 7f 16 00          	cmpb   $0x0,0x16(%edi)
 805003f:	75 1e                	jne    805005f <net_arp_input+0x171>
	    addr->addr[4] == 0x00 &&
 8050041:	80 7f 17 00          	cmpb   $0x0,0x17(%edi)
 8050045:	75 18                	jne    805005f <net_arp_input+0x171>
				net_sprint_ipv4_addr(&arp_hdr->src_ipaddr),
				net_sprint_ll_addr((uint8_t *)&arp_hdr->src_hwaddr,
						   arp_hdr->hwlen));

			arp_update(net_pkt_iface(pkt),
				   (struct in_addr *)arp_hdr->src_ipaddr,
 8050047:	8d 57 0e             	lea    0xe(%edi),%edx
			arp_update(net_pkt_iface(pkt),
 805004a:	57                   	push   %edi
 805004b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 805004e:	89 f1                	mov    %esi,%ecx
 8050050:	57                   	push   %edi
 8050051:	6a 01                	push   $0x1
 8050053:	6a 00                	push   $0x0
 8050055:	e8 03 f9 ff ff       	call   804f95d <arp_update>
 805005a:	83 c4 10             	add    $0x10,%esp
				   &arp_hdr->src_hwaddr,
				   false, true);

			dst_hw_addr = &arp_hdr->src_hwaddr;
 805005d:	eb 06                	jmp    8050065 <net_arp_input+0x177>
		} else {
			dst_hw_addr = &eth_hdr->src;
 805005f:	8b 45 0c             	mov    0xc(%ebp),%eax
 8050062:	8d 70 06             	lea    0x6(%eax),%esi
 8050065:	8b 43 18             	mov    0x18(%ebx),%eax
	pkt = net_pkt_alloc_with_buffer(iface, sizeof(struct net_arp_hdr),
 8050068:	51                   	push   %ecx
 8050069:	51                   	push   %ecx
 805006a:	6a 00                	push   $0x0
 805006c:	6a 0a                	push   $0xa
 805006e:	6a 00                	push   $0x0
 8050070:	6a 00                	push   $0x0
 8050072:	6a 1c                	push   $0x1c
 8050074:	50                   	push   %eax
 8050075:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 8050078:	e8 8a 52 00 00       	call   8055307 <net_pkt_alloc_with_buffer>
 805007d:	83 c4 20             	add    $0x20,%esp
 8050080:	89 c7                	mov    %eax,%edi
	if (!pkt) {
 8050082:	85 c0                	test   %eax,%eax
 8050084:	0f 84 cd 00 00 00    	je     8050157 <net_arp_input+0x269>
	return net_buf_simple_add(&buf->b, len);
 805008a:	50                   	push   %eax
 805008b:	50                   	push   %eax
 805008c:	6a 1c                	push   $0x1c
 805008e:	8b 47 08             	mov    0x8(%edi),%eax
 8050091:	83 c0 0c             	add    $0xc,%eax
 8050094:	50                   	push   %eax
 8050095:	e8 a3 f1 ff ff       	call   804f23d <net_buf_simple_add>
 805009a:	58                   	pop    %eax
	return pkt->frags->data;
 805009b:	8b 47 08             	mov    0x8(%edi),%eax
 805009e:	8b 4b 08             	mov    0x8(%ebx),%ecx
 80500a1:	5a                   	pop    %edx
 80500a2:	8b 40 0c             	mov    0xc(%eax),%eax
 80500a5:	8b 49 0c             	mov    0xc(%ecx),%ecx
	memcpy(&hdr->dst_hwaddr.addr, &dst_addr->addr,
 80500a8:	8d 50 12             	lea    0x12(%eax),%edx
	hdr->hwtype = htons(NET_ARP_HTYPE_ETH);
 80500ab:	c7 00 00 01 08 00    	movl   $0x80100,(%eax)
	hdr->hwlen = sizeof(struct net_eth_addr);
 80500b1:	c7 40 04 06 04 00 02 	movl   $0x2000406,0x4(%eax)
	memcpy(&hdr->dst_hwaddr.addr, &dst_addr->addr,
 80500b8:	89 55 e0             	mov    %edx,-0x20(%ebp)
  return __builtin___memcpy_chk (__dest, __src, __len,
 80500bb:	8b 16                	mov    (%esi),%edx
 80500bd:	89 50 12             	mov    %edx,0x12(%eax)
 80500c0:	66 8b 76 04          	mov    0x4(%esi),%si
 80500c4:	66 89 70 16          	mov    %si,0x16(%eax)
	memcpy(&hdr->src_hwaddr.addr, net_if_get_link_addr(iface)->addr,
 80500c8:	8b 75 e4             	mov    -0x1c(%ebp),%esi
 80500cb:	8b 36                	mov    (%esi),%esi
 80500cd:	8b 76 10             	mov    0x10(%esi),%esi
 80500d0:	8b 16                	mov    (%esi),%edx
 80500d2:	89 50 08             	mov    %edx,0x8(%eax)
 80500d5:	66 8b 76 04          	mov    0x4(%esi),%si
 80500d9:	66 89 70 0c          	mov    %si,0xc(%eax)
	net_ipaddr_copy((struct in_addr *)dest, (const struct in_addr *)src);
 80500dd:	8b 71 0e             	mov    0xe(%ecx),%esi
 80500e0:	89 70 18             	mov    %esi,0x18(%eax)
 80500e3:	8b 49 18             	mov    0x18(%ecx),%ecx
 80500e6:	89 48 0e             	mov    %ecx,0xe(%eax)
	net_pkt_lladdr_src(pkt)->addr = net_if_get_link_addr(iface)->addr;
 80500e9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 80500ec:	8b 00                	mov    (%eax),%eax
 80500ee:	8b 40 10             	mov    0x10(%eax),%eax
	net_pkt_lladdr_src(pkt)->len = sizeof(struct net_eth_addr);
 80500f1:	c6 47 24 06          	movb   $0x6,0x24(%edi)
	net_pkt_lladdr_dst(pkt)->len = sizeof(struct net_eth_addr);
 80500f5:	c6 47 2c 06          	movb   $0x6,0x2c(%edi)
	net_pkt_lladdr_src(pkt)->addr = net_if_get_link_addr(iface)->addr;
 80500f9:	89 47 20             	mov    %eax,0x20(%edi)
	net_pkt_lladdr_dst(pkt)->addr = (uint8_t *)&hdr->dst_hwaddr.addr;
 80500fc:	8b 45 e0             	mov    -0x20(%ebp),%eax
 80500ff:	89 47 28             	mov    %eax,0x28(%edi)

		/* Send reply */
		reply = arp_prepare_reply(net_pkt_iface(pkt), pkt, eth_hdr,
					  dst_hw_addr);
		if (reply) {
			net_if_queue_tx(net_pkt_iface(reply), reply);
 8050102:	57                   	push   %edi
 8050103:	ff 77 18             	push   0x18(%edi)
 8050106:	e8 4a 28 00 00       	call   8052955 <net_if_queue_tx>
 805010b:	eb 28                	jmp    8050135 <net_arp_input+0x247>
			NET_DBG("Cannot send ARP reply");
		}
		break;

	case NET_ARP_REPLY:
		if (net_ipv4_is_my_addr((struct in_addr *)arp_hdr->dst_ipaddr)) {
 805010d:	8d 77 18             	lea    0x18(%edi),%esi
 */
static inline bool net_ipv4_is_my_addr(const struct in_addr *addr)
{
	bool ret;

	ret = net_if_ipv4_addr_lookup(addr, NULL) != NULL;
 8050110:	50                   	push   %eax
 8050111:	50                   	push   %eax
 8050112:	6a 00                	push   $0x0
 8050114:	56                   	push   %esi
 8050115:	e8 2b 26 00 00       	call   8052745 <net_if_ipv4_addr_lookup>
 805011a:	83 c4 10             	add    $0x10,%esp
	if (!ret) {
 805011d:	85 c0                	test   %eax,%eax
 805011f:	74 19                	je     805013a <net_arp_input+0x24c>
			arp_update(net_pkt_iface(pkt),
 8050121:	8b 43 18             	mov    0x18(%ebx),%eax
 8050124:	56                   	push   %esi
 8050125:	8d 4f 08             	lea    0x8(%edi),%ecx
				   (struct in_addr *)arp_hdr->src_ipaddr,
 8050128:	8d 57 0e             	lea    0xe(%edi),%edx
			arp_update(net_pkt_iface(pkt),
 805012b:	56                   	push   %esi
 805012c:	6a 00                	push   $0x0
 805012e:	6a 00                	push   $0x0
 8050130:	e8 28 f8 ff ff       	call   804f95d <arp_update>
 8050135:	83 c4 10             	add    $0x10,%esp
 8050138:	eb 1d                	jmp    8050157 <net_arp_input+0x269>
	if (net_ipv4_addr_cmp(addr, net_ipv4_broadcast_address())) {
 805013a:	e8 35 36 00 00       	call   8053774 <net_ipv4_broadcast_address>
 805013f:	8b 00                	mov    (%eax),%eax
 8050141:	39 47 18             	cmp    %eax,0x18(%edi)
 8050144:	74 db                	je     8050121 <net_arp_input+0x233>
	return net_if_ipv4_is_addr_bcast(iface, addr);
 8050146:	50                   	push   %eax
 8050147:	50                   	push   %eax
 8050148:	56                   	push   %esi
 8050149:	6a 00                	push   $0x0
 805014b:	e8 49 24 00 00       	call   8052599 <net_if_ipv4_is_addr_bcast>
 8050150:	83 c4 10             	add    $0x10,%esp
		if (net_ipv4_is_my_addr((struct in_addr *)arp_hdr->dst_ipaddr)) {
 8050153:	84 c0                	test   %al,%al
 8050155:	75 ca                	jne    8050121 <net_arp_input+0x233>
		}

		break;
	}

	net_pkt_unref(pkt);
 8050157:	83 ec 0c             	sub    $0xc,%esp
 805015a:	53                   	push   %ebx
 805015b:	e8 88 4c 00 00       	call   8054de8 <net_pkt_unref>
 8050160:	83 c4 10             	add    $0x10,%esp

	return NET_OK;
 8050163:	31 c0                	xor    %eax,%eax
}
 8050165:	8d 65 f4             	lea    -0xc(%ebp),%esp
 8050168:	5b                   	pop    %ebx
 8050169:	5e                   	pop    %esi
 805016a:	5f                   	pop    %edi
 805016b:	5d                   	pop    %ebp
 805016c:	c3                   	ret    

0805016d <net_arp_clear_cache>:

void net_arp_clear_cache(struct net_if *iface)
{
 805016d:	55                   	push   %ebp
	sys_snode_t *prev = NULL;
	struct arp_entry *entry, *next;

	NET_DBG("Flushing ARP table");

	k_mutex_lock(&arp_mutex, K_FOREVER);
 805016e:	83 c8 ff             	or     $0xffffffff,%eax
 8050171:	89 c2                	mov    %eax,%edx
{
 8050173:	89 e5                	mov    %esp,%ebp
 8050175:	57                   	push   %edi
 8050176:	56                   	push   %esi
 8050177:	53                   	push   %ebx
 8050178:	83 ec 1c             	sub    $0x1c,%esp
 805017b:	8b 75 08             	mov    0x8(%ebp),%esi
	k_mutex_lock(&arp_mutex, K_FOREVER);
 805017e:	e8 5b f7 ff ff       	call   804f8de <k_mutex_lock.constprop.0.isra.0>
	return list->head;
 8050183:	8b 3d 98 89 06 08    	mov    0x8068998,%edi

	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&arp_table, entry, next, node) {
 8050189:	85 ff                	test   %edi,%edi
 805018b:	75 0c                	jne    8050199 <net_arp_clear_cache+0x2c>
 805018d:	8b 3d a0 89 06 08    	mov    0x80689a0,%edi

	prev = NULL;

	NET_DBG("Flushing ARP pending requests");

	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&arp_pending_entries,
 8050193:	85 ff                	test   %edi,%edi
 8050195:	75 65                	jne    80501fc <net_arp_clear_cache+0x8f>
 8050197:	eb 51                	jmp    80501ea <net_arp_clear_cache+0x7d>
	return node->next;
 8050199:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
 80501a0:	8b 1f                	mov    (%edi),%ebx
			prev = &entry->node;
 80501a2:	89 f8                	mov    %edi,%eax
		if (iface && iface != entry->iface) {
 80501a4:	85 f6                	test   %esi,%esi
 80501a6:	74 05                	je     80501ad <net_arp_clear_cache+0x40>
 80501a8:	39 77 08             	cmp    %esi,0x8(%edi)
 80501ab:	75 27                	jne    80501d4 <net_arp_clear_cache+0x67>
		arp_entry_cleanup(entry, false);
 80501ad:	31 d2                	xor    %edx,%edx
 80501af:	89 f8                	mov    %edi,%eax
 80501b1:	e8 5a f9 ff ff       	call   804fb10 <arp_entry_cleanup>
		sys_slist_remove(&arp_table, prev, &entry->node);
 80501b6:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 80501b9:	89 f9                	mov    %edi,%ecx
 80501bb:	b8 98 89 06 08       	mov    $0x8068998,%eax
 80501c0:	e8 a6 f6 ff ff       	call   804f86b <sys_slist_remove>
		sys_slist_prepend(&arp_free_entries, &entry->node);
 80501c5:	b8 a8 89 06 08       	mov    $0x80689a8,%eax
 80501ca:	89 fa                	mov    %edi,%edx
 80501cc:	e8 8a f6 ff ff       	call   804f85b <sys_slist_prepend>
 80501d1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&arp_table, entry, next, node) {
 80501d4:	85 db                	test   %ebx,%ebx
 80501d6:	74 b5                	je     805018d <net_arp_clear_cache+0x20>
 80501d8:	89 df                	mov    %ebx,%edi
 80501da:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 80501dd:	8b 1b                	mov    (%ebx),%ebx
 80501df:	eb c1                	jmp    80501a2 <net_arp_clear_cache+0x35>

		sys_slist_remove(&arp_pending_entries, prev, &entry->node);
		sys_slist_prepend(&arp_free_entries, &entry->node);
	}

	if (sys_slist_is_empty(&arp_pending_entries)) {
 80501e1:	83 3d a0 89 06 08 00 	cmpl   $0x0,0x80689a0
 80501e8:	75 5d                	jne    8050247 <net_arp_clear_cache+0xda>
		k_work_cancel_delayable(&arp_request_timer);
 80501ea:	83 ec 0c             	sub    $0xc,%esp
 80501ed:	68 e0 7a 06 08       	push   $0x8067ae0
 80501f2:	e8 07 fb 00 00       	call   805fcfe <k_work_cancel_delayable>
 80501f7:	83 c4 10             	add    $0x10,%esp
 80501fa:	eb 4b                	jmp    8050247 <net_arp_clear_cache+0xda>
 80501fc:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
 8050203:	8b 1f                	mov    (%edi),%ebx
			prev = &entry->node;
 8050205:	89 f8                	mov    %edi,%eax
		if (iface && iface != entry->iface) {
 8050207:	85 f6                	test   %esi,%esi
 8050209:	74 05                	je     8050210 <net_arp_clear_cache+0xa3>
 805020b:	3b 77 08             	cmp    0x8(%edi),%esi
 805020e:	75 2a                	jne    805023a <net_arp_clear_cache+0xcd>
		arp_entry_cleanup(entry, true);
 8050210:	ba 01 00 00 00       	mov    $0x1,%edx
 8050215:	89 f8                	mov    %edi,%eax
 8050217:	e8 f4 f8 ff ff       	call   804fb10 <arp_entry_cleanup>
		sys_slist_remove(&arp_pending_entries, prev, &entry->node);
 805021c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 805021f:	89 f9                	mov    %edi,%ecx
 8050221:	b8 a0 89 06 08       	mov    $0x80689a0,%eax
 8050226:	e8 40 f6 ff ff       	call   804f86b <sys_slist_remove>
		sys_slist_prepend(&arp_free_entries, &entry->node);
 805022b:	b8 a8 89 06 08       	mov    $0x80689a8,%eax
 8050230:	89 fa                	mov    %edi,%edx
 8050232:	e8 24 f6 ff ff       	call   804f85b <sys_slist_prepend>
 8050237:	8b 45 e4             	mov    -0x1c(%ebp),%eax
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&arp_pending_entries,
 805023a:	85 db                	test   %ebx,%ebx
 805023c:	74 a3                	je     80501e1 <net_arp_clear_cache+0x74>
 805023e:	89 df                	mov    %ebx,%edi
 8050240:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 8050243:	8b 1b                	mov    (%ebx),%ebx
 8050245:	eb be                	jmp    8050205 <net_arp_clear_cache+0x98>
	}

	k_mutex_unlock(&arp_mutex);
}
 8050247:	8d 65 f4             	lea    -0xc(%ebp),%esp
 805024a:	5b                   	pop    %ebx
 805024b:	5e                   	pop    %esi
 805024c:	5f                   	pop    %edi
 805024d:	5d                   	pop    %ebp
	k_mutex_unlock(&arp_mutex);
 805024e:	e9 a2 f6 ff ff       	jmp    804f8f5 <k_mutex_unlock.constprop.0.isra.0>

08050253 <net_arp_clear_pending>:

int net_arp_clear_pending(struct net_if *iface, struct in_addr *dst)
{
 8050253:	55                   	push   %ebp
 8050254:	89 e5                	mov    %esp,%ebp
 8050256:	83 ec 14             	sub    $0x14,%esp
	return arp_entry_find(&arp_pending_entries, iface, dst, NULL);
 8050259:	a1 a0 89 06 08       	mov    0x80689a0,%eax
 805025e:	8b 55 08             	mov    0x8(%ebp),%edx
 8050261:	8b 4d 0c             	mov    0xc(%ebp),%ecx
 8050264:	6a 00                	push   $0x0
 8050266:	e8 c8 f6 ff ff       	call   804f933 <arp_entry_find.isra.0>
 805026b:	83 c4 10             	add    $0x10,%esp
	struct arp_entry *entry = arp_entry_find_pending(iface, dst);

	if (!entry) {
 805026e:	ba fe ff ff ff       	mov    $0xfffffffe,%edx
 8050273:	85 c0                	test   %eax,%eax
 8050275:	74 0c                	je     8050283 <net_arp_clear_pending+0x30>
		return -ENOENT;
	}

	arp_entry_cleanup(entry, true);
 8050277:	ba 01 00 00 00       	mov    $0x1,%edx
 805027c:	e8 8f f8 ff ff       	call   804fb10 <arp_entry_cleanup>

	return 0;
 8050281:	31 d2                	xor    %edx,%edx
}
 8050283:	c9                   	leave  
 8050284:	89 d0                	mov    %edx,%eax
 8050286:	c3                   	ret    

08050287 <net_arp_init>:

void net_arp_init(void)
{
	int i;

	if (arp_cache_initialized) {
 8050287:	80 3d b3 8a 06 08 00 	cmpb   $0x0,0x8068ab3
 805028e:	0f 85 a6 00 00 00    	jne    805033a <net_arp_init+0xb3>
{
 8050294:	55                   	push   %ebp
 8050295:	89 e5                	mov    %esp,%ebp
 8050297:	83 ec 14             	sub    $0x14,%esp
	list->head = NULL;
 805029a:	c7 05 a8 89 06 08 00 	movl   $0x0,0x80689a8
 80502a1:	00 00 00 
	list->tail = NULL;
 80502a4:	c7 05 ac 89 06 08 00 	movl   $0x0,0x80689ac
 80502ab:	00 00 00 
	list->head = NULL;
 80502ae:	c7 05 a0 89 06 08 00 	movl   $0x0,0x80689a0
 80502b5:	00 00 00 
	list->tail = NULL;
 80502b8:	c7 05 a4 89 06 08 00 	movl   $0x0,0x80689a4
 80502bf:	00 00 00 
	list->head = NULL;
 80502c2:	c7 05 98 89 06 08 00 	movl   $0x0,0x8068998
 80502c9:	00 00 00 
	list->tail = NULL;
 80502cc:	c7 05 9c 89 06 08 00 	movl   $0x0,0x806899c
 80502d3:	00 00 00 
	z_impl_k_queue_init(queue);
 80502d6:	68 38 7b 06 08       	push   $0x8067b38
 80502db:	e8 95 f1 00 00       	call   805f475 <z_impl_k_queue_init>
 80502e0:	83 c4 10             	add    $0x10,%esp
	sys_slist_init(&arp_table);

	for (i = 0; i < CONFIG_NET_ARP_TABLE_SIZE; i++) {
		/* Inserting entry as free with initialised packet queue */
		k_fifo_init(&arp_entries[i].pending_queue);
		sys_slist_prepend(&arp_free_entries, &arp_entries[i].node);
 80502e3:	ba 20 7b 06 08       	mov    $0x8067b20,%edx
 80502e8:	b8 a8 89 06 08       	mov    $0x80689a8,%eax
 80502ed:	e8 69 f5 ff ff       	call   804f85b <sys_slist_prepend>
 80502f2:	83 ec 0c             	sub    $0xc,%esp
 80502f5:	68 68 7b 06 08       	push   $0x8067b68
 80502fa:	e8 76 f1 00 00       	call   805f475 <z_impl_k_queue_init>
 80502ff:	83 c4 10             	add    $0x10,%esp
 8050302:	b8 a8 89 06 08       	mov    $0x80689a8,%eax
 8050307:	ba 50 7b 06 08       	mov    $0x8067b50,%edx
 805030c:	e8 4a f5 ff ff       	call   804f85b <sys_slist_prepend>
	}

	k_work_init_delayable(&arp_request_timer, arp_request_timeout);
 8050311:	50                   	push   %eax
 8050312:	50                   	push   %eax
 8050313:	68 5d fb 04 08       	push   $0x804fb5d
 8050318:	68 e0 7a 06 08       	push   $0x8067ae0
 805031d:	e8 23 f9 00 00       	call   805fc45 <k_work_init_delayable>
	return z_impl_k_mutex_init(mutex);
 8050322:	c7 04 24 84 89 06 08 	movl   $0x8068984,(%esp)
 8050329:	e8 4d ee 00 00       	call   805f17b <z_impl_k_mutex_init>

	k_mutex_init(&arp_mutex);

	arp_cache_initialized = true;
 805032e:	c6 05 b3 8a 06 08 01 	movb   $0x1,0x8068ab3
 8050335:	83 c4 10             	add    $0x10,%esp
}
 8050338:	c9                   	leave  
 8050339:	c3                   	ret    
 805033a:	c3                   	ret    

0805033b <net_ipv6_is_addr_loopback>:
{
 805033b:	89 c2                	mov    %eax,%edx
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
 805033d:	31 c0                	xor    %eax,%eax
 805033f:	83 3a 00             	cmpl   $0x0,(%edx)
 8050342:	75 18                	jne    805035c <net_ipv6_is_addr_loopback+0x21>
	return UNALIGNED_GET(&addr->s6_addr32[0]) == 0 &&
 8050344:	83 7a 04 00          	cmpl   $0x0,0x4(%edx)
 8050348:	75 12                	jne    805035c <net_ipv6_is_addr_loopback+0x21>
		UNALIGNED_GET(&addr->s6_addr32[1]) == 0 &&
 805034a:	83 7a 08 00          	cmpl   $0x0,0x8(%edx)
 805034e:	75 0c                	jne    805035c <net_ipv6_is_addr_loopback+0x21>
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
 8050350:	31 c0                	xor    %eax,%eax
 8050352:	81 7a 0c 00 00 00 01 	cmpl   $0x1000000,0xc(%edx)
 8050359:	0f 94 c0             	sete   %al
 805035c:	83 e0 01             	and    $0x1,%eax
}
 805035f:	c3                   	ret    

08050360 <processing_data>:
	NET_DBG("Unknown protocol family packet (0x%x)", family);
	return NET_DROP;
}

static void processing_data(struct net_pkt *pkt, bool is_loopback)
{
 8050360:	55                   	push   %ebp
 8050361:	89 e5                	mov    %esp,%ebp
 8050363:	56                   	push   %esi
 8050364:	53                   	push   %ebx
 8050365:	89 c3                	mov    %eax,%ebx
	pkt->l2_processed = is_l2_processed;
 8050367:	80 60 34 f7          	andb   $0xf7,0x34(%eax)
	if (!pkt->frags) {
 805036b:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
 805036f:	74 66                	je     80503d7 <processing_data+0x77>
 8050371:	89 d6                	mov    %edx,%esi
	if (!is_loopback && !locally_routed) {
 8050373:	84 d2                	test   %dl,%dl
 8050375:	74 18                	je     805038f <processing_data+0x2f>
	net_pkt_cursor_init(pkt);
 8050377:	83 ec 0c             	sub    $0xc,%esp
 805037a:	80 4b 34 08          	orb    $0x8,0x34(%ebx)
 805037e:	53                   	push   %ebx
 805037f:	e8 d0 4b 00 00       	call   8054f54 <net_pkt_cursor_init>
 8050384:	83 c4 10             	add    $0x10,%esp
	if (IS_ENABLED(CONFIG_NET_IP) && (family == AF_INET || family == AF_INET6 ||
 8050387:	80 7b 33 00          	cmpb   $0x0,0x33(%ebx)
 805038b:	79 17                	jns    80503a4 <processing_data+0x44>
 805038d:	eb 48                	jmp    80503d7 <processing_data+0x77>
		ret = net_if_recv_data(net_pkt_iface(pkt), pkt);
 805038f:	52                   	push   %edx
 8050390:	52                   	push   %edx
 8050391:	53                   	push   %ebx
 8050392:	ff 73 18             	push   0x18(%ebx)
 8050395:	e8 6e 24 00 00       	call   8052808 <net_if_recv_data>
 805039a:	83 c4 10             	add    $0x10,%esp
		if (ret != NET_CONTINUE) {
 805039d:	83 f8 01             	cmp    $0x1,%eax
 80503a0:	75 31                	jne    80503d3 <processing_data+0x73>
 80503a2:	eb d3                	jmp    8050377 <processing_data+0x17>
	return pkt->frags->data;
 80503a4:	8b 43 08             	mov    0x8(%ebx),%eax
		uint8_t vtc_vhl = NET_IPV6_HDR(pkt)->vtc & 0xf0;
 80503a7:	8b 40 0c             	mov    0xc(%eax),%eax
 80503aa:	8a 00                	mov    (%eax),%al
 80503ac:	83 e0 f0             	and    $0xfffffff0,%eax
		if (IS_ENABLED(CONFIG_NET_IPV6) && vtc_vhl == 0x60) {
 80503af:	3c 60                	cmp    $0x60,%al
 80503b1:	75 10                	jne    80503c3 <processing_data+0x63>
			return net_ipv6_input(pkt, is_loopback);
 80503b3:	50                   	push   %eax
 80503b4:	50                   	push   %eax
again:
	switch (process_data(pkt, is_loopback)) {
 80503b5:	89 f0                	mov    %esi,%eax
 80503b7:	0f b6 f0             	movzbl %al,%esi
			return net_ipv6_input(pkt, is_loopback);
 80503ba:	56                   	push   %esi
 80503bb:	53                   	push   %ebx
 80503bc:	e8 53 71 00 00       	call   8057514 <net_ipv6_input>
 80503c1:	eb 0d                	jmp    80503d0 <processing_data+0x70>
		} else if (IS_ENABLED(CONFIG_NET_IPV4) && vtc_vhl == 0x40) {
 80503c3:	3c 40                	cmp    $0x40,%al
 80503c5:	75 10                	jne    80503d7 <processing_data+0x77>
			return net_ipv4_input(pkt);
 80503c7:	83 ec 0c             	sub    $0xc,%esp
 80503ca:	53                   	push   %ebx
 80503cb:	e8 c4 65 00 00       	call   8056994 <net_ipv4_input>
 80503d0:	83 c4 10             	add    $0x10,%esp
	switch (process_data(pkt, is_loopback)) {
 80503d3:	85 c0                	test   %eax,%eax
 80503d5:	74 0c                	je     80503e3 <processing_data+0x83>
			 * to the stack in this case.
			 */
			goto again;
		} else {
			NET_DBG("Dropping pkt %p", pkt);
			net_pkt_unref(pkt);
 80503d7:	83 ec 0c             	sub    $0xc,%esp
 80503da:	53                   	push   %ebx
 80503db:	e8 08 4a 00 00       	call   8054de8 <net_pkt_unref>
 80503e0:	83 c4 10             	add    $0x10,%esp
	default:
		NET_DBG("Dropping pkt %p", pkt);
		net_pkt_unref(pkt);
		break;
	}
}
 80503e3:	8d 65 f8             	lea    -0x8(%ebp),%esp
 80503e6:	5b                   	pop    %ebx
 80503e7:	5e                   	pop    %esi
 80503e8:	5d                   	pop    %ebp
 80503e9:	c3                   	ret    

080503ea <net_init>:

	return status;
}

static int net_init(void)
{
 80503ea:	55                   	push   %ebp
 80503eb:	89 e5                	mov    %esp,%ebp
 80503ed:	83 ec 08             	sub    $0x8,%esp
	net_hostname_init();

	NET_DBG("Priority %d", CONFIG_NET_INIT_PRIO);

	net_pkt_init();
 80503f0:	e8 5c 55 00 00       	call   8055951 <net_pkt_init>

	net_context_init();
 80503f5:	e8 44 46 00 00       	call   8054a3e <net_context_init>
	net_icmpv4_init();
 80503fa:	e8 51 63 00 00       	call   8056750 <net_icmpv4_init>
	net_icmpv6_init();
 80503ff:	e8 21 6d 00 00       	call   8057125 <net_icmpv6_init>
	net_ipv4_init();
 8050404:	e8 aa 67 00 00       	call   8056bb3 <net_ipv4_init>
	net_ipv6_init();
 8050409:	e8 5b 76 00 00       	call   8057a69 <net_ipv6_init>
		net_conn_init();
 805040e:	e8 e0 5d 00 00       	call   80561f3 <net_conn_init>
	net_route_init();
 8050413:	e8 36 a2 00 00       	call   805a64e <net_route_init>
	net_if_init();
 8050418:	e8 5c 27 00 00       	call   8052b79 <net_if_init>
	net_tc_rx_init();
 805041d:	e8 91 55 00 00       	call   80559b3 <net_tc_rx_init>
	net_if_post_init();
 8050422:	e8 8b 28 00 00       	call   8052cb2 <net_if_post_init>
	dns_init_resolver();
 8050427:	e8 46 b8 00 00       	call   805bc72 <dns_init_resolver>
	net_mgmt_event_init();

	init_rx_queues();

	return services_init();
}
 805042c:	31 c0                	xor    %eax,%eax
 805042e:	c9                   	leave  
 805042f:	c3                   	ret    

08050430 <net_send_data>:
{
 8050430:	55                   	push   %ebp
 8050431:	89 e5                	mov    %esp,%ebp
 8050433:	57                   	push   %edi
 8050434:	56                   	push   %esi
 8050435:	53                   	push   %ebx
 8050436:	83 ec 2c             	sub    $0x2c,%esp
 8050439:	8b 5d 08             	mov    0x8(%ebp),%ebx
		return -ENODATA;
 805043c:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 8050442:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 8050445:	b8 c3 ff ff ff       	mov    $0xffffffc3,%eax
	if (!pkt || !pkt->frags) {
 805044a:	85 db                	test   %ebx,%ebx
 805044c:	0f 84 b9 01 00 00    	je     805060b <net_send_data+0x1db>
 8050452:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
 8050456:	0f 84 af 01 00 00    	je     805060b <net_send_data+0x1db>
	if (!net_pkt_iface(pkt)) {
 805045c:	83 7b 18 00          	cmpl   $0x0,0x18(%ebx)
		return -EINVAL;
 8050460:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
	if (!net_pkt_iface(pkt)) {
 8050465:	0f 84 a0 01 00 00    	je     805060b <net_send_data+0x1db>
	net_pkt_trim_buffer(pkt);
 805046b:	83 ec 0c             	sub    $0xc,%esp
 805046e:	53                   	push   %ebx
 805046f:	e8 8c 4a 00 00       	call   8054f00 <net_pkt_trim_buffer>
	net_pkt_cursor_init(pkt);
 8050474:	89 1c 24             	mov    %ebx,(%esp)
 8050477:	e8 d8 4a 00 00       	call   8054f54 <net_pkt_cursor_init>
	return pkt->family;
 805047c:	8a 43 33             	mov    0x33(%ebx),%al
 805047f:	83 c4 10             	add    $0x10,%esp
 8050482:	c0 e8 05             	shr    $0x5,%al
	if (IS_ENABLED(CONFIG_NET_IPV6) && family == AF_INET6) {
 8050485:	3c 02                	cmp    $0x2,%al
 8050487:	0f 85 ab 00 00 00    	jne    8050538 <net_send_data+0x108>
		if (net_ipv6_addr_cmp((struct in6_addr *)NET_IPV6_HDR(pkt)->dst,
 805048d:	e8 e8 32 00 00       	call   805377a <net_ipv6_unspecified_address>
	return pkt->frags->data;
 8050492:	8b 53 08             	mov    0x8(%ebx),%edx
 8050495:	8b 72 0c             	mov    0xc(%edx),%esi
	return !memcmp(addr1, addr2, sizeof(struct in6_addr));
 8050498:	52                   	push   %edx
 8050499:	6a 10                	push   $0x10
 805049b:	83 c6 18             	add    $0x18,%esi
 805049e:	50                   	push   %eax
 805049f:	56                   	push   %esi
 80504a0:	e8 cb 8b ff ff       	call   8049070 <memcmp@plt>
 80504a5:	83 c4 10             	add    $0x10,%esp
 80504a8:	85 c0                	test   %eax,%eax
 80504aa:	75 0a                	jne    80504b6 <net_send_data+0x86>
			return -EADDRNOTAVAIL;
 80504ac:	b8 9d ff ff ff       	mov    $0xffffff9d,%eax
 80504b1:	e9 55 01 00 00       	jmp    805060b <net_send_data+0x1db>
		if (net_ipv6_is_addr_loopback(
 80504b6:	89 f0                	mov    %esi,%eax
 80504b8:	e8 7e fe ff ff       	call   805033b <net_ipv6_is_addr_loopback>
 80504bd:	84 c0                	test   %al,%al
 80504bf:	74 3b                	je     80504fc <net_send_data+0xcc>
 80504c1:	8b 43 08             	mov    0x8(%ebx),%eax
 80504c4:	b9 04 00 00 00       	mov    $0x4,%ecx
 80504c9:	8d 7d d4             	lea    -0x2c(%ebp),%edi
 80504cc:	8b 40 0c             	mov    0xc(%eax),%eax
			net_ipv6_addr_copy_raw((uint8_t *)&addr, NET_IPV6_HDR(pkt)->src);
 80504cf:	8d 50 08             	lea    0x8(%eax),%edx
 80504d2:	89 d6                	mov    %edx,%esi
 80504d4:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
 80504d6:	8d 70 18             	lea    0x18(%eax),%esi
 80504d9:	b9 04 00 00 00       	mov    $0x4,%ecx
 80504de:	89 d7                	mov    %edx,%edi
 80504e0:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
 80504e2:	b9 04 00 00 00       	mov    $0x4,%ecx
 80504e7:	8d 75 d4             	lea    -0x2c(%ebp),%esi
 80504ea:	8b 43 08             	mov    0x8(%ebx),%eax
 80504ed:	8b 40 0c             	mov    0xc(%eax),%eax
 80504f0:	83 c0 18             	add    $0x18,%eax
 80504f3:	89 c7                	mov    %eax,%edi
 80504f5:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	if (status < 0) {
 80504f7:	e9 e4 00 00 00       	jmp    80505e0 <net_send_data+0x1b0>
	return net_if_ipv6_addr_lookup(addr, NULL) != NULL;
 80504fc:	50                   	push   %eax
 80504fd:	50                   	push   %eax
 80504fe:	6a 00                	push   $0x0
 8050500:	56                   	push   %esi
 8050501:	e8 19 0e 00 00       	call   805131f <net_if_ipv6_addr_lookup>
 8050506:	83 c4 10             	add    $0x10,%esp
				(struct in6_addr *)NET_IPV6_HDR(pkt)->dst) ||
 8050509:	85 c0                	test   %eax,%eax
 805050b:	75 b4                	jne    80504c1 <net_send_data+0x91>
 805050d:	8b 43 08             	mov    0x8(%ebx),%eax
 8050510:	8b 40 0c             	mov    0xc(%eax),%eax
 * false otherwise.
 */
static inline bool net_ipv6_is_addr_mcast_scope(const struct in6_addr *addr,
						int scope)
{
	return (addr->s6_addr[0] == 0xff) && (addr->s6_addr[1] == scope);
 8050513:	80 78 18 ff          	cmpb   $0xff,0x18(%eax)
 8050517:	75 0a                	jne    8050523 <net_send_data+0xf3>
 8050519:	80 78 19 01          	cmpb   $0x1,0x19(%eax)
 805051d:	0f 84 bd 00 00 00    	je     80505e0 <net_send_data+0x1b0>
				(struct in6_addr *)NET_IPV6_HDR(pkt)->src)) {
 8050523:	83 c0 08             	add    $0x8,%eax
		if (net_ipv6_is_addr_loopback(
 8050526:	e8 10 fe ff ff       	call   805033b <net_ipv6_is_addr_loopback>
 805052b:	84 c0                	test   %al,%al
 805052d:	0f 84 bd 00 00 00    	je     80505f0 <net_send_data+0x1c0>
 8050533:	e9 74 ff ff ff       	jmp    80504ac <net_send_data+0x7c>
	} else if (IS_ENABLED(CONFIG_NET_IPV4) && family == AF_INET) {
 8050538:	fe c8                	dec    %al
 805053a:	0f 85 b0 00 00 00    	jne    80505f0 <net_send_data+0x1c0>
		if (net_ipv4_addr_cmp((struct in_addr *)NET_IPV4_HDR(pkt)->dst,
 8050540:	e8 29 32 00 00       	call   805376e <net_ipv4_unspecified_address>
 8050545:	8b 53 08             	mov    0x8(%ebx),%edx
 8050548:	8b 00                	mov    (%eax),%eax
 805054a:	8b 72 0c             	mov    0xc(%edx),%esi
 805054d:	39 46 10             	cmp    %eax,0x10(%esi)
 8050550:	0f 84 56 ff ff ff    	je     80504ac <net_send_data+0x7c>
		if (net_ipv4_is_addr_loopback((struct in_addr *)NET_IPV4_HDR(pkt)->dst) ||
 8050556:	80 7e 10 7f          	cmpb   $0x7f,0x10(%esi)
 805055a:	75 1a                	jne    8050576 <net_send_data+0x146>
 805055c:	8b 43 08             	mov    0x8(%ebx),%eax
 805055f:	8b 40 0c             	mov    0xc(%eax),%eax
	net_ipaddr_copy((struct in_addr *)dest, (const struct in_addr *)src);
 8050562:	8b 48 10             	mov    0x10(%eax),%ecx
 8050565:	8b 50 0c             	mov    0xc(%eax),%edx
 8050568:	89 48 0c             	mov    %ecx,0xc(%eax)
 805056b:	8b 43 08             	mov    0x8(%ebx),%eax
 805056e:	8b 40 0c             	mov    0xc(%eax),%eax
 8050571:	89 50 10             	mov    %edx,0x10(%eax)
	if (status < 0) {
 8050574:	eb 6a                	jmp    80505e0 <net_send_data+0x1b0>
	return pkt->iface;
 8050576:	8b 7b 18             	mov    0x18(%ebx),%edi
	if (net_ipv4_addr_cmp(addr, net_ipv4_broadcast_address())) {
 8050579:	e8 f6 31 00 00       	call   8053774 <net_ipv4_broadcast_address>
 805057e:	8b 00                	mov    (%eax),%eax
 8050580:	39 46 10             	cmp    %eax,0x10(%esi)
 8050583:	74 4a                	je     80505cf <net_send_data+0x19f>
				     (struct in_addr *)NET_IPV4_HDR(pkt)->dst) == false &&
 8050585:	83 c6 10             	add    $0x10,%esi
	return net_if_ipv4_is_addr_bcast(iface, addr);
 8050588:	50                   	push   %eax
 8050589:	50                   	push   %eax
 805058a:	56                   	push   %esi
 805058b:	57                   	push   %edi
 805058c:	e8 08 20 00 00       	call   8052599 <net_if_ipv4_is_addr_bcast>
 8050591:	83 c4 10             	add    $0x10,%esp
		if (net_ipv4_is_addr_loopback((struct in_addr *)NET_IPV4_HDR(pkt)->dst) ||
 8050594:	84 c0                	test   %al,%al
 8050596:	75 37                	jne    80505cf <net_send_data+0x19f>
	return pkt->frags->data;
 8050598:	8b 43 08             	mov    0x8(%ebx),%eax
 805059b:	8b 78 0c             	mov    0xc(%eax),%edi
	ret = net_if_ipv4_addr_lookup(addr, NULL) != NULL;
 805059e:	51                   	push   %ecx
 805059f:	51                   	push   %ecx
		     net_ipv4_is_my_addr((struct in_addr *)NET_IPV4_HDR(pkt)->dst))) {
 80505a0:	8d 77 10             	lea    0x10(%edi),%esi
 80505a3:	6a 00                	push   $0x0
 80505a5:	56                   	push   %esi
 80505a6:	e8 9a 21 00 00       	call   8052745 <net_if_ipv4_addr_lookup>
 80505ab:	83 c4 10             	add    $0x10,%esp
	if (!ret) {
 80505ae:	85 c0                	test   %eax,%eax
 80505b0:	75 aa                	jne    805055c <net_send_data+0x12c>
	if (net_ipv4_addr_cmp(addr, net_ipv4_broadcast_address())) {
 80505b2:	e8 bd 31 00 00       	call   8053774 <net_ipv4_broadcast_address>
 80505b7:	8b 00                	mov    (%eax),%eax
 80505b9:	39 47 10             	cmp    %eax,0x10(%edi)
 80505bc:	74 9e                	je     805055c <net_send_data+0x12c>
	return net_if_ipv4_is_addr_bcast(iface, addr);
 80505be:	52                   	push   %edx
 80505bf:	52                   	push   %edx
 80505c0:	56                   	push   %esi
 80505c1:	6a 00                	push   $0x0
 80505c3:	e8 d1 1f 00 00       	call   8052599 <net_if_ipv4_is_addr_bcast>
 80505c8:	83 c4 10             	add    $0x10,%esp
				     (struct in_addr *)NET_IPV4_HDR(pkt)->dst) == false &&
 80505cb:	84 c0                	test   %al,%al
 80505cd:	75 8d                	jne    805055c <net_send_data+0x12c>
 80505cf:	8b 43 08             	mov    0x8(%ebx),%eax
	return addr->s4_addr[0] == 127U;
 80505d2:	8b 40 0c             	mov    0xc(%eax),%eax
		if (net_ipv4_is_addr_loopback((struct in_addr *)NET_IPV4_HDR(pkt)->src)) {
 80505d5:	80 78 0c 7f          	cmpb   $0x7f,0xc(%eax)
 80505d9:	75 15                	jne    80505f0 <net_send_data+0x1c0>
 80505db:	e9 cc fe ff ff       	jmp    80504ac <net_send_data+0x7c>
		processing_data(pkt, true);
 80505e0:	89 d8                	mov    %ebx,%eax
 80505e2:	ba 01 00 00 00       	mov    $0x1,%edx
 80505e7:	e8 74 fd ff ff       	call   8050360 <processing_data>
		return 0;
 80505ec:	31 c0                	xor    %eax,%eax
 80505ee:	eb 1b                	jmp    805060b <net_send_data+0x1db>
	if (net_if_send_data(net_pkt_iface(pkt), pkt) == NET_DROP) {
 80505f0:	50                   	push   %eax
 80505f1:	50                   	push   %eax
 80505f2:	53                   	push   %ebx
 80505f3:	ff 73 18             	push   0x18(%ebx)
 80505f6:	e8 7f 23 00 00       	call   805297a <net_if_send_data>
 80505fb:	83 c4 10             	add    $0x10,%esp
		return -EIO;
 80505fe:	83 f8 02             	cmp    $0x2,%eax
 8050601:	0f 95 c0             	setne  %al
 8050604:	0f b6 c0             	movzbl %al,%eax
 8050607:	8d 44 80 fb          	lea    -0x5(%eax,%eax,4),%eax
}
 805060b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 805060e:	65 2b 15 14 00 00 00 	sub    %gs:0x14,%edx
 8050615:	74 05                	je     805061c <net_send_data+0x1ec>
 8050617:	e8 e4 8c ff ff       	call   8049300 <__stack_chk_fail@plt>
 805061c:	8d 65 f4             	lea    -0xc(%ebp),%esp
 805061f:	5b                   	pop    %ebx
 8050620:	5e                   	pop    %esi
 8050621:	5f                   	pop    %edi
 8050622:	5d                   	pop    %ebp
 8050623:	c3                   	ret    

08050624 <net_process_rx_packet>:
{
 8050624:	55                   	push   %ebp
 8050625:	89 e5                	mov    %esp,%ebp
 8050627:	8b 4d 08             	mov    0x8(%ebp),%ecx
	pkt_len = net_pkt_get_len(pkt);
 805062a:	8b 41 08             	mov    0x8(%ecx),%eax
	while (buf) {
 805062d:	85 c0                	test   %eax,%eax
 805062f:	74 05                	je     8050636 <net_process_rx_packet+0x12>
		buf = buf->frags;
 8050631:	8b 40 04             	mov    0x4(%eax),%eax
 8050634:	eb f7                	jmp    805062d <net_process_rx_packet+0x9>
	processing_data(pkt, is_loopback);
 8050636:	31 d2                	xor    %edx,%edx
 8050638:	89 c8                	mov    %ecx,%eax
}
 805063a:	5d                   	pop    %ebp
	processing_data(pkt, is_loopback);
 805063b:	e9 20 fd ff ff       	jmp    8050360 <processing_data>

08050640 <net_recv_data>:
{
 8050640:	55                   	push   %ebp
 8050641:	89 e5                	mov    %esp,%ebp
 8050643:	56                   	push   %esi
 8050644:	53                   	push   %ebx
 8050645:	8b 5d 0c             	mov    0xc(%ebp),%ebx
 8050648:	8b 75 08             	mov    0x8(%ebp),%esi
	if (!pkt || !iface) {
 805064b:	85 db                	test   %ebx,%ebx
 805064d:	74 6b                	je     80506ba <net_recv_data+0x7a>
 805064f:	85 f6                	test   %esi,%esi
 8050651:	74 67                	je     80506ba <net_recv_data+0x7a>
	if (net_pkt_is_empty(pkt)) {
 8050653:	8b 53 08             	mov    0x8(%ebx),%edx
		return -ENODATA;
 8050656:	b8 c3 ff ff ff       	mov    $0xffffffc3,%eax
	return !pkt->buffer || !net_pkt_data(pkt) || pkt->buffer->len == 0;
 805065b:	85 d2                	test   %edx,%edx
 805065d:	74 60                	je     80506bf <net_recv_data+0x7f>
 805065f:	83 7a 0c 00          	cmpl   $0x0,0xc(%edx)
 8050663:	74 5a                	je     80506bf <net_recv_data+0x7f>
	if (net_pkt_is_empty(pkt)) {
 8050665:	66 83 7a 10 00       	cmpw   $0x0,0x10(%edx)
 805066a:	74 53                	je     80506bf <net_recv_data+0x7f>
 805066c:	8b 06                	mov    (%esi),%eax
 805066e:	8b 50 0c             	mov    0xc(%eax),%edx
		return -ENETDOWN;
 8050671:	b8 9c ff ff ff       	mov    $0xffffff9c,%eax
	if (!net_if_flag_is_set(iface, NET_IF_UP)) {
 8050676:	80 e2 01             	and    $0x1,%dl
 8050679:	74 44                	je     80506bf <net_recv_data+0x7f>
	net_pkt_cursor_init(pkt);
 805067b:	83 ec 0c             	sub    $0xc,%esp
	pkt->overwrite = overwrite;
 805067e:	80 4b 33 01          	orb    $0x1,0x33(%ebx)
 8050682:	53                   	push   %ebx
 8050683:	e8 cc 48 00 00       	call   8054f54 <net_pkt_cursor_init>
	pkt->iface = iface;
 8050688:	89 73 18             	mov    %esi,0x18(%ebx)
		pkt->lladdr_src.type = net_if_get_link_addr(iface)->type;
 805068b:	8b 06                	mov    (%esi),%eax
 805068d:	8a 40 15             	mov    0x15(%eax),%al
 8050690:	88 43 25             	mov    %al,0x25(%ebx)
		pkt->lladdr_dst.type = net_if_get_link_addr(iface)->type;
 8050693:	8b 06                	mov    (%esi),%eax
 8050695:	8a 40 15             	mov    0x15(%eax),%al
 8050698:	88 43 2d             	mov    %al,0x2d(%ebx)
	uint8_t tc = net_rx_priority2tc(prio);
 805069b:	0f b6 43 3d          	movzbl 0x3d(%ebx),%eax
 805069f:	89 04 24             	mov    %eax,(%esp)
 80506a2:	e8 ee 52 00 00       	call   8055995 <net_rx_priority2tc>
 80506a7:	5a                   	pop    %edx
 80506a8:	59                   	pop    %ecx
		net_tc_submit_to_rx_queue(tc, pkt);
 80506a9:	53                   	push   %ebx
 80506aa:	0f b6 c0             	movzbl %al,%eax
 80506ad:	50                   	push   %eax
 80506ae:	e8 c7 52 00 00       	call   805597a <net_tc_submit_to_rx_queue>
 80506b3:	83 c4 10             	add    $0x10,%esp
	return 0;
 80506b6:	31 c0                	xor    %eax,%eax
}
 80506b8:	eb 05                	jmp    80506bf <net_recv_data+0x7f>
		return -EINVAL;
 80506ba:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
}
 80506bf:	8d 65 f8             	lea    -0x8(%ebp),%esp
 80506c2:	5b                   	pop    %ebx
 80506c3:	5e                   	pop    %esi
 80506c4:	5d                   	pop    %ebp
 80506c5:	c3                   	ret    

080506c6 <sys_slist_append>:
	parent->next = child;
 80506c6:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
	return list->tail;
 80506cc:	8b 48 04             	mov    0x4(%eax),%ecx
Z_GENLIST_APPEND(slist, snode)
 80506cf:	85 c9                	test   %ecx,%ecx
 80506d1:	75 06                	jne    80506d9 <sys_slist_append+0x13>
	list->tail = node;
 80506d3:	89 50 04             	mov    %edx,0x4(%eax)
	list->head = node;
 80506d6:	89 10                	mov    %edx,(%eax)
}
 80506d8:	c3                   	ret    
	parent->next = child;
 80506d9:	89 11                	mov    %edx,(%ecx)
	list->tail = node;
 80506db:	89 50 04             	mov    %edx,0x4(%eax)
Z_GENLIST_APPEND(slist, snode)
 80506de:	c3                   	ret    

080506df <sys_slist_find_and_remove>:
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
 80506df:	55                   	push   %ebp
 80506e0:	89 e5                	mov    %esp,%ebp
 80506e2:	53                   	push   %ebx
	return list->head;
 80506e3:	8b 08                	mov    (%eax),%ecx
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
 80506e5:	31 db                	xor    %ebx,%ebx
 80506e7:	85 c9                	test   %ecx,%ecx
 80506e9:	74 30                	je     805071b <sys_slist_find_and_remove+0x3c>
 80506eb:	39 d1                	cmp    %edx,%ecx
 80506ed:	75 26                	jne    8050715 <sys_slist_find_and_remove+0x36>
	return node->next;
 80506ef:	8b 0a                	mov    (%edx),%ecx
Z_GENLIST_REMOVE(slist, snode)
 80506f1:	85 db                	test   %ebx,%ebx
 80506f3:	75 0c                	jne    8050701 <sys_slist_find_and_remove+0x22>
	list->head = node;
 80506f5:	89 08                	mov    %ecx,(%eax)
Z_GENLIST_REMOVE(slist, snode)
 80506f7:	3b 50 04             	cmp    0x4(%eax),%edx
 80506fa:	75 0f                	jne    805070b <sys_slist_find_and_remove+0x2c>
	list->tail = node;
 80506fc:	89 48 04             	mov    %ecx,0x4(%eax)
}
 80506ff:	eb 0a                	jmp    805070b <sys_slist_find_and_remove+0x2c>
	parent->next = child;
 8050701:	89 0b                	mov    %ecx,(%ebx)
Z_GENLIST_REMOVE(slist, snode)
 8050703:	3b 50 04             	cmp    0x4(%eax),%edx
 8050706:	75 03                	jne    805070b <sys_slist_find_and_remove+0x2c>
	list->tail = node;
 8050708:	89 58 04             	mov    %ebx,0x4(%eax)
	parent->next = child;
 805070b:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
 8050711:	b0 01                	mov    $0x1,%al
Z_GENLIST_REMOVE(slist, snode)
 8050713:	eb 08                	jmp    805071d <sys_slist_find_and_remove+0x3e>
	return node->next;
 8050715:	89 cb                	mov    %ecx,%ebx
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
 8050717:	8b 09                	mov    (%ecx),%ecx
 8050719:	eb cc                	jmp    80506e7 <sys_slist_find_and_remove+0x8>
 805071b:	31 c0                	xor    %eax,%eax
 805071d:	5b                   	pop    %ebx
 805071e:	5d                   	pop    %ebp
 805071f:	c3                   	ret    

08050720 <net_ipv6_is_addr_loopback>:
{
 8050720:	89 c2                	mov    %eax,%edx
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
 8050722:	31 c0                	xor    %eax,%eax
 8050724:	83 3a 00             	cmpl   $0x0,(%edx)
 8050727:	75 18                	jne    8050741 <net_ipv6_is_addr_loopback+0x21>
	return UNALIGNED_GET(&addr->s6_addr32[0]) == 0 &&
 8050729:	83 7a 04 00          	cmpl   $0x0,0x4(%edx)
 805072d:	75 12                	jne    8050741 <net_ipv6_is_addr_loopback+0x21>
		UNALIGNED_GET(&addr->s6_addr32[1]) == 0 &&
 805072f:	83 7a 08 00          	cmpl   $0x0,0x8(%edx)
 8050733:	75 0c                	jne    8050741 <net_ipv6_is_addr_loopback+0x21>
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
 8050735:	31 c0                	xor    %eax,%eax
 8050737:	81 7a 0c 00 00 00 01 	cmpl   $0x1000000,0xc(%edx)
 805073e:	0f 94 c0             	sete   %al
 8050741:	83 e0 01             	and    $0x1,%eax
}
 8050744:	c3                   	ret    

08050745 <net_ipv4_is_ll_addr>:
	return (ntohl(UNALIGNED_GET(&addr->s_addr)) & 0xFFFF0000) == 0xA9FE0000;
 8050745:	66 81 38 a9 fe       	cmpw   $0xfea9,(%eax)
 805074a:	0f 94 c0             	sete   %al
}
 805074d:	c3                   	ret    

0805074e <net_if_l2>:
	if (!iface || !iface->if_dev) {
 805074e:	85 c0                	test   %eax,%eax
 8050750:	74 09                	je     805075b <net_if_l2+0xd>
 8050752:	8b 00                	mov    (%eax),%eax
 8050754:	85 c0                	test   %eax,%eax
 8050756:	74 03                	je     805075b <net_if_l2+0xd>
	return iface->if_dev->l2;
 8050758:	8b 40 04             	mov    0x4(%eax),%eax
}
 805075b:	c3                   	ret    

0805075c <net_context_send_cb>:
#endif

static inline void net_context_send_cb(struct net_context *context,
				       int status)
{
	if (!context) {
 805075c:	85 c0                	test   %eax,%eax
 805075e:	74 19                	je     8050779 <net_context_send_cb+0x1d>
		return;
	}

	if (context->send_cb) {
 8050760:	8b 48 4c             	mov    0x4c(%eax),%ecx
 8050763:	85 c9                	test   %ecx,%ecx
 8050765:	74 12                	je     8050779 <net_context_send_cb+0x1d>
{
 8050767:	55                   	push   %ebp
 8050768:	89 e5                	mov    %esp,%ebp
 805076a:	83 ec 0c             	sub    $0xc,%esp
		context->send_cb(context, status, context->user_data);
 805076d:	ff 70 04             	push   0x4(%eax)
 8050770:	52                   	push   %edx
 8050771:	50                   	push   %eax
 8050772:	ff d1                	call   *%ecx
 8050774:	83 c4 10             	add    $0x10,%esp
		net_stats_update_udp_sent(net_context_get_iface(context));
	} else if (IS_ENABLED(CONFIG_NET_TCP) &&
		   net_context_get_proto(context) == IPPROTO_TCP) {
		net_stats_update_tcp_seg_sent(net_context_get_iface(context));
	}
}
 8050777:	c9                   	leave  
 8050778:	c3                   	ret    
 8050779:	c3                   	ret    

0805077a <l2_flags_get>:

	return NULL;
}

static enum net_l2_flags l2_flags_get(struct net_if *iface)
{
 805077a:	55                   	push   %ebp
 805077b:	89 c2                	mov    %eax,%edx
 805077d:	89 e5                	mov    %esp,%ebp
 805077f:	83 ec 08             	sub    $0x8,%esp
	enum net_l2_flags flags = 0;

	if (net_if_l2(iface) && net_if_l2(iface)->get_flags) {
 8050782:	e8 c7 ff ff ff       	call   805074e <net_if_l2>
 8050787:	85 c0                	test   %eax,%eax
 8050789:	74 14                	je     805079f <l2_flags_get+0x25>
 805078b:	8b 48 0c             	mov    0xc(%eax),%ecx
	enum net_l2_flags flags = 0;
 805078e:	31 c0                	xor    %eax,%eax
	if (net_if_l2(iface) && net_if_l2(iface)->get_flags) {
 8050790:	85 c9                	test   %ecx,%ecx
 8050792:	74 0d                	je     80507a1 <l2_flags_get+0x27>
		flags = net_if_l2(iface)->get_flags(iface);
 8050794:	83 ec 0c             	sub    $0xc,%esp
 8050797:	52                   	push   %edx
 8050798:	ff d1                	call   *%ecx
 805079a:	83 c4 10             	add    $0x10,%esp
 805079d:	eb 02                	jmp    80507a1 <l2_flags_get+0x27>
	enum net_l2_flags flags = 0;
 805079f:	31 c0                	xor    %eax,%eax
	}

	return flags;
}
 80507a1:	c9                   	leave  
 80507a2:	c3                   	ret    

080507a3 <get_ipaddr_diff>:

#if defined(CONFIG_NET_NATIVE_IPV4) || defined(CONFIG_NET_NATIVE_IPV6)
/* Return how many bits are shared between two IP addresses */
static uint8_t get_ipaddr_diff(const uint8_t *src, const uint8_t *dst, int addr_len)
{
 80507a3:	55                   	push   %ebp
 80507a4:	89 e5                	mov    %esp,%ebp
 80507a6:	57                   	push   %edi
 80507a7:	56                   	push   %esi
 80507a8:	89 d6                	mov    %edx,%esi
 80507aa:	53                   	push   %ebx
 80507ab:	83 ec 08             	sub    $0x8,%esp
 80507ae:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint8_t j, k, xor;
	uint8_t len = 0U;
 80507b1:	31 c0                	xor    %eax,%eax
{
 80507b3:	89 4d ec             	mov    %ecx,-0x14(%ebp)

	for (j = 0U; j < addr_len; j++) {
 80507b6:	31 c9                	xor    %ecx,%ecx
		if (src[j] == dst[j]) {
 80507b8:	8b 5d f0             	mov    -0x10(%ebp),%ebx
 80507bb:	0f b6 f9             	movzbl %cl,%edi
 80507be:	8a 14 3b             	mov    (%ebx,%edi,1),%dl
 80507c1:	8a 1c 3e             	mov    (%esi,%edi,1),%bl
 80507c4:	38 da                	cmp    %bl,%dl
 80507c6:	75 0e                	jne    80507d6 <get_ipaddr_diff+0x33>
	for (j = 0U; j < addr_len; j++) {
 80507c8:	41                   	inc    %ecx
			len += 8U;
 80507c9:	83 c0 08             	add    $0x8,%eax
	for (j = 0U; j < addr_len; j++) {
 80507cc:	0f b6 d1             	movzbl %cl,%edx
 80507cf:	3b 55 ec             	cmp    -0x14(%ebp),%edx
 80507d2:	7c e4                	jl     80507b8 <get_ipaddr_diff+0x15>
 80507d4:	eb 10                	jmp    80507e6 <get_ipaddr_diff+0x43>
		} else {
			xor = src[j] ^ dst[j];
 80507d6:	31 da                	xor    %ebx,%edx
			for (k = 0U; k < 8; k++) {
 80507d8:	8d 48 08             	lea    0x8(%eax),%ecx
				if (!(xor & 0x80)) {
 80507db:	84 d2                	test   %dl,%dl
 80507dd:	78 07                	js     80507e6 <get_ipaddr_diff+0x43>
					len++;
 80507df:	40                   	inc    %eax
					xor <<= 1;
 80507e0:	01 d2                	add    %edx,%edx
			for (k = 0U; k < 8; k++) {
 80507e2:	38 c1                	cmp    %al,%cl
 80507e4:	75 f5                	jne    80507db <get_ipaddr_diff+0x38>
			break;
		}
	}

	return len;
}
 80507e6:	5a                   	pop    %edx
 80507e7:	59                   	pop    %ecx
 80507e8:	5b                   	pop    %ebx
 80507e9:	5e                   	pop    %esi
 80507ea:	5f                   	pop    %edi
 80507eb:	5d                   	pop    %ebp
 80507ec:	c3                   	ret    

080507ed <net_ipv6_is_prefix>:
	if (length > 128) {
 80507ed:	80 f9 80             	cmp    $0x80,%cl
 80507f0:	77 5b                	ja     805084d <net_ipv6_is_prefix+0x60>
{
 80507f2:	55                   	push   %ebp
 80507f3:	89 e5                	mov    %esp,%ebp
 80507f5:	57                   	push   %edi
 80507f6:	89 d7                	mov    %edx,%edi
 80507f8:	56                   	push   %esi
 80507f9:	89 c6                	mov    %eax,%esi
 80507fb:	53                   	push   %ebx
 80507fc:	89 cb                	mov    %ecx,%ebx
	uint8_t bytes = length / 8U;
 80507fe:	c0 e9 03             	shr    $0x3,%cl
	if (memcmp(addr1, addr2, bytes)) {
 8050801:	0f b6 c9             	movzbl %cl,%ecx
{
 8050804:	83 ec 20             	sub    $0x20,%esp
	if (memcmp(addr1, addr2, bytes)) {
 8050807:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
 805080a:	51                   	push   %ecx
 805080b:	52                   	push   %edx
 805080c:	50                   	push   %eax
 805080d:	e8 5e 88 ff ff       	call   8049070 <memcmp@plt>
 8050812:	83 c4 10             	add    $0x10,%esp
 8050815:	89 c2                	mov    %eax,%edx
		return false;
 8050817:	31 c0                	xor    %eax,%eax
	if (memcmp(addr1, addr2, bytes)) {
 8050819:	85 d2                	test   %edx,%edx
 805081b:	75 33                	jne    8050850 <net_ipv6_is_prefix+0x63>
	if (!remain) {
 805081d:	f7 db                	neg    %ebx
		return true;
 805081f:	b0 01                	mov    $0x1,%al
	if (!remain) {
 8050821:	80 e3 07             	and    $0x7,%bl
 8050824:	74 2a                	je     8050850 <net_ipv6_is_prefix+0x63>
	return (addr1[bytes] & mask) == (addr2[bytes] & mask);
 8050826:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
	mask = ((0xff << (8 - remain)) ^ 0xff) << remain;
 8050829:	0f b6 c3             	movzbl %bl,%eax
	return (addr1[bytes] & mask) == (addr2[bytes] & mask);
 805082c:	8a 14 0e             	mov    (%esi,%ecx,1),%dl
 805082f:	32 14 0f             	xor    (%edi,%ecx,1),%dl
	mask = ((0xff << (8 - remain)) ^ 0xff) << remain;
 8050832:	b9 08 00 00 00       	mov    $0x8,%ecx
 8050837:	29 c1                	sub    %eax,%ecx
 8050839:	b8 ff 00 00 00       	mov    $0xff,%eax
 805083e:	d3 e0                	shl    %cl,%eax
 8050840:	89 d9                	mov    %ebx,%ecx
 8050842:	34 ff                	xor    $0xff,%al
 8050844:	d3 e0                	shl    %cl,%eax
	return (addr1[bytes] & mask) == (addr2[bytes] & mask);
 8050846:	84 c2                	test   %al,%dl
 8050848:	0f 94 c0             	sete   %al
 805084b:	eb 03                	jmp    8050850 <net_ipv6_is_prefix+0x63>
		return false;
 805084d:	31 c0                	xor    %eax,%eax
}
 805084f:	c3                   	ret    
 8050850:	8d 65 f4             	lea    -0xc(%ebp),%esp
 8050853:	5b                   	pop    %ebx
 8050854:	5e                   	pop    %esi
 8050855:	5f                   	pop    %edi
 8050856:	5d                   	pop    %ebp
 8050857:	c3                   	ret    

08050858 <net_ipv6_addr_cmp>:
{
 8050858:	55                   	push   %ebp
 8050859:	89 e5                	mov    %esp,%ebp
 805085b:	83 ec 0c             	sub    $0xc,%esp
	return !memcmp(addr1, addr2, sizeof(struct in6_addr));
 805085e:	6a 10                	push   $0x10
 8050860:	52                   	push   %edx
 8050861:	50                   	push   %eax
 8050862:	e8 09 88 ff ff       	call   8049070 <memcmp@plt>
 8050867:	83 c4 10             	add    $0x10,%esp
}
 805086a:	c9                   	leave  
	return !memcmp(addr1, addr2, sizeof(struct in6_addr));
 805086b:	85 c0                	test   %eax,%eax
 805086d:	0f 94 c0             	sete   %al
}
 8050870:	c3                   	ret    

08050871 <k_uptime_get_32>:
{
 8050871:	55                   	push   %ebp
 8050872:	89 e5                	mov    %esp,%ebp
 8050874:	83 ec 08             	sub    $0x8,%esp
	return z_impl_k_uptime_ticks();
 8050877:	e8 98 03 01 00       	call   8060c14 <z_impl_k_uptime_ticks>
			return t * ((uint64_t)to_hz / from_hz);
 805087c:	ba 0a 00 00 00       	mov    $0xa,%edx
}
 8050881:	c9                   	leave  
 8050882:	f7 e2                	mul    %edx
 8050884:	c3                   	ret    

08050885 <k_mutex_lock.constprop.0.isra.0>:
static inline int k_mutex_lock(struct k_mutex * mutex, k_timeout_t timeout)
 8050885:	55                   	push   %ebp
 8050886:	89 e5                	mov    %esp,%ebp
 8050888:	83 ec 0c             	sub    $0xc,%esp
	return z_impl_k_mutex_lock(mutex, timeout);
 805088b:	52                   	push   %edx
 805088c:	50                   	push   %eax
 805088d:	68 c0 75 06 08       	push   $0x80675c0
 8050892:	e8 01 e9 00 00       	call   805f198 <z_impl_k_mutex_lock>
 8050897:	83 c4 10             	add    $0x10,%esp
}
 805089a:	c9                   	leave  
 805089b:	c3                   	ret    

0805089c <k_mutex_unlock.constprop.0.isra.0>:
static inline int k_mutex_unlock(struct k_mutex * mutex)
 805089c:	55                   	push   %ebp
 805089d:	89 e5                	mov    %esp,%ebp
 805089f:	83 ec 14             	sub    $0x14,%esp
	return z_impl_k_mutex_unlock(mutex);
 80508a2:	68 c0 75 06 08       	push   $0x80675c0
 80508a7:	e8 fa e9 00 00       	call   805f2a6 <z_impl_k_mutex_unlock>
 80508ac:	83 c4 10             	add    $0x10,%esp
}
 80508af:	c9                   	leave  
 80508b0:	c3                   	ret    

080508b1 <if_ipv4_get_addr>:
	return src;
}

static struct in_addr *if_ipv4_get_addr(struct net_if *iface,
					enum net_addr_state addr_state, bool ll)
{
 80508b1:	55                   	push   %ebp
 80508b2:	89 e5                	mov    %esp,%ebp
 80508b4:	57                   	push   %edi
 80508b5:	89 cf                	mov    %ecx,%edi
 80508b7:	56                   	push   %esi
 80508b8:	89 d6                	mov    %edx,%esi
 80508ba:	53                   	push   %ebx
 80508bb:	89 c3                	mov    %eax,%ebx
	struct in_addr *addr = NULL;
	struct net_if_ipv4 *ipv4;
	int i;

	k_mutex_lock(&lock, K_FOREVER);
 80508bd:	83 c8 ff             	or     $0xffffffff,%eax
 80508c0:	89 c2                	mov    %eax,%edx
{
 80508c2:	83 ec 0c             	sub    $0xc,%esp
	k_mutex_lock(&lock, K_FOREVER);
 80508c5:	e8 bb ff ff ff       	call   8050885 <k_mutex_lock.constprop.0.isra.0>

	if (!iface) {
 80508ca:	85 db                	test   %ebx,%ebx
 80508cc:	74 48                	je     8050916 <if_ipv4_get_addr+0x65>
		goto out;
	}

	ipv4 = iface->config.ip.ipv4;
 80508ce:	8b 5b 08             	mov    0x8(%ebx),%ebx
	if (!ipv4) {
 80508d1:	85 db                	test   %ebx,%ebx
 80508d3:	74 41                	je     8050916 <if_ipv4_get_addr+0x65>
		goto out;
	}

	for (i = 0; i < NET_IF_MAX_IPV4_ADDR; i++) {
		if (!ipv4->unicast[i].is_used ||
 80508d5:	f6 43 2f 02          	testb  $0x2,0x2f(%ebx)
 80508d9:	74 39                	je     8050914 <if_ipv4_get_addr+0x63>
 80508db:	89 f0                	mov    %esi,%eax
 80508dd:	3c ff                	cmp    $0xff,%al
 80508df:	74 05                	je     80508e6 <if_ipv4_get_addr+0x35>
		    (addr_state != NET_ADDR_ANY_STATE &&
 80508e1:	38 43 2d             	cmp    %al,0x2d(%ebx)
 80508e4:	75 2e                	jne    8050914 <if_ipv4_get_addr+0x63>
		     ipv4->unicast[i].addr_state != addr_state) ||
 80508e6:	66 83 3b 01          	cmpw   $0x1,(%ebx)
 80508ea:	75 28                	jne    8050914 <if_ipv4_get_addr+0x63>
		    ipv4->unicast[i].address.family != AF_INET) {
			continue;
		}

		if (net_ipv4_is_ll_addr(&ipv4->unicast[i].address.in_addr)) {
 80508ec:	83 c3 04             	add    $0x4,%ebx
 80508ef:	89 d8                	mov    %ebx,%eax
 80508f1:	e8 4f fe ff ff       	call   8050745 <net_ipv4_is_ll_addr>
 80508f6:	84 c0                	test   %al,%al
	struct in_addr *addr = NULL;
 80508f8:	89 f8                	mov    %edi,%eax
		if (net_ipv4_is_ll_addr(&ipv4->unicast[i].address.in_addr)) {
 80508fa:	74 0c                	je     8050908 <if_ipv4_get_addr+0x57>
	struct in_addr *addr = NULL;
 80508fc:	84 c0                	test   %al,%al
 80508fe:	b8 00 00 00 00       	mov    $0x0,%eax
 8050903:	0f 44 d8             	cmove  %eax,%ebx
 8050906:	eb 0e                	jmp    8050916 <if_ipv4_get_addr+0x65>
 8050908:	84 c0                	test   %al,%al
 805090a:	b8 00 00 00 00       	mov    $0x0,%eax
 805090f:	0f 45 d8             	cmovne %eax,%ebx
 8050912:	eb 02                	jmp    8050916 <if_ipv4_get_addr+0x65>
 8050914:	31 db                	xor    %ebx,%ebx
		addr = &ipv4->unicast[i].address.in_addr;
		goto out;
	}

out:
	k_mutex_unlock(&lock);
 8050916:	e8 81 ff ff ff       	call   805089c <k_mutex_unlock.constprop.0.isra.0>

	return addr;
}
 805091b:	83 c4 0c             	add    $0xc,%esp
 805091e:	89 d8                	mov    %ebx,%eax
 8050920:	5b                   	pop    %ebx
 8050921:	5e                   	pop    %esi
 8050922:	5f                   	pop    %edi
 8050923:	5d                   	pop    %ebp
 8050924:	c3                   	ret    

08050925 <iface_router_lookup>:
{
 8050925:	55                   	push   %ebp
 8050926:	89 e5                	mov    %esp,%ebp
 8050928:	57                   	push   %edi
 8050929:	89 cf                	mov    %ecx,%edi
 805092b:	56                   	push   %esi
 805092c:	53                   	push   %ebx
 805092d:	bb 48 7e 06 08       	mov    $0x8067e48,%ebx
 8050932:	83 ec 1c             	sub    $0x1c,%esp
 8050935:	89 45 e0             	mov    %eax,-0x20(%ebp)
	k_mutex_lock(&lock, K_FOREVER);
 8050938:	83 c8 ff             	or     $0xffffffff,%eax
{
 805093b:	88 55 e4             	mov    %dl,-0x1c(%ebp)
	k_mutex_lock(&lock, K_FOREVER);
 805093e:	89 c2                	mov    %eax,%edx
 8050940:	e8 40 ff ff ff       	call   8050885 <k_mutex_lock.constprop.0.isra.0>
		    routers[i].address.family != family ||
 8050945:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
	for (i = 0; i < CONFIG_NET_MAX_ROUTERS; i++) {
 8050949:	31 c9                	xor    %ecx,%ecx
		    routers[i].address.family != family ||
 805094b:	66 89 45 de          	mov    %ax,-0x22(%ebp)
		if (!routers[i].is_used ||
 805094f:	6b f1 24             	imul   $0x24,%ecx,%esi
 8050952:	f6 86 62 7e 06 08 01 	testb  $0x1,0x8067e62(%esi)
 8050959:	74 3b                	je     8050996 <iface_router_lookup+0x71>
 805095b:	66 8b 45 de          	mov    -0x22(%ebp),%ax
 805095f:	66 39 43 fc          	cmp    %ax,-0x4(%ebx)
 8050963:	75 31                	jne    8050996 <iface_router_lookup+0x71>
		    routers[i].address.family != family ||
 8050965:	8b 45 e0             	mov    -0x20(%ebp),%eax
 8050968:	39 43 10             	cmp    %eax,0x10(%ebx)
 805096b:	75 29                	jne    8050996 <iface_router_lookup+0x71>
		if ((IS_ENABLED(CONFIG_NET_IPV6) && family == AF_INET6 &&
 805096d:	80 7d e4 02          	cmpb   $0x2,-0x1c(%ebp)
 8050971:	75 15                	jne    8050988 <iface_router_lookup+0x63>
		     net_ipv6_addr_cmp(net_if_router_ipv6(&routers[i]),
 8050973:	89 fa                	mov    %edi,%edx
 8050975:	89 d8                	mov    %ebx,%eax
 8050977:	89 4d d8             	mov    %ecx,-0x28(%ebp)
 805097a:	e8 d9 fe ff ff       	call   8050858 <net_ipv6_addr_cmp>
		if ((IS_ENABLED(CONFIG_NET_IPV6) && family == AF_INET6 &&
 805097f:	8b 4d d8             	mov    -0x28(%ebp),%ecx
 8050982:	84 c0                	test   %al,%al
 8050984:	74 10                	je     8050996 <iface_router_lookup+0x71>
 8050986:	eb 06                	jmp    805098e <iface_router_lookup+0x69>
		    (IS_ENABLED(CONFIG_NET_IPV4) && family == AF_INET &&
 8050988:	8b 03                	mov    (%ebx),%eax
 805098a:	39 07                	cmp    %eax,(%edi)
 805098c:	75 08                	jne    8050996 <iface_router_lookup+0x71>
			router = &routers[i];
 805098e:	8d 86 40 7e 06 08    	lea    0x8067e40(%esi),%eax
			goto out;
 8050994:	eb 0f                	jmp    80509a5 <iface_router_lookup+0x80>
	for (i = 0; i < CONFIG_NET_MAX_ROUTERS; i++) {
 8050996:	83 c3 24             	add    $0x24,%ebx
 8050999:	49                   	dec    %ecx
 805099a:	74 07                	je     80509a3 <iface_router_lookup+0x7e>
 805099c:	b9 01 00 00 00       	mov    $0x1,%ecx
 80509a1:	eb ac                	jmp    805094f <iface_router_lookup+0x2a>
	struct net_if_router *router = NULL;
 80509a3:	31 c0                	xor    %eax,%eax
 80509a5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	k_mutex_unlock(&lock);
 80509a8:	e8 ef fe ff ff       	call   805089c <k_mutex_unlock.constprop.0.isra.0>
}
 80509ad:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 80509b0:	83 c4 1c             	add    $0x1c,%esp
 80509b3:	5b                   	pop    %ebx
 80509b4:	5e                   	pop    %esi
 80509b5:	5f                   	pop    %edi
 80509b6:	5d                   	pop    %ebp
 80509b7:	c3                   	ret    

080509b8 <iface_router_update_timer>:
{
 80509b8:	55                   	push   %ebp
 80509b9:	89 e5                	mov    %esp,%ebp
 80509bb:	56                   	push   %esi
 80509bc:	31 f6                	xor    %esi,%esi
 80509be:	53                   	push   %ebx
 80509bf:	89 c3                	mov    %eax,%ebx
	k_mutex_lock(&lock, K_FOREVER);
 80509c1:	83 c8 ff             	or     $0xffffffff,%eax
 80509c4:	89 c2                	mov    %eax,%edx
 80509c6:	e8 ba fe ff ff       	call   8050885 <k_mutex_lock.constprop.0.isra.0>
	return list->head;
 80509cb:	8b 15 e0 89 06 08    	mov    0x80689e0,%edx
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&active_router_timers,
 80509d1:	85 d2                	test   %edx,%edx
 80509d3:	74 02                	je     80509d7 <iface_router_update_timer+0x1f>
	return node->next;
 80509d5:	8b 32                	mov    (%edx),%esi
 80509d7:	83 c8 ff             	or     $0xffffffff,%eax
 80509da:	85 d2                	test   %edx,%edx
 80509dc:	74 28                	je     8050a06 <iface_router_update_timer+0x4e>
	ends += MSEC_PER_SEC * router->lifetime;
 80509de:	0f b7 4a 20          	movzwl 0x20(%edx),%ecx
	return (int32_t)(ends - now);
 80509e2:	8b 52 1c             	mov    0x1c(%edx),%edx
	ends += MSEC_PER_SEC * router->lifetime;
 80509e5:	69 c9 e8 03 00 00    	imul   $0x3e8,%ecx,%ecx
	return (int32_t)(ends - now);
 80509eb:	29 da                	sub    %ebx,%edx
 80509ed:	01 ca                	add    %ecx,%edx
		if (ends <= 0) {
 80509ef:	85 d2                	test   %edx,%edx
 80509f1:	7e 27                	jle    8050a1a <iface_router_update_timer+0x62>
		new_delay = MIN((uint32_t)ends, new_delay);
 80509f3:	39 d0                	cmp    %edx,%eax
 80509f5:	0f 47 c2             	cmova  %edx,%eax
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&active_router_timers,
 80509f8:	31 c9                	xor    %ecx,%ecx
 80509fa:	85 f6                	test   %esi,%esi
 80509fc:	74 02                	je     8050a00 <iface_router_update_timer+0x48>
 80509fe:	8b 0e                	mov    (%esi),%ecx
 8050a00:	89 f2                	mov    %esi,%edx
 8050a02:	89 ce                	mov    %ecx,%esi
 8050a04:	eb d4                	jmp    80509da <iface_router_update_timer+0x22>
	if (new_delay == UINT32_MAX) {
 8050a06:	83 f8 ff             	cmp    $0xffffffff,%eax
 8050a09:	75 11                	jne    8050a1c <iface_router_update_timer+0x64>
		k_work_cancel_delayable(&router_timer);
 8050a0b:	83 ec 0c             	sub    $0xc,%esp
 8050a0e:	68 00 7e 06 08       	push   $0x8067e00
 8050a13:	e8 e6 f2 00 00       	call   805fcfe <k_work_cancel_delayable>
 8050a18:	eb 24                	jmp    8050a3e <iface_router_update_timer+0x86>
			new_delay = 0;
 8050a1a:	31 c0                	xor    %eax,%eax
		k_work_reschedule(&router_timer, K_MSEC(new_delay));
 8050a1c:	31 d2                	xor    %edx,%edx
		t += off;
 8050a1e:	83 c0 09             	add    $0x9,%eax
			return t / ((uint64_t)from_hz / to_hz);
 8050a21:	6a 00                	push   $0x0
		t += off;
 8050a23:	83 d2 00             	adc    $0x0,%edx
			return t / ((uint64_t)from_hz / to_hz);
 8050a26:	6a 0a                	push   $0xa
 8050a28:	52                   	push   %edx
 8050a29:	50                   	push   %eax
 8050a2a:	e8 21 8b ff ff       	call   8049550 <__udivdi3>
 8050a2f:	83 c4 0c             	add    $0xc,%esp
 8050a32:	52                   	push   %edx
 8050a33:	50                   	push   %eax
 8050a34:	68 00 7e 06 08       	push   $0x8067e00
 8050a39:	e8 a2 f2 00 00       	call   805fce0 <k_work_reschedule>
 8050a3e:	83 c4 10             	add    $0x10,%esp
}
 8050a41:	8d 65 f8             	lea    -0x8(%ebp),%esp
 8050a44:	5b                   	pop    %ebx
 8050a45:	5e                   	pop    %esi
 8050a46:	5d                   	pop    %ebp
	k_mutex_unlock(&lock);
 8050a47:	e9 50 fe ff ff       	jmp    805089c <k_mutex_unlock.constprop.0.isra.0>

08050a4c <iface_router_add>:
{
 8050a4c:	55                   	push   %ebp
 8050a4d:	89 e5                	mov    %esp,%ebp
 8050a4f:	57                   	push   %edi
 8050a50:	31 ff                	xor    %edi,%edi
 8050a52:	56                   	push   %esi
 8050a53:	53                   	push   %ebx
 8050a54:	83 ec 2c             	sub    $0x2c,%esp
 8050a57:	89 45 dc             	mov    %eax,-0x24(%ebp)
 8050a5a:	8b 45 08             	mov    0x8(%ebp),%eax
 8050a5d:	89 4d e0             	mov    %ecx,-0x20(%ebp)
 8050a60:	8b 4d 0c             	mov    0xc(%ebp),%ecx
 8050a63:	89 45 d8             	mov    %eax,-0x28(%ebp)
	k_mutex_lock(&lock, K_FOREVER);
 8050a66:	83 c8 ff             	or     $0xffffffff,%eax
{
 8050a69:	89 55 e4             	mov    %edx,-0x1c(%ebp)
	k_mutex_lock(&lock, K_FOREVER);
 8050a6c:	89 c2                	mov    %eax,%edx
{
 8050a6e:	89 4d d4             	mov    %ecx,-0x2c(%ebp)
	k_mutex_lock(&lock, K_FOREVER);
 8050a71:	e8 0f fe ff ff       	call   8050885 <k_mutex_lock.constprop.0.isra.0>
		if (routers[i].is_used) {
 8050a76:	f6 05 62 7e 06 08 01 	testb  $0x1,0x8067e62
 8050a7d:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
 8050a80:	74 14                	je     8050a96 <iface_router_add+0x4a>
	struct net_if_router *router = NULL;
 8050a82:	31 db                	xor    %ebx,%ebx
	for (i = 0; i < CONFIG_NET_MAX_ROUTERS; i++) {
 8050a84:	bf 01 00 00 00       	mov    $0x1,%edi
		if (routers[i].is_used) {
 8050a89:	f6 05 86 7e 06 08 01 	testb  $0x1,0x8067e86
 8050a90:	0f 85 af 00 00 00    	jne    8050b45 <iface_router_add+0xf9>
		routers[i].is_used = true;
 8050a96:	6b f7 24             	imul   $0x24,%edi,%esi
		routers[i].iface = iface;
 8050a99:	8b 5d dc             	mov    -0x24(%ebp),%ebx
		routers[i].address.family = family;
 8050a9c:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
		routers[i].iface = iface;
 8050aa0:	8d 86 40 7e 06 08    	lea    0x8067e40(%esi),%eax
 8050aa6:	89 9e 58 7e 06 08    	mov    %ebx,0x8067e58(%esi)
		routers[i].is_used = true;
 8050aac:	80 8e 62 7e 06 08 01 	orb    $0x1,0x8067e62(%esi)
			sys_slist_append(&active_router_timers,
 8050ab3:	89 c3                	mov    %eax,%ebx
		routers[i].address.family = family;
 8050ab5:	66 89 96 44 7e 06 08 	mov    %dx,0x8067e44(%esi)
		if (lifetime) {
 8050abc:	66 85 c9             	test   %cx,%cx
 8050abf:	74 2e                	je     8050aef <iface_router_add+0xa3>
			routers[i].is_default = true;
 8050ac1:	8a 40 22             	mov    0x22(%eax),%al
			routers[i].lifetime = lifetime;
 8050ac4:	66 89 4b 20          	mov    %cx,0x20(%ebx)
			routers[i].is_default = true;
 8050ac8:	83 e0 f9             	and    $0xfffffff9,%eax
 8050acb:	83 c8 02             	or     $0x2,%eax
 8050ace:	88 43 22             	mov    %al,0x22(%ebx)
			routers[i].life_start = k_uptime_get_32();
 8050ad1:	e8 9b fd ff ff       	call   8050871 <k_uptime_get_32>
			sys_slist_append(&active_router_timers,
 8050ad6:	89 da                	mov    %ebx,%edx
			routers[i].life_start = k_uptime_get_32();
 8050ad8:	89 43 1c             	mov    %eax,0x1c(%ebx)
			sys_slist_append(&active_router_timers,
 8050adb:	b8 e0 89 06 08       	mov    $0x80689e0,%eax
 8050ae0:	e8 e1 fb ff ff       	call   80506c6 <sys_slist_append>
			iface_router_update_timer(routers[i].life_start);
 8050ae5:	8b 43 1c             	mov    0x1c(%ebx),%eax
 8050ae8:	e8 cb fe ff ff       	call   80509b8 <iface_router_update_timer>
 8050aed:	eb 12                	jmp    8050b01 <iface_router_add+0xb5>
			routers[i].lifetime = 0;
 8050aef:	66 c7 40 20 00 00    	movw   $0x0,0x20(%eax)
			routers[i].is_default = false;
 8050af5:	8a 40 22             	mov    0x22(%eax),%al
 8050af8:	83 e0 f9             	and    $0xfffffff9,%eax
 8050afb:	83 c8 04             	or     $0x4,%eax
 8050afe:	88 43 22             	mov    %al,0x22(%ebx)
		if (IS_ENABLED(CONFIG_NET_IPV6) && family == AF_INET6) {
 8050b01:	80 7d e4 02          	cmpb   $0x2,-0x1c(%ebp)
 * @return pointer to the IPv6 address, or NULL if none
 */
#if defined(CONFIG_NET_NATIVE_IPV6)
static inline struct in6_addr *net_if_router_ipv6(struct net_if_router *router)
{
	return &router->address.in6_addr;
 8050b05:	8d 56 08             	lea    0x8(%esi),%edx
 8050b08:	8d 86 48 7e 06 08    	lea    0x8067e48(%esi),%eax
 8050b0e:	75 0e                	jne    8050b1e <iface_router_add+0xd2>
 8050b10:	8b 75 e0             	mov    -0x20(%ebp),%esi
 8050b13:	b9 04 00 00 00       	mov    $0x4,%ecx
 8050b18:	89 c7                	mov    %eax,%edi
 8050b1a:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
			NET_DBG("interface %p router %s lifetime %u default %d "
 8050b1c:	eb 27                	jmp    8050b45 <iface_router_add+0xf9>
 8050b1e:	8b 45 e0             	mov    -0x20(%ebp),%eax
			routers[i].is_default = is_default;
 8050b21:	8a 4d d8             	mov    -0x28(%ebp),%cl
 8050b24:	8b 00                	mov    (%eax),%eax
 8050b26:	83 e1 01             	and    $0x1,%ecx
 8050b29:	01 c9                	add    %ecx,%ecx
 8050b2b:	89 82 40 7e 06 08    	mov    %eax,0x8067e40(%edx)
 8050b31:	6b d7 24             	imul   $0x24,%edi,%edx
 8050b34:	8a 82 62 7e 06 08    	mov    0x8067e62(%edx),%al
 8050b3a:	83 e0 fd             	and    $0xfffffffd,%eax
 8050b3d:	09 c8                	or     %ecx,%eax
 8050b3f:	88 82 62 7e 06 08    	mov    %al,0x8067e62(%edx)
	k_mutex_unlock(&lock);
 8050b45:	e8 52 fd ff ff       	call   805089c <k_mutex_unlock.constprop.0.isra.0>
}
 8050b4a:	83 c4 2c             	add    $0x2c,%esp
 8050b4d:	89 d8                	mov    %ebx,%eax
 8050b4f:	5b                   	pop    %ebx
 8050b50:	5e                   	pop    %esi
 8050b51:	5f                   	pop    %edi
 8050b52:	5d                   	pop    %ebp
 8050b53:	c3                   	ret    

08050b54 <iface_router_rm>:
{
 8050b54:	55                   	push   %ebp
 8050b55:	89 e5                	mov    %esp,%ebp
 8050b57:	53                   	push   %ebx
 8050b58:	89 c3                	mov    %eax,%ebx
	k_mutex_lock(&lock, K_FOREVER);
 8050b5a:	83 c8 ff             	or     $0xffffffff,%eax
 8050b5d:	89 c2                	mov    %eax,%edx
{
 8050b5f:	83 ec 14             	sub    $0x14,%esp
	k_mutex_lock(&lock, K_FOREVER);
 8050b62:	e8 1e fd ff ff       	call   8050885 <k_mutex_lock.constprop.0.isra.0>
	bool ret = false;
 8050b67:	31 c0                	xor    %eax,%eax
	if (!router->is_used) {
 8050b69:	f6 43 22 01          	testb  $0x1,0x22(%ebx)
 8050b6d:	74 20                	je     8050b8f <iface_router_rm+0x3b>
	if (sys_slist_find_and_remove(&active_router_timers, &router->node)) {
 8050b6f:	89 da                	mov    %ebx,%edx
 8050b71:	b8 e0 89 06 08       	mov    $0x80689e0,%eax
 8050b76:	e8 64 fb ff ff       	call   80506df <sys_slist_find_and_remove>
 8050b7b:	84 c0                	test   %al,%al
 8050b7d:	74 0a                	je     8050b89 <iface_router_rm+0x35>
		iface_router_update_timer(k_uptime_get_32());
 8050b7f:	e8 ed fc ff ff       	call   8050871 <k_uptime_get_32>
 8050b84:	e8 2f fe ff ff       	call   80509b8 <iface_router_update_timer>
	router->is_used = false;
 8050b89:	80 63 22 fe          	andb   $0xfe,0x22(%ebx)
	ret = true;
 8050b8d:	b0 01                	mov    $0x1,%al
 8050b8f:	88 45 f7             	mov    %al,-0x9(%ebp)
	k_mutex_unlock(&lock);
 8050b92:	e8 05 fd ff ff       	call   805089c <k_mutex_unlock.constprop.0.isra.0>
}
 8050b97:	8a 45 f7             	mov    -0x9(%ebp),%al
 8050b9a:	83 c4 14             	add    $0x14,%esp
 8050b9d:	5b                   	pop    %ebx
 8050b9e:	5d                   	pop    %ebp
 8050b9f:	c3                   	ret    

08050ba0 <address_lifetime_timeout>:
{
 8050ba0:	55                   	push   %ebp
 8050ba1:	89 e5                	mov    %esp,%ebp
 8050ba3:	57                   	push   %edi
 8050ba4:	56                   	push   %esi
 8050ba5:	53                   	push   %ebx
 8050ba6:	83 ec 1c             	sub    $0x1c,%esp
	uint32_t current_time = k_uptime_get_32();
 8050ba9:	e8 c3 fc ff ff       	call   8050871 <k_uptime_get_32>
 8050bae:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	k_mutex_lock(&lock, K_FOREVER);
 8050bb1:	83 c8 ff             	or     $0xffffffff,%eax
 8050bb4:	89 c2                	mov    %eax,%edx
 8050bb6:	e8 ca fc ff ff       	call   8050885 <k_mutex_lock.constprop.0.isra.0>
	return list->head;
 8050bbb:	8b 1d d8 89 06 08    	mov    0x80689d8,%ebx
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&active_address_lifetime_timers,
 8050bc1:	31 d2                	xor    %edx,%edx
 8050bc3:	85 db                	test   %ebx,%ebx
 8050bc5:	74 0c                	je     8050bd3 <address_lifetime_timeout+0x33>
 8050bc7:	8d 53 ec             	lea    -0x14(%ebx),%edx
	return node->next;
 8050bca:	8b 1b                	mov    (%ebx),%ebx
 8050bcc:	85 db                	test   %ebx,%ebx
 8050bce:	74 03                	je     8050bd3 <address_lifetime_timeout+0x33>
 8050bd0:	83 eb 14             	sub    $0x14,%ebx
 8050bd3:	83 ce ff             	or     $0xffffffff,%esi
 8050bd6:	85 d2                	test   %edx,%edx
 8050bd8:	74 5a                	je     8050c34 <address_lifetime_timeout+0x94>
		struct net_timeout *timeout = &current->lifetime;
 8050bda:	8d 7a 14             	lea    0x14(%edx),%edi
 8050bdd:	89 55 e0             	mov    %edx,-0x20(%ebp)
		uint32_t this_update = net_timeout_evaluate(timeout,
 8050be0:	52                   	push   %edx
 8050be1:	52                   	push   %edx
 8050be2:	ff 75 e4             	push   -0x1c(%ebp)
 8050be5:	57                   	push   %edi
 8050be6:	e8 af 21 00 00       	call   8052d9a <net_timeout_evaluate>
 8050beb:	83 c4 10             	add    $0x10,%esp
		if (this_update == 0U) {
 8050bee:	8b 55 e0             	mov    -0x20(%ebp),%edx
 8050bf1:	85 c0                	test   %eax,%eax
 8050bf3:	75 20                	jne    8050c15 <address_lifetime_timeout+0x75>
	ifaddr->addr_state = NET_ADDR_DEPRECATED;
 8050bf5:	c6 42 2d 02          	movb   $0x2,0x2d(%edx)
	sys_slist_find_and_remove(&active_address_lifetime_timers,
 8050bf9:	b8 d8 89 06 08       	mov    $0x80689d8,%eax
 8050bfe:	89 fa                	mov    %edi,%edx
 8050c00:	e8 da fa ff ff       	call   80506df <sys_slist_find_and_remove>
	net_timeout_set(&ifaddr->lifetime, 0, 0);
 8050c05:	50                   	push   %eax
 8050c06:	6a 00                	push   $0x0
 8050c08:	6a 00                	push   $0x0
 8050c0a:	57                   	push   %edi
 8050c0b:	e8 da 20 00 00       	call   8052cea <net_timeout_set>
 8050c10:	83 c4 10             	add    $0x10,%esp
			continue;
 8050c13:	eb 09                	jmp    8050c1e <address_lifetime_timeout+0x7e>
		if (this_update < next_update) {
 8050c15:	39 c6                	cmp    %eax,%esi
 8050c17:	0f 47 f0             	cmova  %eax,%esi
		if (current == next) {
 8050c1a:	39 da                	cmp    %ebx,%edx
 8050c1c:	74 16                	je     8050c34 <address_lifetime_timeout+0x94>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&active_address_lifetime_timers,
 8050c1e:	31 c0                	xor    %eax,%eax
 8050c20:	85 db                	test   %ebx,%ebx
 8050c22:	74 0a                	je     8050c2e <address_lifetime_timeout+0x8e>
 8050c24:	8b 43 14             	mov    0x14(%ebx),%eax
 8050c27:	85 c0                	test   %eax,%eax
 8050c29:	74 03                	je     8050c2e <address_lifetime_timeout+0x8e>
 8050c2b:	83 e8 14             	sub    $0x14,%eax
 8050c2e:	89 da                	mov    %ebx,%edx
 8050c30:	89 c3                	mov    %eax,%ebx
 8050c32:	eb a2                	jmp    8050bd6 <address_lifetime_timeout+0x36>
	if (next_update != UINT32_MAX) {
 8050c34:	83 fe ff             	cmp    $0xffffffff,%esi
 8050c37:	74 27                	je     8050c60 <address_lifetime_timeout+0xc0>
		k_work_reschedule(&address_lifetime_timer, K_MSEC(next_update));
 8050c39:	89 f0                	mov    %esi,%eax
 8050c3b:	31 d2                	xor    %edx,%edx
 8050c3d:	6a 00                	push   $0x0
		t += off;
 8050c3f:	83 c0 09             	add    $0x9,%eax
			return t / ((uint64_t)from_hz / to_hz);
 8050c42:	6a 0a                	push   $0xa
		t += off;
 8050c44:	83 d2 00             	adc    $0x0,%edx
			return t / ((uint64_t)from_hz / to_hz);
 8050c47:	52                   	push   %edx
 8050c48:	50                   	push   %eax
 8050c49:	e8 02 89 ff ff       	call   8049550 <__udivdi3>
 8050c4e:	83 c4 0c             	add    $0xc,%esp
 8050c51:	52                   	push   %edx
 8050c52:	50                   	push   %eax
 8050c53:	68 c0 7d 06 08       	push   $0x8067dc0
 8050c58:	e8 83 f0 00 00       	call   805fce0 <k_work_reschedule>
 8050c5d:	83 c4 10             	add    $0x10,%esp
}
 8050c60:	8d 65 f4             	lea    -0xc(%ebp),%esp
 8050c63:	5b                   	pop    %ebx
 8050c64:	5e                   	pop    %esi
 8050c65:	5f                   	pop    %edi
 8050c66:	5d                   	pop    %ebp
	k_mutex_unlock(&lock);
 8050c67:	e9 30 fc ff ff       	jmp    805089c <k_mutex_unlock.constprop.0.isra.0>

08050c6c <iface_router_find_default.constprop.0>:
static struct net_if_router *iface_router_find_default(struct net_if *iface,
 8050c6c:	55                   	push   %ebp
 8050c6d:	89 e5                	mov    %esp,%ebp
 8050c6f:	53                   	push   %ebx
 8050c70:	89 c3                	mov    %eax,%ebx
	k_mutex_lock(&lock, K_FOREVER);
 8050c72:	83 c8 ff             	or     $0xffffffff,%eax
static struct net_if_router *iface_router_find_default(struct net_if *iface,
 8050c75:	83 ec 14             	sub    $0x14,%esp
 8050c78:	89 55 f4             	mov    %edx,-0xc(%ebp)
	k_mutex_lock(&lock, K_FOREVER);
 8050c7b:	89 c2                	mov    %eax,%edx
 8050c7d:	e8 03 fc ff ff       	call   8050885 <k_mutex_lock.constprop.0.isra.0>
		if (!routers[i].is_used ||
 8050c82:	a0 62 7e 06 08       	mov    0x8067e62,%al
 8050c87:	8b 4d f4             	mov    -0xc(%ebp),%ecx
 8050c8a:	a8 01                	test   $0x1,%al
 8050c8c:	74 1c                	je     8050caa <iface_router_find_default.constprop.0+0x3e>
 8050c8e:	a8 02                	test   $0x2,%al
 8050c90:	74 18                	je     8050caa <iface_router_find_default.constprop.0+0x3e>
		    routers[i].address.family != family) {
 8050c92:	0f b6 c1             	movzbl %cl,%eax
		    !routers[i].is_default ||
 8050c95:	66 39 05 44 7e 06 08 	cmp    %ax,0x8067e44
 8050c9c:	75 0c                	jne    8050caa <iface_router_find_default.constprop.0+0x3e>
		if (iface && iface != routers[i].iface) {
 8050c9e:	85 db                	test   %ebx,%ebx
 8050ca0:	74 2c                	je     8050cce <iface_router_find_default.constprop.0+0x62>
 8050ca2:	3b 1d 58 7e 06 08    	cmp    0x8067e58,%ebx
 8050ca8:	74 24                	je     8050cce <iface_router_find_default.constprop.0+0x62>
		if (!routers[i].is_used ||
 8050caa:	8a 15 86 7e 06 08    	mov    0x8067e86,%dl
	struct net_if_router *router = NULL;
 8050cb0:	31 c0                	xor    %eax,%eax
		if (!routers[i].is_used ||
 8050cb2:	f6 c2 01             	test   $0x1,%dl
 8050cb5:	74 32                	je     8050ce9 <iface_router_find_default.constprop.0+0x7d>
 8050cb7:	80 e2 02             	and    $0x2,%dl
 8050cba:	74 2d                	je     8050ce9 <iface_router_find_default.constprop.0+0x7d>
		    routers[i].address.family != family) {
 8050cbc:	0f b6 c9             	movzbl %cl,%ecx
		    !routers[i].is_default ||
 8050cbf:	66 39 0d 68 7e 06 08 	cmp    %cx,0x8067e68
 8050cc6:	75 21                	jne    8050ce9 <iface_router_find_default.constprop.0+0x7d>
		if (iface && iface != routers[i].iface) {
 8050cc8:	85 db                	test   %ebx,%ebx
 8050cca:	75 0e                	jne    8050cda <iface_router_find_default.constprop.0+0x6e>
 8050ccc:	eb 14                	jmp    8050ce2 <iface_router_find_default.constprop.0+0x76>
	for (i = 0; i < CONFIG_NET_MAX_ROUTERS; i++) {
 8050cce:	31 c0                	xor    %eax,%eax
		router = &routers[i];
 8050cd0:	6b c0 24             	imul   $0x24,%eax,%eax
 8050cd3:	05 40 7e 06 08       	add    $0x8067e40,%eax
		goto out;
 8050cd8:	eb 0f                	jmp    8050ce9 <iface_router_find_default.constprop.0+0x7d>
		if (iface && iface != routers[i].iface) {
 8050cda:	3b 1d 7c 7e 06 08    	cmp    0x8067e7c,%ebx
 8050ce0:	75 07                	jne    8050ce9 <iface_router_find_default.constprop.0+0x7d>
	for (i = 0; i < CONFIG_NET_MAX_ROUTERS; i++) {
 8050ce2:	b8 01 00 00 00       	mov    $0x1,%eax
 8050ce7:	eb e7                	jmp    8050cd0 <iface_router_find_default.constprop.0+0x64>
 8050ce9:	89 45 f4             	mov    %eax,-0xc(%ebp)
	k_mutex_unlock(&lock);
 8050cec:	e8 ab fb ff ff       	call   805089c <k_mutex_unlock.constprop.0.isra.0>
}
 8050cf1:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8050cf4:	83 c4 14             	add    $0x14,%esp
 8050cf7:	5b                   	pop    %ebx
 8050cf8:	5d                   	pop    %ebp
 8050cf9:	c3                   	ret    

08050cfa <net_if_flag_is_set>:
{
 8050cfa:	89 d1                	mov    %edx,%ecx
	if (iface == NULL) {
 8050cfc:	85 c0                	test   %eax,%eax
 8050cfe:	74 0b                	je     8050d0b <net_if_flag_is_set+0x11>
 8050d00:	8b 00                	mov    (%eax),%eax
 8050d02:	8b 40 0c             	mov    0xc(%eax),%eax
 8050d05:	d3 f8                	sar    %cl,%eax
 8050d07:	83 e0 01             	and    $0x1,%eax
 8050d0a:	c3                   	ret    
		return false;
 8050d0b:	31 c0                	xor    %eax,%eax
}
 8050d0d:	c3                   	ret    

08050d0e <net_if_ipv6_start_dad>:
{
 8050d0e:	55                   	push   %ebp
 8050d0f:	89 e5                	mov    %esp,%ebp
 8050d11:	56                   	push   %esi
 8050d12:	89 c6                	mov    %eax,%esi
 8050d14:	53                   	push   %ebx
 8050d15:	89 d3                	mov    %edx,%ebx
	ifaddr->addr_state = NET_ADDR_TENTATIVE;
 8050d17:	c6 42 2d 00          	movb   $0x0,0x2d(%edx)
 */
static inline bool net_if_is_up(struct net_if *iface)
{
	NET_ASSERT(iface);

	return net_if_flag_is_set(iface, NET_IF_UP) &&
 8050d1b:	31 d2                	xor    %edx,%edx
 8050d1d:	e8 d8 ff ff ff       	call   8050cfa <net_if_flag_is_set>
 8050d22:	84 c0                	test   %al,%al
 8050d24:	74 5f                	je     8050d85 <net_if_ipv6_start_dad+0x77>
	       net_if_flag_is_set(iface, NET_IF_RUNNING);
 8050d26:	ba 08 00 00 00       	mov    $0x8,%edx
 8050d2b:	89 f0                	mov    %esi,%eax
 8050d2d:	e8 c8 ff ff ff       	call   8050cfa <net_if_flag_is_set>
	if (net_if_is_up(iface)) {
 8050d32:	84 c0                	test   %al,%al
 8050d34:	74 4f                	je     8050d85 <net_if_ipv6_start_dad+0x77>
		ifaddr->dad_count = 1U;
 8050d36:	c6 43 2e 01          	movb   $0x1,0x2e(%ebx)
		if (!net_ipv6_start_dad(iface, ifaddr)) {
 8050d3a:	52                   	push   %edx
 8050d3b:	52                   	push   %edx
 8050d3c:	53                   	push   %ebx
 8050d3d:	56                   	push   %esi
 8050d3e:	e8 2f 86 00 00       	call   8059372 <net_ipv6_start_dad>
 8050d43:	83 c4 10             	add    $0x10,%esp
 8050d46:	85 c0                	test   %eax,%eax
 8050d48:	75 3b                	jne    8050d85 <net_if_ipv6_start_dad+0x77>
			ifaddr->dad_start = k_uptime_get_32();
 8050d4a:	e8 22 fb ff ff       	call   8050871 <k_uptime_get_32>
			sys_slist_append(&active_dad_timers, &ifaddr->dad_node);
 8050d4f:	8d 53 24             	lea    0x24(%ebx),%edx
			ifaddr->dad_start = k_uptime_get_32();
 8050d52:	89 43 28             	mov    %eax,0x28(%ebx)
			sys_slist_append(&active_dad_timers, &ifaddr->dad_node);
 8050d55:	b8 c8 89 06 08       	mov    $0x80689c8,%eax
 8050d5a:	e8 67 f9 ff ff       	call   80506c6 <sys_slist_append>
	return z_timeout_remaining(&dwork->timeout);
 8050d5f:	83 ec 0c             	sub    $0xc,%esp
 8050d62:	68 50 7d 06 08       	push   $0x8067d50
 8050d67:	e8 2d fd 00 00       	call   8060a99 <z_timeout_remaining>
 8050d6c:	83 c4 10             	add    $0x10,%esp
			if (!k_work_delayable_remaining_get(&dad_timer)) {
 8050d6f:	09 c2                	or     %eax,%edx
 8050d71:	75 12                	jne    8050d85 <net_if_ipv6_start_dad+0x77>
				k_work_reschedule(&dad_timer,
 8050d73:	50                   	push   %eax
 8050d74:	6a 00                	push   $0x0
 8050d76:	6a 0a                	push   $0xa
 8050d78:	68 40 7d 06 08       	push   $0x8067d40
 8050d7d:	e8 5e ef 00 00       	call   805fce0 <k_work_reschedule>
 8050d82:	83 c4 10             	add    $0x10,%esp
}
 8050d85:	8d 65 f8             	lea    -0x8(%ebp),%esp
 8050d88:	5b                   	pop    %ebx
 8050d89:	5e                   	pop    %esi
 8050d8a:	5d                   	pop    %ebp
 8050d8b:	c3                   	ret    

08050d8c <ipv4_maddr_find.isra.0>:
						 const struct in_addr *addr)
{
	struct net_if_ipv4 *ipv4 = iface->config.ip.ipv4;
	int i;

	if (!ipv4) {
 8050d8c:	85 c0                	test   %eax,%eax
 8050d8e:	74 2d                	je     8050dbd <ipv4_maddr_find.isra.0+0x31>
static struct net_if_mcast_addr *ipv4_maddr_find(struct net_if *iface,
 8050d90:	55                   	push   %ebp
 8050d91:	89 e5                	mov    %esp,%ebp
 8050d93:	53                   	push   %ebx
		return NULL;
	}

	for (i = 0; i < NET_IF_MAX_IPV4_MADDR; i++) {
		if ((is_used && !ipv4->mcast[i].is_used) ||
 8050d94:	8a 58 44             	mov    0x44(%eax),%bl
 8050d97:	83 e3 01             	and    $0x1,%ebx
 8050d9a:	84 d2                	test   %dl,%dl
 8050d9c:	74 06                	je     8050da4 <ipv4_maddr_find.isra.0+0x18>
 8050d9e:	84 db                	test   %bl,%bl
 8050da0:	75 06                	jne    8050da8 <ipv4_maddr_find.isra.0+0x1c>
 8050da2:	eb 14                	jmp    8050db8 <ipv4_maddr_find.isra.0+0x2c>
		    (!is_used && ipv4->mcast[i].is_used)) {
 8050da4:	84 db                	test   %bl,%bl
 8050da6:	75 10                	jne    8050db8 <ipv4_maddr_find.isra.0+0x2c>
			continue;
		}

		if (addr) {
 8050da8:	85 c9                	test   %ecx,%ecx
 8050daa:	74 07                	je     8050db3 <ipv4_maddr_find.isra.0+0x27>
			if (!net_ipv4_addr_cmp(&ipv4->mcast[i].address.in_addr,
 8050dac:	8b 11                	mov    (%ecx),%edx
 8050dae:	39 50 34             	cmp    %edx,0x34(%eax)
 8050db1:	75 05                	jne    8050db8 <ipv4_maddr_find.isra.0+0x2c>
					       addr)) {
				continue;
			}
		}

		return &ipv4->mcast[i];
 8050db3:	83 c0 30             	add    $0x30,%eax
 8050db6:	eb 02                	jmp    8050dba <ipv4_maddr_find.isra.0+0x2e>
		return NULL;
 8050db8:	31 c0                	xor    %eax,%eax
	}

	return NULL;
}
 8050dba:	5b                   	pop    %ebx
 8050dbb:	5d                   	pop    %ebp
 8050dbc:	c3                   	ret    
 8050dbd:	c3                   	ret    

08050dbe <net_if_ipv4_get_best_match.isra.0>:
static struct in_addr *net_if_ipv4_get_best_match(struct net_if *iface,
 8050dbe:	55                   	push   %ebp
 8050dbf:	89 e5                	mov    %esp,%ebp
 8050dc1:	57                   	push   %edi
 8050dc2:	56                   	push   %esi
 8050dc3:	53                   	push   %ebx
 8050dc4:	89 c3                	mov    %eax,%ebx
 8050dc6:	83 ec 0c             	sub    $0xc,%esp
	if (!ipv4) {
 8050dc9:	85 c0                	test   %eax,%eax
 8050dcb:	74 3f                	je     8050e0c <net_if_ipv4_get_best_match.isra.0+0x4e>
	if (addr->is_used && addr->addr_state == NET_ADDR_PREFERRED &&
 8050dcd:	8b 40 2c             	mov    0x2c(%eax),%eax
 8050dd0:	25 00 ff 00 02       	and    $0x200ff00,%eax
 8050dd5:	3d 00 01 00 02       	cmp    $0x2000100,%eax
 8050dda:	75 2e                	jne    8050e0a <net_if_ipv4_get_best_match.isra.0+0x4c>
 8050ddc:	66 83 3b 01          	cmpw   $0x1,(%ebx)
 8050de0:	75 28                	jne    8050e0a <net_if_ipv4_get_best_match.isra.0+0x4c>
	    !net_ipv4_is_ll_addr(&addr->address.in_addr)) {
 8050de2:	83 c3 04             	add    $0x4,%ebx
 8050de5:	89 d8                	mov    %ebx,%eax
 8050de7:	e8 59 f9 ff ff       	call   8050745 <net_ipv4_is_ll_addr>
	    addr->address.family == AF_INET &&
 8050dec:	84 c0                	test   %al,%al
 8050dee:	75 1a                	jne    8050e0a <net_if_ipv4_get_best_match.isra.0+0x4c>
 8050df0:	89 d7                	mov    %edx,%edi
 8050df2:	89 ce                	mov    %ecx,%esi
	return get_ipaddr_diff((const uint8_t *)src, (const uint8_t *)dst, 4);
 8050df4:	89 da                	mov    %ebx,%edx
 8050df6:	b9 04 00 00 00       	mov    $0x4,%ecx
 8050dfb:	89 f8                	mov    %edi,%eax
 8050dfd:	e8 a1 f9 ff ff       	call   80507a3 <get_ipaddr_diff>
		if (len >= *best_so_far) {
 8050e02:	38 06                	cmp    %al,(%esi)
 8050e04:	77 04                	ja     8050e0a <net_if_ipv4_get_best_match.isra.0+0x4c>
			*best_so_far = len;
 8050e06:	88 06                	mov    %al,(%esi)
	for (i = 0; i < NET_IF_MAX_IPV4_ADDR; i++) {
 8050e08:	eb 02                	jmp    8050e0c <net_if_ipv4_get_best_match.isra.0+0x4e>
		return NULL;
 8050e0a:	31 db                	xor    %ebx,%ebx
}
 8050e0c:	83 c4 0c             	add    $0xc,%esp
 8050e0f:	89 d8                	mov    %ebx,%eax
 8050e11:	5b                   	pop    %ebx
 8050e12:	5e                   	pop    %esi
 8050e13:	5f                   	pop    %edi
 8050e14:	5d                   	pop    %ebp
 8050e15:	c3                   	ret    

08050e16 <net_if_ipv6_get_best_match.isra.0>:
static struct in6_addr *net_if_ipv6_get_best_match(struct net_if *iface,
 8050e16:	55                   	push   %ebp
 8050e17:	89 e5                	mov    %esp,%ebp
 8050e19:	57                   	push   %edi
 8050e1a:	56                   	push   %esi
 8050e1b:	53                   	push   %ebx
 8050e1c:	83 ec 10             	sub    $0x10,%esp
 8050e1f:	89 4d e8             	mov    %ecx,-0x18(%ebp)
	if (!ipv6) {
 8050e22:	85 c0                	test   %eax,%eax
 8050e24:	0f 84 80 00 00 00    	je     8050eaa <net_if_ipv6_get_best_match.isra.0+0x94>
	struct in6_addr *src = NULL;
 8050e2a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
 8050e31:	89 d6                	mov    %edx,%esi
 8050e33:	89 c3                	mov    %eax,%ebx
 8050e35:	8d 50 04             	lea    0x4(%eax),%edx
	for (i = 0; i < NET_IF_MAX_IPV6_ADDR; i++) {
 8050e38:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	if (addr->is_used && addr->addr_state == NET_ADDR_PREFERRED &&
 8050e3f:	6b 7d f0 30          	imul   $0x30,-0x10(%ebp),%edi
 8050e43:	01 df                	add    %ebx,%edi
 8050e45:	8b 47 2c             	mov    0x2c(%edi),%eax
 8050e48:	25 00 ff 00 02       	and    $0x200ff00,%eax
 8050e4d:	3d 00 01 00 02       	cmp    $0x2000100,%eax
 8050e52:	75 44                	jne    8050e98 <net_if_ipv6_get_best_match.isra.0+0x82>
 8050e54:	66 83 7a fc 02       	cmpw   $0x2,-0x4(%edx)
 8050e59:	75 3d                	jne    8050e98 <net_if_ipv6_get_best_match.isra.0+0x82>
	    addr->address.family == AF_INET6 &&
 8050e5b:	66 81 3a fe 80       	cmpw   $0x80fe,(%edx)
 8050e60:	74 36                	je     8050e98 <net_if_ipv6_get_best_match.isra.0+0x82>
	return get_ipaddr_diff((const uint8_t *)src, (const uint8_t *)dst, 16);
 8050e62:	b9 10 00 00 00       	mov    $0x10,%ecx
 8050e67:	89 f0                	mov    %esi,%eax
 8050e69:	89 55 e4             	mov    %edx,-0x1c(%ebp)
 8050e6c:	e8 32 f9 ff ff       	call   80507a3 <get_ipaddr_diff>
		if (len >= *best_so_far) {
 8050e71:	8b 4d e8             	mov    -0x18(%ebp),%ecx
 8050e74:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 8050e77:	38 01                	cmp    %al,(%ecx)
 8050e79:	77 1d                	ja     8050e98 <net_if_ipv6_get_best_match.isra.0+0x82>
			if (ipv6->unicast[i].is_mesh_local && len < 64 &&
 8050e7b:	f6 47 2f 04          	testb  $0x4,0x2f(%edi)
 8050e7f:	74 0f                	je     8050e90 <net_if_ipv6_get_best_match.isra.0+0x7a>
 8050e81:	3c 3f                	cmp    $0x3f,%al
 8050e83:	77 0b                	ja     8050e90 <net_if_ipv6_get_best_match.isra.0+0x7a>
	return (addr->s6_addr[0] == 0xff) && (addr->s6_addr[1] == scope);
 8050e85:	80 3e ff             	cmpb   $0xff,(%esi)
 8050e88:	75 0e                	jne    8050e98 <net_if_ipv6_get_best_match.isra.0+0x82>
 8050e8a:	80 7e 01 03          	cmpb   $0x3,0x1(%esi)
 8050e8e:	75 08                	jne    8050e98 <net_if_ipv6_get_best_match.isra.0+0x82>
			*best_so_far = len;
 8050e90:	8b 7d e8             	mov    -0x18(%ebp),%edi
 8050e93:	89 55 ec             	mov    %edx,-0x14(%ebp)
 8050e96:	88 07                	mov    %al,(%edi)
	for (i = 0; i < NET_IF_MAX_IPV6_ADDR; i++) {
 8050e98:	83 c2 30             	add    $0x30,%edx
 8050e9b:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
 8050e9f:	74 10                	je     8050eb1 <net_if_ipv6_get_best_match.isra.0+0x9b>
 8050ea1:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
 8050ea8:	eb 95                	jmp    8050e3f <net_if_ipv6_get_best_match.isra.0+0x29>
		return NULL;
 8050eaa:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
}
 8050eb1:	8b 45 ec             	mov    -0x14(%ebp),%eax
 8050eb4:	83 c4 10             	add    $0x10,%esp
 8050eb7:	5b                   	pop    %ebx
 8050eb8:	5e                   	pop    %esi
 8050eb9:	5f                   	pop    %edi
 8050eba:	5d                   	pop    %ebp
 8050ebb:	c3                   	ret    

08050ebc <need_calc_checksum>:

	k_mutex_unlock(&lock);
}

static bool need_calc_checksum(struct net_if *iface, enum ethernet_hw_caps caps)
{
 8050ebc:	55                   	push   %ebp
 8050ebd:	89 e5                	mov    %esp,%ebp
 8050ebf:	53                   	push   %ebx
 8050ec0:	51                   	push   %ecx
 8050ec1:	89 c1                	mov    %eax,%ecx
#if defined(CONFIG_NET_L2_ETHERNET)
	if (net_if_l2(iface) != &NET_L2_GET_NAME(ETHERNET)) {
 8050ec3:	e8 86 f8 ff ff       	call   805074e <net_if_l2>
 8050ec8:	3d d8 76 06 08       	cmp    $0x80676d8,%eax
 8050ecd:	75 22                	jne    8050ef1 <need_calc_checksum+0x35>
	return iface->if_dev->dev;
 8050ecf:	8b 01                	mov    (%ecx),%eax
 8050ed1:	89 d3                	mov    %edx,%ebx
 8050ed3:	8b 08                	mov    (%eax),%ecx
	if (!eth->get_capabilities) {
 8050ed5:	8b 41 08             	mov    0x8(%ecx),%eax
 8050ed8:	8b 50 0c             	mov    0xc(%eax),%edx
		return (enum ethernet_hw_caps)0;
 8050edb:	31 c0                	xor    %eax,%eax
	if (!eth->get_capabilities) {
 8050edd:	85 d2                	test   %edx,%edx
 8050edf:	74 09                	je     8050eea <need_calc_checksum+0x2e>
	return eth->get_capabilities(net_if_get_device(iface));
 8050ee1:	83 ec 0c             	sub    $0xc,%esp
 8050ee4:	51                   	push   %ecx
 8050ee5:	ff d2                	call   *%edx
 8050ee7:	83 c4 10             	add    $0x10,%esp
		return true;
	}

	return !(net_eth_get_hw_capabilities(iface) & caps);
 8050eea:	85 c3                	test   %eax,%ebx
 8050eec:	0f 94 c0             	sete   %al
 8050eef:	eb 02                	jmp    8050ef3 <need_calc_checksum+0x37>
		return true;
 8050ef1:	b0 01                	mov    $0x1,%al
	ARG_UNUSED(iface);
	ARG_UNUSED(caps);

	return true;
#endif
}
 8050ef3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 8050ef6:	c9                   	leave  
 8050ef7:	c3                   	ret    

08050ef8 <net_if_flag_clear.isra.0>:
static inline void net_if_flag_clear(struct net_if *iface,
 8050ef8:	55                   	push   %ebp
 */
static inline void atomic_clear_bit(atomic_t *target, int bit)
{
	atomic_val_t mask = ATOMIC_MASK(bit);

	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
 8050ef9:	89 d1                	mov    %edx,%ecx
 8050efb:	89 e5                	mov    %esp,%ebp
 8050efd:	53                   	push   %ebx
	atomic_val_t mask = ATOMIC_MASK(bit);
 8050efe:	bb fe ff ff ff       	mov    $0xfffffffe,%ebx
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
 8050f03:	d3 c3                	rol    %cl,%ebx
 *
 * @return Previous value of @a target.
 */
static inline atomic_val_t atomic_and(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
 8050f05:	f0 21 58 0c          	lock and %ebx,0xc(%eax)
}
 8050f09:	5b                   	pop    %ebx
 8050f0a:	5d                   	pop    %ebp
 8050f0b:	c3                   	ret    

08050f0c <net_if_flag_set.isra.0>:
static inline void net_if_flag_set(struct net_if *iface,
 8050f0c:	55                   	push   %ebp
 * @param target Address of atomic variable or array.
 * @param bit Bit number (starting from 0).
 */
static inline void atomic_set_bit(atomic_t *target, int bit)
{
	atomic_val_t mask = ATOMIC_MASK(bit);
 8050f0d:	89 d1                	mov    %edx,%ecx
 8050f0f:	89 e5                	mov    %esp,%ebp
 8050f11:	53                   	push   %ebx
 8050f12:	bb 01 00 00 00       	mov    $0x1,%ebx
 8050f17:	d3 e3                	shl    %cl,%ebx
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
 8050f19:	f0 09 58 0c          	lock or %ebx,0xc(%eax)
}
 8050f1d:	5b                   	pop    %ebx
 8050f1e:	5d                   	pop    %ebp
 8050f1f:	c3                   	ret    

08050f20 <net_if_flag_test_and_set.isra.0>:
 8050f20:	f0 0f ab 50 0c       	lock bts %edx,0xc(%eax)
	return (old & mask) != 0;
 8050f25:	0f 92 c0             	setb   %al
}
 8050f28:	c3                   	ret    

08050f29 <atomic_test_and_clear_bit>:
{
 8050f29:	55                   	push   %ebp
 8050f2a:	89 e5                	mov    %esp,%ebp
 8050f2c:	57                   	push   %edi
 8050f2d:	56                   	push   %esi
	atomic_val_t mask = ATOMIC_MASK(bit);
 8050f2e:	be 01 00 00 00       	mov    $0x1,%esi
{
 8050f33:	53                   	push   %ebx
 8050f34:	89 c3                	mov    %eax,%ebx
 8050f36:	51                   	push   %ecx
 8050f37:	89 d1                	mov    %edx,%ecx
	atomic_val_t mask = ATOMIC_MASK(bit);
 8050f39:	d3 e6                	shl    %cl,%esi
	old = atomic_and(ATOMIC_ELEM(target, bit), ~mask);
 8050f3b:	c1 e9 05             	shr    $0x5,%ecx
 8050f3e:	89 f0                	mov    %esi,%eax
 8050f40:	f7 d0                	not    %eax
 8050f42:	89 45 f0             	mov    %eax,-0x10(%ebp)
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
 8050f45:	8b 04 8b             	mov    (%ebx,%ecx,4),%eax
 8050f48:	8b 7d f0             	mov    -0x10(%ebp),%edi
 8050f4b:	89 c2                	mov    %eax,%edx
 8050f4d:	21 c7                	and    %eax,%edi
 8050f4f:	f0 0f b1 3c 8b       	lock cmpxchg %edi,(%ebx,%ecx,4)
 8050f54:	75 f2                	jne    8050f48 <atomic_test_and_clear_bit+0x1f>
	return (old & mask) != 0;
 8050f56:	85 f2                	test   %esi,%edx
}
 8050f58:	5a                   	pop    %edx
 8050f59:	5b                   	pop    %ebx
	return (old & mask) != 0;
 8050f5a:	0f 95 c0             	setne  %al
}
 8050f5d:	5e                   	pop    %esi
 8050f5e:	5f                   	pop    %edi
 8050f5f:	5d                   	pop    %ebp
 8050f60:	c3                   	ret    

08050f61 <iface_router_expired>:
{
 8050f61:	55                   	push   %ebp
 8050f62:	89 e5                	mov    %esp,%ebp
 8050f64:	57                   	push   %edi
 8050f65:	56                   	push   %esi
 8050f66:	53                   	push   %ebx
 8050f67:	83 ec 1c             	sub    $0x1c,%esp
	uint32_t current_time = k_uptime_get_32();
 8050f6a:	e8 02 f9 ff ff       	call   8050871 <k_uptime_get_32>
 8050f6f:	89 c3                	mov    %eax,%ebx
	k_mutex_lock(&lock, K_FOREVER);
 8050f71:	83 c8 ff             	or     $0xffffffff,%eax
 8050f74:	89 c2                	mov    %eax,%edx
 8050f76:	e8 0a f9 ff ff       	call   8050885 <k_mutex_lock.constprop.0.isra.0>
	return list->head;
 8050f7b:	a1 e0 89 06 08       	mov    0x80689e0,%eax
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&active_router_timers,
 8050f80:	85 c0                	test   %eax,%eax
 8050f82:	75 13                	jne    8050f97 <iface_router_expired+0x36>
	iface_router_update_timer(current_time);
 8050f84:	89 d8                	mov    %ebx,%eax
 8050f86:	e8 2d fa ff ff       	call   80509b8 <iface_router_update_timer>
}
 8050f8b:	83 c4 1c             	add    $0x1c,%esp
 8050f8e:	5b                   	pop    %ebx
 8050f8f:	5e                   	pop    %esi
 8050f90:	5f                   	pop    %edi
 8050f91:	5d                   	pop    %ebp
	k_mutex_unlock(&lock);
 8050f92:	e9 05 f9 ff ff       	jmp    805089c <k_mutex_unlock.constprop.0.isra.0>
	return node->next;
 8050f97:	8b 08                	mov    (%eax),%ecx
 8050f99:	31 d2                	xor    %edx,%edx
	return (int32_t)(ends - now);
 8050f9b:	8b 70 1c             	mov    0x1c(%eax),%esi
			prev_node = &router->node;
 8050f9e:	89 c7                	mov    %eax,%edi
	return (int32_t)(ends - now);
 8050fa0:	29 de                	sub    %ebx,%esi
 8050fa2:	89 75 e4             	mov    %esi,-0x1c(%ebp)
	ends += MSEC_PER_SEC * router->lifetime;
 8050fa5:	0f b7 70 20          	movzwl 0x20(%eax),%esi
 8050fa9:	69 f6 e8 03 00 00    	imul   $0x3e8,%esi,%esi
	return (int32_t)(ends - now);
 8050faf:	03 75 e4             	add    -0x1c(%ebp),%esi
		if (ends > 0) {
 8050fb2:	85 f6                	test   %esi,%esi
 8050fb4:	7f 38                	jg     8050fee <iface_router_expired+0x8d>
 8050fb6:	8b 30                	mov    (%eax),%esi
Z_GENLIST_REMOVE(slist, snode)
 8050fb8:	85 d2                	test   %edx,%edx
 8050fba:	75 16                	jne    8050fd2 <iface_router_expired+0x71>
	list->head = node;
 8050fbc:	89 35 e0 89 06 08    	mov    %esi,0x80689e0
Z_GENLIST_REMOVE(slist, snode)
 8050fc2:	39 05 e4 89 06 08    	cmp    %eax,0x80689e4
 8050fc8:	75 18                	jne    8050fe2 <iface_router_expired+0x81>
	list->tail = node;
 8050fca:	89 35 e4 89 06 08    	mov    %esi,0x80689e4
}
 8050fd0:	eb 10                	jmp    8050fe2 <iface_router_expired+0x81>
	parent->next = child;
 8050fd2:	89 32                	mov    %esi,(%edx)
Z_GENLIST_REMOVE(slist, snode)
 8050fd4:	39 05 e4 89 06 08    	cmp    %eax,0x80689e4
 8050fda:	75 06                	jne    8050fe2 <iface_router_expired+0x81>
	list->tail = node;
 8050fdc:	89 15 e4 89 06 08    	mov    %edx,0x80689e4
		router->is_used = false;
 8050fe2:	80 60 22 fe          	andb   $0xfe,0x22(%eax)
 8050fe6:	89 d7                	mov    %edx,%edi
	parent->next = child;
 8050fe8:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&active_router_timers,
 8050fee:	85 c9                	test   %ecx,%ecx
 8050ff0:	74 92                	je     8050f84 <iface_router_expired+0x23>
	return node->next;
 8050ff2:	89 c8                	mov    %ecx,%eax
 8050ff4:	89 fa                	mov    %edi,%edx
 8050ff6:	8b 09                	mov    (%ecx),%ecx
 8050ff8:	eb a1                	jmp    8050f9b <iface_router_expired+0x3a>

08050ffa <z_impl_net_if_get_by_index>:
{
 8050ffa:	55                   	push   %ebp
		return NULL;
 8050ffb:	31 c0                	xor    %eax,%eax
{
 8050ffd:	89 e5                	mov    %esp,%ebp
 8050fff:	8b 55 08             	mov    0x8(%ebp),%edx
	if (index <= 0) {
 8051002:	85 d2                	test   %edx,%edx
 8051004:	7e 14                	jle    805101a <z_impl_net_if_get_by_index+0x20>
	if (&_net_if_list_start[index - 1] >= _net_if_list_end) {
 8051006:	8d 42 ff             	lea    -0x1(%edx),%eax
 8051009:	6b c0 0c             	imul   $0xc,%eax,%eax
 805100c:	05 b0 76 06 08       	add    $0x80676b0,%eax
 8051011:	3d bc 76 06 08       	cmp    $0x80676bc,%eax
 8051016:	72 02                	jb     805101a <z_impl_net_if_get_by_index+0x20>
		return NULL;
 8051018:	31 c0                	xor    %eax,%eax
}
 805101a:	5d                   	pop    %ebp
 805101b:	c3                   	ret    

0805101c <net_if_set_link_addr_locked>:
{
 805101c:	55                   	push   %ebp
	k_mutex_lock(&lock, K_FOREVER);
 805101d:	83 c8 ff             	or     $0xffffffff,%eax
 8051020:	89 c2                	mov    %eax,%edx
{
 8051022:	89 e5                	mov    %esp,%ebp
 8051024:	57                   	push   %edi
 8051025:	56                   	push   %esi
 8051026:	53                   	push   %ebx
 8051027:	83 ec 1c             	sub    $0x1c,%esp
 805102a:	8b 5d 08             	mov    0x8(%ebp),%ebx
 805102d:	8b 7d 10             	mov    0x10(%ebp),%edi
 8051030:	8b 75 14             	mov    0x14(%ebp),%esi
	k_mutex_lock(&lock, K_FOREVER);
 8051033:	e8 4d f8 ff ff       	call   8050885 <k_mutex_lock.constprop.0.isra.0>
	if (net_if_flag_is_set(iface, NET_IF_RUNNING)) {
 8051038:	ba 08 00 00 00       	mov    $0x8,%edx
 805103d:	89 d8                	mov    %ebx,%eax
 805103f:	e8 b6 fc ff ff       	call   8050cfa <net_if_flag_is_set>
 8051044:	89 c2                	mov    %eax,%edx
 8051046:	83 c8 ff             	or     $0xffffffff,%eax
 8051049:	84 d2                	test   %dl,%dl
 805104b:	75 18                	jne    8051065 <net_if_set_link_addr_locked+0x49>
	return &iface->if_dev->link_addr;
 805104d:	8b 03                	mov    (%ebx),%eax
	net_if_get_link_addr(iface)->addr = addr;
 805104f:	8b 55 0c             	mov    0xc(%ebp),%edx
	net_if_get_link_addr(iface)->len = len;
 8051052:	89 f9                	mov    %edi,%ecx
	net_if_get_link_addr(iface)->addr = addr;
 8051054:	89 50 10             	mov    %edx,0x10(%eax)
	return &iface->if_dev->link_addr;
 8051057:	8b 03                	mov    (%ebx),%eax
	net_if_get_link_addr(iface)->len = len;
 8051059:	88 48 14             	mov    %cl,0x14(%eax)
	return &iface->if_dev->link_addr;
 805105c:	8b 03                	mov    (%ebx),%eax
	net_if_get_link_addr(iface)->type = type;
 805105e:	89 f1                	mov    %esi,%ecx
 8051060:	88 48 15             	mov    %cl,0x15(%eax)
	return 0;
 8051063:	31 c0                	xor    %eax,%eax
 8051065:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	k_mutex_unlock(&lock);
 8051068:	e8 2f f8 ff ff       	call   805089c <k_mutex_unlock.constprop.0.isra.0>
}
 805106d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8051070:	83 c4 1c             	add    $0x1c,%esp
 8051073:	5b                   	pop    %ebx
 8051074:	5e                   	pop    %esi
 8051075:	5f                   	pop    %edi
 8051076:	5d                   	pop    %ebp
 8051077:	c3                   	ret    

08051078 <net_if_lookup_by_dev>:
{
 8051078:	55                   	push   %ebp
	STRUCT_SECTION_FOREACH(net_if, iface) {
 8051079:	b8 b0 76 06 08       	mov    $0x80676b0,%eax
{
 805107e:	89 e5                	mov    %esp,%ebp
 8051080:	8b 55 08             	mov    0x8(%ebp),%edx
	STRUCT_SECTION_FOREACH(net_if, iface) {
 8051083:	3d bc 76 06 08       	cmp    $0x80676bc,%eax
 8051088:	73 0b                	jae    8051095 <net_if_lookup_by_dev+0x1d>
	return iface->if_dev->dev;
 805108a:	8b 08                	mov    (%eax),%ecx
		if (net_if_get_device(iface) == dev) {
 805108c:	3b 11                	cmp    (%ecx),%edx
 805108e:	74 07                	je     8051097 <net_if_lookup_by_dev+0x1f>
	STRUCT_SECTION_FOREACH(net_if, iface) {
 8051090:	83 c0 0c             	add    $0xc,%eax
 8051093:	eb ee                	jmp    8051083 <net_if_lookup_by_dev+0xb>
	return NULL;
 8051095:	31 c0                	xor    %eax,%eax
}
 8051097:	5d                   	pop    %ebp
 8051098:	c3                   	ret    

08051099 <net_if_get_default>:
	if (&_net_if_list_start[0] == &_net_if_list_end[0]) {
 8051099:	ba b0 76 06 08       	mov    $0x80676b0,%edx
		return NULL;
 805109e:	31 c0                	xor    %eax,%eax
	if (&_net_if_list_start[0] == &_net_if_list_end[0]) {
 80510a0:	81 fa bc 76 06 08    	cmp    $0x80676bc,%edx
 80510a6:	74 0b                	je     80510b3 <net_if_get_default+0x1a>
	if (default_iface != NULL) {
 80510a8:	a1 e8 89 06 08       	mov    0x80689e8,%eax
 80510ad:	85 c0                	test   %eax,%eax
 80510af:	75 02                	jne    80510b3 <net_if_get_default+0x1a>
	return iface ? iface : _net_if_list_start;
 80510b1:	89 d0                	mov    %edx,%eax
}
 80510b3:	c3                   	ret    

080510b4 <net_if_mcast_monitor>:
{
 80510b4:	55                   	push   %ebp
	k_mutex_lock(&lock, K_FOREVER);
 80510b5:	83 c8 ff             	or     $0xffffffff,%eax
 80510b8:	89 c2                	mov    %eax,%edx
{
 80510ba:	89 e5                	mov    %esp,%ebp
 80510bc:	57                   	push   %edi
 80510bd:	56                   	push   %esi
 80510be:	53                   	push   %ebx
 80510bf:	83 ec 1c             	sub    $0x1c,%esp
 80510c2:	8b 75 08             	mov    0x8(%ebp),%esi
 80510c5:	8b 7d 0c             	mov    0xc(%ebp),%edi
 80510c8:	0f b6 5d 10          	movzbl 0x10(%ebp),%ebx
	k_mutex_lock(&lock, K_FOREVER);
 80510cc:	e8 b4 f7 ff ff       	call   8050885 <k_mutex_lock.constprop.0.isra.0>
	return list->head;
 80510d1:	a1 b0 89 06 08       	mov    0x80689b0,%eax
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&mcast_monitor_callbacks,
 80510d6:	85 c0                	test   %eax,%eax
 80510d8:	75 0c                	jne    80510e6 <net_if_mcast_monitor+0x32>
}
 80510da:	8d 65 f4             	lea    -0xc(%ebp),%esp
 80510dd:	5b                   	pop    %ebx
 80510de:	5e                   	pop    %esi
 80510df:	5f                   	pop    %edi
 80510e0:	5d                   	pop    %ebp
	k_mutex_unlock(&lock);
 80510e1:	e9 b6 f7 ff ff       	jmp    805089c <k_mutex_unlock.constprop.0.isra.0>
	return node->next;
 80510e6:	8b 10                	mov    (%eax),%edx
		if (iface == mon->iface) {
 80510e8:	39 70 04             	cmp    %esi,0x4(%eax)
 80510eb:	75 10                	jne    80510fd <net_if_mcast_monitor+0x49>
 80510ed:	89 55 e4             	mov    %edx,-0x1c(%ebp)
			mon->cb(iface, addr, is_joined);
 80510f0:	52                   	push   %edx
 80510f1:	53                   	push   %ebx
 80510f2:	57                   	push   %edi
 80510f3:	56                   	push   %esi
 80510f4:	ff 50 08             	call   *0x8(%eax)
 80510f7:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 80510fa:	83 c4 10             	add    $0x10,%esp
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&mcast_monitor_callbacks,
 80510fd:	85 d2                	test   %edx,%edx
 80510ff:	74 d9                	je     80510da <net_if_mcast_monitor+0x26>
 8051101:	89 d0                	mov    %edx,%eax
 8051103:	8b 12                	mov    (%edx),%edx
 8051105:	eb e1                	jmp    80510e8 <net_if_mcast_monitor+0x34>

08051107 <net_if_config_ipv6_get>:
{
 8051107:	55                   	push   %ebp
	k_mutex_lock(&lock, K_FOREVER);
 8051108:	83 c8 ff             	or     $0xffffffff,%eax
 805110b:	89 c2                	mov    %eax,%edx
{
 805110d:	89 e5                	mov    %esp,%ebp
 805110f:	56                   	push   %esi
 8051110:	53                   	push   %ebx
 8051111:	83 ec 10             	sub    $0x10,%esp
 8051114:	8b 5d 08             	mov    0x8(%ebp),%ebx
 8051117:	8b 75 0c             	mov    0xc(%ebp),%esi
	k_mutex_lock(&lock, K_FOREVER);
 805111a:	e8 66 f7 ff ff       	call   8050885 <k_mutex_lock.constprop.0.isra.0>
	if (!net_if_flag_is_set(iface, NET_IF_IPV6)) {
 805111f:	ba 07 00 00 00       	mov    $0x7,%edx
 8051124:	89 d8                	mov    %ebx,%eax
 8051126:	e8 cf fb ff ff       	call   8050cfa <net_if_flag_is_set>
 805112b:	89 c2                	mov    %eax,%edx
		ret = -ENOTSUP;
 805112d:	b8 a1 ff ff ff       	mov    $0xffffffa1,%eax
	if (!net_if_flag_is_set(iface, NET_IF_IPV6)) {
 8051132:	84 d2                	test   %dl,%dl
 8051134:	74 38                	je     805116e <net_if_config_ipv6_get+0x67>
	if (iface->config.ip.ipv6) {
 8051136:	8b 43 04             	mov    0x4(%ebx),%eax
 8051139:	85 c0                	test   %eax,%eax
 805113b:	74 0a                	je     8051147 <net_if_config_ipv6_get+0x40>
		if (ipv6) {
 805113d:	85 f6                	test   %esi,%esi
 805113f:	74 02                	je     8051143 <net_if_config_ipv6_get+0x3c>
			*ipv6 = iface->config.ip.ipv6;
 8051141:	89 06                	mov    %eax,(%esi)
	int ret = 0;
 8051143:	31 c0                	xor    %eax,%eax
 8051145:	eb 27                	jmp    805116e <net_if_config_ipv6_get+0x67>
		if (ipv6_addresses[i].iface) {
 8051147:	83 3d f0 7c 06 08 00 	cmpl   $0x0,0x8067cf0
 805114e:	75 19                	jne    8051169 <net_if_config_ipv6_get+0x62>
		iface->config.ip.ipv6 = &ipv6_addresses[i].ipv6;
 8051150:	c7 43 04 e0 7b 06 08 	movl   $0x8067be0,0x4(%ebx)
		ipv6_addresses[i].iface = iface;
 8051157:	89 1d f0 7c 06 08    	mov    %ebx,0x8067cf0
		if (ipv6) {
 805115d:	85 f6                	test   %esi,%esi
 805115f:	74 e2                	je     8051143 <net_if_config_ipv6_get+0x3c>
			*ipv6 = &ipv6_addresses[i].ipv6;
 8051161:	c7 06 e0 7b 06 08    	movl   $0x8067be0,(%esi)
 8051167:	eb da                	jmp    8051143 <net_if_config_ipv6_get+0x3c>
	ret = -ESRCH;
 8051169:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
 805116e:	89 45 f4             	mov    %eax,-0xc(%ebp)
	k_mutex_unlock(&lock);
 8051171:	e8 26 f7 ff ff       	call   805089c <k_mutex_unlock.constprop.0.isra.0>
}
 8051176:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8051179:	83 c4 10             	add    $0x10,%esp
 805117c:	5b                   	pop    %ebx
 805117d:	5e                   	pop    %esi
 805117e:	5d                   	pop    %ebp
 805117f:	c3                   	ret    

08051180 <net_if_start_rs>:
{
 8051180:	55                   	push   %ebp
	k_mutex_lock(&lock, K_FOREVER);
 8051181:	83 c8 ff             	or     $0xffffffff,%eax
 8051184:	89 c2                	mov    %eax,%edx
{
 8051186:	89 e5                	mov    %esp,%ebp
 8051188:	56                   	push   %esi
 8051189:	53                   	push   %ebx
 805118a:	8b 75 08             	mov    0x8(%ebp),%esi
	k_mutex_lock(&lock, K_FOREVER);
 805118d:	e8 f3 f6 ff ff       	call   8050885 <k_mutex_lock.constprop.0.isra.0>
	ipv6 = iface->config.ip.ipv6;
 8051192:	8b 5e 04             	mov    0x4(%esi),%ebx
	if (!ipv6) {
 8051195:	85 db                	test   %ebx,%ebx
 8051197:	74 51                	je     80511ea <net_if_start_rs+0x6a>
	if (!net_ipv6_start_rs(iface)) {
 8051199:	83 ec 0c             	sub    $0xc,%esp
 805119c:	56                   	push   %esi
 805119d:	e8 36 86 00 00       	call   80597d8 <net_ipv6_start_rs>
 80511a2:	83 c4 10             	add    $0x10,%esp
 80511a5:	85 c0                	test   %eax,%eax
 80511a7:	75 41                	jne    80511ea <net_if_start_rs+0x6a>
		ipv6->rs_start = k_uptime_get_32();
 80511a9:	e8 c3 f6 ff ff       	call   8050871 <k_uptime_get_32>
		sys_slist_append(&active_rs_timers, &ipv6->rs_node);
 80511ae:	8d 93 04 01 00 00    	lea    0x104(%ebx),%edx
		ipv6->rs_start = k_uptime_get_32();
 80511b4:	89 83 08 01 00 00    	mov    %eax,0x108(%ebx)
		sys_slist_append(&active_rs_timers, &ipv6->rs_node);
 80511ba:	b8 c0 89 06 08       	mov    $0x80689c0,%eax
 80511bf:	e8 02 f5 ff ff       	call   80506c6 <sys_slist_append>
 80511c4:	83 ec 0c             	sub    $0xc,%esp
 80511c7:	68 10 7d 06 08       	push   $0x8067d10
 80511cc:	e8 c8 f8 00 00       	call   8060a99 <z_timeout_remaining>
 80511d1:	83 c4 10             	add    $0x10,%esp
		if (!k_work_delayable_remaining_get(&rs_timer)) {
 80511d4:	09 c2                	or     %eax,%edx
 80511d6:	75 12                	jne    80511ea <net_if_start_rs+0x6a>
			k_work_reschedule(&rs_timer, K_MSEC(RS_TIMEOUT));
 80511d8:	50                   	push   %eax
 80511d9:	6a 00                	push   $0x0
 80511db:	6a 64                	push   $0x64
 80511dd:	68 00 7d 06 08       	push   $0x8067d00
 80511e2:	e8 f9 ea 00 00       	call   805fce0 <k_work_reschedule>
 80511e7:	83 c4 10             	add    $0x10,%esp
}
 80511ea:	8d 65 f8             	lea    -0x8(%ebp),%esp
 80511ed:	5b                   	pop    %ebx
 80511ee:	5e                   	pop    %esi
 80511ef:	5d                   	pop    %ebp
	k_mutex_unlock(&lock);
 80511f0:	e9 a7 f6 ff ff       	jmp    805089c <k_mutex_unlock.constprop.0.isra.0>

080511f5 <rs_timeout>:
{
 80511f5:	55                   	push   %ebp
 80511f6:	89 e5                	mov    %esp,%ebp
 80511f8:	56                   	push   %esi
 80511f9:	53                   	push   %ebx
	uint32_t current_time = k_uptime_get_32();
 80511fa:	e8 72 f6 ff ff       	call   8050871 <k_uptime_get_32>
 80511ff:	89 c3                	mov    %eax,%ebx
	k_mutex_lock(&lock, K_FOREVER);
 8051201:	83 c8 ff             	or     $0xffffffff,%eax
 8051204:	89 c2                	mov    %eax,%edx
 8051206:	e8 7a f6 ff ff       	call   8050885 <k_mutex_lock.constprop.0.isra.0>
	return list->head;
 805120b:	a1 c0 89 06 08       	mov    0x80689c0,%eax
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&active_rs_timers,
 8051210:	85 c0                	test   %eax,%eax
 8051212:	0f 84 cb 00 00 00    	je     80512e3 <rs_timeout+0xee>
	return node->next;
 8051218:	8b 30                	mov    (%eax),%esi
 805121a:	8d 90 fc fe ff ff    	lea    -0x104(%eax),%edx
 8051220:	85 f6                	test   %esi,%esi
 8051222:	74 06                	je     805122a <rs_timeout+0x35>
 8051224:	81 ee 04 01 00 00    	sub    $0x104,%esi
		delay = (int32_t)(ipv6->rs_start + RS_TIMEOUT - current_time);
 805122a:	8b 8a 08 01 00 00    	mov    0x108(%edx),%ecx
 8051230:	29 d9                	sub    %ebx,%ecx
 8051232:	8d 81 e8 03 00 00    	lea    0x3e8(%ecx),%eax
		if (delay > 0) {
 8051238:	85 c0                	test   %eax,%eax
 805123a:	7f 7a                	jg     80512b6 <rs_timeout+0xc1>
 805123c:	8b 82 04 01 00 00    	mov    0x104(%edx),%eax
		sys_slist_remove(&active_rs_timers, NULL, &ipv6->rs_node);
 8051242:	8d 8a 04 01 00 00    	lea    0x104(%edx),%ecx
	list->head = node;
 8051248:	a3 c0 89 06 08       	mov    %eax,0x80689c0
Z_GENLIST_REMOVE(slist, snode)
 805124d:	39 0d c4 89 06 08    	cmp    %ecx,0x80689c4
 8051253:	75 05                	jne    805125a <rs_timeout+0x65>
	list->tail = node;
 8051255:	a3 c4 89 06 08       	mov    %eax,0x80689c4
	parent->next = child;
 805125a:	c7 82 04 01 00 00 00 	movl   $0x0,0x104(%edx)
 8051261:	00 00 00 
		ipv6->rs_count++;
 8051264:	8a 82 0c 01 00 00    	mov    0x10c(%edx),%al
 805126a:	8d 48 01             	lea    0x1(%eax),%ecx
		STRUCT_SECTION_FOREACH(net_if, tmp) {
 805126d:	b8 b0 76 06 08       	mov    $0x80676b0,%eax
		ipv6->rs_count++;
 8051272:	88 8a 0c 01 00 00    	mov    %cl,0x10c(%edx)
		STRUCT_SECTION_FOREACH(net_if, tmp) {
 8051278:	3d bc 76 06 08       	cmp    $0x80676bc,%eax
 805127d:	73 1b                	jae    805129a <rs_timeout+0xa5>
			if (tmp->config.ip.ipv6 == ipv6) {
 805127f:	39 50 04             	cmp    %edx,0x4(%eax)
 8051282:	74 05                	je     8051289 <rs_timeout+0x94>
		STRUCT_SECTION_FOREACH(net_if, tmp) {
 8051284:	83 c0 0c             	add    $0xc,%eax
 8051287:	eb ef                	jmp    8051278 <rs_timeout+0x83>
			if (ipv6->rs_count < RS_COUNT) {
 8051289:	80 f9 02             	cmp    $0x2,%cl
 805128c:	77 0c                	ja     805129a <rs_timeout+0xa5>
				net_if_start_rs(iface);
 805128e:	83 ec 0c             	sub    $0xc,%esp
 8051291:	50                   	push   %eax
 8051292:	e8 e9 fe ff ff       	call   8051180 <net_if_start_rs>
 8051297:	83 c4 10             	add    $0x10,%esp
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&active_rs_timers,
 805129a:	85 f6                	test   %esi,%esi
 805129c:	74 45                	je     80512e3 <rs_timeout+0xee>
	return node->next;
 805129e:	8b 86 04 01 00 00    	mov    0x104(%esi),%eax
 80512a4:	85 c0                	test   %eax,%eax
 80512a6:	74 05                	je     80512ad <rs_timeout+0xb8>
 80512a8:	2d 04 01 00 00       	sub    $0x104,%eax
{
 80512ad:	89 f2                	mov    %esi,%edx
 80512af:	89 c6                	mov    %eax,%esi
 80512b1:	e9 74 ff ff ff       	jmp    805122a <rs_timeout+0x35>
		k_work_reschedule(&rs_timer, K_MSEC(ipv6->rs_start +
 80512b6:	31 d2                	xor    %edx,%edx
 80512b8:	81 f9 18 fc ff ff    	cmp    $0xfffffc18,%ecx
 80512be:	6a 00                	push   $0x0
 80512c0:	0f 44 c2             	cmove  %edx,%eax
		t += off;
 80512c3:	31 d2                	xor    %edx,%edx
			return t / ((uint64_t)from_hz / to_hz);
 80512c5:	6a 0a                	push   $0xa
 80512c7:	52                   	push   %edx
		t += off;
 80512c8:	83 c0 09             	add    $0x9,%eax
			return t / ((uint64_t)from_hz / to_hz);
 80512cb:	50                   	push   %eax
 80512cc:	e8 7f 82 ff ff       	call   8049550 <__udivdi3>
 80512d1:	83 c4 0c             	add    $0xc,%esp
 80512d4:	52                   	push   %edx
 80512d5:	50                   	push   %eax
 80512d6:	68 00 7d 06 08       	push   $0x8067d00
 80512db:	e8 00 ea 00 00       	call   805fce0 <k_work_reschedule>
 80512e0:	83 c4 10             	add    $0x10,%esp
}
 80512e3:	8d 65 f8             	lea    -0x8(%ebp),%esp
 80512e6:	5b                   	pop    %ebx
 80512e7:	5e                   	pop    %esi
 80512e8:	5d                   	pop    %ebp
	k_mutex_unlock(&lock);
 80512e9:	e9 ae f5 ff ff       	jmp    805089c <k_mutex_unlock.constprop.0.isra.0>

080512ee <net_if_stop_rs>:
{
 80512ee:	55                   	push   %ebp
	k_mutex_lock(&lock, K_FOREVER);
 80512ef:	83 c8 ff             	or     $0xffffffff,%eax
{
 80512f2:	89 e5                	mov    %esp,%ebp
 80512f4:	53                   	push   %ebx
 80512f5:	52                   	push   %edx
 80512f6:	8b 5d 08             	mov    0x8(%ebp),%ebx
	k_mutex_lock(&lock, K_FOREVER);
 80512f9:	89 c2                	mov    %eax,%edx
 80512fb:	e8 85 f5 ff ff       	call   8050885 <k_mutex_lock.constprop.0.isra.0>
	ipv6 = iface->config.ip.ipv6;
 8051300:	8b 53 04             	mov    0x4(%ebx),%edx
	if (!ipv6) {
 8051303:	85 d2                	test   %edx,%edx
 8051305:	74 10                	je     8051317 <net_if_stop_rs+0x29>
	sys_slist_find_and_remove(&active_rs_timers, &ipv6->rs_node);
 8051307:	81 c2 04 01 00 00    	add    $0x104,%edx
 805130d:	b8 c0 89 06 08       	mov    $0x80689c0,%eax
 8051312:	e8 c8 f3 ff ff       	call   80506df <sys_slist_find_and_remove>
}
 8051317:	58                   	pop    %eax
 8051318:	5b                   	pop    %ebx
 8051319:	5d                   	pop    %ebp
	k_mutex_unlock(&lock);
 805131a:	e9 7d f5 ff ff       	jmp    805089c <k_mutex_unlock.constprop.0.isra.0>

0805131f <net_if_ipv6_addr_lookup>:
{
 805131f:	55                   	push   %ebp
	k_mutex_lock(&lock, K_FOREVER);
 8051320:	83 c8 ff             	or     $0xffffffff,%eax
 8051323:	89 c2                	mov    %eax,%edx
{
 8051325:	89 e5                	mov    %esp,%ebp
 8051327:	57                   	push   %edi
 8051328:	56                   	push   %esi
	STRUCT_SECTION_FOREACH(net_if, iface) {
 8051329:	be b0 76 06 08       	mov    $0x80676b0,%esi
{
 805132e:	53                   	push   %ebx
 805132f:	83 ec 1c             	sub    $0x1c,%esp
 8051332:	8b 7d 0c             	mov    0xc(%ebp),%edi
	k_mutex_lock(&lock, K_FOREVER);
 8051335:	e8 4b f5 ff ff       	call   8050885 <k_mutex_lock.constprop.0.isra.0>
	STRUCT_SECTION_FOREACH(net_if, iface) {
 805133a:	81 fe bc 76 06 08    	cmp    $0x80676bc,%esi
 8051340:	73 60                	jae    80513a2 <net_if_ipv6_addr_lookup+0x83>
		struct net_if_ipv6 *ipv6 = iface->config.ip.ipv6;
 8051342:	8b 5e 04             	mov    0x4(%esi),%ebx
		if (!ipv6) {
 8051345:	85 db                	test   %ebx,%ebx
 8051347:	74 54                	je     805139d <net_if_ipv6_addr_lookup+0x7e>
			if (!ipv6->unicast[i].is_used ||
 8051349:	f6 43 2f 02          	testb  $0x2,0x2f(%ebx)
 805134d:	74 1a                	je     8051369 <net_if_ipv6_addr_lookup+0x4a>
 805134f:	66 83 3b 02          	cmpw   $0x2,(%ebx)
 8051353:	75 14                	jne    8051369 <net_if_ipv6_addr_lookup+0x4a>
			if (net_ipv6_is_prefix(
 8051355:	8b 45 08             	mov    0x8(%ebp),%eax
				    ipv6->unicast[i].address.in6_addr.s6_addr,
 8051358:	8d 53 04             	lea    0x4(%ebx),%edx
			if (net_ipv6_is_prefix(
 805135b:	b9 80 00 00 00       	mov    $0x80,%ecx
 8051360:	e8 88 f4 ff ff       	call   80507ed <net_ipv6_is_prefix>
 8051365:	84 c0                	test   %al,%al
 8051367:	75 28                	jne    8051391 <net_if_ipv6_addr_lookup+0x72>
			if (!ipv6->unicast[i].is_used ||
 8051369:	f6 43 5f 02          	testb  $0x2,0x5f(%ebx)
 805136d:	74 2e                	je     805139d <net_if_ipv6_addr_lookup+0x7e>
 805136f:	66 83 7b 30 02       	cmpw   $0x2,0x30(%ebx)
 8051374:	75 27                	jne    805139d <net_if_ipv6_addr_lookup+0x7e>
			if (net_ipv6_is_prefix(
 8051376:	8b 45 08             	mov    0x8(%ebp),%eax
				    ipv6->unicast[i].address.in6_addr.s6_addr,
 8051379:	8d 53 34             	lea    0x34(%ebx),%edx
			if (net_ipv6_is_prefix(
 805137c:	b9 80 00 00 00       	mov    $0x80,%ecx
 8051381:	e8 67 f4 ff ff       	call   80507ed <net_ipv6_is_prefix>
 8051386:	84 c0                	test   %al,%al
 8051388:	74 13                	je     805139d <net_if_ipv6_addr_lookup+0x7e>
 805138a:	b8 30 00 00 00       	mov    $0x30,%eax
 805138f:	eb 02                	jmp    8051393 <net_if_ipv6_addr_lookup+0x74>
 8051391:	31 c0                	xor    %eax,%eax
				if (ret) {
 8051393:	85 ff                	test   %edi,%edi
 8051395:	74 02                	je     8051399 <net_if_ipv6_addr_lookup+0x7a>
					*ret = iface;
 8051397:	89 37                	mov    %esi,(%edi)
				ifaddr = &ipv6->unicast[i];
 8051399:	01 d8                	add    %ebx,%eax
				goto out;
 805139b:	eb 07                	jmp    80513a4 <net_if_ipv6_addr_lookup+0x85>
	STRUCT_SECTION_FOREACH(net_if, iface) {
 805139d:	83 c6 0c             	add    $0xc,%esi
 80513a0:	eb 98                	jmp    805133a <net_if_ipv6_addr_lookup+0x1b>
	struct net_if_addr *ifaddr = NULL;
 80513a2:	31 c0                	xor    %eax,%eax
 80513a4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	k_mutex_unlock(&lock);
 80513a7:	e8 f0 f4 ff ff       	call   805089c <k_mutex_unlock.constprop.0.isra.0>
}
 80513ac:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 80513af:	83 c4 1c             	add    $0x1c,%esp
 80513b2:	5b                   	pop    %ebx
 80513b3:	5e                   	pop    %esi
 80513b4:	5f                   	pop    %edi
 80513b5:	5d                   	pop    %ebp
 80513b6:	c3                   	ret    

080513b7 <dad_timeout>:
{
 80513b7:	55                   	push   %ebp
 80513b8:	89 e5                	mov    %esp,%ebp
 80513ba:	57                   	push   %edi
 80513bb:	56                   	push   %esi
 80513bc:	53                   	push   %ebx
 80513bd:	83 ec 2c             	sub    $0x2c,%esp
 80513c0:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 80513c6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 80513c9:	31 c0                	xor    %eax,%eax
	uint32_t current_time = k_uptime_get_32();
 80513cb:	e8 a1 f4 ff ff       	call   8050871 <k_uptime_get_32>
 80513d0:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	k_mutex_lock(&lock, K_FOREVER);
 80513d3:	83 c8 ff             	or     $0xffffffff,%eax
 80513d6:	89 c2                	mov    %eax,%edx
 80513d8:	e8 a8 f4 ff ff       	call   8050885 <k_mutex_lock.constprop.0.isra.0>
	return list->head;
 80513dd:	a1 c8 89 06 08       	mov    0x80689c8,%eax
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&active_dad_timers,
 80513e2:	85 c0                	test   %eax,%eax
 80513e4:	0f 84 a9 00 00 00    	je     8051493 <dad_timeout+0xdc>
	return node->next;
 80513ea:	8b 30                	mov    (%eax),%esi
 80513ec:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
 80513ef:	8d 58 dc             	lea    -0x24(%eax),%ebx
 80513f2:	85 f6                	test   %esi,%esi
 80513f4:	74 03                	je     80513f9 <dad_timeout+0x42>
 80513f6:	83 ee 24             	sub    $0x24,%esi
				  DAD_TIMEOUT - current_time);
 80513f9:	bf 64 00 00 00       	mov    $0x64,%edi
 80513fe:	29 cf                	sub    %ecx,%edi
 8051400:	8b 43 28             	mov    0x28(%ebx),%eax
 8051403:	01 f8                	add    %edi,%eax
		if (delay > 0) {
 8051405:	85 c0                	test   %eax,%eax
 8051407:	7f 5a                	jg     8051463 <dad_timeout+0xac>
 8051409:	8b 43 24             	mov    0x24(%ebx),%eax
		sys_slist_remove(&active_dad_timers, NULL, &ifaddr->dad_node);
 805140c:	8d 53 24             	lea    0x24(%ebx),%edx
	list->head = node;
 805140f:	a3 c8 89 06 08       	mov    %eax,0x80689c8
Z_GENLIST_REMOVE(slist, snode)
 8051414:	39 15 cc 89 06 08    	cmp    %edx,0x80689cc
 805141a:	75 05                	jne    8051421 <dad_timeout+0x6a>
	list->tail = node;
 805141c:	a3 cc 89 06 08       	mov    %eax,0x80689cc
		tmp = net_if_ipv6_addr_lookup(&ifaddr->address.in6_addr,
 8051421:	8d 53 04             	lea    0x4(%ebx),%edx
 8051424:	8d 45 e0             	lea    -0x20(%ebp),%eax
		ifaddr->addr_state = NET_ADDR_PREFERRED;
 8051427:	c6 43 2d 01          	movb   $0x1,0x2d(%ebx)
	parent->next = child;
 805142b:	c7 43 24 00 00 00 00 	movl   $0x0,0x24(%ebx)
		tmp = net_if_ipv6_addr_lookup(&ifaddr->address.in6_addr,
 8051432:	51                   	push   %ecx
 8051433:	51                   	push   %ecx
 8051434:	50                   	push   %eax
 8051435:	52                   	push   %edx
 8051436:	89 55 d4             	mov    %edx,-0x2c(%ebp)
		iface = NULL;
 8051439:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		tmp = net_if_ipv6_addr_lookup(&ifaddr->address.in6_addr,
 8051440:	e8 da fe ff ff       	call   805131f <net_if_ipv6_addr_lookup>
 8051445:	83 c4 10             	add    $0x10,%esp
		if (tmp == ifaddr) {
 8051448:	8b 55 d4             	mov    -0x2c(%ebp),%edx
 805144b:	39 c3                	cmp    %eax,%ebx
 805144d:	75 0e                	jne    805145d <dad_timeout+0xa6>
			net_ipv6_nbr_rm(iface, &ifaddr->address.in6_addr);
 805144f:	50                   	push   %eax
 8051450:	50                   	push   %eax
 8051451:	52                   	push   %edx
 8051452:	ff 75 e0             	push   -0x20(%ebp)
 8051455:	e8 79 6b 00 00       	call   8057fd3 <net_ipv6_nbr_rm>
 805145a:	83 c4 10             	add    $0x10,%esp
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&active_dad_timers,
 805145d:	85 f6                	test   %esi,%esi
 805145f:	75 26                	jne    8051487 <dad_timeout+0xd0>
 8051461:	eb 30                	jmp    8051493 <dad_timeout+0xdc>
		t += off;
 8051463:	83 c0 09             	add    $0x9,%eax
 8051466:	31 d2                	xor    %edx,%edx
			return t / ((uint64_t)from_hz / to_hz);
 8051468:	6a 00                	push   $0x0
 805146a:	6a 0a                	push   $0xa
 805146c:	52                   	push   %edx
 805146d:	50                   	push   %eax
 805146e:	e8 dd 80 ff ff       	call   8049550 <__udivdi3>
 8051473:	83 c4 0c             	add    $0xc,%esp
		k_work_reschedule(&dad_timer, K_MSEC((uint32_t)delay));
 8051476:	52                   	push   %edx
 8051477:	50                   	push   %eax
 8051478:	68 40 7d 06 08       	push   $0x8067d40
 805147d:	e8 5e e8 00 00       	call   805fce0 <k_work_reschedule>
 8051482:	83 c4 10             	add    $0x10,%esp
 8051485:	eb 0c                	jmp    8051493 <dad_timeout+0xdc>
	return node->next;
 8051487:	8b 46 24             	mov    0x24(%esi),%eax
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&active_dad_timers,
 805148a:	85 c0                	test   %eax,%eax
 805148c:	74 22                	je     80514b0 <dad_timeout+0xf9>
 805148e:	83 e8 24             	sub    $0x24,%eax
 8051491:	eb 1d                	jmp    80514b0 <dad_timeout+0xf9>
	k_mutex_unlock(&lock);
 8051493:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8051496:	65 2b 05 14 00 00 00 	sub    %gs:0x14,%eax
 805149d:	74 05                	je     80514a4 <dad_timeout+0xed>
 805149f:	e8 5c 7e ff ff       	call   8049300 <__stack_chk_fail@plt>
}
 80514a4:	8d 65 f4             	lea    -0xc(%ebp),%esp
 80514a7:	5b                   	pop    %ebx
 80514a8:	5e                   	pop    %esi
 80514a9:	5f                   	pop    %edi
 80514aa:	5d                   	pop    %ebp
	k_mutex_unlock(&lock);
 80514ab:	e9 ec f3 ff ff       	jmp    805089c <k_mutex_unlock.constprop.0.isra.0>
{
 80514b0:	89 f3                	mov    %esi,%ebx
 80514b2:	89 c6                	mov    %eax,%esi
 80514b4:	e9 47 ff ff ff       	jmp    8051400 <dad_timeout+0x49>

080514b9 <net_if_ipv6_addr_lookup_by_iface>:
{
 80514b9:	55                   	push   %ebp
	k_mutex_lock(&lock, K_FOREVER);
 80514ba:	83 c8 ff             	or     $0xffffffff,%eax
 80514bd:	89 c2                	mov    %eax,%edx
{
 80514bf:	89 e5                	mov    %esp,%ebp
 80514c1:	53                   	push   %ebx
 80514c2:	51                   	push   %ecx
	k_mutex_lock(&lock, K_FOREVER);
 80514c3:	e8 bd f3 ff ff       	call   8050885 <k_mutex_lock.constprop.0.isra.0>
	ipv6 = iface->config.ip.ipv6;
 80514c8:	8b 45 08             	mov    0x8(%ebp),%eax
 80514cb:	8b 58 04             	mov    0x4(%eax),%ebx
	if (!ipv6) {
 80514ce:	85 db                	test   %ebx,%ebx
 80514d0:	74 50                	je     8051522 <net_if_ipv6_addr_lookup_by_iface+0x69>
		if (!ipv6->unicast[i].is_used ||
 80514d2:	f6 43 2f 02          	testb  $0x2,0x2f(%ebx)
 80514d6:	74 1a                	je     80514f2 <net_if_ipv6_addr_lookup_by_iface+0x39>
 80514d8:	66 83 3b 02          	cmpw   $0x2,(%ebx)
 80514dc:	75 14                	jne    80514f2 <net_if_ipv6_addr_lookup_by_iface+0x39>
		if (net_ipv6_is_prefix(
 80514de:	8b 45 0c             	mov    0xc(%ebp),%eax
			    ipv6->unicast[i].address.in6_addr.s6_addr,
 80514e1:	8d 53 04             	lea    0x4(%ebx),%edx
		if (net_ipv6_is_prefix(
 80514e4:	b9 80 00 00 00       	mov    $0x80,%ecx
 80514e9:	e8 ff f2 ff ff       	call   80507ed <net_ipv6_is_prefix>
 80514ee:	84 c0                	test   %al,%al
 80514f0:	75 28                	jne    805151a <net_if_ipv6_addr_lookup_by_iface+0x61>
		if (!ipv6->unicast[i].is_used ||
 80514f2:	f6 43 5f 02          	testb  $0x2,0x5f(%ebx)
 80514f6:	74 28                	je     8051520 <net_if_ipv6_addr_lookup_by_iface+0x67>
 80514f8:	66 83 7b 30 02       	cmpw   $0x2,0x30(%ebx)
 80514fd:	75 21                	jne    8051520 <net_if_ipv6_addr_lookup_by_iface+0x67>
		if (net_ipv6_is_prefix(
 80514ff:	8b 45 0c             	mov    0xc(%ebp),%eax
			    ipv6->unicast[i].address.in6_addr.s6_addr,
 8051502:	8d 53 34             	lea    0x34(%ebx),%edx
		if (net_ipv6_is_prefix(
 8051505:	b9 80 00 00 00       	mov    $0x80,%ecx
 805150a:	e8 de f2 ff ff       	call   80507ed <net_ipv6_is_prefix>
 805150f:	84 c0                	test   %al,%al
 8051511:	74 0d                	je     8051520 <net_if_ipv6_addr_lookup_by_iface+0x67>
 8051513:	b8 30 00 00 00       	mov    $0x30,%eax
 8051518:	eb 02                	jmp    805151c <net_if_ipv6_addr_lookup_by_iface+0x63>
 805151a:	31 c0                	xor    %eax,%eax
			ifaddr = &ipv6->unicast[i];
 805151c:	01 c3                	add    %eax,%ebx
			goto out;
 805151e:	eb 02                	jmp    8051522 <net_if_ipv6_addr_lookup_by_iface+0x69>
	struct net_if_addr *ifaddr = NULL;
 8051520:	31 db                	xor    %ebx,%ebx
	k_mutex_unlock(&lock);
 8051522:	e8 75 f3 ff ff       	call   805089c <k_mutex_unlock.constprop.0.isra.0>
}
 8051527:	89 d8                	mov    %ebx,%eax
 8051529:	5a                   	pop    %edx
 805152a:	5b                   	pop    %ebx
 805152b:	5d                   	pop    %ebp
 805152c:	c3                   	ret    

0805152d <net_if_ipv6_addr_update_lifetime>:
{
 805152d:	55                   	push   %ebp
	k_mutex_lock(&lock, K_FOREVER);
 805152e:	83 c8 ff             	or     $0xffffffff,%eax
 8051531:	89 c2                	mov    %eax,%edx
{
 8051533:	89 e5                	mov    %esp,%ebp
 8051535:	56                   	push   %esi
 8051536:	53                   	push   %ebx
 8051537:	8b 5d 08             	mov    0x8(%ebp),%ebx
 805153a:	8b 75 0c             	mov    0xc(%ebp),%esi
	sys_slist_append(&active_address_lifetime_timers,
 805153d:	83 c3 14             	add    $0x14,%ebx
	k_mutex_lock(&lock, K_FOREVER);
 8051540:	e8 40 f3 ff ff       	call   8050885 <k_mutex_lock.constprop.0.isra.0>
	ifaddr->addr_state = NET_ADDR_PREFERRED;
 8051545:	c6 43 19 01          	movb   $0x1,0x19(%ebx)
	sys_slist_append(&active_address_lifetime_timers,
 8051549:	b8 d8 89 06 08       	mov    $0x80689d8,%eax
 805154e:	89 da                	mov    %ebx,%edx
 8051550:	e8 71 f1 ff ff       	call   80506c6 <sys_slist_append>
	net_timeout_set(&ifaddr->lifetime, vlifetime, k_uptime_get_32());
 8051555:	e8 17 f3 ff ff       	call   8050871 <k_uptime_get_32>
 805155a:	52                   	push   %edx
 805155b:	50                   	push   %eax
 805155c:	56                   	push   %esi
 805155d:	53                   	push   %ebx
 805155e:	e8 87 17 00 00       	call   8052cea <net_timeout_set>
 8051563:	83 c4 0c             	add    $0xc,%esp
	k_work_reschedule(&address_lifetime_timer, K_NO_WAIT);
 8051566:	6a 00                	push   $0x0
 8051568:	6a 00                	push   $0x0
 805156a:	68 c0 7d 06 08       	push   $0x8067dc0
 805156f:	e8 6c e7 00 00       	call   805fce0 <k_work_reschedule>
 8051574:	83 c4 10             	add    $0x10,%esp
}
 8051577:	8d 65 f8             	lea    -0x8(%ebp),%esp
 805157a:	5b                   	pop    %ebx
 805157b:	5e                   	pop    %esi
 805157c:	5d                   	pop    %ebp
	k_mutex_unlock(&lock);
 805157d:	e9 1a f3 ff ff       	jmp    805089c <k_mutex_unlock.constprop.0.isra.0>

08051582 <net_if_ipv6_addr_add>:
{
 8051582:	55                   	push   %ebp
 8051583:	89 e5                	mov    %esp,%ebp
 8051585:	57                   	push   %edi
 8051586:	56                   	push   %esi
 8051587:	53                   	push   %ebx
 8051588:	83 ec 5c             	sub    $0x5c,%esp
 805158b:	8b 45 08             	mov    0x8(%ebp),%eax
 805158e:	8b 75 10             	mov    0x10(%ebp),%esi
 8051591:	89 45 b4             	mov    %eax,-0x4c(%ebp)
 8051594:	8b 45 0c             	mov    0xc(%ebp),%eax
 8051597:	89 45 a8             	mov    %eax,-0x58(%ebp)
	k_mutex_lock(&lock, K_FOREVER);
 805159a:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 80515a0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 80515a3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 80515a8:	89 c2                	mov    %eax,%edx
 80515aa:	e8 d6 f2 ff ff       	call   8050885 <k_mutex_lock.constprop.0.isra.0>
	if (net_if_config_ipv6_get(iface, &ipv6) < 0) {
 80515af:	8d 45 c0             	lea    -0x40(%ebp),%eax
 80515b2:	53                   	push   %ebx
 80515b3:	53                   	push   %ebx
	struct net_if_addr *ifaddr = NULL;
 80515b4:	31 db                	xor    %ebx,%ebx
	if (net_if_config_ipv6_get(iface, &ipv6) < 0) {
 80515b6:	50                   	push   %eax
 80515b7:	ff 75 b4             	push   -0x4c(%ebp)
 80515ba:	e8 48 fb ff ff       	call   8051107 <net_if_config_ipv6_get>
 80515bf:	83 c4 10             	add    $0x10,%esp
 80515c2:	85 c0                	test   %eax,%eax
 80515c4:	0f 88 82 01 00 00    	js     805174c <net_if_ipv6_addr_add+0x1ca>
	ifaddr = ipv6_addr_find(iface, addr);
 80515ca:	8b 45 b4             	mov    -0x4c(%ebp),%eax
 80515cd:	8b 58 04             	mov    0x4(%eax),%ebx
		if (!ipv6->unicast[i].is_used) {
 80515d0:	f6 43 2f 02          	testb  $0x2,0x2f(%ebx)
 80515d4:	74 0f                	je     80515e5 <net_if_ipv6_addr_add+0x63>
		if (net_ipv6_addr_cmp(
 80515d6:	8b 45 a8             	mov    -0x58(%ebp),%eax
			    addr, &ipv6->unicast[i].address.in6_addr)) {
 80515d9:	8d 53 04             	lea    0x4(%ebx),%edx
		if (net_ipv6_addr_cmp(
 80515dc:	e8 77 f2 ff ff       	call   8050858 <net_ipv6_addr_cmp>
 80515e1:	84 c0                	test   %al,%al
 80515e3:	75 1c                	jne    8051601 <net_if_ipv6_addr_add+0x7f>
		if (!ipv6->unicast[i].is_used) {
 80515e5:	f6 43 5f 02          	testb  $0x2,0x5f(%ebx)
 80515e9:	74 22                	je     805160d <net_if_ipv6_addr_add+0x8b>
		if (net_ipv6_addr_cmp(
 80515eb:	8b 45 a8             	mov    -0x58(%ebp),%eax
			    addr, &ipv6->unicast[i].address.in6_addr)) {
 80515ee:	8d 53 34             	lea    0x34(%ebx),%edx
		if (net_ipv6_addr_cmp(
 80515f1:	e8 62 f2 ff ff       	call   8050858 <net_ipv6_addr_cmp>
 80515f6:	84 c0                	test   %al,%al
 80515f8:	74 13                	je     805160d <net_if_ipv6_addr_add+0x8b>
	for (i = 0; i < NET_IF_MAX_IPV6_ADDR; i++) {
 80515fa:	b8 01 00 00 00       	mov    $0x1,%eax
 80515ff:	eb 02                	jmp    8051603 <net_if_ipv6_addr_add+0x81>
 8051601:	31 c0                	xor    %eax,%eax
			return &ipv6->unicast[i];
 8051603:	6b c0 30             	imul   $0x30,%eax,%eax
 8051606:	01 c3                	add    %eax,%ebx
	if (ifaddr) {
 8051608:	e9 3f 01 00 00       	jmp    805174c <net_if_ipv6_addr_add+0x1ca>
		if (ipv6->unicast[i].is_used) {
 805160d:	8b 45 c0             	mov    -0x40(%ebp),%eax
 8051610:	89 45 b0             	mov    %eax,-0x50(%ebp)
 8051613:	f6 40 2f 02          	testb  $0x2,0x2f(%eax)
 8051617:	74 15                	je     805162e <net_if_ipv6_addr_add+0xac>
	struct net_if_addr *ifaddr = NULL;
 8051619:	31 db                	xor    %ebx,%ebx
		if (ipv6->unicast[i].is_used) {
 805161b:	f6 40 5f 02          	testb  $0x2,0x5f(%eax)
 805161f:	0f 85 27 01 00 00    	jne    805174c <net_if_ipv6_addr_add+0x1ca>
	for (i = 0; i < NET_IF_MAX_IPV6_ADDR; i++) {
 8051625:	c7 45 ac 01 00 00 00 	movl   $0x1,-0x54(%ebp)
 805162c:	eb 07                	jmp    8051635 <net_if_ipv6_addr_add+0xb3>
 805162e:	c7 45 ac 00 00 00 00 	movl   $0x0,-0x54(%ebp)
		net_if_addr_init(&ipv6->unicast[i], addr, addr_type,
 8051635:	6b 45 ac 30          	imul   $0x30,-0x54(%ebp),%eax
 8051639:	8b 5d b0             	mov    -0x50(%ebp),%ebx
	ifaddr->addr_type = addr_type;
 805163c:	89 f1                	mov    %esi,%ecx
	net_ipaddr_copy(&ifaddr->address.in6_addr, addr);
 805163e:	8d 7d c4             	lea    -0x3c(%ebp),%edi
 8051641:	8b 75 a8             	mov    -0x58(%ebp),%esi
		net_if_addr_init(&ipv6->unicast[i], addr, addr_type,
 8051644:	01 c3                	add    %eax,%ebx
	ifaddr->is_used = true;
 8051646:	89 45 a4             	mov    %eax,-0x5c(%ebp)
 8051649:	80 4b 2f 02          	orb    $0x2,0x2f(%ebx)
 805164d:	8d 43 20             	lea    0x20(%ebx),%eax
	if (vlifetime) {
 8051650:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
	ifaddr->addr_type = addr_type;
 8051654:	88 4b 2c             	mov    %cl,0x2c(%ebx)
	net_ipaddr_copy(&ifaddr->address.in6_addr, addr);
 8051657:	b9 04 00 00 00       	mov    $0x4,%ecx
	ifaddr->address.family = AF_INET6;
 805165c:	66 c7 03 02 00       	movw   $0x2,(%ebx)
	net_ipaddr_copy(&ifaddr->address.in6_addr, addr);
 8051661:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
 8051663:	8d 7b 04             	lea    0x4(%ebx),%edi
 8051666:	8d 75 c4             	lea    -0x3c(%ebp),%esi
 8051669:	b9 04 00 00 00       	mov    $0x4,%ecx
 805166e:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	if (vlifetime) {
 8051670:	8a 50 0f             	mov    0xf(%eax),%dl
 8051673:	74 16                	je     805168b <net_if_ipv6_addr_add+0x109>
		ifaddr->is_infinite = false;
 8051675:	83 e2 fe             	and    $0xfffffffe,%edx
 8051678:	88 50 0f             	mov    %dl,0xf(%eax)
		net_if_ipv6_addr_update_lifetime(ifaddr, vlifetime);
 805167b:	51                   	push   %ecx
 805167c:	51                   	push   %ecx
 805167d:	ff 75 14             	push   0x14(%ebp)
 8051680:	53                   	push   %ebx
 8051681:	e8 a7 fe ff ff       	call   805152d <net_if_ipv6_addr_update_lifetime>
 8051686:	83 c4 10             	add    $0x10,%esp
 8051689:	eb 06                	jmp    8051691 <net_if_ipv6_addr_add+0x10f>
		ifaddr->is_infinite = true;
 805168b:	83 ca 01             	or     $0x1,%edx
 805168e:	88 50 0f             	mov    %dl,0xf(%eax)
		if (!(l2_flags_get(iface) & NET_L2_POINT_TO_POINT) &&
 8051691:	8b 45 b4             	mov    -0x4c(%ebp),%eax
 8051694:	e8 e1 f0 ff ff       	call   805077a <l2_flags_get>
 8051699:	a8 08                	test   $0x8,%al
 805169b:	0f 85 9f 00 00 00    	jne    8051740 <net_if_ipv6_addr_add+0x1be>
		    !net_ipv6_is_addr_loopback(addr)) {
 80516a1:	8b 45 a8             	mov    -0x58(%ebp),%eax
 80516a4:	e8 77 f0 ff ff       	call   8050720 <net_ipv6_is_addr_loopback>
		if (!(l2_flags_get(iface) & NET_L2_POINT_TO_POINT) &&
 80516a9:	84 c0                	test   %al,%al
 80516ab:	0f 85 8f 00 00 00    	jne    8051740 <net_if_ipv6_addr_add+0x1be>
	flags = l2_flags_get(iface);
 80516b1:	8b 45 b4             	mov    -0x4c(%ebp),%eax
 80516b4:	e8 c1 f0 ff ff       	call   805077a <l2_flags_get>
 80516b9:	89 c6                	mov    %eax,%esi
	if (flags & NET_L2_MULTICAST) {
 80516bb:	a8 01                	test   $0x1,%al
 80516bd:	74 75                	je     8051734 <net_if_ipv6_addr_add+0x1b2>
	ret = net_ipv6_mld_join(iface, &addr);
 80516bf:	8d 7d d4             	lea    -0x2c(%ebp),%edi
 80516c2:	52                   	push   %edx
 80516c3:	52                   	push   %edx
 80516c4:	57                   	push   %edi
 80516c5:	ff 75 b4             	push   -0x4c(%ebp)
					uint16_t addr0, uint16_t addr1,
					uint16_t addr2, uint16_t addr3,
					uint16_t addr4, uint16_t addr5,
					uint16_t addr6, uint16_t addr7)
{
	UNALIGNED_PUT(htons(addr0), &addr->s6_addr16[0]);
 80516c8:	c7 45 d4 ff 02 00 00 	movl   $0x2ff,-0x2c(%ebp)
	UNALIGNED_PUT(htons(addr1), &addr->s6_addr16[1]);
	UNALIGNED_PUT(htons(addr2), &addr->s6_addr16[2]);
 80516cf:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	UNALIGNED_PUT(htons(addr3), &addr->s6_addr16[3]);
	UNALIGNED_PUT(htons(addr4), &addr->s6_addr16[4]);
 80516d6:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	UNALIGNED_PUT(htons(addr5), &addr->s6_addr16[5]);
	UNALIGNED_PUT(htons(addr6), &addr->s6_addr16[6]);
 80516dd:	c7 45 e0 00 00 00 01 	movl   $0x1000000,-0x20(%ebp)
 80516e4:	e8 af 85 00 00       	call   8059c98 <net_ipv6_mld_join>
 80516e9:	83 c4 10             	add    $0x10,%esp
		if (!(flags & NET_L2_MULTICAST_SKIP_JOIN_SOLICIT_NODE)) {
 80516ec:	83 e6 02             	and    $0x2,%esi
 80516ef:	75 43                	jne    8051734 <net_if_ipv6_addr_add+0x1b2>
	dst->s6_addr[13]  = src->s6_addr[13];
 80516f1:	6b 45 ac 30          	imul   $0x30,-0x54(%ebp),%eax
 80516f5:	8b 4d b0             	mov    -0x50(%ebp),%ecx
	dst->s6_addr[0]   = 0xFF;
 80516f8:	c7 45 d4 ff 02 00 00 	movl   $0x2ff,-0x2c(%ebp)
	UNALIGNED_PUT(0, &dst->s6_addr16[2]);
 80516ff:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	UNALIGNED_PUT(0, &dst->s6_addr16[4]);
 8051706:	c7 45 dc 00 00 00 01 	movl   $0x1000000,-0x24(%ebp)
	dst->s6_addr[12]  = 0xFF;
 805170d:	c6 45 e0 ff          	movb   $0xff,-0x20(%ebp)
	dst->s6_addr[13]  = src->s6_addr[13];
 8051711:	8a 44 01 11          	mov    0x11(%ecx,%eax,1),%al
 8051715:	88 45 e1             	mov    %al,-0x1f(%ebp)
	UNALIGNED_PUT(UNALIGNED_GET(&src->s6_addr16[7]), &dst->s6_addr16[7]);
 8051718:	89 c8                	mov    %ecx,%eax
 805171a:	8b 4d a4             	mov    -0x5c(%ebp),%ecx
 805171d:	66 8b 44 08 12       	mov    0x12(%eax,%ecx,1),%ax
 8051722:	66 89 45 e2          	mov    %ax,-0x1e(%ebp)
	ret = net_ipv6_mld_join(iface, &addr);
 8051726:	50                   	push   %eax
 8051727:	50                   	push   %eax
 8051728:	57                   	push   %edi
 8051729:	ff 75 b4             	push   -0x4c(%ebp)
 805172c:	e8 67 85 00 00       	call   8059c98 <net_ipv6_mld_join>
 8051731:	83 c4 10             	add    $0x10,%esp
			net_if_ipv6_start_dad(iface, &ipv6->unicast[i]);
 8051734:	8b 45 b4             	mov    -0x4c(%ebp),%eax
 8051737:	89 da                	mov    %ebx,%edx
 8051739:	e8 d0 f5 ff ff       	call   8050d0e <net_if_ipv6_start_dad>
 805173e:	eb 0c                	jmp    805174c <net_if_ipv6_addr_add+0x1ca>
			ipv6->unicast[i].addr_state = NET_ADDR_PREFERRED;
 8051740:	6b 45 ac 30          	imul   $0x30,-0x54(%ebp),%eax
 8051744:	8b 7d b0             	mov    -0x50(%ebp),%edi
 8051747:	c6 44 07 2d 01       	movb   $0x1,0x2d(%edi,%eax,1)
	k_mutex_unlock(&lock);
 805174c:	e8 4b f1 ff ff       	call   805089c <k_mutex_unlock.constprop.0.isra.0>
}
 8051751:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8051754:	65 2b 05 14 00 00 00 	sub    %gs:0x14,%eax
 805175b:	74 05                	je     8051762 <net_if_ipv6_addr_add+0x1e0>
 805175d:	e8 9e 7b ff ff       	call   8049300 <__stack_chk_fail@plt>
 8051762:	8d 65 f4             	lea    -0xc(%ebp),%esp
 8051765:	89 d8                	mov    %ebx,%eax
 8051767:	5b                   	pop    %ebx
 8051768:	5e                   	pop    %esi
 8051769:	5f                   	pop    %edi
 805176a:	5d                   	pop    %ebp
 805176b:	c3                   	ret    

0805176c <net_if_start_dad>:
{
 805176c:	55                   	push   %ebp
	struct in6_addr addr = { };
 805176d:	b9 04 00 00 00       	mov    $0x4,%ecx
{
 8051772:	89 e5                	mov    %esp,%ebp
 8051774:	57                   	push   %edi
 8051775:	56                   	push   %esi
	struct in6_addr addr = { };
 8051776:	8d 7d d4             	lea    -0x2c(%ebp),%edi
{
 8051779:	53                   	push   %ebx
 805177a:	83 ec 3c             	sub    $0x3c,%esp
 805177d:	8b 75 08             	mov    0x8(%ebp),%esi
 8051780:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 8051786:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 8051789:	31 c0                	xor    %eax,%eax
	struct in6_addr addr = { };
 805178b:	f3 ab                	rep stos %eax,%es:(%edi)
	k_mutex_lock(&lock, K_FOREVER);
 805178d:	83 c8 ff             	or     $0xffffffff,%eax
 8051790:	89 c2                	mov    %eax,%edx
 8051792:	e8 ee f0 ff ff       	call   8050885 <k_mutex_lock.constprop.0.isra.0>
	ret = net_if_config_ipv6_get(iface, &ipv6);
 8051797:	50                   	push   %eax
 8051798:	50                   	push   %eax
 8051799:	8d 45 d0             	lea    -0x30(%ebp),%eax
 805179c:	50                   	push   %eax
 805179d:	56                   	push   %esi
 805179e:	e8 64 f9 ff ff       	call   8051107 <net_if_config_ipv6_get>
 80517a3:	83 c4 10             	add    $0x10,%esp
	if (ret < 0) {
 80517a6:	85 c0                	test   %eax,%eax
 80517a8:	79 1a                	jns    80517c4 <net_if_start_dad+0x58>
	k_mutex_unlock(&lock);
 80517aa:	e8 ed f0 ff ff       	call   805089c <k_mutex_unlock.constprop.0.isra.0>
}
 80517af:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 80517b2:	65 2b 05 14 00 00 00 	sub    %gs:0x14,%eax
 80517b9:	0f 84 0f 01 00 00    	je     80518ce <net_if_start_dad+0x162>
 80517bf:	e8 3c 7b ff ff       	call   8049300 <__stack_chk_fail@plt>
	if (!ipv6) {
 80517c4:	8b 5d d0             	mov    -0x30(%ebp),%ebx
 80517c7:	85 db                	test   %ebx,%ebx
 80517c9:	74 df                	je     80517aa <net_if_start_dad+0x3e>
	return &iface->if_dev->link_addr;
 80517cb:	8b 06                	mov    (%esi),%eax
 *  @param lladdr Link local address
 */
static inline void net_ipv6_addr_create_iid(struct in6_addr *addr,
					    struct net_linkaddr *lladdr)
{
	UNALIGNED_PUT(htonl(0xfe800000), &addr->s6_addr32[0]);
 80517cd:	c7 45 d4 fe 80 00 00 	movl   $0x80fe,-0x2c(%ebp)
	UNALIGNED_PUT(0, &addr->s6_addr32[1]);
 80517d4:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)

	switch (lladdr->len) {
 80517db:	8a 50 14             	mov    0x14(%eax),%dl
 80517de:	80 fa 06             	cmp    $0x6,%dl
 80517e1:	74 2d                	je     8051810 <net_if_start_dad+0xa4>
 80517e3:	80 fa 08             	cmp    $0x8,%dl
 80517e6:	74 58                	je     8051840 <net_if_start_dad+0xd4>
 80517e8:	80 fa 02             	cmp    $0x2,%dl
 80517eb:	75 67                	jne    8051854 <net_if_start_dad+0xe8>
	case 2:
		/* The generated IPv6 shall not toggle the
		 * Universal/Local bit. RFC 6282 ch 3.2.2
		 */
		if (lladdr->type == NET_LINK_IEEE802154) {
 80517ed:	80 78 15 01          	cmpb   $0x1,0x15(%eax)
 80517f1:	75 61                	jne    8051854 <net_if_start_dad+0xe8>
			UNALIGNED_PUT(0, &addr->s6_addr32[2]);
			addr->s6_addr[11] = 0xff;
			addr->s6_addr[12] = 0xfe;
			addr->s6_addr[13] = 0U;
			addr->s6_addr[14] = lladdr->addr[0];
 80517f3:	8b 40 10             	mov    0x10(%eax),%eax
			UNALIGNED_PUT(0, &addr->s6_addr32[2]);
 80517f6:	c7 45 dc 00 00 00 ff 	movl   $0xff000000,-0x24(%ebp)
			addr->s6_addr[12] = 0xfe;
 80517fd:	66 c7 45 e0 fe 00    	movw   $0xfe,-0x20(%ebp)
			addr->s6_addr[14] = lladdr->addr[0];
 8051803:	8a 10                	mov    (%eax),%dl
 8051805:	88 55 e2             	mov    %dl,-0x1e(%ebp)
			addr->s6_addr[15] = lladdr->addr[1];
 8051808:	8a 40 01             	mov    0x1(%eax),%al
 805180b:	88 45 e3             	mov    %al,-0x1d(%ebp)
 805180e:	eb 44                	jmp    8051854 <net_if_start_dad+0xe8>
		break;
	case 6:
		/* We do not toggle the Universal/Local bit
		 * in Bluetooth. See RFC 7668 ch 3.2.2
		 */
		memcpy(&addr->s6_addr[8], lladdr->addr, 3);
 8051810:	8b 48 10             	mov    0x10(%eax),%ecx
		if (lladdr->type == NET_LINK_BLUETOOTH) {
			addr->s6_addr[8] ^= 0x02;
		}
#endif

		if (lladdr->type == NET_LINK_ETHERNET) {
 8051813:	80 78 15 03          	cmpb   $0x3,0x15(%eax)
 8051817:	66 8b 11             	mov    (%ecx),%dx
 805181a:	66 89 55 dc          	mov    %dx,-0x24(%ebp)
 805181e:	8a 51 02             	mov    0x2(%ecx),%dl
		addr->s6_addr[11] = 0xff;
 8051821:	66 c7 45 df ff fe    	movw   $0xfeff,-0x21(%ebp)
 8051827:	88 55 de             	mov    %dl,-0x22(%ebp)
 805182a:	66 8b 51 03          	mov    0x3(%ecx),%dx
 805182e:	66 89 55 e1          	mov    %dx,-0x1f(%ebp)
 8051832:	8a 51 05             	mov    0x5(%ecx),%dl
 8051835:	88 55 e3             	mov    %dl,-0x1d(%ebp)
		if (lladdr->type == NET_LINK_ETHERNET) {
 8051838:	75 1a                	jne    8051854 <net_if_start_dad+0xe8>
			addr->s6_addr[8] ^= 0x02;
 805183a:	80 75 dc 02          	xorb   $0x2,-0x24(%ebp)
 805183e:	eb 14                	jmp    8051854 <net_if_start_dad+0xe8>
 8051840:	8b 50 10             	mov    0x10(%eax),%edx
 8051843:	8b 02                	mov    (%edx),%eax
 8051845:	8b 52 04             	mov    0x4(%edx),%edx
 8051848:	89 45 dc             	mov    %eax,-0x24(%ebp)
		}

		break;
	case 8:
		memcpy(&addr->s6_addr[8], lladdr->addr, lladdr->len);
		addr->s6_addr[8] ^= 0x02;
 805184b:	83 f0 02             	xor    $0x2,%eax
 805184e:	89 55 e0             	mov    %edx,-0x20(%ebp)
 8051851:	88 45 dc             	mov    %al,-0x24(%ebp)
	ifaddr = net_if_ipv6_addr_add(iface, &addr, NET_ADDR_AUTOCONF, 0);
 8051854:	8d 45 d4             	lea    -0x2c(%ebp),%eax
 8051857:	6a 00                	push   $0x0
 8051859:	6a 01                	push   $0x1
 805185b:	50                   	push   %eax
 805185c:	56                   	push   %esi
 805185d:	e8 20 fd ff ff       	call   8051582 <net_if_ipv6_addr_add>
 8051862:	83 c4 10             	add    $0x10,%esp
 8051865:	89 c7                	mov    %eax,%edi
		if (!ipv6->unicast[i].is_used ||
 8051867:	f6 43 2f 02          	testb  $0x2,0x2f(%ebx)
 805186b:	74 1f                	je     805188c <net_if_start_dad+0x120>
 805186d:	66 83 3b 02          	cmpw   $0x2,(%ebx)
 8051871:	75 19                	jne    805188c <net_if_start_dad+0x120>
		    ipv6->unicast[i].address.family != AF_INET6 ||
 8051873:	39 c3                	cmp    %eax,%ebx
 8051875:	74 15                	je     805188c <net_if_start_dad+0x120>
		    net_ipv6_is_addr_loopback(
 8051877:	8d 43 04             	lea    0x4(%ebx),%eax
 805187a:	e8 a1 ee ff ff       	call   8050720 <net_ipv6_is_addr_loopback>
		    &ipv6->unicast[i] == ifaddr ||
 805187f:	84 c0                	test   %al,%al
 8051881:	75 09                	jne    805188c <net_if_start_dad+0x120>
		net_if_ipv6_start_dad(iface, &ipv6->unicast[i]);
 8051883:	89 da                	mov    %ebx,%edx
 8051885:	89 f0                	mov    %esi,%eax
 8051887:	e8 82 f4 ff ff       	call   8050d0e <net_if_ipv6_start_dad>
		if (!ipv6->unicast[i].is_used ||
 805188c:	f6 43 5f 02          	testb  $0x2,0x5f(%ebx)
 8051890:	0f 84 14 ff ff ff    	je     80517aa <net_if_start_dad+0x3e>
 8051896:	66 83 7b 30 02       	cmpw   $0x2,0x30(%ebx)
 805189b:	0f 85 09 ff ff ff    	jne    80517aa <net_if_start_dad+0x3e>
		    &ipv6->unicast[i] == ifaddr ||
 80518a1:	8d 53 30             	lea    0x30(%ebx),%edx
		    ipv6->unicast[i].address.family != AF_INET6 ||
 80518a4:	39 d7                	cmp    %edx,%edi
 80518a6:	89 55 c4             	mov    %edx,-0x3c(%ebp)
 80518a9:	0f 84 fb fe ff ff    	je     80517aa <net_if_start_dad+0x3e>
		    net_ipv6_is_addr_loopback(
 80518af:	8d 43 34             	lea    0x34(%ebx),%eax
 80518b2:	e8 69 ee ff ff       	call   8050720 <net_ipv6_is_addr_loopback>
		    &ipv6->unicast[i] == ifaddr ||
 80518b7:	84 c0                	test   %al,%al
 80518b9:	0f 85 eb fe ff ff    	jne    80517aa <net_if_start_dad+0x3e>
		net_if_ipv6_start_dad(iface, &ipv6->unicast[i]);
 80518bf:	8b 55 c4             	mov    -0x3c(%ebp),%edx
 80518c2:	89 f0                	mov    %esi,%eax
 80518c4:	e8 45 f4 ff ff       	call   8050d0e <net_if_ipv6_start_dad>
	for (i = 0; i < NET_IF_MAX_IPV6_ADDR; i++) {
 80518c9:	e9 dc fe ff ff       	jmp    80517aa <net_if_start_dad+0x3e>
}
 80518ce:	8d 65 f4             	lea    -0xc(%ebp),%esp
 80518d1:	5b                   	pop    %ebx
 80518d2:	5e                   	pop    %esi
 80518d3:	5f                   	pop    %edi
 80518d4:	5d                   	pop    %ebp
 80518d5:	c3                   	ret    

080518d6 <update_operational_state>:
	return "";
#endif /* CONFIG_NET_IF_LOG_LEVEL >= LOG_LEVEL_DBG */
}

static void update_operational_state(struct net_if *iface)
{
 80518d6:	55                   	push   %ebp
 */
static inline bool net_if_is_admin_up(struct net_if *iface)
{
	NET_ASSERT(iface);

	return net_if_flag_is_set(iface, NET_IF_UP);
 80518d7:	31 d2                	xor    %edx,%edx
 80518d9:	89 e5                	mov    %esp,%ebp
 80518db:	56                   	push   %esi
 80518dc:	89 c6                	mov    %eax,%esi
 80518de:	53                   	push   %ebx
	enum net_if_oper_state prev_state = iface->if_dev->oper_state;
 80518df:	8b 00                	mov    (%eax),%eax
 80518e1:	8a 58 1a             	mov    0x1a(%eax),%bl
 80518e4:	89 f0                	mov    %esi,%eax
 80518e6:	e8 0f f4 ff ff       	call   8050cfa <net_if_flag_is_set>
	enum net_if_oper_state new_state = NET_IF_OPER_UNKNOWN;

	if (!net_if_is_admin_up(iface)) {
 80518eb:	84 c0                	test   %al,%al
 80518ed:	75 04                	jne    80518f3 <update_operational_state+0x1d>
		new_state = NET_IF_OPER_DOWN;
 80518ef:	b0 02                	mov    $0x2,%al
 80518f1:	eb 22                	jmp    8051915 <update_operational_state+0x3f>
 */
static inline bool net_if_is_carrier_ok(struct net_if *iface)
{
	NET_ASSERT(iface);

	return net_if_flag_is_set(iface, NET_IF_LOWER_UP);
 80518f3:	ba 09 00 00 00       	mov    $0x9,%edx
 80518f8:	89 f0                	mov    %esi,%eax
 80518fa:	e8 fb f3 ff ff       	call   8050cfa <net_if_flag_is_set>
		goto exit;
	}

	if (!net_if_is_carrier_ok(iface)) {
 80518ff:	84 c0                	test   %al,%al
 8051901:	74 ec                	je     80518ef <update_operational_state+0x19>
 */
static inline bool net_if_is_dormant(struct net_if *iface)
{
	NET_ASSERT(iface);

	return net_if_flag_is_set(iface, NET_IF_DORMANT);
 8051903:	ba 0a 00 00 00       	mov    $0xa,%edx
 8051908:	89 f0                	mov    %esi,%eax
 805190a:	e8 eb f3 ff ff       	call   8050cfa <net_if_flag_is_set>
 805190f:	89 c2                	mov    %eax,%edx
		}

		goto exit;
	}

	if (net_if_is_dormant(iface)) {
 8051911:	b0 06                	mov    $0x6,%al
 8051913:	29 d0                	sub    %edx,%eax
		iface->if_dev->oper_state = oper_state;
 8051915:	8b 16                	mov    (%esi),%edx
 8051917:	88 42 1a             	mov    %al,0x1a(%edx)
	return iface->if_dev->oper_state;
 805191a:	8b 0e                	mov    (%esi),%ecx
	}

	new_state = NET_IF_OPER_UP;

exit:
	if (net_if_oper_state_set(iface, new_state) != new_state) {
 805191c:	3a 41 1a             	cmp    0x1a(%ecx),%al
 805191f:	75 64                	jne    8051985 <update_operational_state+0xaf>
		iface, net_if_oper_state2str(net_if_oper_state(iface)),
		net_if_is_admin_up(iface) ? "UP" : "DOWN",
		net_if_is_carrier_ok(iface) ? "ON" : "OFF",
		net_if_is_dormant(iface) ? "ON" : "OFF");

	if (net_if_oper_state(iface) == NET_IF_OPER_UP) {
 8051921:	3c 06                	cmp    $0x6,%al
 8051923:	75 42                	jne    8051967 <update_operational_state+0x91>
		if (prev_state != NET_IF_OPER_UP) {
 8051925:	80 fb 06             	cmp    $0x6,%bl
 8051928:	74 5b                	je     8051985 <update_operational_state+0xaf>
	net_if_flag_set(iface, NET_IF_RUNNING);
 805192a:	89 c8                	mov    %ecx,%eax
 805192c:	ba 08 00 00 00       	mov    $0x8,%edx
 8051931:	e8 d6 f5 ff ff       	call   8050f0c <net_if_flag_set.isra.0>
	    !(l2_flags_get(iface) & NET_L2_POINT_TO_POINT)) {
 8051936:	89 f0                	mov    %esi,%eax
 8051938:	e8 3d ee ff ff       	call   805077a <l2_flags_get>
	if (!is_iface_offloaded(iface) &&
 805193d:	a8 08                	test   $0x8,%al
 805193f:	75 44                	jne    8051985 <update_operational_state+0xaf>
	if (!net_if_flag_is_set(iface, NET_IF_IPV6)) {
 8051941:	ba 07 00 00 00       	mov    $0x7,%edx
 8051946:	89 f0                	mov    %esi,%eax
 8051948:	e8 ad f3 ff ff       	call   8050cfa <net_if_flag_is_set>
 805194d:	84 c0                	test   %al,%al
 805194f:	74 34                	je     8051985 <update_operational_state+0xaf>
		net_if_start_dad(iface);
 8051951:	83 ec 0c             	sub    $0xc,%esp
 8051954:	56                   	push   %esi
 8051955:	e8 12 fe ff ff       	call   805176c <net_if_start_dad>
	net_if_start_rs(iface);
 805195a:	89 34 24             	mov    %esi,(%esp)
 805195d:	e8 1e f8 ff ff       	call   8051180 <net_if_start_rs>
 8051962:	83 c4 10             	add    $0x10,%esp
 8051965:	eb 1e                	jmp    8051985 <update_operational_state+0xaf>
			notify_iface_up(iface);
		}
	} else {
		if (prev_state == NET_IF_OPER_UP) {
 8051967:	80 fb 06             	cmp    $0x6,%bl
 805196a:	75 19                	jne    8051985 <update_operational_state+0xaf>
	net_if_flag_clear(iface, NET_IF_RUNNING);
 805196c:	89 c8                	mov    %ecx,%eax
 805196e:	ba 08 00 00 00       	mov    $0x8,%edx
 8051973:	e8 80 f5 ff ff       	call   8050ef8 <net_if_flag_clear.isra.0>
			notify_iface_down(iface);
		}
	}
}
 8051978:	8d 65 f8             	lea    -0x8(%ebp),%esp
	    !(l2_flags_get(iface) & NET_L2_POINT_TO_POINT)) {
 805197b:	89 f0                	mov    %esi,%eax
}
 805197d:	5b                   	pop    %ebx
 805197e:	5e                   	pop    %esi
 805197f:	5d                   	pop    %ebp
	    !(l2_flags_get(iface) & NET_L2_POINT_TO_POINT)) {
 8051980:	e9 f5 ed ff ff       	jmp    805077a <l2_flags_get>
}
 8051985:	8d 65 f8             	lea    -0x8(%ebp),%esp
 8051988:	5b                   	pop    %ebx
 8051989:	5e                   	pop    %esi
 805198a:	5d                   	pop    %ebp
 805198b:	c3                   	ret    

0805198c <net_if_ipv6_maddr_rm>:
{
 805198c:	55                   	push   %ebp
	k_mutex_lock(&lock, K_FOREVER);
 805198d:	83 c8 ff             	or     $0xffffffff,%eax
 8051990:	89 c2                	mov    %eax,%edx
{
 8051992:	89 e5                	mov    %esp,%ebp
 8051994:	57                   	push   %edi
 8051995:	56                   	push   %esi
 8051996:	53                   	push   %ebx
 8051997:	83 ec 1c             	sub    $0x1c,%esp
	k_mutex_lock(&lock, K_FOREVER);
 805199a:	e8 e6 ee ff ff       	call   8050885 <k_mutex_lock.constprop.0.isra.0>
	ipv6 = iface->config.ip.ipv6;
 805199f:	8b 45 08             	mov    0x8(%ebp),%eax
 80519a2:	8b 78 04             	mov    0x4(%eax),%edi
	bool ret = false;
 80519a5:	31 c0                	xor    %eax,%eax
	if (!ipv6) {
 80519a7:	85 ff                	test   %edi,%edi
 80519a9:	74 40                	je     80519eb <net_if_ipv6_maddr_rm+0x5f>
 80519ab:	8d 77 64             	lea    0x64(%edi),%esi
	for (i = 0; i < NET_IF_MAX_IPV6_MADDR; i++) {
 80519ae:	31 db                	xor    %ebx,%ebx
		if (!ipv6->mcast[i].is_used) {
 80519b0:	6b c3 18             	imul   $0x18,%ebx,%eax
 80519b3:	8d 4c 07 70          	lea    0x70(%edi,%eax,1),%ecx
 80519b7:	8a 41 04             	mov    0x4(%ecx),%al
 80519ba:	89 4d e0             	mov    %ecx,-0x20(%ebp)
 80519bd:	88 45 e7             	mov    %al,-0x19(%ebp)
 80519c0:	a8 01                	test   $0x1,%al
 80519c2:	74 1c                	je     80519e0 <net_if_ipv6_maddr_rm+0x54>
		if (!net_ipv6_addr_cmp(&ipv6->mcast[i].address.in6_addr,
 80519c4:	8b 55 0c             	mov    0xc(%ebp),%edx
 80519c7:	89 f0                	mov    %esi,%eax
 80519c9:	e8 8a ee ff ff       	call   8050858 <net_ipv6_addr_cmp>
 80519ce:	84 c0                	test   %al,%al
 80519d0:	74 0e                	je     80519e0 <net_if_ipv6_maddr_rm+0x54>
		ipv6->mcast[i].is_used = false;
 80519d2:	8a 55 e7             	mov    -0x19(%ebp),%dl
 80519d5:	8b 4d e0             	mov    -0x20(%ebp),%ecx
 80519d8:	83 e2 fe             	and    $0xfffffffe,%edx
 80519db:	88 51 04             	mov    %dl,0x4(%ecx)
		goto out;
 80519de:	eb 0b                	jmp    80519eb <net_if_ipv6_maddr_rm+0x5f>
	for (i = 0; i < NET_IF_MAX_IPV6_MADDR; i++) {
 80519e0:	43                   	inc    %ebx
 80519e1:	83 c6 18             	add    $0x18,%esi
 80519e4:	83 fb 03             	cmp    $0x3,%ebx
 80519e7:	75 c7                	jne    80519b0 <net_if_ipv6_maddr_rm+0x24>
	bool ret = false;
 80519e9:	31 c0                	xor    %eax,%eax
 80519eb:	88 45 e7             	mov    %al,-0x19(%ebp)
	k_mutex_unlock(&lock);
 80519ee:	e8 a9 ee ff ff       	call   805089c <k_mutex_unlock.constprop.0.isra.0>
}
 80519f3:	8a 45 e7             	mov    -0x19(%ebp),%al
 80519f6:	83 c4 1c             	add    $0x1c,%esp
 80519f9:	5b                   	pop    %ebx
 80519fa:	5e                   	pop    %esi
 80519fb:	5f                   	pop    %edi
 80519fc:	5d                   	pop    %ebp
 80519fd:	c3                   	ret    

080519fe <net_if_ipv6_addr_rm>:
{
 80519fe:	55                   	push   %ebp
 80519ff:	89 e5                	mov    %esp,%ebp
 8051a01:	57                   	push   %edi
 8051a02:	56                   	push   %esi
 8051a03:	53                   	push   %ebx
 8051a04:	83 ec 3c             	sub    $0x3c,%esp
 8051a07:	8b 45 08             	mov    0x8(%ebp),%eax
 8051a0a:	8b 75 0c             	mov    0xc(%ebp),%esi
 8051a0d:	89 45 c4             	mov    %eax,-0x3c(%ebp)
	k_mutex_lock(&lock, K_FOREVER);
 8051a10:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 8051a16:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 8051a19:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 8051a1e:	89 c2                	mov    %eax,%edx
 8051a20:	e8 60 ee ff ff       	call   8050885 <k_mutex_lock.constprop.0.isra.0>
	ipv6 = iface->config.ip.ipv6;
 8051a25:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 8051a28:	8b 78 04             	mov    0x4(%eax),%edi
	bool ret = false;
 8051a2b:	31 c0                	xor    %eax,%eax
	if (!ipv6) {
 8051a2d:	85 ff                	test   %edi,%edi
 8051a2f:	0f 84 a6 00 00 00    	je     8051adb <net_if_ipv6_addr_rm+0xdd>
		if (!ipv6->unicast[i].is_used) {
 8051a35:	f6 47 2f 02          	testb  $0x2,0x2f(%edi)
 8051a39:	74 10                	je     8051a4b <net_if_ipv6_addr_rm+0x4d>
		if (!net_ipv6_addr_cmp(&ipv6->unicast[i].address.in6_addr,
 8051a3b:	8d 47 04             	lea    0x4(%edi),%eax
 8051a3e:	89 f2                	mov    %esi,%edx
	for (i = 0; i < NET_IF_MAX_IPV6_ADDR; i++) {
 8051a40:	31 db                	xor    %ebx,%ebx
		if (!net_ipv6_addr_cmp(&ipv6->unicast[i].address.in6_addr,
 8051a42:	e8 11 ee ff ff       	call   8050858 <net_ipv6_addr_cmp>
 8051a47:	84 c0                	test   %al,%al
 8051a49:	75 1d                	jne    8051a68 <net_if_ipv6_addr_rm+0x6a>
		if (!ipv6->unicast[i].is_used) {
 8051a4b:	f6 47 5f 02          	testb  $0x2,0x5f(%edi)
 8051a4f:	74 13                	je     8051a64 <net_if_ipv6_addr_rm+0x66>
		if (!net_ipv6_addr_cmp(&ipv6->unicast[i].address.in6_addr,
 8051a51:	8d 47 34             	lea    0x34(%edi),%eax
 8051a54:	89 f2                	mov    %esi,%edx
	for (i = 0; i < NET_IF_MAX_IPV6_ADDR; i++) {
 8051a56:	bb 01 00 00 00       	mov    $0x1,%ebx
		if (!net_ipv6_addr_cmp(&ipv6->unicast[i].address.in6_addr,
 8051a5b:	e8 f8 ed ff ff       	call   8050858 <net_ipv6_addr_cmp>
 8051a60:	84 c0                	test   %al,%al
 8051a62:	75 04                	jne    8051a68 <net_if_ipv6_addr_rm+0x6a>
	bool ret = false;
 8051a64:	31 c0                	xor    %eax,%eax
out:
 8051a66:	eb 73                	jmp    8051adb <net_if_ipv6_addr_rm+0xdd>
		if (!ipv6->unicast[i].is_infinite) {
 8051a68:	6b c3 30             	imul   $0x30,%ebx,%eax
 8051a6b:	f6 44 07 2f 01       	testb  $0x1,0x2f(%edi,%eax,1)
 8051a70:	75 27                	jne    8051a99 <net_if_ipv6_addr_rm+0x9b>
			sys_slist_find_and_remove(
 8051a72:	8d 54 07 14          	lea    0x14(%edi,%eax,1),%edx
 8051a76:	b8 d8 89 06 08       	mov    $0x80689d8,%eax
 8051a7b:	e8 5f ec ff ff       	call   80506df <sys_slist_find_and_remove>
			if (sys_slist_is_empty(
 8051a80:	83 3d d8 89 06 08 00 	cmpl   $0x0,0x80689d8
 8051a87:	75 10                	jne    8051a99 <net_if_ipv6_addr_rm+0x9b>
				k_work_cancel_delayable(
 8051a89:	83 ec 0c             	sub    $0xc,%esp
 8051a8c:	68 c0 7d 06 08       	push   $0x8067dc0
 8051a91:	e8 68 e2 00 00       	call   805fcfe <k_work_cancel_delayable>
 8051a96:	83 c4 10             	add    $0x10,%esp
		ipv6->unicast[i].is_used = false;
 8051a99:	6b db 30             	imul   $0x30,%ebx,%ebx
	dst->s6_addr[0]   = 0xFF;
 8051a9c:	c7 45 d4 ff 02 00 00 	movl   $0x2ff,-0x2c(%ebp)
	UNALIGNED_PUT(0, &dst->s6_addr16[2]);
 8051aa3:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	UNALIGNED_PUT(0, &dst->s6_addr16[4]);
 8051aaa:	c7 45 dc 00 00 00 01 	movl   $0x1000000,-0x24(%ebp)
 8051ab1:	80 64 1f 2f fd       	andb   $0xfd,0x2f(%edi,%ebx,1)
	dst->s6_addr[13]  = src->s6_addr[13];
 8051ab6:	8a 46 0d             	mov    0xd(%esi),%al
	dst->s6_addr[12]  = 0xFF;
 8051ab9:	c6 45 e0 ff          	movb   $0xff,-0x20(%ebp)
	dst->s6_addr[13]  = src->s6_addr[13];
 8051abd:	88 45 e1             	mov    %al,-0x1f(%ebp)
	UNALIGNED_PUT(UNALIGNED_GET(&src->s6_addr16[7]), &dst->s6_addr16[7]);
 8051ac0:	66 8b 46 0e          	mov    0xe(%esi),%ax
 8051ac4:	66 89 45 e2          	mov    %ax,-0x1e(%ebp)
		net_if_ipv6_maddr_rm(iface, &maddr);
 8051ac8:	50                   	push   %eax
 8051ac9:	50                   	push   %eax
 8051aca:	8d 45 d4             	lea    -0x2c(%ebp),%eax
 8051acd:	50                   	push   %eax
 8051ace:	ff 75 c4             	push   -0x3c(%ebp)
 8051ad1:	e8 b6 fe ff ff       	call   805198c <net_if_ipv6_maddr_rm>
 8051ad6:	83 c4 10             	add    $0x10,%esp
		ret = true;
 8051ad9:	b0 01                	mov    $0x1,%al
 8051adb:	88 45 c4             	mov    %al,-0x3c(%ebp)
	k_mutex_unlock(&lock);
 8051ade:	e8 b9 ed ff ff       	call   805089c <k_mutex_unlock.constprop.0.isra.0>
}
 8051ae3:	8a 45 c4             	mov    -0x3c(%ebp),%al
 8051ae6:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 8051ae9:	65 2b 15 14 00 00 00 	sub    %gs:0x14,%edx
 8051af0:	74 05                	je     8051af7 <net_if_ipv6_addr_rm+0xf9>
 8051af2:	e8 09 78 ff ff       	call   8049300 <__stack_chk_fail@plt>
 8051af7:	8d 65 f4             	lea    -0xc(%ebp),%esp
 8051afa:	5b                   	pop    %ebx
 8051afb:	5e                   	pop    %esi
 8051afc:	5f                   	pop    %edi
 8051afd:	5d                   	pop    %ebp
 8051afe:	c3                   	ret    

08051aff <net_if_ipv6_dad_failed>:
{
 8051aff:	55                   	push   %ebp
	k_mutex_lock(&lock, K_FOREVER);
 8051b00:	83 c8 ff             	or     $0xffffffff,%eax
{
 8051b03:	89 e5                	mov    %esp,%ebp
 8051b05:	53                   	push   %ebx
 8051b06:	52                   	push   %edx
	k_mutex_lock(&lock, K_FOREVER);
 8051b07:	89 c2                	mov    %eax,%edx
{
 8051b09:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	k_mutex_lock(&lock, K_FOREVER);
 8051b0c:	e8 74 ed ff ff       	call   8050885 <k_mutex_lock.constprop.0.isra.0>
	ifaddr = net_if_ipv6_addr_lookup(addr, &iface);
 8051b11:	8d 45 08             	lea    0x8(%ebp),%eax
 8051b14:	51                   	push   %ecx
 8051b15:	51                   	push   %ecx
 8051b16:	50                   	push   %eax
 8051b17:	53                   	push   %ebx
 8051b18:	e8 02 f8 ff ff       	call   805131f <net_if_ipv6_addr_lookup>
 8051b1d:	83 c4 10             	add    $0x10,%esp
	if (!ifaddr) {
 8051b20:	85 c0                	test   %eax,%eax
 8051b22:	74 1b                	je     8051b3f <net_if_ipv6_dad_failed+0x40>
	sys_slist_find_and_remove(&active_dad_timers, &ifaddr->dad_node);
 8051b24:	8d 50 24             	lea    0x24(%eax),%edx
 8051b27:	b8 c8 89 06 08       	mov    $0x80689c8,%eax
 8051b2c:	e8 ae eb ff ff       	call   80506df <sys_slist_find_and_remove>
	net_if_ipv6_addr_rm(iface, addr);
 8051b31:	50                   	push   %eax
 8051b32:	50                   	push   %eax
 8051b33:	53                   	push   %ebx
 8051b34:	ff 75 08             	push   0x8(%ebp)
 8051b37:	e8 c2 fe ff ff       	call   80519fe <net_if_ipv6_addr_rm>
 8051b3c:	83 c4 10             	add    $0x10,%esp
	k_mutex_unlock(&lock);
 8051b3f:	e8 58 ed ff ff       	call   805089c <k_mutex_unlock.constprop.0.isra.0>
}
 8051b44:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 8051b47:	c9                   	leave  
 8051b48:	c3                   	ret    

08051b49 <remove_prefix_addresses>:
{
 8051b49:	55                   	push   %ebp
 8051b4a:	89 e5                	mov    %esp,%ebp
 8051b4c:	57                   	push   %edi
 8051b4d:	56                   	push   %esi
 8051b4e:	89 c6                	mov    %eax,%esi
 8051b50:	53                   	push   %ebx
 8051b51:	89 d3                	mov    %edx,%ebx
 8051b53:	83 ec 1c             	sub    $0x1c,%esp
 8051b56:	8b 45 08             	mov    0x8(%ebp),%eax
 8051b59:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
 8051b5c:	89 45 e0             	mov    %eax,-0x20(%ebp)
		if (!ipv6->unicast[i].is_used ||
 8051b5f:	f6 42 2f 02          	testb  $0x2,0x2f(%edx)
 8051b63:	74 2d                	je     8051b92 <remove_prefix_addresses+0x49>
 8051b65:	66 83 3a 02          	cmpw   $0x2,(%edx)
 8051b69:	75 27                	jne    8051b92 <remove_prefix_addresses+0x49>
		    ipv6->unicast[i].address.family != AF_INET6 ||
 8051b6b:	80 7a 2c 01          	cmpb   $0x1,0x2c(%edx)
 8051b6f:	75 21                	jne    8051b92 <remove_prefix_addresses+0x49>
				ipv6->unicast[i].address.in6_addr.s6_addr,
 8051b71:	8d 7a 04             	lea    0x4(%edx),%edi
		if (net_ipv6_is_prefix(
 8051b74:	0f b6 4d e0          	movzbl -0x20(%ebp),%ecx
 8051b78:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8051b7b:	89 fa                	mov    %edi,%edx
 8051b7d:	e8 6b ec ff ff       	call   80507ed <net_ipv6_is_prefix>
 8051b82:	84 c0                	test   %al,%al
 8051b84:	74 0c                	je     8051b92 <remove_prefix_addresses+0x49>
			net_if_ipv6_addr_rm(iface,
 8051b86:	52                   	push   %edx
 8051b87:	52                   	push   %edx
 8051b88:	57                   	push   %edi
 8051b89:	56                   	push   %esi
 8051b8a:	e8 6f fe ff ff       	call   80519fe <net_if_ipv6_addr_rm>
 8051b8f:	83 c4 10             	add    $0x10,%esp
		if (!ipv6->unicast[i].is_used ||
 8051b92:	f6 43 5f 02          	testb  $0x2,0x5f(%ebx)
 8051b96:	74 2e                	je     8051bc6 <remove_prefix_addresses+0x7d>
 8051b98:	66 83 7b 30 02       	cmpw   $0x2,0x30(%ebx)
 8051b9d:	75 27                	jne    8051bc6 <remove_prefix_addresses+0x7d>
		    ipv6->unicast[i].address.family != AF_INET6 ||
 8051b9f:	80 7b 5c 01          	cmpb   $0x1,0x5c(%ebx)
 8051ba3:	75 21                	jne    8051bc6 <remove_prefix_addresses+0x7d>
				ipv6->unicast[i].address.in6_addr.s6_addr,
 8051ba5:	83 c3 34             	add    $0x34,%ebx
		if (net_ipv6_is_prefix(
 8051ba8:	0f b6 4d e0          	movzbl -0x20(%ebp),%ecx
 8051bac:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8051baf:	89 da                	mov    %ebx,%edx
 8051bb1:	e8 37 ec ff ff       	call   80507ed <net_ipv6_is_prefix>
 8051bb6:	84 c0                	test   %al,%al
 8051bb8:	74 0c                	je     8051bc6 <remove_prefix_addresses+0x7d>
			net_if_ipv6_addr_rm(iface,
 8051bba:	50                   	push   %eax
 8051bbb:	50                   	push   %eax
 8051bbc:	53                   	push   %ebx
 8051bbd:	56                   	push   %esi
 8051bbe:	e8 3b fe ff ff       	call   80519fe <net_if_ipv6_addr_rm>
 8051bc3:	83 c4 10             	add    $0x10,%esp
}
 8051bc6:	8d 65 f4             	lea    -0xc(%ebp),%esp
 8051bc9:	5b                   	pop    %ebx
 8051bca:	5e                   	pop    %esi
 8051bcb:	5f                   	pop    %edi
 8051bcc:	5d                   	pop    %ebp
 8051bcd:	c3                   	ret    

08051bce <prefix_lifetime_timeout>:
{
 8051bce:	55                   	push   %ebp
 8051bcf:	89 e5                	mov    %esp,%ebp
 8051bd1:	57                   	push   %edi
 8051bd2:	56                   	push   %esi
 8051bd3:	31 f6                	xor    %esi,%esi
 8051bd5:	53                   	push   %ebx
 8051bd6:	83 ec 2c             	sub    $0x2c,%esp
 8051bd9:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 8051bdf:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 8051be2:	31 c0                	xor    %eax,%eax
	uint32_t current_time = k_uptime_get_32();
 8051be4:	e8 88 ec ff ff       	call   8050871 <k_uptime_get_32>
 8051be9:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	k_mutex_lock(&lock, K_FOREVER);
 8051bec:	83 c8 ff             	or     $0xffffffff,%eax
 8051bef:	89 c2                	mov    %eax,%edx
 8051bf1:	e8 8f ec ff ff       	call   8050885 <k_mutex_lock.constprop.0.isra.0>
	return list->head;
 8051bf6:	8b 3d d0 89 06 08    	mov    0x80689d0,%edi
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&active_prefix_lifetime_timers,
 8051bfc:	85 ff                	test   %edi,%edi
 8051bfe:	74 02                	je     8051c02 <prefix_lifetime_timeout+0x34>
	return node->next;
 8051c00:	8b 37                	mov    (%edi),%esi
 8051c02:	83 cb ff             	or     $0xffffffff,%ebx
 8051c05:	85 ff                	test   %edi,%edi
 8051c07:	74 5d                	je     8051c66 <prefix_lifetime_timeout+0x98>
		uint32_t this_update = net_timeout_evaluate(timeout,
 8051c09:	52                   	push   %edx
 8051c0a:	52                   	push   %edx
 8051c0b:	ff 75 d4             	push   -0x2c(%ebp)
 8051c0e:	57                   	push   %edi
 8051c0f:	e8 86 11 00 00       	call   8052d9a <net_timeout_evaluate>
 8051c14:	83 c4 10             	add    $0x10,%esp
		if (this_update == 0U) {
 8051c17:	85 c0                	test   %eax,%eax
 8051c19:	75 34                	jne    8051c4f <prefix_lifetime_timeout+0x81>
	ifprefix->is_used = false;
 8051c1b:	80 67 25 fd          	andb   $0xfd,0x25(%edi)
	if (net_if_config_ipv6_get(ifprefix->iface, &ipv6) < 0) {
 8051c1f:	50                   	push   %eax
 8051c20:	50                   	push   %eax
 8051c21:	8d 45 e0             	lea    -0x20(%ebp),%eax
 8051c24:	50                   	push   %eax
 8051c25:	ff 77 20             	push   0x20(%edi)
 8051c28:	e8 da f4 ff ff       	call   8051107 <net_if_config_ipv6_get>
 8051c2d:	83 c4 10             	add    $0x10,%esp
 8051c30:	85 c0                	test   %eax,%eax
 8051c32:	78 24                	js     8051c58 <prefix_lifetime_timeout+0x8a>
	remove_prefix_addresses(ifprefix->iface, ipv6, &ifprefix->prefix,
 8051c34:	0f b6 57 24          	movzbl 0x24(%edi),%edx
 8051c38:	83 ec 0c             	sub    $0xc,%esp
 8051c3b:	8b 47 20             	mov    0x20(%edi),%eax
 8051c3e:	8d 4f 10             	lea    0x10(%edi),%ecx
 8051c41:	52                   	push   %edx
 8051c42:	8b 55 e0             	mov    -0x20(%ebp),%edx
 8051c45:	e8 ff fe ff ff       	call   8051b49 <remove_prefix_addresses>
 8051c4a:	83 c4 10             	add    $0x10,%esp
		&ifprefix->prefix, sizeof(struct in6_addr));
 8051c4d:	eb 09                	jmp    8051c58 <prefix_lifetime_timeout+0x8a>
		if (this_update < next_update) {
 8051c4f:	39 c3                	cmp    %eax,%ebx
 8051c51:	0f 47 d8             	cmova  %eax,%ebx
		if (current == next) {
 8051c54:	39 f7                	cmp    %esi,%edi
 8051c56:	74 0e                	je     8051c66 <prefix_lifetime_timeout+0x98>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&active_prefix_lifetime_timers,
 8051c58:	31 c0                	xor    %eax,%eax
 8051c5a:	85 f6                	test   %esi,%esi
 8051c5c:	74 02                	je     8051c60 <prefix_lifetime_timeout+0x92>
 8051c5e:	8b 06                	mov    (%esi),%eax
 8051c60:	89 f7                	mov    %esi,%edi
 8051c62:	89 c6                	mov    %eax,%esi
 8051c64:	eb 9f                	jmp    8051c05 <prefix_lifetime_timeout+0x37>
	if (next_update != UINT32_MAX) {
 8051c66:	83 fb ff             	cmp    $0xffffffff,%ebx
 8051c69:	74 27                	je     8051c92 <prefix_lifetime_timeout+0xc4>
		k_work_reschedule(&prefix_lifetime_timer, K_MSEC(next_update));
 8051c6b:	89 d8                	mov    %ebx,%eax
 8051c6d:	31 d2                	xor    %edx,%edx
 8051c6f:	6a 00                	push   $0x0
		t += off;
 8051c71:	83 c0 09             	add    $0x9,%eax
			return t / ((uint64_t)from_hz / to_hz);
 8051c74:	6a 0a                	push   $0xa
		t += off;
 8051c76:	83 d2 00             	adc    $0x0,%edx
			return t / ((uint64_t)from_hz / to_hz);
 8051c79:	52                   	push   %edx
 8051c7a:	50                   	push   %eax
 8051c7b:	e8 d0 78 ff ff       	call   8049550 <__udivdi3>
 8051c80:	83 c4 0c             	add    $0xc,%esp
 8051c83:	52                   	push   %edx
 8051c84:	50                   	push   %eax
 8051c85:	68 80 7d 06 08       	push   $0x8067d80
 8051c8a:	e8 51 e0 00 00       	call   805fce0 <k_work_reschedule>
 8051c8f:	83 c4 10             	add    $0x10,%esp
	k_mutex_unlock(&lock);
 8051c92:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8051c95:	65 2b 05 14 00 00 00 	sub    %gs:0x14,%eax
 8051c9c:	74 05                	je     8051ca3 <prefix_lifetime_timeout+0xd5>
 8051c9e:	e8 5d 76 ff ff       	call   8049300 <__stack_chk_fail@plt>
}
 8051ca3:	8d 65 f4             	lea    -0xc(%ebp),%esp
 8051ca6:	5b                   	pop    %ebx
 8051ca7:	5e                   	pop    %esi
 8051ca8:	5f                   	pop    %edi
 8051ca9:	5d                   	pop    %ebp
	k_mutex_unlock(&lock);
 8051caa:	e9 ed eb ff ff       	jmp    805089c <k_mutex_unlock.constprop.0.isra.0>

08051caf <net_if_ipv6_maddr_lookup>:
{
 8051caf:	55                   	push   %ebp
	k_mutex_lock(&lock, K_FOREVER);
 8051cb0:	83 c8 ff             	or     $0xffffffff,%eax
 8051cb3:	89 c2                	mov    %eax,%edx
{
 8051cb5:	89 e5                	mov    %esp,%ebp
 8051cb7:	57                   	push   %edi
 8051cb8:	56                   	push   %esi
 8051cb9:	53                   	push   %ebx
	STRUCT_SECTION_FOREACH(net_if, iface) {
 8051cba:	bb b0 76 06 08       	mov    $0x80676b0,%ebx
{
 8051cbf:	83 ec 1c             	sub    $0x1c,%esp
	k_mutex_lock(&lock, K_FOREVER);
 8051cc2:	e8 be eb ff ff       	call   8050885 <k_mutex_lock.constprop.0.isra.0>
	STRUCT_SECTION_FOREACH(net_if, iface) {
 8051cc7:	81 fb bc 76 06 08    	cmp    $0x80676bc,%ebx
 8051ccd:	73 6f                	jae    8051d3e <net_if_ipv6_maddr_lookup+0x8f>
		if (ret && *ret && iface != *ret) {
 8051ccf:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
 8051cd3:	74 0d                	je     8051ce2 <net_if_ipv6_maddr_lookup+0x33>
 8051cd5:	8b 45 0c             	mov    0xc(%ebp),%eax
 8051cd8:	8b 00                	mov    (%eax),%eax
 8051cda:	85 c0                	test   %eax,%eax
 8051cdc:	74 04                	je     8051ce2 <net_if_ipv6_maddr_lookup+0x33>
 8051cde:	39 d8                	cmp    %ebx,%eax
 8051ce0:	75 57                	jne    8051d39 <net_if_ipv6_maddr_lookup+0x8a>
		struct net_if_ipv6 *ipv6 = iface->config.ip.ipv6;
 8051ce2:	8b 73 04             	mov    0x4(%ebx),%esi
		if (!ipv6) {
 8051ce5:	85 f6                	test   %esi,%esi
 8051ce7:	74 50                	je     8051d39 <net_if_ipv6_maddr_lookup+0x8a>
		for (i = 0; i < NET_IF_MAX_IPV6_MADDR; i++) {
 8051ce9:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
 8051cf0:	8d 56 64             	lea    0x64(%esi),%edx
			if (!ipv6->mcast[i].is_used ||
 8051cf3:	6b 7d e4 18          	imul   $0x18,-0x1c(%ebp),%edi
 8051cf7:	f6 44 3e 74 01       	testb  $0x1,0x74(%esi,%edi,1)
 8051cfc:	74 2f                	je     8051d2d <net_if_ipv6_maddr_lookup+0x7e>
 8051cfe:	66 83 7a fc 02       	cmpw   $0x2,-0x4(%edx)
 8051d03:	75 28                	jne    8051d2d <net_if_ipv6_maddr_lookup+0x7e>
			if (net_ipv6_is_prefix(
 8051d05:	8b 45 08             	mov    0x8(%ebp),%eax
 8051d08:	b9 80 00 00 00       	mov    $0x80,%ecx
 8051d0d:	89 55 e0             	mov    %edx,-0x20(%ebp)
 8051d10:	e8 d8 ea ff ff       	call   80507ed <net_ipv6_is_prefix>
 8051d15:	8b 55 e0             	mov    -0x20(%ebp),%edx
 8051d18:	84 c0                	test   %al,%al
 8051d1a:	74 11                	je     8051d2d <net_if_ipv6_maddr_lookup+0x7e>
				if (ret) {
 8051d1c:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
 8051d20:	74 05                	je     8051d27 <net_if_ipv6_maddr_lookup+0x78>
					*ret = iface;
 8051d22:	8b 45 0c             	mov    0xc(%ebp),%eax
 8051d25:	89 18                	mov    %ebx,(%eax)
				ifmaddr = &ipv6->mcast[i];
 8051d27:	8d 44 3e 60          	lea    0x60(%esi,%edi,1),%eax
				goto out;
 8051d2b:	eb 13                	jmp    8051d40 <net_if_ipv6_maddr_lookup+0x91>
		for (i = 0; i < NET_IF_MAX_IPV6_MADDR; i++) {
 8051d2d:	ff 45 e4             	incl   -0x1c(%ebp)
 8051d30:	83 c2 18             	add    $0x18,%edx
 8051d33:	83 7d e4 03          	cmpl   $0x3,-0x1c(%ebp)
 8051d37:	75 ba                	jne    8051cf3 <net_if_ipv6_maddr_lookup+0x44>
	STRUCT_SECTION_FOREACH(net_if, iface) {
 8051d39:	83 c3 0c             	add    $0xc,%ebx
 8051d3c:	eb 89                	jmp    8051cc7 <net_if_ipv6_maddr_lookup+0x18>
	struct net_if_mcast_addr *ifmaddr = NULL;
 8051d3e:	31 c0                	xor    %eax,%eax
 8051d40:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	k_mutex_unlock(&lock);
 8051d43:	e8 54 eb ff ff       	call   805089c <k_mutex_unlock.constprop.0.isra.0>
}
 8051d48:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8051d4b:	83 c4 1c             	add    $0x1c,%esp
 8051d4e:	5b                   	pop    %ebx
 8051d4f:	5e                   	pop    %esi
 8051d50:	5f                   	pop    %edi
 8051d51:	5d                   	pop    %ebp
 8051d52:	c3                   	ret    

08051d53 <net_if_ipv6_maddr_add>:
{
 8051d53:	55                   	push   %ebp
 8051d54:	89 e5                	mov    %esp,%ebp
 8051d56:	57                   	push   %edi
 8051d57:	56                   	push   %esi
 8051d58:	53                   	push   %ebx
 8051d59:	83 ec 2c             	sub    $0x2c,%esp
 8051d5c:	8b 45 08             	mov    0x8(%ebp),%eax
 8051d5f:	8b 75 0c             	mov    0xc(%ebp),%esi
 8051d62:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	k_mutex_lock(&lock, K_FOREVER);
 8051d65:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 8051d6b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 8051d6e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 8051d73:	89 c2                	mov    %eax,%edx
 8051d75:	e8 0b eb ff ff       	call   8050885 <k_mutex_lock.constprop.0.isra.0>
	if (net_if_config_ipv6_get(iface, &ipv6) < 0) {
 8051d7a:	8d 45 e0             	lea    -0x20(%ebp),%eax
 8051d7d:	52                   	push   %edx
 8051d7e:	52                   	push   %edx
 8051d7f:	50                   	push   %eax
 8051d80:	ff 75 d4             	push   -0x2c(%ebp)
 8051d83:	e8 7f f3 ff ff       	call   8051107 <net_if_config_ipv6_get>
 8051d88:	83 c4 10             	add    $0x10,%esp
 8051d8b:	85 c0                	test   %eax,%eax
 8051d8d:	79 04                	jns    8051d93 <net_if_ipv6_maddr_add+0x40>
	struct net_if_mcast_addr *ifmaddr = NULL;
 8051d8f:	31 c0                	xor    %eax,%eax
 8051d91:	eb 64                	jmp    8051df7 <net_if_ipv6_maddr_add+0xa4>
	if (!net_ipv6_is_addr_mcast(addr)) {
 8051d93:	80 3e ff             	cmpb   $0xff,(%esi)
 8051d96:	75 f7                	jne    8051d8f <net_if_ipv6_maddr_add+0x3c>
	if (net_if_ipv6_maddr_lookup(addr, &iface)) {
 8051d98:	50                   	push   %eax
 8051d99:	50                   	push   %eax
 8051d9a:	8d 45 d4             	lea    -0x2c(%ebp),%eax
 8051d9d:	50                   	push   %eax
 8051d9e:	56                   	push   %esi
 8051d9f:	e8 0b ff ff ff       	call   8051caf <net_if_ipv6_maddr_lookup>
 8051da4:	83 c4 10             	add    $0x10,%esp
 8051da7:	85 c0                	test   %eax,%eax
 8051da9:	75 e4                	jne    8051d8f <net_if_ipv6_maddr_add+0x3c>
		if (ipv6->mcast[i].is_used) {
 8051dab:	8b 55 e0             	mov    -0x20(%ebp),%edx
 8051dae:	f6 42 74 01          	testb  $0x1,0x74(%edx)
 8051db2:	74 19                	je     8051dcd <net_if_ipv6_maddr_add+0x7a>
 8051db4:	f6 82 8c 00 00 00 01 	testb  $0x1,0x8c(%edx)
 8051dbb:	74 14                	je     8051dd1 <net_if_ipv6_maddr_add+0x7e>
	for (i = 0; i < NET_IF_MAX_IPV6_MADDR; i++) {
 8051dbd:	b8 02 00 00 00       	mov    $0x2,%eax
		if (ipv6->mcast[i].is_used) {
 8051dc2:	f6 82 a4 00 00 00 01 	testb  $0x1,0xa4(%edx)
 8051dc9:	75 c4                	jne    8051d8f <net_if_ipv6_maddr_add+0x3c>
 8051dcb:	eb 09                	jmp    8051dd6 <net_if_ipv6_maddr_add+0x83>
	for (i = 0; i < NET_IF_MAX_IPV6_MADDR; i++) {
 8051dcd:	31 c0                	xor    %eax,%eax
 8051dcf:	eb 05                	jmp    8051dd6 <net_if_ipv6_maddr_add+0x83>
 8051dd1:	b8 01 00 00 00       	mov    $0x1,%eax
		ipv6->mcast[i].is_used = true;
 8051dd6:	6b d8 18             	imul   $0x18,%eax,%ebx
 8051dd9:	b9 04 00 00 00       	mov    $0x4,%ecx
 8051dde:	8d 04 1a             	lea    (%edx,%ebx,1),%eax
 8051de1:	80 48 74 01          	orb    $0x1,0x74(%eax)
		ipv6->mcast[i].address.family = AF_INET6;
 8051de5:	66 c7 40 60 02 00    	movw   $0x2,0x60(%eax)
		memcpy(&ipv6->mcast[i].address.in6_addr, addr, 16);
 8051deb:	8d 44 1a 64          	lea    0x64(%edx,%ebx,1),%eax
 8051def:	89 c7                	mov    %eax,%edi
		ifmaddr = &ipv6->mcast[i];
 8051df1:	8d 44 1a 60          	lea    0x60(%edx,%ebx,1),%eax
 8051df5:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
		goto out;
 8051df7:	89 45 d0             	mov    %eax,-0x30(%ebp)
	k_mutex_unlock(&lock);
 8051dfa:	e8 9d ea ff ff       	call   805089c <k_mutex_unlock.constprop.0.isra.0>
}
 8051dff:	8b 45 d0             	mov    -0x30(%ebp),%eax
 8051e02:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 8051e05:	65 2b 15 14 00 00 00 	sub    %gs:0x14,%edx
 8051e0c:	74 05                	je     8051e13 <net_if_ipv6_maddr_add+0xc0>
 8051e0e:	e8 ed 74 ff ff       	call   8049300 <__stack_chk_fail@plt>
 8051e13:	8d 65 f4             	lea    -0xc(%ebp),%esp
 8051e16:	5b                   	pop    %ebx
 8051e17:	5e                   	pop    %esi
 8051e18:	5f                   	pop    %edi
 8051e19:	5d                   	pop    %ebp
 8051e1a:	c3                   	ret    

08051e1b <net_if_ipv6_maddr_join>:
{
 8051e1b:	55                   	push   %ebp
 8051e1c:	89 e5                	mov    %esp,%ebp
 8051e1e:	53                   	push   %ebx
 8051e1f:	50                   	push   %eax
	k_mutex_lock(&lock, K_FOREVER);
 8051e20:	83 c8 ff             	or     $0xffffffff,%eax
{
 8051e23:	8b 5d 08             	mov    0x8(%ebp),%ebx
	k_mutex_lock(&lock, K_FOREVER);
 8051e26:	89 c2                	mov    %eax,%edx
 8051e28:	e8 58 ea ff ff       	call   8050885 <k_mutex_lock.constprop.0.isra.0>
	addr->is_joined = true;
 8051e2d:	80 4b 14 02          	orb    $0x2,0x14(%ebx)
}
 8051e31:	5a                   	pop    %edx
 8051e32:	5b                   	pop    %ebx
 8051e33:	5d                   	pop    %ebp
	k_mutex_unlock(&lock);
 8051e34:	e9 63 ea ff ff       	jmp    805089c <k_mutex_unlock.constprop.0.isra.0>

08051e39 <net_if_ipv6_prefix_add>:
{
 8051e39:	55                   	push   %ebp
 8051e3a:	89 e5                	mov    %esp,%ebp
 8051e3c:	57                   	push   %edi
 8051e3d:	56                   	push   %esi
 8051e3e:	53                   	push   %ebx
 8051e3f:	83 ec 3c             	sub    $0x3c,%esp
 8051e42:	8b 45 10             	mov    0x10(%ebp),%eax
 8051e45:	8b 5d 08             	mov    0x8(%ebp),%ebx
 8051e48:	8b 75 0c             	mov    0xc(%ebp),%esi
 8051e4b:	89 45 c4             	mov    %eax,-0x3c(%ebp)
	k_mutex_lock(&lock, K_FOREVER);
 8051e4e:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 8051e54:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 8051e57:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 8051e5c:	89 c2                	mov    %eax,%edx
 8051e5e:	e8 22 ea ff ff       	call   8050885 <k_mutex_lock.constprop.0.isra.0>
	if (net_if_config_ipv6_get(iface, &ipv6) < 0) {
 8051e63:	50                   	push   %eax
 8051e64:	50                   	push   %eax
 8051e65:	8d 45 d0             	lea    -0x30(%ebp),%eax
 8051e68:	50                   	push   %eax
 8051e69:	53                   	push   %ebx
 8051e6a:	e8 98 f2 ff ff       	call   8051107 <net_if_config_ipv6_get>
 8051e6f:	83 c4 10             	add    $0x10,%esp
 8051e72:	89 c2                	mov    %eax,%edx
	struct net_if_ipv6_prefix *ifprefix = NULL;
 8051e74:	31 c0                	xor    %eax,%eax
	if (net_if_config_ipv6_get(iface, &ipv6) < 0) {
 8051e76:	85 d2                	test   %edx,%edx
 8051e78:	0f 88 ea 00 00 00    	js     8051f68 <net_if_ipv6_prefix_add+0x12f>
	ifprefix = ipv6_prefix_find(iface, prefix, len);
 8051e7e:	8b 7b 04             	mov    0x4(%ebx),%edi
	if (!ipv6) {
 8051e81:	85 ff                	test   %edi,%edi
 8051e83:	74 5f                	je     8051ee4 <net_if_ipv6_prefix_add+0xab>
		if (!ipv6->prefix[i].is_used) {
 8051e85:	f6 87 cd 00 00 00 02 	testb  $0x2,0xcd(%edi)
 8051e8c:	74 1c                	je     8051eaa <net_if_ipv6_prefix_add+0x71>
		if (net_ipv6_addr_cmp(prefix, &ipv6->prefix[i].prefix) &&
 8051e8e:	8d 97 b8 00 00 00    	lea    0xb8(%edi),%edx
 8051e94:	89 f0                	mov    %esi,%eax
 8051e96:	e8 bd e9 ff ff       	call   8050858 <net_ipv6_addr_cmp>
 8051e9b:	84 c0                	test   %al,%al
 8051e9d:	74 0b                	je     8051eaa <net_if_ipv6_prefix_add+0x71>
 8051e9f:	8a 45 c4             	mov    -0x3c(%ebp),%al
 8051ea2:	3a 87 cc 00 00 00    	cmp    0xcc(%edi),%al
 8051ea8:	74 2c                	je     8051ed6 <net_if_ipv6_prefix_add+0x9d>
		if (!ipv6->prefix[i].is_used) {
 8051eaa:	f6 87 f5 00 00 00 02 	testb  $0x2,0xf5(%edi)
 8051eb1:	74 31                	je     8051ee4 <net_if_ipv6_prefix_add+0xab>
		if (net_ipv6_addr_cmp(prefix, &ipv6->prefix[i].prefix) &&
 8051eb3:	8d 97 e0 00 00 00    	lea    0xe0(%edi),%edx
 8051eb9:	89 f0                	mov    %esi,%eax
 8051ebb:	e8 98 e9 ff ff       	call   8050858 <net_ipv6_addr_cmp>
 8051ec0:	84 c0                	test   %al,%al
 8051ec2:	74 20                	je     8051ee4 <net_if_ipv6_prefix_add+0xab>
 8051ec4:	8a 45 c4             	mov    -0x3c(%ebp),%al
 8051ec7:	3a 87 f4 00 00 00    	cmp    0xf4(%edi),%al
 8051ecd:	75 15                	jne    8051ee4 <net_if_ipv6_prefix_add+0xab>
 8051ecf:	b8 28 00 00 00       	mov    $0x28,%eax
 8051ed4:	eb 02                	jmp    8051ed8 <net_if_ipv6_prefix_add+0x9f>
 8051ed6:	31 c0                	xor    %eax,%eax
			return &ipv6->prefix[i];
 8051ed8:	8d 84 07 a8 00 00 00 	lea    0xa8(%edi,%eax,1),%eax
	if (ifprefix) {
 8051edf:	e9 84 00 00 00       	jmp    8051f68 <net_if_ipv6_prefix_add+0x12f>
	if (!ipv6) {
 8051ee4:	8b 45 d0             	mov    -0x30(%ebp),%eax
 8051ee7:	85 c0                	test   %eax,%eax
 8051ee9:	74 7d                	je     8051f68 <net_if_ipv6_prefix_add+0x12f>
		if (ipv6->prefix[i].is_used) {
 8051eeb:	f6 80 cd 00 00 00 02 	testb  $0x2,0xcd(%eax)
 8051ef2:	74 10                	je     8051f04 <net_if_ipv6_prefix_add+0xcb>
	for (i = 0; i < NET_IF_MAX_IPV6_PREFIX; i++) {
 8051ef4:	b9 01 00 00 00       	mov    $0x1,%ecx
		if (ipv6->prefix[i].is_used) {
 8051ef9:	f6 80 f5 00 00 00 02 	testb  $0x2,0xf5(%eax)
 8051f00:	75 64                	jne    8051f66 <net_if_ipv6_prefix_add+0x12d>
 8051f02:	eb 02                	jmp    8051f06 <net_if_ipv6_prefix_add+0xcd>
	for (i = 0; i < NET_IF_MAX_IPV6_PREFIX; i++) {
 8051f04:	31 c9                	xor    %ecx,%ecx
		net_if_ipv6_prefix_init(iface, &ipv6->prefix[i], prefix,
 8051f06:	6b c9 28             	imul   $0x28,%ecx,%ecx
	net_ipaddr_copy(&ifprefix->prefix, addr);
 8051f09:	8d 7d d4             	lea    -0x2c(%ebp),%edi
		net_if_ipv6_prefix_init(iface, &ipv6->prefix[i], prefix,
 8051f0c:	8d 94 08 a8 00 00 00 	lea    0xa8(%eax,%ecx,1),%edx
	ifprefix->is_used = true;
 8051f13:	01 c1                	add    %eax,%ecx
 8051f15:	8d 81 c0 00 00 00    	lea    0xc0(%ecx),%eax
 8051f1b:	80 89 cd 00 00 00 02 	orb    $0x2,0xcd(%ecx)
	if (lifetime == NET_IPV6_ND_INFINITE_LIFETIME) {
 8051f22:	83 7d 14 ff          	cmpl   $0xffffffff,0x14(%ebp)
	ifprefix->is_used = true;
 8051f26:	89 45 c0             	mov    %eax,-0x40(%ebp)
	ifprefix->len = len;
 8051f29:	8a 45 c4             	mov    -0x3c(%ebp),%al
	ifprefix->iface = iface;
 8051f2c:	89 99 c8 00 00 00    	mov    %ebx,0xc8(%ecx)
	ifprefix->len = len;
 8051f32:	88 81 cc 00 00 00    	mov    %al,0xcc(%ecx)
	net_ipaddr_copy(&ifprefix->prefix, addr);
 8051f38:	b9 04 00 00 00       	mov    $0x4,%ecx
 8051f3d:	8b 45 c0             	mov    -0x40(%ebp),%eax
 8051f40:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
 8051f42:	8d 7a 10             	lea    0x10(%edx),%edi
 8051f45:	8d 75 d4             	lea    -0x2c(%ebp),%esi
 8051f48:	b9 04 00 00 00       	mov    $0x4,%ecx
 8051f4d:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	if (lifetime == NET_IPV6_ND_INFINITE_LIFETIME) {
 8051f4f:	8a 48 0d             	mov    0xd(%eax),%cl
 8051f52:	75 05                	jne    8051f59 <net_if_ipv6_prefix_add+0x120>
		ifprefix->is_infinite = true;
 8051f54:	83 c9 01             	or     $0x1,%ecx
 8051f57:	eb 06                	jmp    8051f5f <net_if_ipv6_prefix_add+0x126>
		ifprefix->is_infinite = false;
 8051f59:	8b 45 c0             	mov    -0x40(%ebp),%eax
 8051f5c:	83 e1 fe             	and    $0xfffffffe,%ecx
 8051f5f:	88 48 0d             	mov    %cl,0xd(%eax)
 8051f62:	89 d0                	mov    %edx,%eax
 8051f64:	eb 02                	jmp    8051f68 <net_if_ipv6_prefix_add+0x12f>
	struct net_if_ipv6_prefix *ifprefix = NULL;
 8051f66:	31 c0                	xor    %eax,%eax
 8051f68:	89 45 c4             	mov    %eax,-0x3c(%ebp)
	k_mutex_unlock(&lock);
 8051f6b:	e8 2c e9 ff ff       	call   805089c <k_mutex_unlock.constprop.0.isra.0>
}
 8051f70:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 8051f73:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 8051f76:	65 2b 15 14 00 00 00 	sub    %gs:0x14,%edx
 8051f7d:	74 05                	je     8051f84 <net_if_ipv6_prefix_add+0x14b>
 8051f7f:	e8 7c 73 ff ff       	call   8049300 <__stack_chk_fail@plt>
 8051f84:	8d 65 f4             	lea    -0xc(%ebp),%esp
 8051f87:	5b                   	pop    %ebx
 8051f88:	5e                   	pop    %esi
 8051f89:	5f                   	pop    %edi
 8051f8a:	5d                   	pop    %ebp
 8051f8b:	c3                   	ret    

08051f8c <net_if_ipv6_prefix_lookup>:
{
 8051f8c:	55                   	push   %ebp
	k_mutex_lock(&lock, K_FOREVER);
 8051f8d:	83 c8 ff             	or     $0xffffffff,%eax
 8051f90:	89 c2                	mov    %eax,%edx
{
 8051f92:	89 e5                	mov    %esp,%ebp
 8051f94:	56                   	push   %esi
 8051f95:	53                   	push   %ebx
 8051f96:	8b 75 10             	mov    0x10(%ebp),%esi
	k_mutex_lock(&lock, K_FOREVER);
 8051f99:	e8 e7 e8 ff ff       	call   8050885 <k_mutex_lock.constprop.0.isra.0>
	ipv6 = iface->config.ip.ipv6;
 8051f9e:	8b 45 08             	mov    0x8(%ebp),%eax
 8051fa1:	8b 58 04             	mov    0x4(%eax),%ebx
	if (!ipv6) {
 8051fa4:	85 db                	test   %ebx,%ebx
 8051fa6:	74 57                	je     8051fff <net_if_ipv6_prefix_lookup+0x73>
		if (!ipv6->prefix[i].is_used) {
 8051fa8:	f6 83 cd 00 00 00 02 	testb  $0x2,0xcd(%ebx)
 8051faf:	74 17                	je     8051fc8 <net_if_ipv6_prefix_lookup+0x3c>
		if (net_ipv6_is_prefix(ipv6->prefix[i].prefix.s6_addr,
 8051fb1:	89 f0                	mov    %esi,%eax
 8051fb3:	8b 55 0c             	mov    0xc(%ebp),%edx
 8051fb6:	0f b6 c8             	movzbl %al,%ecx
 8051fb9:	8d 83 b8 00 00 00    	lea    0xb8(%ebx),%eax
 8051fbf:	e8 29 e8 ff ff       	call   80507ed <net_ipv6_is_prefix>
 8051fc4:	84 c0                	test   %al,%al
 8051fc6:	75 27                	jne    8051fef <net_if_ipv6_prefix_lookup+0x63>
		if (!ipv6->prefix[i].is_used) {
 8051fc8:	f6 83 f5 00 00 00 02 	testb  $0x2,0xf5(%ebx)
 8051fcf:	74 2c                	je     8051ffd <net_if_ipv6_prefix_lookup+0x71>
		if (net_ipv6_is_prefix(ipv6->prefix[i].prefix.s6_addr,
 8051fd1:	89 f0                	mov    %esi,%eax
 8051fd3:	8b 55 0c             	mov    0xc(%ebp),%edx
 8051fd6:	0f b6 c8             	movzbl %al,%ecx
 8051fd9:	8d 83 e0 00 00 00    	lea    0xe0(%ebx),%eax
 8051fdf:	e8 09 e8 ff ff       	call   80507ed <net_ipv6_is_prefix>
 8051fe4:	84 c0                	test   %al,%al
 8051fe6:	74 15                	je     8051ffd <net_if_ipv6_prefix_lookup+0x71>
	for (i = 0; i < NET_IF_MAX_IPV6_PREFIX; i++) {
 8051fe8:	b8 01 00 00 00       	mov    $0x1,%eax
 8051fed:	eb 02                	jmp    8051ff1 <net_if_ipv6_prefix_lookup+0x65>
 8051fef:	31 c0                	xor    %eax,%eax
			prefix = &ipv6->prefix[i];
 8051ff1:	6b c0 28             	imul   $0x28,%eax,%eax
 8051ff4:	8d 9c 03 a8 00 00 00 	lea    0xa8(%ebx,%eax,1),%ebx
			goto out;
 8051ffb:	eb 02                	jmp    8051fff <net_if_ipv6_prefix_lookup+0x73>
	struct net_if_ipv6_prefix *prefix = NULL;
 8051ffd:	31 db                	xor    %ebx,%ebx
	k_mutex_unlock(&lock);
 8051fff:	e8 98 e8 ff ff       	call   805089c <k_mutex_unlock.constprop.0.isra.0>
}
 8052004:	89 d8                	mov    %ebx,%eax
 8052006:	5b                   	pop    %ebx
 8052007:	5e                   	pop    %esi
 8052008:	5d                   	pop    %ebp
 8052009:	c3                   	ret    

0805200a <net_if_ipv6_addr_onlink>:
{
 805200a:	55                   	push   %ebp
	k_mutex_lock(&lock, K_FOREVER);
 805200b:	83 c8 ff             	or     $0xffffffff,%eax
 805200e:	89 c2                	mov    %eax,%edx
{
 8052010:	89 e5                	mov    %esp,%ebp
 8052012:	57                   	push   %edi
 8052013:	56                   	push   %esi
	STRUCT_SECTION_FOREACH(net_if, tmp) {
 8052014:	be b0 76 06 08       	mov    $0x80676b0,%esi
{
 8052019:	53                   	push   %ebx
 805201a:	83 ec 1c             	sub    $0x1c,%esp
 805201d:	8b 7d 08             	mov    0x8(%ebp),%edi
	k_mutex_lock(&lock, K_FOREVER);
 8052020:	e8 60 e8 ff ff       	call   8050885 <k_mutex_lock.constprop.0.isra.0>
	STRUCT_SECTION_FOREACH(net_if, tmp) {
 8052025:	81 fe bc 76 06 08    	cmp    $0x80676bc,%esi
 805202b:	73 6c                	jae    8052099 <net_if_ipv6_addr_onlink+0x8f>
		if (iface && *iface && *iface != tmp) {
 805202d:	85 ff                	test   %edi,%edi
 805202f:	74 0a                	je     805203b <net_if_ipv6_addr_onlink+0x31>
 8052031:	8b 07                	mov    (%edi),%eax
 8052033:	39 f0                	cmp    %esi,%eax
 8052035:	74 04                	je     805203b <net_if_ipv6_addr_onlink+0x31>
 8052037:	85 c0                	test   %eax,%eax
 8052039:	75 59                	jne    8052094 <net_if_ipv6_addr_onlink+0x8a>
		struct net_if_ipv6 *ipv6 = tmp->config.ip.ipv6;
 805203b:	8b 5e 04             	mov    0x4(%esi),%ebx
		if (!ipv6) {
 805203e:	85 db                	test   %ebx,%ebx
 8052040:	74 52                	je     8052094 <net_if_ipv6_addr_onlink+0x8a>
			if (ipv6->prefix[i].is_used &&
 8052042:	f6 83 cd 00 00 00 02 	testb  $0x2,0xcd(%ebx)
 8052049:	74 21                	je     805206c <net_if_ipv6_addr_onlink+0x62>
			    net_ipv6_is_prefix(ipv6->prefix[i].prefix.s6_addr,
 805204b:	0f b6 8b cc 00 00 00 	movzbl 0xcc(%ebx),%ecx
 8052052:	8b 55 0c             	mov    0xc(%ebp),%edx
 8052055:	8d 83 b8 00 00 00    	lea    0xb8(%ebx),%eax
 805205b:	e8 8d e7 ff ff       	call   80507ed <net_ipv6_is_prefix>
			if (ipv6->prefix[i].is_used &&
 8052060:	84 c0                	test   %al,%al
 8052062:	74 08                	je     805206c <net_if_ipv6_addr_onlink+0x62>
				if (iface) {
 8052064:	85 ff                	test   %edi,%edi
 8052066:	74 28                	je     8052090 <net_if_ipv6_addr_onlink+0x86>
					*iface = tmp;
 8052068:	89 37                	mov    %esi,(%edi)
 805206a:	eb 24                	jmp    8052090 <net_if_ipv6_addr_onlink+0x86>
			if (ipv6->prefix[i].is_used &&
 805206c:	f6 83 f5 00 00 00 02 	testb  $0x2,0xf5(%ebx)
 8052073:	74 1f                	je     8052094 <net_if_ipv6_addr_onlink+0x8a>
			    net_ipv6_is_prefix(ipv6->prefix[i].prefix.s6_addr,
 8052075:	0f b6 8b f4 00 00 00 	movzbl 0xf4(%ebx),%ecx
 805207c:	8b 55 0c             	mov    0xc(%ebp),%edx
 805207f:	8d 83 e0 00 00 00    	lea    0xe0(%ebx),%eax
 8052085:	e8 63 e7 ff ff       	call   80507ed <net_ipv6_is_prefix>
			if (ipv6->prefix[i].is_used &&
 805208a:	84 c0                	test   %al,%al
 805208c:	74 06                	je     8052094 <net_if_ipv6_addr_onlink+0x8a>
 805208e:	eb d4                	jmp    8052064 <net_if_ipv6_addr_onlink+0x5a>
				ret = true;
 8052090:	b0 01                	mov    $0x1,%al
 8052092:	eb 07                	jmp    805209b <net_if_ipv6_addr_onlink+0x91>
	STRUCT_SECTION_FOREACH(net_if, tmp) {
 8052094:	83 c6 0c             	add    $0xc,%esi
 8052097:	eb 8c                	jmp    8052025 <net_if_ipv6_addr_onlink+0x1b>
	bool ret = false;
 8052099:	31 c0                	xor    %eax,%eax
 805209b:	88 45 e7             	mov    %al,-0x19(%ebp)
	k_mutex_unlock(&lock);
 805209e:	e8 f9 e7 ff ff       	call   805089c <k_mutex_unlock.constprop.0.isra.0>
}
 80520a3:	8a 45 e7             	mov    -0x19(%ebp),%al
 80520a6:	83 c4 1c             	add    $0x1c,%esp
 80520a9:	5b                   	pop    %ebx
 80520aa:	5e                   	pop    %esi
 80520ab:	5f                   	pop    %edi
 80520ac:	5d                   	pop    %ebp
 80520ad:	c3                   	ret    

080520ae <net_if_ipv6_prefix_set_timer>:
{
 80520ae:	55                   	push   %ebp
 80520af:	89 e5                	mov    %esp,%ebp
 80520b1:	56                   	push   %esi
 80520b2:	8b 75 0c             	mov    0xc(%ebp),%esi
 80520b5:	53                   	push   %ebx
 80520b6:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (lifetime == 0xffffffff) {
 80520b9:	83 fe ff             	cmp    $0xffffffff,%esi
 80520bc:	74 4d                	je     805210b <net_if_ipv6_prefix_set_timer+0x5d>
	k_mutex_lock(&lock, K_FOREVER);
 80520be:	83 c8 ff             	or     $0xffffffff,%eax
 80520c1:	89 c2                	mov    %eax,%edx
 80520c3:	e8 bd e7 ff ff       	call   8050885 <k_mutex_lock.constprop.0.isra.0>
	(void)sys_slist_find_and_remove(&active_prefix_lifetime_timers,
 80520c8:	89 da                	mov    %ebx,%edx
 80520ca:	b8 d0 89 06 08       	mov    $0x80689d0,%eax
 80520cf:	e8 0b e6 ff ff       	call   80506df <sys_slist_find_and_remove>
	sys_slist_append(&active_prefix_lifetime_timers,
 80520d4:	b8 d0 89 06 08       	mov    $0x80689d0,%eax
 80520d9:	e8 e8 e5 ff ff       	call   80506c6 <sys_slist_append>
	net_timeout_set(&ifprefix->lifetime, lifetime, k_uptime_get_32());
 80520de:	e8 8e e7 ff ff       	call   8050871 <k_uptime_get_32>
 80520e3:	52                   	push   %edx
 80520e4:	50                   	push   %eax
 80520e5:	56                   	push   %esi
 80520e6:	53                   	push   %ebx
 80520e7:	e8 fe 0b 00 00       	call   8052cea <net_timeout_set>
 80520ec:	83 c4 0c             	add    $0xc,%esp
	k_work_reschedule(&prefix_lifetime_timer, K_NO_WAIT);
 80520ef:	6a 00                	push   $0x0
 80520f1:	6a 00                	push   $0x0
 80520f3:	68 80 7d 06 08       	push   $0x8067d80
 80520f8:	e8 e3 db 00 00       	call   805fce0 <k_work_reschedule>
 80520fd:	83 c4 10             	add    $0x10,%esp
}
 8052100:	8d 65 f8             	lea    -0x8(%ebp),%esp
 8052103:	5b                   	pop    %ebx
 8052104:	5e                   	pop    %esi
 8052105:	5d                   	pop    %ebp
	k_mutex_unlock(&lock);
 8052106:	e9 91 e7 ff ff       	jmp    805089c <k_mutex_unlock.constprop.0.isra.0>
}
 805210b:	8d 65 f8             	lea    -0x8(%ebp),%esp
 805210e:	5b                   	pop    %ebx
 805210f:	5e                   	pop    %esi
 8052110:	5d                   	pop    %ebp
 8052111:	c3                   	ret    

08052112 <net_if_ipv6_prefix_unset_timer>:
{
 8052112:	55                   	push   %ebp
 8052113:	89 e5                	mov    %esp,%ebp
 8052115:	53                   	push   %ebx
 8052116:	52                   	push   %edx
 8052117:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (!prefix->is_used) {
 805211a:	f6 43 25 02          	testb  $0x2,0x25(%ebx)
 805211e:	74 2d                	je     805214d <net_if_ipv6_prefix_unset_timer+0x3b>
	k_mutex_lock(&lock, K_FOREVER);
 8052120:	83 c8 ff             	or     $0xffffffff,%eax
 8052123:	89 c2                	mov    %eax,%edx
 8052125:	e8 5b e7 ff ff       	call   8050885 <k_mutex_lock.constprop.0.isra.0>
	sys_slist_find_and_remove(&active_prefix_lifetime_timers,
 805212a:	89 da                	mov    %ebx,%edx
 805212c:	b8 d0 89 06 08       	mov    $0x80689d0,%eax
 8052131:	e8 a9 e5 ff ff       	call   80506df <sys_slist_find_and_remove>
	net_timeout_set(&ifprefix->lifetime, 0, 0);
 8052136:	50                   	push   %eax
 8052137:	6a 00                	push   $0x0
 8052139:	6a 00                	push   $0x0
 805213b:	53                   	push   %ebx
 805213c:	e8 a9 0b 00 00       	call   8052cea <net_timeout_set>
}
 8052141:	8b 5d fc             	mov    -0x4(%ebp),%ebx
	net_timeout_set(&ifprefix->lifetime, 0, 0);
 8052144:	83 c4 10             	add    $0x10,%esp
}
 8052147:	c9                   	leave  
	k_mutex_unlock(&lock);
 8052148:	e9 4f e7 ff ff       	jmp    805089c <k_mutex_unlock.constprop.0.isra.0>
}
 805214d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 8052150:	c9                   	leave  
 8052151:	c3                   	ret    

08052152 <net_if_ipv6_prefix_rm>:
{
 8052152:	55                   	push   %ebp
	k_mutex_lock(&lock, K_FOREVER);
 8052153:	83 c8 ff             	or     $0xffffffff,%eax
 8052156:	89 c2                	mov    %eax,%edx
{
 8052158:	89 e5                	mov    %esp,%ebp
 805215a:	57                   	push   %edi
 805215b:	56                   	push   %esi
 805215c:	53                   	push   %ebx
 805215d:	83 ec 1c             	sub    $0x1c,%esp
 8052160:	8b 75 10             	mov    0x10(%ebp),%esi
	k_mutex_lock(&lock, K_FOREVER);
 8052163:	e8 1d e7 ff ff       	call   8050885 <k_mutex_lock.constprop.0.isra.0>
	ipv6 = iface->config.ip.ipv6;
 8052168:	8b 45 08             	mov    0x8(%ebp),%eax
 805216b:	8b 58 04             	mov    0x4(%eax),%ebx
	bool ret = false;
 805216e:	31 c0                	xor    %eax,%eax
	if (!ipv6) {
 8052170:	85 db                	test   %ebx,%ebx
 8052172:	0f 84 94 00 00 00    	je     805220c <net_if_ipv6_prefix_rm+0xba>
		if (!ipv6->prefix[i].is_used) {
 8052178:	f6 83 cd 00 00 00 02 	testb  $0x2,0xcd(%ebx)
 805217f:	74 1c                	je     805219d <net_if_ipv6_prefix_rm+0x4b>
		if (!net_ipv6_addr_cmp(&ipv6->prefix[i].prefix, addr) ||
 8052181:	8b 55 0c             	mov    0xc(%ebp),%edx
 8052184:	8d 83 b8 00 00 00    	lea    0xb8(%ebx),%eax
 805218a:	e8 c9 e6 ff ff       	call   8050858 <net_ipv6_addr_cmp>
 805218f:	84 c0                	test   %al,%al
 8052191:	74 0a                	je     805219d <net_if_ipv6_prefix_rm+0x4b>
 8052193:	89 f0                	mov    %esi,%eax
 8052195:	3a 83 cc 00 00 00    	cmp    0xcc(%ebx),%al
 805219b:	74 36                	je     80521d3 <net_if_ipv6_prefix_rm+0x81>
		if (!ipv6->prefix[i].is_used) {
 805219d:	8a 83 f5 00 00 00    	mov    0xf5(%ebx),%al
 80521a3:	d0 e8                	shr    %al
 80521a5:	24 01                	and    $0x1,%al
 80521a7:	74 63                	je     805220c <net_if_ipv6_prefix_rm+0xba>
		if (!net_ipv6_addr_cmp(&ipv6->prefix[i].prefix, addr) ||
 80521a9:	8b 55 0c             	mov    0xc(%ebp),%edx
 80521ac:	8d 83 e0 00 00 00    	lea    0xe0(%ebx),%eax
 80521b2:	e8 a1 e6 ff ff       	call   8050858 <net_ipv6_addr_cmp>
 80521b7:	84 c0                	test   %al,%al
 80521b9:	74 51                	je     805220c <net_if_ipv6_prefix_rm+0xba>
	bool ret = false;
 80521bb:	31 c0                	xor    %eax,%eax
		if (!net_ipv6_addr_cmp(&ipv6->prefix[i].prefix, addr) ||
 80521bd:	89 f1                	mov    %esi,%ecx
 80521bf:	38 8b f4 00 00 00    	cmp    %cl,0xf4(%ebx)
 80521c5:	75 45                	jne    805220c <net_if_ipv6_prefix_rm+0xba>
	for (i = 0; i < NET_IF_MAX_IPV6_PREFIX; i++) {
 80521c7:	bf 01 00 00 00       	mov    $0x1,%edi
 80521cc:	b8 28 00 00 00       	mov    $0x28,%eax
 80521d1:	eb 04                	jmp    80521d7 <net_if_ipv6_prefix_rm+0x85>
 80521d3:	31 ff                	xor    %edi,%edi
		if (!net_ipv6_addr_cmp(&ipv6->prefix[i].prefix, addr) ||
 80521d5:	31 c0                	xor    %eax,%eax
		net_if_ipv6_prefix_unset_timer(&ipv6->prefix[i]);
 80521d7:	83 ec 0c             	sub    $0xc,%esp
 80521da:	8d 84 03 a8 00 00 00 	lea    0xa8(%ebx,%eax,1),%eax
 80521e1:	50                   	push   %eax
 80521e2:	e8 2b ff ff ff       	call   8052112 <net_if_ipv6_prefix_unset_timer>
		ipv6->prefix[i].is_used = false;
 80521e7:	6b c7 28             	imul   $0x28,%edi,%eax
		remove_prefix_addresses(iface, ipv6, addr, len);
 80521ea:	8b 4d 0c             	mov    0xc(%ebp),%ecx
 80521ed:	89 da                	mov    %ebx,%edx
		ipv6->prefix[i].is_used = false;
 80521ef:	80 a4 03 cd 00 00 00 	andb   $0xfd,0xcd(%ebx,%eax,1)
 80521f6:	fd 
		remove_prefix_addresses(iface, ipv6, addr, len);
 80521f7:	89 f0                	mov    %esi,%eax
 80521f9:	0f b6 f0             	movzbl %al,%esi
 80521fc:	8b 45 08             	mov    0x8(%ebp),%eax
 80521ff:	89 34 24             	mov    %esi,(%esp)
 8052202:	e8 42 f9 ff ff       	call   8051b49 <remove_prefix_addresses>
 8052207:	83 c4 10             	add    $0x10,%esp
		ret = true;
 805220a:	b0 01                	mov    $0x1,%al
 805220c:	88 45 e7             	mov    %al,-0x19(%ebp)
	k_mutex_unlock(&lock);
 805220f:	e8 88 e6 ff ff       	call   805089c <k_mutex_unlock.constprop.0.isra.0>
}
 8052214:	8a 45 e7             	mov    -0x19(%ebp),%al
 8052217:	8d 65 f4             	lea    -0xc(%ebp),%esp
 805221a:	5b                   	pop    %ebx
 805221b:	5e                   	pop    %esi
 805221c:	5f                   	pop    %edi
 805221d:	5d                   	pop    %ebp
 805221e:	c3                   	ret    

0805221f <net_if_ipv6_router_lookup>:
{
 805221f:	55                   	push   %ebp
	return iface_router_lookup(iface, AF_INET6, addr);
 8052220:	ba 02 00 00 00       	mov    $0x2,%edx
{
 8052225:	89 e5                	mov    %esp,%ebp
	return iface_router_lookup(iface, AF_INET6, addr);
 8052227:	8b 4d 0c             	mov    0xc(%ebp),%ecx
 805222a:	8b 45 08             	mov    0x8(%ebp),%eax
}
 805222d:	5d                   	pop    %ebp
	return iface_router_lookup(iface, AF_INET6, addr);
 805222e:	e9 f2 e6 ff ff       	jmp    8050925 <iface_router_lookup>

08052233 <net_if_ipv6_router_find_default>:
{
 8052233:	55                   	push   %ebp
	return iface_router_find_default(iface, AF_INET6, addr);
 8052234:	ba 02 00 00 00       	mov    $0x2,%edx
{
 8052239:	89 e5                	mov    %esp,%ebp
	return iface_router_find_default(iface, AF_INET6, addr);
 805223b:	8b 45 08             	mov    0x8(%ebp),%eax
}
 805223e:	5d                   	pop    %ebp
	return iface_router_find_default(iface, AF_INET6, addr);
 805223f:	e9 28 ea ff ff       	jmp    8050c6c <iface_router_find_default.constprop.0>

08052244 <net_if_ipv6_router_update_lifetime>:
{
 8052244:	55                   	push   %ebp
 8052245:	89 e5                	mov    %esp,%ebp
 8052247:	56                   	push   %esi
 8052248:	53                   	push   %ebx
 8052249:	8b 75 0c             	mov    0xc(%ebp),%esi
 805224c:	8b 5d 08             	mov    0x8(%ebp),%ebx
	router->life_start = k_uptime_get_32();
 805224f:	e8 1d e6 ff ff       	call   8050871 <k_uptime_get_32>
	router->lifetime = lifetime;
 8052254:	66 89 73 20          	mov    %si,0x20(%ebx)
	router->life_start = k_uptime_get_32();
 8052258:	89 43 1c             	mov    %eax,0x1c(%ebx)
}
 805225b:	5b                   	pop    %ebx
 805225c:	5e                   	pop    %esi
 805225d:	5d                   	pop    %ebp
	iface_router_update_timer(router->life_start);
 805225e:	e9 55 e7 ff ff       	jmp    80509b8 <iface_router_update_timer>

08052263 <net_if_ipv6_router_add>:
{
 8052263:	55                   	push   %ebp
 8052264:	89 e5                	mov    %esp,%ebp
	return iface_router_add(iface, AF_INET6, addr, false, lifetime);
 8052266:	0f b7 55 10          	movzwl 0x10(%ebp),%edx
{
 805226a:	8b 45 08             	mov    0x8(%ebp),%eax
	return iface_router_add(iface, AF_INET6, addr, false, lifetime);
 805226d:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
{
 8052274:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	return iface_router_add(iface, AF_INET6, addr, false, lifetime);
 8052277:	89 55 0c             	mov    %edx,0xc(%ebp)
 805227a:	ba 02 00 00 00       	mov    $0x2,%edx
}
 805227f:	5d                   	pop    %ebp
	return iface_router_add(iface, AF_INET6, addr, false, lifetime);
 8052280:	e9 c7 e7 ff ff       	jmp    8050a4c <iface_router_add>

08052285 <net_if_ipv6_router_rm>:
{
 8052285:	55                   	push   %ebp
 8052286:	89 e5                	mov    %esp,%ebp
	return iface_router_rm(router);
 8052288:	8b 45 08             	mov    0x8(%ebp),%eax
}
 805228b:	5d                   	pop    %ebp
	return iface_router_rm(router);
 805228c:	e9 c3 e8 ff ff       	jmp    8050b54 <iface_router_rm>

08052291 <net_if_ipv6_get_hop_limit>:
{
 8052291:	55                   	push   %ebp
	k_mutex_lock(&lock, K_FOREVER);
 8052292:	83 c8 ff             	or     $0xffffffff,%eax
 8052295:	89 c2                	mov    %eax,%edx
{
 8052297:	89 e5                	mov    %esp,%ebp
 8052299:	53                   	push   %ebx
 805229a:	31 db                	xor    %ebx,%ebx
 805229c:	51                   	push   %ecx
	k_mutex_lock(&lock, K_FOREVER);
 805229d:	e8 e3 e5 ff ff       	call   8050885 <k_mutex_lock.constprop.0.isra.0>
	if (!iface->config.ip.ipv6) {
 80522a2:	8b 45 08             	mov    0x8(%ebp),%eax
 80522a5:	8b 40 04             	mov    0x4(%eax),%eax
 80522a8:	85 c0                	test   %eax,%eax
 80522aa:	74 07                	je     80522b3 <net_if_ipv6_get_hop_limit+0x22>
	ret = iface->config.ip.ipv6->hop_limit;
 80522ac:	0f b6 98 0d 01 00 00 	movzbl 0x10d(%eax),%ebx
	k_mutex_unlock(&lock);
 80522b3:	e8 e4 e5 ff ff       	call   805089c <k_mutex_unlock.constprop.0.isra.0>
	return ret;
 80522b8:	89 d8                	mov    %ebx,%eax
}
 80522ba:	5a                   	pop    %edx
 80522bb:	5b                   	pop    %ebx
 80522bc:	5d                   	pop    %ebp
 80522bd:	c3                   	ret    

080522be <net_ipv6_set_hop_limit>:
{
 80522be:	55                   	push   %ebp
	k_mutex_lock(&lock, K_FOREVER);
 80522bf:	83 c8 ff             	or     $0xffffffff,%eax
 80522c2:	89 c2                	mov    %eax,%edx
{
 80522c4:	89 e5                	mov    %esp,%ebp
 80522c6:	56                   	push   %esi
 80522c7:	53                   	push   %ebx
 80522c8:	8b 75 08             	mov    0x8(%ebp),%esi
 80522cb:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	k_mutex_lock(&lock, K_FOREVER);
 80522ce:	e8 b2 e5 ff ff       	call   8050885 <k_mutex_lock.constprop.0.isra.0>
	if (!iface->config.ip.ipv6) {
 80522d3:	8b 46 04             	mov    0x4(%esi),%eax
 80522d6:	85 c0                	test   %eax,%eax
 80522d8:	74 06                	je     80522e0 <net_ipv6_set_hop_limit+0x22>
	iface->config.ip.ipv6->hop_limit = hop_limit;
 80522da:	88 98 0d 01 00 00    	mov    %bl,0x10d(%eax)
}
 80522e0:	5b                   	pop    %ebx
 80522e1:	5e                   	pop    %esi
 80522e2:	5d                   	pop    %ebp
	k_mutex_unlock(&lock);
 80522e3:	e9 b4 e5 ff ff       	jmp    805089c <k_mutex_unlock.constprop.0.isra.0>

080522e8 <net_if_ipv6_get_ll>:
{
 80522e8:	55                   	push   %ebp
	k_mutex_lock(&lock, K_FOREVER);
 80522e9:	83 c8 ff             	or     $0xffffffff,%eax
 80522ec:	89 c2                	mov    %eax,%edx
{
 80522ee:	89 e5                	mov    %esp,%ebp
 80522f0:	53                   	push   %ebx
 80522f1:	83 ec 14             	sub    $0x14,%esp
 80522f4:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	k_mutex_lock(&lock, K_FOREVER);
 80522f7:	e8 89 e5 ff ff       	call   8050885 <k_mutex_lock.constprop.0.isra.0>
	ipv6 = iface->config.ip.ipv6;
 80522fc:	8b 45 08             	mov    0x8(%ebp),%eax
 80522ff:	8b 40 04             	mov    0x4(%eax),%eax
	if (!ipv6) {
 8052302:	85 c0                	test   %eax,%eax
 8052304:	74 49                	je     805234f <net_if_ipv6_get_ll+0x67>
		if (!ipv6->unicast[i].is_used ||
 8052306:	f6 40 2f 02          	testb  $0x2,0x2f(%eax)
 805230a:	74 1b                	je     8052327 <net_if_ipv6_get_ll+0x3f>
 805230c:	80 fb ff             	cmp    $0xff,%bl
 805230f:	74 05                	je     8052316 <net_if_ipv6_get_ll+0x2e>
		    (addr_state != NET_ADDR_ANY_STATE &&
 8052311:	3a 58 2d             	cmp    0x2d(%eax),%bl
 8052314:	75 11                	jne    8052327 <net_if_ipv6_get_ll+0x3f>
		     ipv6->unicast[i].addr_state != addr_state) ||
 8052316:	66 83 38 02          	cmpw   $0x2,(%eax)
 805231a:	75 0b                	jne    8052327 <net_if_ipv6_get_ll+0x3f>
		if (net_ipv6_is_ll_addr(&ipv6->unicast[i].address.in6_addr)) {
 805231c:	66 81 78 04 fe 80    	cmpw   $0x80fe,0x4(%eax)
 8052322:	8d 50 04             	lea    0x4(%eax),%edx
 8052325:	74 22                	je     8052349 <net_if_ipv6_get_ll+0x61>
		if (!ipv6->unicast[i].is_used ||
 8052327:	f6 40 5f 02          	testb  $0x2,0x5f(%eax)
 805232b:	74 20                	je     805234d <net_if_ipv6_get_ll+0x65>
 805232d:	80 fb ff             	cmp    $0xff,%bl
 8052330:	74 05                	je     8052337 <net_if_ipv6_get_ll+0x4f>
		    (addr_state != NET_ADDR_ANY_STATE &&
 8052332:	38 58 5d             	cmp    %bl,0x5d(%eax)
 8052335:	75 16                	jne    805234d <net_if_ipv6_get_ll+0x65>
		     ipv6->unicast[i].addr_state != addr_state) ||
 8052337:	66 83 78 30 02       	cmpw   $0x2,0x30(%eax)
 805233c:	75 0f                	jne    805234d <net_if_ipv6_get_ll+0x65>
		if (net_ipv6_is_ll_addr(&ipv6->unicast[i].address.in6_addr)) {
 805233e:	66 81 78 34 fe 80    	cmpw   $0x80fe,0x34(%eax)
 8052344:	8d 50 34             	lea    0x34(%eax),%edx
 8052347:	75 04                	jne    805234d <net_if_ipv6_get_ll+0x65>
 8052349:	89 d0                	mov    %edx,%eax
 805234b:	eb 02                	jmp    805234f <net_if_ipv6_get_ll+0x67>
	struct in6_addr *addr = NULL;
 805234d:	31 c0                	xor    %eax,%eax
 805234f:	89 45 f4             	mov    %eax,-0xc(%ebp)
	k_mutex_unlock(&lock);
 8052352:	e8 45 e5 ff ff       	call   805089c <k_mutex_unlock.constprop.0.isra.0>
}
 8052357:	8b 45 f4             	mov    -0xc(%ebp),%eax
 805235a:	83 c4 14             	add    $0x14,%esp
 805235d:	5b                   	pop    %ebx
 805235e:	5d                   	pop    %ebp
 805235f:	c3                   	ret    

08052360 <net_if_ipv6_select_src_addr>:
{
 8052360:	55                   	push   %ebp
 8052361:	89 e5                	mov    %esp,%ebp
 8052363:	57                   	push   %edi
 8052364:	56                   	push   %esi
 8052365:	53                   	push   %ebx
 8052366:	83 ec 1c             	sub    $0x1c,%esp
 8052369:	8b 75 0c             	mov    0xc(%ebp),%esi
 805236c:	8b 5d 08             	mov    0x8(%ebp),%ebx
 805236f:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 8052375:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 8052378:	31 c0                	xor    %eax,%eax
	k_mutex_lock(&lock, K_FOREVER);
 805237a:	83 c8 ff             	or     $0xffffffff,%eax
	uint8_t best_match = 0U;
 805237d:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
	k_mutex_lock(&lock, K_FOREVER);
 8052381:	89 c2                	mov    %eax,%edx
 8052383:	e8 fd e4 ff ff       	call   8050885 <k_mutex_lock.constprop.0.isra.0>
	if (!net_ipv6_is_ll_addr(dst) && !net_ipv6_is_addr_mcast_link(dst)) {
 8052388:	66 81 3e fe 80       	cmpw   $0x80fe,(%esi)
 805238d:	74 42                	je     80523d1 <net_if_ipv6_select_src_addr+0x71>
	return (addr->s6_addr[0] == 0xff) && (addr->s6_addr[1] == scope);
 805238f:	80 3e ff             	cmpb   $0xff,(%esi)
 8052392:	75 06                	jne    805239a <net_if_ipv6_select_src_addr+0x3a>
 8052394:	80 7e 01 02          	cmpb   $0x2,0x1(%esi)
 8052398:	74 37                	je     80523d1 <net_if_ipv6_select_src_addr+0x71>
		if (dst_iface) {
 805239a:	85 db                	test   %ebx,%ebx
 805239c:	74 0f                	je     80523ad <net_if_ipv6_select_src_addr+0x4d>
			src = net_if_ipv6_get_best_match(dst_iface, dst,
 805239e:	8b 43 04             	mov    0x4(%ebx),%eax
 80523a1:	8d 4d e3             	lea    -0x1d(%ebp),%ecx
 80523a4:	89 f2                	mov    %esi,%edx
 80523a6:	e8 6b ea ff ff       	call   8050e16 <net_if_ipv6_get_best_match.isra.0>
 80523ab:	eb 35                	jmp    80523e2 <net_if_ipv6_select_src_addr+0x82>
			STRUCT_SECTION_FOREACH(net_if, iface) {
 80523ad:	bf b0 76 06 08       	mov    $0x80676b0,%edi
 80523b2:	81 ff bc 76 06 08    	cmp    $0x80676bc,%edi
 80523b8:	73 51                	jae    805240b <net_if_ipv6_select_src_addr+0xab>
				addr = net_if_ipv6_get_best_match(iface, dst,
 80523ba:	8b 47 04             	mov    0x4(%edi),%eax
 80523bd:	8d 4d e3             	lea    -0x1d(%ebp),%ecx
 80523c0:	89 f2                	mov    %esi,%edx
 80523c2:	e8 4f ea ff ff       	call   8050e16 <net_if_ipv6_get_best_match.isra.0>
				if (addr) {
 80523c7:	85 c0                	test   %eax,%eax
 80523c9:	0f 45 d8             	cmovne %eax,%ebx
			STRUCT_SECTION_FOREACH(net_if, iface) {
 80523cc:	83 c7 0c             	add    $0xc,%edi
 80523cf:	eb e1                	jmp    80523b2 <net_if_ipv6_select_src_addr+0x52>
		if (dst_iface) {
 80523d1:	85 db                	test   %ebx,%ebx
 80523d3:	74 11                	je     80523e6 <net_if_ipv6_select_src_addr+0x86>
			src = net_if_ipv6_get_ll(dst_iface, NET_ADDR_PREFERRED);
 80523d5:	52                   	push   %edx
 80523d6:	52                   	push   %edx
 80523d7:	6a 01                	push   $0x1
 80523d9:	53                   	push   %ebx
 80523da:	e8 09 ff ff ff       	call   80522e8 <net_if_ipv6_get_ll>
 80523df:	83 c4 10             	add    $0x10,%esp
 80523e2:	89 c3                	mov    %eax,%ebx
 80523e4:	eb 25                	jmp    805240b <net_if_ipv6_select_src_addr+0xab>
			STRUCT_SECTION_FOREACH(net_if, iface) {
 80523e6:	be b0 76 06 08       	mov    $0x80676b0,%esi
 80523eb:	81 fe bc 76 06 08    	cmp    $0x80676bc,%esi
 80523f1:	73 1c                	jae    805240f <net_if_ipv6_select_src_addr+0xaf>
				addr = net_if_ipv6_get_ll(iface,
 80523f3:	50                   	push   %eax
 80523f4:	50                   	push   %eax
 80523f5:	6a 01                	push   $0x1
 80523f7:	56                   	push   %esi
 80523f8:	e8 eb fe ff ff       	call   80522e8 <net_if_ipv6_get_ll>
 80523fd:	83 c4 10             	add    $0x10,%esp
 8052400:	89 c3                	mov    %eax,%ebx
				if (addr) {
 8052402:	85 c0                	test   %eax,%eax
 8052404:	75 10                	jne    8052416 <net_if_ipv6_select_src_addr+0xb6>
			STRUCT_SECTION_FOREACH(net_if, iface) {
 8052406:	83 c6 0c             	add    $0xc,%esi
 8052409:	eb e0                	jmp    80523eb <net_if_ipv6_select_src_addr+0x8b>
	if (!src) {
 805240b:	85 db                	test   %ebx,%ebx
 805240d:	75 07                	jne    8052416 <net_if_ipv6_select_src_addr+0xb6>
		src = net_ipv6_unspecified_address();
 805240f:	e8 66 13 00 00       	call   805377a <net_ipv6_unspecified_address>
 8052414:	89 c3                	mov    %eax,%ebx
	k_mutex_unlock(&lock);
 8052416:	e8 81 e4 ff ff       	call   805089c <k_mutex_unlock.constprop.0.isra.0>
}
 805241b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 805241e:	65 2b 05 14 00 00 00 	sub    %gs:0x14,%eax
 8052425:	74 05                	je     805242c <net_if_ipv6_select_src_addr+0xcc>
 8052427:	e8 d4 6e ff ff       	call   8049300 <__stack_chk_fail@plt>
 805242c:	8d 65 f4             	lea    -0xc(%ebp),%esp
 805242f:	89 d8                	mov    %ebx,%eax
 8052431:	5b                   	pop    %ebx
 8052432:	5e                   	pop    %esi
 8052433:	5f                   	pop    %edi
 8052434:	5d                   	pop    %ebp
 8052435:	c3                   	ret    

08052436 <net_if_ipv6_select_src_iface>:
{
 8052436:	55                   	push   %ebp
 8052437:	89 e5                	mov    %esp,%ebp
 8052439:	53                   	push   %ebx
 805243a:	83 ec 14             	sub    $0x14,%esp
 805243d:	8b 5d 08             	mov    0x8(%ebp),%ebx
 8052440:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 8052446:	89 45 f4             	mov    %eax,-0xc(%ebp)
 8052449:	31 c0                	xor    %eax,%eax
	k_mutex_lock(&lock, K_FOREVER);
 805244b:	83 c8 ff             	or     $0xffffffff,%eax
	struct net_if *iface = NULL;
 805244e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	k_mutex_lock(&lock, K_FOREVER);
 8052455:	89 c2                	mov    %eax,%edx
 8052457:	e8 29 e4 ff ff       	call   8050885 <k_mutex_lock.constprop.0.isra.0>
	src = net_if_ipv6_select_src_addr(NULL, dst);
 805245c:	52                   	push   %edx
 805245d:	52                   	push   %edx
 805245e:	53                   	push   %ebx
 805245f:	6a 00                	push   $0x0
 8052461:	e8 fa fe ff ff       	call   8052360 <net_if_ipv6_select_src_addr>
 8052466:	83 c4 10             	add    $0x10,%esp
 8052469:	89 c3                	mov    %eax,%ebx
	if (src != net_ipv6_unspecified_address()) {
 805246b:	e8 0a 13 00 00       	call   805377a <net_ipv6_unspecified_address>
 8052470:	39 c3                	cmp    %eax,%ebx
 8052472:	75 0a                	jne    805247e <net_if_ipv6_select_src_iface+0x48>
		iface = net_if_get_default();
 8052474:	e8 20 ec ff ff       	call   8051099 <net_if_get_default>
 8052479:	89 45 f0             	mov    %eax,-0x10(%ebp)
 805247c:	eb 15                	jmp    8052493 <net_if_ipv6_select_src_iface+0x5d>
		net_if_ipv6_addr_lookup(src, &iface);
 805247e:	50                   	push   %eax
 805247f:	50                   	push   %eax
 8052480:	8d 45 f0             	lea    -0x10(%ebp),%eax
 8052483:	50                   	push   %eax
 8052484:	53                   	push   %ebx
 8052485:	e8 95 ee ff ff       	call   805131f <net_if_ipv6_addr_lookup>
 805248a:	83 c4 10             	add    $0x10,%esp
	if (iface == NULL) {
 805248d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
 8052491:	74 e1                	je     8052474 <net_if_ipv6_select_src_iface+0x3e>
	k_mutex_unlock(&lock);
 8052493:	e8 04 e4 ff ff       	call   805089c <k_mutex_unlock.constprop.0.isra.0>
	return iface;
 8052498:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
 805249b:	8b 55 f4             	mov    -0xc(%ebp),%edx
 805249e:	65 2b 15 14 00 00 00 	sub    %gs:0x14,%edx
 80524a5:	74 05                	je     80524ac <net_if_ipv6_select_src_iface+0x76>
 80524a7:	e8 54 6e ff ff       	call   8049300 <__stack_chk_fail@plt>
 80524ac:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 80524af:	c9                   	leave  
 80524b0:	c3                   	ret    

080524b1 <net_if_ipv6_calc_reachable_time>:
{
 80524b1:	55                   	push   %ebp
	k_mutex_lock(&lock, K_FOREVER);
 80524b2:	83 c8 ff             	or     $0xffffffff,%eax
 80524b5:	89 c2                	mov    %eax,%edx
{
 80524b7:	89 e5                	mov    %esp,%ebp
 80524b9:	56                   	push   %esi
 80524ba:	53                   	push   %ebx
	k_mutex_lock(&lock, K_FOREVER);
 80524bb:	e8 c5 e3 ff ff       	call   8050885 <k_mutex_lock.constprop.0.isra.0>
	min_reachable = (MIN_RANDOM_NUMER * ipv6->base_reachable_time)
 80524c0:	8b 45 08             	mov    0x8(%ebp),%eax
 80524c3:	8b 98 f8 00 00 00    	mov    0xf8(%eax),%ebx
	k_mutex_unlock(&lock);
 80524c9:	e8 ce e3 ff ff       	call   805089c <k_mutex_unlock.constprop.0.isra.0>
	min_reachable = (MIN_RANDOM_NUMER * ipv6->base_reachable_time)
 80524ce:	89 de                	mov    %ebx,%esi
 80524d0:	d1 ee                	shr    %esi
	if (z_syscall_trap()) {
		return (uint32_t) arch_syscall_invoke0(K_SYSCALL_SYS_RAND32_GET);
	}
#endif
	compiler_barrier();
	return z_impl_sys_rand32_get();
 80524d2:	e8 49 ca ff ff       	call   804ef20 <z_impl_sys_rand32_get>
	max_reachable = (MAX_RANDOM_NUMER * ipv6->base_reachable_time)
 80524d7:	8d 0c 5b             	lea    (%ebx,%ebx,2),%ecx
	       sys_rand32_get() % (max_reachable - min_reachable);
 80524da:	31 d2                	xor    %edx,%edx
}
 80524dc:	5b                   	pop    %ebx
	max_reachable = (MAX_RANDOM_NUMER * ipv6->base_reachable_time)
 80524dd:	d1 e9                	shr    %ecx
	       sys_rand32_get() % (max_reachable - min_reachable);
 80524df:	29 f1                	sub    %esi,%ecx
 80524e1:	f7 f1                	div    %ecx
	return min_reachable +
 80524e3:	8d 04 32             	lea    (%edx,%esi,1),%eax
}
 80524e6:	5e                   	pop    %esi
 80524e7:	5d                   	pop    %ebp
 80524e8:	c3                   	ret    

080524e9 <net_if_ipv4_get_ttl>:
{
 80524e9:	55                   	push   %ebp
	k_mutex_lock(&lock, K_FOREVER);
 80524ea:	83 c8 ff             	or     $0xffffffff,%eax
 80524ed:	89 c2                	mov    %eax,%edx
{
 80524ef:	89 e5                	mov    %esp,%ebp
 80524f1:	53                   	push   %ebx
 80524f2:	31 db                	xor    %ebx,%ebx
 80524f4:	51                   	push   %ecx
	k_mutex_lock(&lock, K_FOREVER);
 80524f5:	e8 8b e3 ff ff       	call   8050885 <k_mutex_lock.constprop.0.isra.0>
	if (!iface->config.ip.ipv4) {
 80524fa:	8b 45 08             	mov    0x8(%ebp),%eax
 80524fd:	8b 40 08             	mov    0x8(%eax),%eax
 8052500:	85 c0                	test   %eax,%eax
 8052502:	74 04                	je     8052508 <net_if_ipv4_get_ttl+0x1f>
	ret = iface->config.ip.ipv4->ttl;
 8052504:	0f b6 58 50          	movzbl 0x50(%eax),%ebx
	k_mutex_unlock(&lock);
 8052508:	e8 8f e3 ff ff       	call   805089c <k_mutex_unlock.constprop.0.isra.0>
	return ret;
 805250d:	89 d8                	mov    %ebx,%eax
}
 805250f:	5a                   	pop    %edx
 8052510:	5b                   	pop    %ebx
 8052511:	5d                   	pop    %ebp
 8052512:	c3                   	ret    

08052513 <net_if_ipv4_addr_mask_cmp>:
{
 8052513:	55                   	push   %ebp
	k_mutex_lock(&lock, K_FOREVER);
 8052514:	83 c8 ff             	or     $0xffffffff,%eax
 8052517:	89 c2                	mov    %eax,%edx
{
 8052519:	89 e5                	mov    %esp,%ebp
 805251b:	53                   	push   %ebx
 805251c:	83 ec 14             	sub    $0x14,%esp
	k_mutex_lock(&lock, K_FOREVER);
 805251f:	e8 61 e3 ff ff       	call   8050885 <k_mutex_lock.constprop.0.isra.0>
	ipv4 = iface->config.ip.ipv4;
 8052524:	8b 45 08             	mov    0x8(%ebp),%eax
 8052527:	8b 50 08             	mov    0x8(%eax),%edx
	bool ret = false;
 805252a:	31 c0                	xor    %eax,%eax
	if (!ipv4) {
 805252c:	85 d2                	test   %edx,%edx
 805252e:	74 21                	je     8052551 <net_if_ipv4_addr_mask_cmp+0x3e>
	subnet = UNALIGNED_GET(&addr->s_addr) & ipv4->netmask.s_addr;
 8052530:	8b 45 0c             	mov    0xc(%ebp),%eax
 8052533:	8b 5a 4c             	mov    0x4c(%edx),%ebx
 8052536:	8b 08                	mov    (%eax),%ecx
		if (!ipv4->unicast[i].is_used ||
 8052538:	8a 42 2f             	mov    0x2f(%edx),%al
 805253b:	d0 e8                	shr    %al
 805253d:	24 01                	and    $0x1,%al
 805253f:	74 10                	je     8052551 <net_if_ipv4_addr_mask_cmp+0x3e>
	bool ret = false;
 8052541:	31 c0                	xor    %eax,%eax
		if (!ipv4->unicast[i].is_used ||
 8052543:	66 83 3a 01          	cmpw   $0x1,(%edx)
 8052547:	75 08                	jne    8052551 <net_if_ipv4_addr_mask_cmp+0x3e>
		if ((ipv4->unicast[i].address.in_addr.s_addr &
 8052549:	33 4a 04             	xor    0x4(%edx),%ecx
 805254c:	85 d9                	test   %ebx,%ecx
 805254e:	0f 94 c0             	sete   %al
 8052551:	88 45 f7             	mov    %al,-0x9(%ebp)
	k_mutex_unlock(&lock);
 8052554:	e8 43 e3 ff ff       	call   805089c <k_mutex_unlock.constprop.0.isra.0>
}
 8052559:	8a 45 f7             	mov    -0x9(%ebp),%al
 805255c:	83 c4 14             	add    $0x14,%esp
 805255f:	5b                   	pop    %ebx
 8052560:	5d                   	pop    %ebp
 8052561:	c3                   	ret    

08052562 <ipv4_is_broadcast_address>:
{
 8052562:	55                   	push   %ebp
 8052563:	89 e5                	mov    %esp,%ebp
 8052565:	56                   	push   %esi
 8052566:	53                   	push   %ebx
	struct net_if_ipv4 *ipv4 = iface->config.ip.ipv4;
 8052567:	8b 70 08             	mov    0x8(%eax),%esi
	if (!ipv4) {
 805256a:	85 f6                	test   %esi,%esi
 805256c:	75 04                	jne    8052572 <ipv4_is_broadcast_address+0x10>
		return false;
 805256e:	31 c0                	xor    %eax,%eax
 8052570:	eb 20                	jmp    8052592 <ipv4_is_broadcast_address+0x30>
 8052572:	89 d3                	mov    %edx,%ebx
	if (!net_if_ipv4_addr_mask_cmp(iface, addr)) {
 8052574:	52                   	push   %edx
 8052575:	52                   	push   %edx
 8052576:	53                   	push   %ebx
 8052577:	50                   	push   %eax
 8052578:	e8 96 ff ff ff       	call   8052513 <net_if_ipv4_addr_mask_cmp>
 805257d:	83 c4 10             	add    $0x10,%esp
 8052580:	84 c0                	test   %al,%al
 8052582:	74 ea                	je     805256e <ipv4_is_broadcast_address+0xc>
	if ((UNALIGNED_GET(&addr->s_addr) & ~ipv4->netmask.s_addr) ==
 8052584:	8b 46 4c             	mov    0x4c(%esi),%eax
 8052587:	8b 13                	mov    (%ebx),%edx
 8052589:	f7 d0                	not    %eax
 805258b:	21 c2                	and    %eax,%edx
 805258d:	39 c2                	cmp    %eax,%edx
 805258f:	0f 94 c0             	sete   %al
}
 8052592:	8d 65 f8             	lea    -0x8(%ebp),%esp
 8052595:	5b                   	pop    %ebx
 8052596:	5e                   	pop    %esi
 8052597:	5d                   	pop    %ebp
 8052598:	c3                   	ret    

08052599 <net_if_ipv4_is_addr_bcast>:
{
 8052599:	55                   	push   %ebp
	k_mutex_lock(&lock, K_FOREVER);
 805259a:	83 c8 ff             	or     $0xffffffff,%eax
 805259d:	89 c2                	mov    %eax,%edx
{
 805259f:	89 e5                	mov    %esp,%ebp
 80525a1:	53                   	push   %ebx
 80525a2:	bb b0 76 06 08       	mov    $0x80676b0,%ebx
 80525a7:	83 ec 14             	sub    $0x14,%esp
	k_mutex_lock(&lock, K_FOREVER);
 80525aa:	e8 d6 e2 ff ff       	call   8050885 <k_mutex_lock.constprop.0.isra.0>
	if (iface) {
 80525af:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 80525b3:	74 1e                	je     80525d3 <net_if_ipv4_is_addr_bcast+0x3a>
		ret = ipv4_is_broadcast_address(iface, addr);
 80525b5:	8b 55 0c             	mov    0xc(%ebp),%edx
 80525b8:	8b 45 08             	mov    0x8(%ebp),%eax
 80525bb:	e8 a2 ff ff ff       	call   8052562 <ipv4_is_broadcast_address>
		goto out;
 80525c0:	eb 1b                	jmp    80525dd <net_if_ipv4_is_addr_bcast+0x44>
		ret = ipv4_is_broadcast_address(iface, addr);
 80525c2:	8b 55 0c             	mov    0xc(%ebp),%edx
 80525c5:	89 d8                	mov    %ebx,%eax
 80525c7:	e8 96 ff ff ff       	call   8052562 <ipv4_is_broadcast_address>
		if (ret) {
 80525cc:	84 c0                	test   %al,%al
 80525ce:	75 0d                	jne    80525dd <net_if_ipv4_is_addr_bcast+0x44>
	STRUCT_SECTION_FOREACH(net_if, iface) {
 80525d0:	83 c3 0c             	add    $0xc,%ebx
 80525d3:	81 fb bc 76 06 08    	cmp    $0x80676bc,%ebx
 80525d9:	72 e7                	jb     80525c2 <net_if_ipv4_is_addr_bcast+0x29>
out:
 80525db:	31 c0                	xor    %eax,%eax
 80525dd:	88 45 f7             	mov    %al,-0x9(%ebp)
	k_mutex_unlock(&lock);
 80525e0:	e8 b7 e2 ff ff       	call   805089c <k_mutex_unlock.constprop.0.isra.0>
}
 80525e5:	8a 45 f7             	mov    -0x9(%ebp),%al
 80525e8:	83 c4 14             	add    $0x14,%esp
 80525eb:	5b                   	pop    %ebx
 80525ec:	5d                   	pop    %ebp
 80525ed:	c3                   	ret    

080525ee <net_if_ipv4_select_src_iface>:
{
 80525ee:	55                   	push   %ebp
	k_mutex_lock(&lock, K_FOREVER);
 80525ef:	83 c8 ff             	or     $0xffffffff,%eax
{
 80525f2:	89 e5                	mov    %esp,%ebp
 80525f4:	53                   	push   %ebx
	STRUCT_SECTION_FOREACH(net_if, iface) {
 80525f5:	bb b0 76 06 08       	mov    $0x80676b0,%ebx
{
 80525fa:	52                   	push   %edx
	k_mutex_lock(&lock, K_FOREVER);
 80525fb:	89 c2                	mov    %eax,%edx
 80525fd:	e8 83 e2 ff ff       	call   8050885 <k_mutex_lock.constprop.0.isra.0>
	STRUCT_SECTION_FOREACH(net_if, iface) {
 8052602:	81 fb bc 76 06 08    	cmp    $0x80676bc,%ebx
 8052608:	73 17                	jae    8052621 <net_if_ipv4_select_src_iface+0x33>
		ret = net_if_ipv4_addr_mask_cmp(iface, dst);
 805260a:	50                   	push   %eax
 805260b:	50                   	push   %eax
 805260c:	ff 75 08             	push   0x8(%ebp)
 805260f:	53                   	push   %ebx
 8052610:	e8 fe fe ff ff       	call   8052513 <net_if_ipv4_addr_mask_cmp>
 8052615:	83 c4 10             	add    $0x10,%esp
		if (ret) {
 8052618:	84 c0                	test   %al,%al
 805261a:	75 0c                	jne    8052628 <net_if_ipv4_select_src_iface+0x3a>
	STRUCT_SECTION_FOREACH(net_if, iface) {
 805261c:	83 c3 0c             	add    $0xc,%ebx
 805261f:	eb e1                	jmp    8052602 <net_if_ipv4_select_src_iface+0x14>
		selected = net_if_get_default();
 8052621:	e8 73 ea ff ff       	call   8051099 <net_if_get_default>
 8052626:	89 c3                	mov    %eax,%ebx
	k_mutex_unlock(&lock);
 8052628:	e8 6f e2 ff ff       	call   805089c <k_mutex_unlock.constprop.0.isra.0>
}
 805262d:	89 d8                	mov    %ebx,%eax
 805262f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 8052632:	c9                   	leave  
 8052633:	c3                   	ret    

08052634 <net_if_ipv4_get_ll>:
{
 8052634:	55                   	push   %ebp
	return if_ipv4_get_addr(iface, addr_state, true);
 8052635:	b9 01 00 00 00       	mov    $0x1,%ecx
{
 805263a:	89 e5                	mov    %esp,%ebp
	return if_ipv4_get_addr(iface, addr_state, true);
 805263c:	0f be 55 0c          	movsbl 0xc(%ebp),%edx
 8052640:	8b 45 08             	mov    0x8(%ebp),%eax
}
 8052643:	5d                   	pop    %ebp
	return if_ipv4_get_addr(iface, addr_state, true);
 8052644:	e9 68 e2 ff ff       	jmp    80508b1 <if_ipv4_get_addr>

08052649 <net_if_ipv4_get_global_addr>:
{
 8052649:	55                   	push   %ebp
	return if_ipv4_get_addr(iface, addr_state, false);
 805264a:	31 c9                	xor    %ecx,%ecx
{
 805264c:	89 e5                	mov    %esp,%ebp
	return if_ipv4_get_addr(iface, addr_state, false);
 805264e:	0f be 55 0c          	movsbl 0xc(%ebp),%edx
 8052652:	8b 45 08             	mov    0x8(%ebp),%eax
}
 8052655:	5d                   	pop    %ebp
	return if_ipv4_get_addr(iface, addr_state, false);
 8052656:	e9 56 e2 ff ff       	jmp    80508b1 <if_ipv4_get_addr>

0805265b <net_if_ipv4_select_src_addr>:
{
 805265b:	55                   	push   %ebp
 805265c:	89 e5                	mov    %esp,%ebp
 805265e:	57                   	push   %edi
 805265f:	56                   	push   %esi
 8052660:	53                   	push   %ebx
 8052661:	83 ec 2c             	sub    $0x2c,%esp
 8052664:	8b 45 0c             	mov    0xc(%ebp),%eax
 8052667:	8b 75 08             	mov    0x8(%ebp),%esi
 805266a:	89 45 d4             	mov    %eax,-0x2c(%ebp)
 805266d:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 8052673:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 8052676:	31 c0                	xor    %eax,%eax
	k_mutex_lock(&lock, K_FOREVER);
 8052678:	83 c8 ff             	or     $0xffffffff,%eax
	uint8_t best_match = 0U;
 805267b:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
	k_mutex_lock(&lock, K_FOREVER);
 805267f:	89 c2                	mov    %eax,%edx
 8052681:	e8 ff e1 ff ff       	call   8050885 <k_mutex_lock.constprop.0.isra.0>
	if (!net_ipv4_is_ll_addr(dst)) {
 8052686:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 8052689:	e8 b7 e0 ff ff       	call   8050745 <net_ipv4_is_ll_addr>
 805268e:	84 c0                	test   %al,%al
 8052690:	75 3b                	jne    80526cd <net_if_ipv4_select_src_addr+0x72>
		if (dst_iface) {
 8052692:	85 f6                	test   %esi,%esi
 8052694:	74 10                	je     80526a6 <net_if_ipv4_select_src_addr+0x4b>
			src = net_if_ipv4_get_best_match(dst_iface, dst,
 8052696:	8b 46 08             	mov    0x8(%esi),%eax
 8052699:	8b 55 d4             	mov    -0x2c(%ebp),%edx
 805269c:	8d 4d e3             	lea    -0x1d(%ebp),%ecx
 805269f:	e8 1a e7 ff ff       	call   8050dbe <net_if_ipv4_get_best_match.isra.0>
 80526a4:	eb 38                	jmp    80526de <net_if_ipv4_select_src_addr+0x83>
	const struct in_addr *src = NULL;
 80526a6:	31 db                	xor    %ebx,%ebx
			STRUCT_SECTION_FOREACH(net_if, iface) {
 80526a8:	bf b0 76 06 08       	mov    $0x80676b0,%edi
 80526ad:	81 ff bc 76 06 08    	cmp    $0x80676bc,%edi
 80526b3:	73 52                	jae    8052707 <net_if_ipv4_select_src_addr+0xac>
				addr = net_if_ipv4_get_best_match(iface, dst,
 80526b5:	8b 47 08             	mov    0x8(%edi),%eax
 80526b8:	8b 55 d4             	mov    -0x2c(%ebp),%edx
 80526bb:	8d 4d e3             	lea    -0x1d(%ebp),%ecx
 80526be:	e8 fb e6 ff ff       	call   8050dbe <net_if_ipv4_get_best_match.isra.0>
				if (addr) {
 80526c3:	85 c0                	test   %eax,%eax
 80526c5:	0f 45 d8             	cmovne %eax,%ebx
			STRUCT_SECTION_FOREACH(net_if, iface) {
 80526c8:	83 c7 0c             	add    $0xc,%edi
 80526cb:	eb e0                	jmp    80526ad <net_if_ipv4_select_src_addr+0x52>
		if (dst_iface) {
 80526cd:	85 f6                	test   %esi,%esi
 80526cf:	74 11                	je     80526e2 <net_if_ipv4_select_src_addr+0x87>
			src = net_if_ipv4_get_ll(dst_iface, NET_ADDR_PREFERRED);
 80526d1:	51                   	push   %ecx
 80526d2:	51                   	push   %ecx
 80526d3:	6a 01                	push   $0x1
 80526d5:	56                   	push   %esi
 80526d6:	e8 59 ff ff ff       	call   8052634 <net_if_ipv4_get_ll>
 80526db:	83 c4 10             	add    $0x10,%esp
 80526de:	89 c3                	mov    %eax,%ebx
 80526e0:	eb 25                	jmp    8052707 <net_if_ipv4_select_src_addr+0xac>
			STRUCT_SECTION_FOREACH(net_if, iface) {
 80526e2:	bf b0 76 06 08       	mov    $0x80676b0,%edi
 80526e7:	81 ff bc 76 06 08    	cmp    $0x80676bc,%edi
 80526ed:	73 1c                	jae    805270b <net_if_ipv4_select_src_addr+0xb0>
				addr = net_if_ipv4_get_ll(iface,
 80526ef:	52                   	push   %edx
 80526f0:	52                   	push   %edx
 80526f1:	6a 01                	push   $0x1
 80526f3:	57                   	push   %edi
 80526f4:	e8 3b ff ff ff       	call   8052634 <net_if_ipv4_get_ll>
 80526f9:	83 c4 10             	add    $0x10,%esp
 80526fc:	89 c3                	mov    %eax,%ebx
				if (addr) {
 80526fe:	85 c0                	test   %eax,%eax
 8052700:	75 23                	jne    8052725 <net_if_ipv4_select_src_addr+0xca>
			STRUCT_SECTION_FOREACH(net_if, iface) {
 8052702:	83 c7 0c             	add    $0xc,%edi
 8052705:	eb e0                	jmp    80526e7 <net_if_ipv4_select_src_addr+0x8c>
	if (!src) {
 8052707:	85 db                	test   %ebx,%ebx
 8052709:	75 1a                	jne    8052725 <net_if_ipv4_select_src_addr+0xca>
		src = net_if_ipv4_get_global_addr(dst_iface,
 805270b:	50                   	push   %eax
 805270c:	50                   	push   %eax
 805270d:	6a 01                	push   $0x1
 805270f:	56                   	push   %esi
 8052710:	e8 34 ff ff ff       	call   8052649 <net_if_ipv4_get_global_addr>
 8052715:	83 c4 10             	add    $0x10,%esp
 8052718:	89 c3                	mov    %eax,%ebx
		if (!src) {
 805271a:	85 c0                	test   %eax,%eax
 805271c:	75 07                	jne    8052725 <net_if_ipv4_select_src_addr+0xca>
			src = net_ipv4_unspecified_address();
 805271e:	e8 4b 10 00 00       	call   805376e <net_ipv4_unspecified_address>
 8052723:	89 c3                	mov    %eax,%ebx
	k_mutex_unlock(&lock);
 8052725:	e8 72 e1 ff ff       	call   805089c <k_mutex_unlock.constprop.0.isra.0>
}
 805272a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 805272d:	65 2b 05 14 00 00 00 	sub    %gs:0x14,%eax
 8052734:	74 05                	je     805273b <net_if_ipv4_select_src_addr+0xe0>
 8052736:	e8 c5 6b ff ff       	call   8049300 <__stack_chk_fail@plt>
 805273b:	8d 65 f4             	lea    -0xc(%ebp),%esp
 805273e:	89 d8                	mov    %ebx,%eax
 8052740:	5b                   	pop    %ebx
 8052741:	5e                   	pop    %esi
 8052742:	5f                   	pop    %edi
 8052743:	5d                   	pop    %ebp
 8052744:	c3                   	ret    

08052745 <net_if_ipv4_addr_lookup>:
{
 8052745:	55                   	push   %ebp
	k_mutex_lock(&lock, K_FOREVER);
 8052746:	83 c8 ff             	or     $0xffffffff,%eax
 8052749:	89 c2                	mov    %eax,%edx
{
 805274b:	89 e5                	mov    %esp,%ebp
 805274d:	53                   	push   %ebx
 805274e:	83 ec 14             	sub    $0x14,%esp
 8052751:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	k_mutex_lock(&lock, K_FOREVER);
 8052754:	e8 2c e1 ff ff       	call   8050885 <k_mutex_lock.constprop.0.isra.0>
	STRUCT_SECTION_FOREACH(net_if, iface) {
 8052759:	ba b0 76 06 08       	mov    $0x80676b0,%edx
 805275e:	81 fa bc 76 06 08    	cmp    $0x80676bc,%edx
 8052764:	73 2a                	jae    8052790 <net_if_ipv4_addr_lookup+0x4b>
		struct net_if_ipv4 *ipv4 = iface->config.ip.ipv4;
 8052766:	8b 42 08             	mov    0x8(%edx),%eax
		if (!ipv4) {
 8052769:	85 c0                	test   %eax,%eax
 805276b:	74 1e                	je     805278b <net_if_ipv4_addr_lookup+0x46>
			if (!ipv4->unicast[i].is_used ||
 805276d:	f6 40 2f 02          	testb  $0x2,0x2f(%eax)
 8052771:	74 18                	je     805278b <net_if_ipv4_addr_lookup+0x46>
 8052773:	66 83 38 01          	cmpw   $0x1,(%eax)
 8052777:	75 12                	jne    805278b <net_if_ipv4_addr_lookup+0x46>
			if (UNALIGNED_GET(&addr->s4_addr32[0]) ==
 8052779:	8b 4d 08             	mov    0x8(%ebp),%ecx
 805277c:	8b 09                	mov    (%ecx),%ecx
 805277e:	39 48 04             	cmp    %ecx,0x4(%eax)
 8052781:	75 08                	jne    805278b <net_if_ipv4_addr_lookup+0x46>
				if (ret) {
 8052783:	85 db                	test   %ebx,%ebx
 8052785:	74 0b                	je     8052792 <net_if_ipv4_addr_lookup+0x4d>
					*ret = iface;
 8052787:	89 13                	mov    %edx,(%ebx)
				goto out;
 8052789:	eb 07                	jmp    8052792 <net_if_ipv4_addr_lookup+0x4d>
	STRUCT_SECTION_FOREACH(net_if, iface) {
 805278b:	83 c2 0c             	add    $0xc,%edx
 805278e:	eb ce                	jmp    805275e <net_if_ipv4_addr_lookup+0x19>
	struct net_if_addr *ifaddr = NULL;
 8052790:	31 c0                	xor    %eax,%eax
 8052792:	89 45 f4             	mov    %eax,-0xc(%ebp)
	k_mutex_unlock(&lock);
 8052795:	e8 02 e1 ff ff       	call   805089c <k_mutex_unlock.constprop.0.isra.0>
}
 805279a:	8b 45 f4             	mov    -0xc(%ebp),%eax
 805279d:	83 c4 14             	add    $0x14,%esp
 80527a0:	5b                   	pop    %ebx
 80527a1:	5d                   	pop    %ebp
 80527a2:	c3                   	ret    

080527a3 <net_if_ipv4_maddr_lookup>:
{
 80527a3:	55                   	push   %ebp
	k_mutex_lock(&lock, K_FOREVER);
 80527a4:	83 c8 ff             	or     $0xffffffff,%eax
 80527a7:	89 c2                	mov    %eax,%edx
{
 80527a9:	89 e5                	mov    %esp,%ebp
 80527ab:	56                   	push   %esi
 80527ac:	53                   	push   %ebx
	STRUCT_SECTION_FOREACH(net_if, iface) {
 80527ad:	bb b0 76 06 08       	mov    $0x80676b0,%ebx
{
 80527b2:	83 ec 10             	sub    $0x10,%esp
 80527b5:	8b 75 0c             	mov    0xc(%ebp),%esi
	k_mutex_lock(&lock, K_FOREVER);
 80527b8:	e8 c8 e0 ff ff       	call   8050885 <k_mutex_lock.constprop.0.isra.0>
	STRUCT_SECTION_FOREACH(net_if, iface) {
 80527bd:	81 fb bc 76 06 08    	cmp    $0x80676bc,%ebx
 80527c3:	73 2f                	jae    80527f4 <net_if_ipv4_maddr_lookup+0x51>
		if (ret && *ret && iface != *ret) {
 80527c5:	85 f6                	test   %esi,%esi
 80527c7:	74 0a                	je     80527d3 <net_if_ipv4_maddr_lookup+0x30>
 80527c9:	8b 06                	mov    (%esi),%eax
 80527cb:	85 c0                	test   %eax,%eax
 80527cd:	74 04                	je     80527d3 <net_if_ipv4_maddr_lookup+0x30>
 80527cf:	39 d8                	cmp    %ebx,%eax
 80527d1:	75 1c                	jne    80527ef <net_if_ipv4_maddr_lookup+0x4c>
		addr = ipv4_maddr_find(iface, true, maddr);
 80527d3:	8b 43 08             	mov    0x8(%ebx),%eax
 80527d6:	8b 4d 08             	mov    0x8(%ebp),%ecx
 80527d9:	ba 01 00 00 00       	mov    $0x1,%edx
 80527de:	e8 a9 e5 ff ff       	call   8050d8c <ipv4_maddr_find.isra.0>
		if (addr) {
 80527e3:	85 c0                	test   %eax,%eax
 80527e5:	74 08                	je     80527ef <net_if_ipv4_maddr_lookup+0x4c>
			if (ret) {
 80527e7:	85 f6                	test   %esi,%esi
 80527e9:	74 0b                	je     80527f6 <net_if_ipv4_maddr_lookup+0x53>
				*ret = iface;
 80527eb:	89 1e                	mov    %ebx,(%esi)
 80527ed:	eb 07                	jmp    80527f6 <net_if_ipv4_maddr_lookup+0x53>
	STRUCT_SECTION_FOREACH(net_if, iface) {
 80527ef:	83 c3 0c             	add    $0xc,%ebx
 80527f2:	eb c9                	jmp    80527bd <net_if_ipv4_maddr_lookup+0x1a>
out:
 80527f4:	31 c0                	xor    %eax,%eax
 80527f6:	89 45 f4             	mov    %eax,-0xc(%ebp)
	k_mutex_unlock(&lock);
 80527f9:	e8 9e e0 ff ff       	call   805089c <k_mutex_unlock.constprop.0.isra.0>
}
 80527fe:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8052801:	83 c4 10             	add    $0x10,%esp
 8052804:	5b                   	pop    %ebx
 8052805:	5e                   	pop    %esi
 8052806:	5d                   	pop    %ebp
 8052807:	c3                   	ret    

08052808 <net_if_recv_data>:
{
 8052808:	55                   	push   %ebp
 8052809:	89 e5                	mov    %esp,%ebp
 805280b:	83 ec 08             	sub    $0x8,%esp
	return net_if_l2(iface)->recv(iface, pkt);
 805280e:	8b 45 08             	mov    0x8(%ebp),%eax
 8052811:	e8 38 df ff ff       	call   805074e <net_if_l2>
 8052816:	8b 00                	mov    (%eax),%eax
}
 8052818:	c9                   	leave  
	return net_if_l2(iface)->recv(iface, pkt);
 8052819:	ff e0                	jmp    *%eax

0805281b <net_if_call_link_cb>:
{
 805281b:	55                   	push   %ebp
	k_mutex_lock(&lock, K_FOREVER);
 805281c:	83 c8 ff             	or     $0xffffffff,%eax
 805281f:	89 c2                	mov    %eax,%edx
{
 8052821:	89 e5                	mov    %esp,%ebp
 8052823:	57                   	push   %edi
 8052824:	56                   	push   %esi
 8052825:	53                   	push   %ebx
 8052826:	83 ec 1c             	sub    $0x1c,%esp
 8052829:	8b 5d 08             	mov    0x8(%ebp),%ebx
 805282c:	8b 75 0c             	mov    0xc(%ebp),%esi
 805282f:	8b 7d 10             	mov    0x10(%ebp),%edi
	k_mutex_lock(&lock, K_FOREVER);
 8052832:	e8 4e e0 ff ff       	call   8050885 <k_mutex_lock.constprop.0.isra.0>
	return list->head;
 8052837:	8b 15 b8 89 06 08    	mov    0x80689b8,%edx
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&link_callbacks, link, tmp, node) {
 805283d:	85 d2                	test   %edx,%edx
 805283f:	75 0c                	jne    805284d <net_if_call_link_cb+0x32>
}
 8052841:	8d 65 f4             	lea    -0xc(%ebp),%esp
 8052844:	5b                   	pop    %ebx
 8052845:	5e                   	pop    %esi
 8052846:	5f                   	pop    %edi
 8052847:	5d                   	pop    %ebp
	k_mutex_unlock(&lock);
 8052848:	e9 4f e0 ff ff       	jmp    805089c <k_mutex_unlock.constprop.0.isra.0>
	return node->next;
 805284d:	8b 02                	mov    (%edx),%eax
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&link_callbacks, link, tmp, node) {
 805284f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		link->cb(iface, lladdr, status);
 8052852:	50                   	push   %eax
 8052853:	57                   	push   %edi
 8052854:	56                   	push   %esi
 8052855:	53                   	push   %ebx
 8052856:	ff 52 04             	call   *0x4(%edx)
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&link_callbacks, link, tmp, node) {
 8052859:	8b 45 e4             	mov    -0x1c(%ebp),%eax
		link->cb(iface, lladdr, status);
 805285c:	83 c4 10             	add    $0x10,%esp
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&link_callbacks, link, tmp, node) {
 805285f:	85 c0                	test   %eax,%eax
 8052861:	74 de                	je     8052841 <net_if_call_link_cb+0x26>
 8052863:	89 c2                	mov    %eax,%edx
 8052865:	8b 00                	mov    (%eax),%eax
 8052867:	eb e6                	jmp    805284f <net_if_call_link_cb+0x34>

08052869 <net_if_tx.isra.0>:
static bool net_if_tx(struct net_if *iface, struct net_pkt *pkt)
 8052869:	55                   	push   %ebp
 805286a:	89 e5                	mov    %esp,%ebp
 805286c:	57                   	push   %edi
 805286d:	56                   	push   %esi
 805286e:	89 c6                	mov    %eax,%esi
 8052870:	53                   	push   %ebx
 8052871:	83 ec 3c             	sub    $0x3c,%esp
 8052874:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 805287a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 805287d:	31 c0                	xor    %eax,%eax
	struct net_linkaddr ll_dst = {
 805287f:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
 8052886:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	if (!pkt) {
 805288d:	85 d2                	test   %edx,%edx
 805288f:	0f 84 a7 00 00 00    	je     805293c <net_if_tx.isra.0+0xd3>
	if (!sys_slist_is_empty(&link_callbacks)) {
 8052895:	83 3d b8 89 06 08 00 	cmpl   $0x0,0x80689b8
 805289c:	89 d3                	mov    %edx,%ebx
 805289e:	74 37                	je     80528d7 <net_if_tx.isra.0+0x6e>
		if (net_linkaddr_set(&ll_dst_storage,
 80528a0:	8b 43 28             	mov    0x28(%ebx),%eax
				     net_pkt_lladdr_dst(pkt)->len) == 0) {
 80528a3:	8a 52 2c             	mov    0x2c(%edx),%dl
{
	if (!lladdr_store || !new_addr) {
		return -EINVAL;
	}

	if (new_len > NET_LINK_ADDR_MAX_LENGTH) {
 80528a6:	85 c0                	test   %eax,%eax
 80528a8:	74 2d                	je     80528d7 <net_if_tx.isra.0+0x6e>
 80528aa:	80 fa 06             	cmp    $0x6,%dl
 80528ad:	77 28                	ja     80528d7 <net_if_tx.isra.0+0x6e>
		return -EMSGSIZE;
	}

	lladdr_store->len = new_len;
	memcpy(lladdr_store->addr, new_addr, new_len);
 80528af:	0f b6 ca             	movzbl %dl,%ecx
 80528b2:	8d 7d de             	lea    -0x22(%ebp),%edi
 80528b5:	6a 06                	push   $0x6
 80528b7:	51                   	push   %ecx
 80528b8:	50                   	push   %eax
 80528b9:	57                   	push   %edi
	lladdr_store->len = new_len;
 80528ba:	88 55 dd             	mov    %dl,-0x23(%ebp)
	memcpy(lladdr_store->addr, new_addr, new_len);
 80528bd:	88 55 c4             	mov    %dl,-0x3c(%ebp)
 80528c0:	e8 7b 68 ff ff       	call   8049140 <__memcpy_chk@plt>
			ll_dst.len = ll_dst_storage.len;
 80528c5:	8a 55 c4             	mov    -0x3c(%ebp),%dl
			ll_dst.type = net_pkt_lladdr_dst(pkt)->type;
 80528c8:	8a 43 2d             	mov    0x2d(%ebx),%al
			ll_dst.addr = ll_dst_storage.addr;
 80528cb:	89 7d d4             	mov    %edi,-0x2c(%ebp)
 80528ce:	83 c4 10             	add    $0x10,%esp
			ll_dst.len = ll_dst_storage.len;
 80528d1:	88 55 d8             	mov    %dl,-0x28(%ebp)
			ll_dst.type = net_pkt_lladdr_dst(pkt)->type;
 80528d4:	88 45 d9             	mov    %al,-0x27(%ebp)
	return pkt->context;
 80528d7:	8b 43 14             	mov    0x14(%ebx),%eax
	if (net_if_flag_is_set(iface, NET_IF_LOWER_UP)) {
 80528da:	ba 09 00 00 00       	mov    $0x9,%edx
 80528df:	89 45 c4             	mov    %eax,-0x3c(%ebp)
 80528e2:	89 f0                	mov    %esi,%eax
 80528e4:	e8 11 e4 ff ff       	call   8050cfa <net_if_flag_is_set>
 80528e9:	84 c0                	test   %al,%al
 80528eb:	74 19                	je     8052906 <net_if_tx.isra.0+0x9d>
		status = net_if_l2(iface)->send(iface, pkt);
 80528ed:	89 f0                	mov    %esi,%eax
 80528ef:	e8 5a de ff ff       	call   805074e <net_if_l2>
 80528f4:	52                   	push   %edx
 80528f5:	52                   	push   %edx
 80528f6:	53                   	push   %ebx
 80528f7:	56                   	push   %esi
 80528f8:	ff 50 04             	call   *0x4(%eax)
 80528fb:	89 c7                	mov    %eax,%edi
 80528fd:	83 c4 10             	add    $0x10,%esp
	if (status < 0) {
 8052900:	85 c0                	test   %eax,%eax
 8052902:	79 13                	jns    8052917 <net_if_tx.isra.0+0xae>
 8052904:	eb 05                	jmp    805290b <net_if_tx.isra.0+0xa2>
		status = -ENETDOWN;
 8052906:	bf 9c ff ff ff       	mov    $0xffffff9c,%edi
		net_pkt_unref(pkt);
 805290b:	83 ec 0c             	sub    $0xc,%esp
 805290e:	53                   	push   %ebx
 805290f:	e8 d4 24 00 00       	call   8054de8 <net_pkt_unref>
 8052914:	83 c4 10             	add    $0x10,%esp
	if (context) {
 8052917:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
 805291b:	74 0a                	je     8052927 <net_if_tx.isra.0+0xbe>
		net_context_send_cb(context, status);
 805291d:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 8052920:	89 fa                	mov    %edi,%edx
 8052922:	e8 35 de ff ff       	call   805075c <net_context_send_cb>
	if (ll_dst.addr) {
 8052927:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
 805292b:	74 0f                	je     805293c <net_if_tx.isra.0+0xd3>
		net_if_call_link_cb(iface, &ll_dst, status);
 805292d:	50                   	push   %eax
 805292e:	8d 45 d4             	lea    -0x2c(%ebp),%eax
 8052931:	57                   	push   %edi
 8052932:	50                   	push   %eax
 8052933:	56                   	push   %esi
 8052934:	e8 e2 fe ff ff       	call   805281b <net_if_call_link_cb>
 8052939:	83 c4 10             	add    $0x10,%esp
}
 805293c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 805293f:	65 2b 05 14 00 00 00 	sub    %gs:0x14,%eax
 8052946:	74 05                	je     805294d <net_if_tx.isra.0+0xe4>
 8052948:	e8 b3 69 ff ff       	call   8049300 <__stack_chk_fail@plt>
 805294d:	8d 65 f4             	lea    -0xc(%ebp),%esp
 8052950:	5b                   	pop    %ebx
 8052951:	5e                   	pop    %esi
 8052952:	5f                   	pop    %edi
 8052953:	5d                   	pop    %ebp
 8052954:	c3                   	ret    

08052955 <net_if_queue_tx>:
{
 8052955:	55                   	push   %ebp
 8052956:	89 e5                	mov    %esp,%ebp
 8052958:	83 ec 24             	sub    $0x24,%esp
 805295b:	8b 55 0c             	mov    0xc(%ebp),%edx
	uint8_t tc = net_tx_priority2tc(prio);
 805295e:	0f b6 42 3d          	movzbl 0x3d(%edx),%eax
 8052962:	89 55 f4             	mov    %edx,-0xc(%ebp)
 8052965:	50                   	push   %eax
 8052966:	e8 27 30 00 00       	call   8055992 <net_tx_priority2tc>
		net_if_tx(net_pkt_iface(pkt), pkt);
 805296b:	8b 55 f4             	mov    -0xc(%ebp),%edx
	uint8_t tc = net_tx_priority2tc(prio);
 805296e:	83 c4 10             	add    $0x10,%esp
		net_if_tx(net_pkt_iface(pkt), pkt);
 8052971:	8b 42 18             	mov    0x18(%edx),%eax
}
 8052974:	c9                   	leave  
		net_if_tx(net_pkt_iface(pkt), pkt);
 8052975:	e9 ef fe ff ff       	jmp    8052869 <net_if_tx.isra.0>

0805297a <net_if_send_data>:
{
 805297a:	55                   	push   %ebp
	k_mutex_lock(&lock, K_FOREVER);
 805297b:	83 c8 ff             	or     $0xffffffff,%eax
 805297e:	89 c2                	mov    %eax,%edx
{
 8052980:	89 e5                	mov    %esp,%ebp
 8052982:	57                   	push   %edi
 8052983:	56                   	push   %esi
 8052984:	53                   	push   %ebx
 8052985:	83 ec 1c             	sub    $0x1c,%esp
 8052988:	8b 75 08             	mov    0x8(%ebp),%esi
 805298b:	8b 5d 0c             	mov    0xc(%ebp),%ebx
 805298e:	8b 7b 14             	mov    0x14(%ebx),%edi
	k_mutex_lock(&lock, K_FOREVER);
 8052991:	e8 ef de ff ff       	call   8050885 <k_mutex_lock.constprop.0.isra.0>
	if (!net_if_flag_is_set(iface, NET_IF_LOWER_UP) ||
 8052996:	ba 09 00 00 00       	mov    $0x9,%edx
 805299b:	89 f0                	mov    %esi,%eax
 805299d:	e8 58 e3 ff ff       	call   8050cfa <net_if_flag_is_set>
 80529a2:	84 c0                	test   %al,%al
 80529a4:	75 07                	jne    80529ad <net_if_send_data+0x33>
		status = -ENETDOWN;
 80529a6:	ba 9c ff ff ff       	mov    $0xffffff9c,%edx
 80529ab:	eb 69                	jmp    8052a16 <net_if_send_data+0x9c>
	    net_if_flag_is_set(iface, NET_IF_SUSPENDED)) {
 80529ad:	ba 04 00 00 00       	mov    $0x4,%edx
 80529b2:	89 f0                	mov    %esi,%eax
 80529b4:	e8 41 e3 ff ff       	call   8050cfa <net_if_flag_is_set>
	if (!net_if_flag_is_set(iface, NET_IF_LOWER_UP) ||
 80529b9:	84 c0                	test   %al,%al
 80529bb:	75 e9                	jne    80529a6 <net_if_send_data+0x2c>
	if (!net_if_flag_is_set(iface, NET_IF_POINTOPOINT) &&
 80529bd:	ba 01 00 00 00       	mov    $0x1,%edx
 80529c2:	89 f0                	mov    %esi,%eax
 80529c4:	e8 31 e3 ff ff       	call   8050cfa <net_if_flag_is_set>
 80529c9:	84 c0                	test   %al,%al
 80529cb:	75 19                	jne    80529e6 <net_if_send_data+0x6c>
 80529cd:	83 7b 20 00          	cmpl   $0x0,0x20(%ebx)
 80529d1:	75 13                	jne    80529e6 <net_if_send_data+0x6c>
	return net_if_get_link_addr(pkt->iface);
 80529d3:	8b 43 18             	mov    0x18(%ebx),%eax
		net_pkt_lladdr_src(pkt)->addr = net_pkt_lladdr_if(pkt)->addr;
 80529d6:	8b 10                	mov    (%eax),%edx
 80529d8:	8b 52 10             	mov    0x10(%edx),%edx
 80529db:	89 53 20             	mov    %edx,0x20(%ebx)
		net_pkt_lladdr_src(pkt)->len = net_pkt_lladdr_if(pkt)->len;
 80529de:	8b 00                	mov    (%eax),%eax
 80529e0:	8a 40 14             	mov    0x14(%eax),%al
 80529e3:	88 43 24             	mov    %al,0x24(%ebx)
	return pkt->family;
 80529e6:	8a 43 33             	mov    0x33(%ebx),%al
 80529e9:	c0 e8 05             	shr    $0x5,%al
	if (IS_ENABLED(CONFIG_NET_IPV6) && net_pkt_family(pkt) == AF_INET6) {
 80529ec:	3c 02                	cmp    $0x2,%al
 80529ee:	74 10                	je     8052a00 <net_if_send_data+0x86>
		net_if_queue_tx(iface, pkt);
 80529f0:	52                   	push   %edx
 80529f1:	52                   	push   %edx
 80529f2:	53                   	push   %ebx
 80529f3:	56                   	push   %esi
 80529f4:	e8 5c ff ff ff       	call   8052955 <net_if_queue_tx>
 80529f9:	83 c4 10             	add    $0x10,%esp
 80529fc:	31 c0                	xor    %eax,%eax
 80529fe:	eb 4d                	jmp    8052a4d <net_if_send_data+0xd3>
		verdict = net_ipv6_prepare_for_send(pkt);
 8052a00:	83 ec 0c             	sub    $0xc,%esp
 8052a03:	53                   	push   %ebx
 8052a04:	e8 8b 69 00 00       	call   8059394 <net_ipv6_prepare_for_send>
 8052a09:	83 c4 10             	add    $0x10,%esp
	if (verdict == NET_DROP) {
 8052a0c:	83 f8 02             	cmp    $0x2,%eax
 8052a0f:	75 38                	jne    8052a49 <net_if_send_data+0xcf>
	int status = -EIO;
 8052a11:	ba fb ff ff ff       	mov    $0xfffffffb,%edx
		if (context) {
 8052a16:	85 ff                	test   %edi,%edi
 8052a18:	74 0d                	je     8052a27 <net_if_send_data+0xad>
			net_context_send_cb(context, status);
 8052a1a:	89 f8                	mov    %edi,%eax
 8052a1c:	89 55 e4             	mov    %edx,-0x1c(%ebp)
 8052a1f:	e8 38 dd ff ff       	call   805075c <net_context_send_cb>
 8052a24:	8b 55 e4             	mov    -0x1c(%ebp),%edx
		if (dst->addr) {
 8052a27:	83 7b 28 00          	cmpl   $0x0,0x28(%ebx)
 8052a2b:	b8 02 00 00 00       	mov    $0x2,%eax
 8052a30:	74 1b                	je     8052a4d <net_if_send_data+0xd3>
	return &pkt->lladdr_dst;
 8052a32:	83 c3 28             	add    $0x28,%ebx
 8052a35:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			net_if_call_link_cb(iface, dst, status);
 8052a38:	50                   	push   %eax
 8052a39:	52                   	push   %edx
 8052a3a:	53                   	push   %ebx
 8052a3b:	56                   	push   %esi
 8052a3c:	e8 da fd ff ff       	call   805281b <net_if_call_link_cb>
 8052a41:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8052a44:	83 c4 10             	add    $0x10,%esp
 8052a47:	eb 04                	jmp    8052a4d <net_if_send_data+0xd3>
	} else if (verdict == NET_OK) {
 8052a49:	85 c0                	test   %eax,%eax
 8052a4b:	74 a3                	je     80529f0 <net_if_send_data+0x76>
 8052a4d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	k_mutex_unlock(&lock);
 8052a50:	e8 47 de ff ff       	call   805089c <k_mutex_unlock.constprop.0.isra.0>
}
 8052a55:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8052a58:	8d 65 f4             	lea    -0xc(%ebp),%esp
 8052a5b:	5b                   	pop    %ebx
 8052a5c:	5e                   	pop    %esi
 8052a5d:	5f                   	pop    %edi
 8052a5e:	5d                   	pop    %ebp
 8052a5f:	c3                   	ret    

08052a60 <net_if_need_calc_tx_checksum>:
{
 8052a60:	55                   	push   %ebp
	return need_calc_checksum(iface, ETHERNET_HW_TX_CHKSUM_OFFLOAD);
 8052a61:	ba 01 00 00 00       	mov    $0x1,%edx
{
 8052a66:	89 e5                	mov    %esp,%ebp
	return need_calc_checksum(iface, ETHERNET_HW_TX_CHKSUM_OFFLOAD);
 8052a68:	8b 45 08             	mov    0x8(%ebp),%eax
}
 8052a6b:	5d                   	pop    %ebp
	return need_calc_checksum(iface, ETHERNET_HW_TX_CHKSUM_OFFLOAD);
 8052a6c:	e9 4b e4 ff ff       	jmp    8050ebc <need_calc_checksum>

08052a71 <net_if_need_calc_rx_checksum>:
{
 8052a71:	55                   	push   %ebp
	return need_calc_checksum(iface, ETHERNET_HW_RX_CHKSUM_OFFLOAD);
 8052a72:	ba 02 00 00 00       	mov    $0x2,%edx
{
 8052a77:	89 e5                	mov    %esp,%ebp
	return need_calc_checksum(iface, ETHERNET_HW_RX_CHKSUM_OFFLOAD);
 8052a79:	8b 45 08             	mov    0x8(%ebp),%eax
}
 8052a7c:	5d                   	pop    %ebp
	return need_calc_checksum(iface, ETHERNET_HW_RX_CHKSUM_OFFLOAD);
 8052a7d:	e9 3a e4 ff ff       	jmp    8050ebc <need_calc_checksum>

08052a82 <net_if_get_by_iface>:
{
 8052a82:	55                   	push   %ebp
 8052a83:	89 e5                	mov    %esp,%ebp
 8052a85:	8b 45 08             	mov    0x8(%ebp),%eax
	if (!(iface >= _net_if_list_start && iface < _net_if_list_end)) {
 8052a88:	3d b0 76 06 08       	cmp    $0x80676b0,%eax
 8052a8d:	72 18                	jb     8052aa7 <net_if_get_by_iface+0x25>
 8052a8f:	3d bc 76 06 08       	cmp    $0x80676bc,%eax
 8052a94:	73 11                	jae    8052aa7 <net_if_get_by_iface+0x25>
	return (iface - _net_if_list_start) + 1;
 8052a96:	2d b0 76 06 08       	sub    $0x80676b0,%eax
 8052a9b:	c1 f8 02             	sar    $0x2,%eax
 8052a9e:	69 c0 ab aa aa aa    	imul   $0xaaaaaaab,%eax,%eax
 8052aa4:	40                   	inc    %eax
 8052aa5:	eb 03                	jmp    8052aaa <net_if_get_by_iface+0x28>
		return -1;
 8052aa7:	83 c8 ff             	or     $0xffffffff,%eax
}
 8052aaa:	5d                   	pop    %ebp
 8052aab:	c3                   	ret    

08052aac <net_if_up>:
	return;
#endif
}

int net_if_up(struct net_if *iface)
{
 8052aac:	55                   	push   %ebp
	int status = 0;

	NET_DBG("iface %p", iface);

	k_mutex_lock(&lock, K_FOREVER);
 8052aad:	83 c8 ff             	or     $0xffffffff,%eax
 8052ab0:	89 c2                	mov    %eax,%edx
{
 8052ab2:	89 e5                	mov    %esp,%ebp
 8052ab4:	56                   	push   %esi
 8052ab5:	53                   	push   %ebx
 8052ab6:	8b 75 08             	mov    0x8(%ebp),%esi

	if (net_if_flag_is_set(iface, NET_IF_UP)) {
		status = -EALREADY;
 8052ab9:	bb 8e ff ff ff       	mov    $0xffffff8e,%ebx
	k_mutex_lock(&lock, K_FOREVER);
 8052abe:	e8 c2 dd ff ff       	call   8050885 <k_mutex_lock.constprop.0.isra.0>
	if (net_if_flag_is_set(iface, NET_IF_UP)) {
 8052ac3:	31 d2                	xor    %edx,%edx
 8052ac5:	89 f0                	mov    %esi,%eax
 8052ac7:	e8 2e e2 ff ff       	call   8050cfa <net_if_flag_is_set>
 8052acc:	84 c0                	test   %al,%al
 8052ace:	75 36                	jne    8052b06 <net_if_up+0x5a>
		goto out;
	}

	/* If the L2 does not support enable just set the flag */
	if (!net_if_l2(iface) || !net_if_l2(iface)->enable) {
 8052ad0:	89 f0                	mov    %esi,%eax
 8052ad2:	e8 77 dc ff ff       	call   805074e <net_if_l2>
 8052ad7:	85 c0                	test   %eax,%eax
 8052ad9:	74 19                	je     8052af4 <net_if_up+0x48>
 8052adb:	8b 40 08             	mov    0x8(%eax),%eax
 8052ade:	85 c0                	test   %eax,%eax
 8052ae0:	74 12                	je     8052af4 <net_if_up+0x48>
		goto done;
	}

	/* Notify L2 to enable the interface */
	status = net_if_l2(iface)->enable(iface, true);
 8052ae2:	52                   	push   %edx
 8052ae3:	52                   	push   %edx
 8052ae4:	6a 01                	push   $0x1
 8052ae6:	56                   	push   %esi
 8052ae7:	ff d0                	call   *%eax
 8052ae9:	89 c3                	mov    %eax,%ebx
 8052aeb:	83 c4 10             	add    $0x10,%esp
	if (status < 0) {
 8052aee:	85 c0                	test   %eax,%eax
 8052af0:	79 04                	jns    8052af6 <net_if_up+0x4a>
 8052af2:	eb 12                	jmp    8052b06 <net_if_up+0x5a>
	int status = 0;
 8052af4:	31 db                	xor    %ebx,%ebx
	}

	init_igmp(iface);

done:
	net_if_flag_set(iface, NET_IF_UP);
 8052af6:	8b 06                	mov    (%esi),%eax
 8052af8:	31 d2                	xor    %edx,%edx
 8052afa:	e8 0d e4 ff ff       	call   8050f0c <net_if_flag_set.isra.0>
	net_mgmt_event_notify(NET_EVENT_IF_ADMIN_UP, iface);
	update_operational_state(iface);
 8052aff:	89 f0                	mov    %esi,%eax
 8052b01:	e8 d0 ed ff ff       	call   80518d6 <update_operational_state>

out:
	k_mutex_unlock(&lock);
 8052b06:	e8 91 dd ff ff       	call   805089c <k_mutex_unlock.constprop.0.isra.0>

	return status;
}
 8052b0b:	8d 65 f8             	lea    -0x8(%ebp),%esp
 8052b0e:	89 d8                	mov    %ebx,%eax
 8052b10:	5b                   	pop    %ebx
 8052b11:	5e                   	pop    %esi
 8052b12:	5d                   	pop    %ebp
 8052b13:	c3                   	ret    

08052b14 <net_if_carrier_on>:

	return status;
}

void net_if_carrier_on(struct net_if *iface)
{
 8052b14:	55                   	push   %ebp
	NET_ASSERT(iface);

	k_mutex_lock(&lock, K_FOREVER);
 8052b15:	83 c8 ff             	or     $0xffffffff,%eax
{
 8052b18:	89 e5                	mov    %esp,%ebp
 8052b1a:	53                   	push   %ebx
 8052b1b:	52                   	push   %edx
 8052b1c:	8b 5d 08             	mov    0x8(%ebp),%ebx
	k_mutex_lock(&lock, K_FOREVER);
 8052b1f:	89 c2                	mov    %eax,%edx
 8052b21:	e8 5f dd ff ff       	call   8050885 <k_mutex_lock.constprop.0.isra.0>

	if (!net_if_flag_test_and_set(iface, NET_IF_LOWER_UP)) {
 8052b26:	8b 03                	mov    (%ebx),%eax
 8052b28:	ba 09 00 00 00       	mov    $0x9,%edx
 8052b2d:	e8 ee e3 ff ff       	call   8050f20 <net_if_flag_test_and_set.isra.0>
 8052b32:	84 c0                	test   %al,%al
 8052b34:	75 07                	jne    8052b3d <net_if_carrier_on+0x29>
		update_operational_state(iface);
 8052b36:	89 d8                	mov    %ebx,%eax
 8052b38:	e8 99 ed ff ff       	call   80518d6 <update_operational_state>
	}

	k_mutex_unlock(&lock);
}
 8052b3d:	58                   	pop    %eax
 8052b3e:	5b                   	pop    %ebx
 8052b3f:	5d                   	pop    %ebp
	k_mutex_unlock(&lock);
 8052b40:	e9 57 dd ff ff       	jmp    805089c <k_mutex_unlock.constprop.0.isra.0>

08052b45 <net_if_carrier_off>:

void net_if_carrier_off(struct net_if *iface)
{
 8052b45:	55                   	push   %ebp
	NET_ASSERT(iface);

	k_mutex_lock(&lock, K_FOREVER);
 8052b46:	83 c8 ff             	or     $0xffffffff,%eax
{
 8052b49:	89 e5                	mov    %esp,%ebp
 8052b4b:	53                   	push   %ebx
 8052b4c:	52                   	push   %edx
 8052b4d:	8b 5d 08             	mov    0x8(%ebp),%ebx
	k_mutex_lock(&lock, K_FOREVER);
 8052b50:	89 c2                	mov    %eax,%edx
 8052b52:	e8 2e dd ff ff       	call   8050885 <k_mutex_lock.constprop.0.isra.0>
	return atomic_test_and_clear_bit(iface->if_dev->flags, value);
 8052b57:	8b 03                	mov    (%ebx),%eax
 8052b59:	ba 09 00 00 00       	mov    $0x9,%edx
 8052b5e:	83 c0 0c             	add    $0xc,%eax
 8052b61:	e8 c3 e3 ff ff       	call   8050f29 <atomic_test_and_clear_bit>

	if (net_if_flag_test_and_clear(iface, NET_IF_LOWER_UP)) {
 8052b66:	84 c0                	test   %al,%al
 8052b68:	74 07                	je     8052b71 <net_if_carrier_off+0x2c>
		update_operational_state(iface);
 8052b6a:	89 d8                	mov    %ebx,%eax
 8052b6c:	e8 65 ed ff ff       	call   80518d6 <update_operational_state>
	}

	k_mutex_unlock(&lock);
}
 8052b71:	58                   	pop    %eax
 8052b72:	5b                   	pop    %ebx
 8052b73:	5d                   	pop    %ebp
	k_mutex_unlock(&lock);
 8052b74:	e9 23 dd ff ff       	jmp    805089c <k_mutex_unlock.constprop.0.isra.0>

08052b79 <net_if_init>:
	k_fifo_put(&tx_ts_queue, pkt);
}
#endif /* CONFIG_NET_PKT_TIMESTAMP_THREAD */

void net_if_init(void)
{
 8052b79:	55                   	push   %ebp
	int if_count = 0;

	NET_DBG("");

	k_mutex_lock(&lock, K_FOREVER);
 8052b7a:	83 c8 ff             	or     $0xffffffff,%eax
 8052b7d:	89 c2                	mov    %eax,%edx
{
 8052b7f:	89 e5                	mov    %esp,%ebp
 8052b81:	57                   	push   %edi
 8052b82:	56                   	push   %esi
	int if_count = 0;
 8052b83:	31 f6                	xor    %esi,%esi
{
 8052b85:	53                   	push   %ebx

	net_tc_tx_init();

	STRUCT_SECTION_FOREACH(net_if, iface) {
 8052b86:	bb b0 76 06 08       	mov    $0x80676b0,%ebx
{
 8052b8b:	83 ec 0c             	sub    $0xc,%esp
	k_mutex_lock(&lock, K_FOREVER);
 8052b8e:	e8 f2 dc ff ff       	call   8050885 <k_mutex_lock.constprop.0.isra.0>
	net_tc_tx_init();
 8052b93:	e8 1a 2e 00 00       	call   80559b2 <net_tc_tx_init>
	STRUCT_SECTION_FOREACH(net_if, iface) {
 8052b98:	81 fb bc 76 06 08    	cmp    $0x80676bc,%ebx
 8052b9e:	73 41                	jae    8052be1 <net_if_init+0x68>
	return iface->if_dev->dev;
 8052ba0:	8b 03                	mov    (%ebx),%eax
	const struct net_if_api *api = net_if_get_device(iface)->api;
 8052ba2:	8b 10                	mov    (%eax),%edx
 8052ba4:	8b 7a 08             	mov    0x8(%edx),%edi
	if (!api || !api->init) {
 8052ba7:	85 ff                	test   %edi,%edi
 8052ba9:	74 30                	je     8052bdb <net_if_init+0x62>
 8052bab:	83 3f 00             	cmpl   $0x0,(%edi)
 8052bae:	74 2b                	je     8052bdb <net_if_init+0x62>
	net_if_flag_set(iface, NET_IF_IPV4);
 8052bb0:	ba 06 00 00 00       	mov    $0x6,%edx
 8052bb5:	e8 52 e3 ff ff       	call   8050f0c <net_if_flag_set.isra.0>
	net_if_flag_set(iface, NET_IF_IPV6);
 8052bba:	8b 03                	mov    (%ebx),%eax
 8052bbc:	ba 07 00 00 00       	mov    $0x7,%edx
 8052bc1:	e8 46 e3 ff ff       	call   8050f0c <net_if_flag_set.isra.0>
	net_if_flag_test_and_set(iface, NET_IF_LOWER_UP);
 8052bc6:	8b 03                	mov    (%ebx),%eax
 8052bc8:	ba 09 00 00 00       	mov    $0x9,%edx
 8052bcd:	e8 4e e3 ff ff       	call   8050f20 <net_if_flag_test_and_set.isra.0>
	api->init(iface);
 8052bd2:	83 ec 0c             	sub    $0xc,%esp
 8052bd5:	53                   	push   %ebx
 8052bd6:	ff 17                	call   *(%edi)
 8052bd8:	83 c4 10             	add    $0x10,%esp
		init_iface(iface);
		if_count++;
 8052bdb:	46                   	inc    %esi
	STRUCT_SECTION_FOREACH(net_if, iface) {
 8052bdc:	83 c3 0c             	add    $0xc,%ebx
 8052bdf:	eb b7                	jmp    8052b98 <net_if_init+0x1f>
	}

	if (if_count == 0) {
 8052be1:	85 f6                	test   %esi,%esi
 8052be3:	0f 84 bd 00 00 00    	je     8052ca6 <net_if_init+0x12d>
	k_work_init_delayable(&dad_timer, dad_timeout);
 8052be9:	50                   	push   %eax
 8052bea:	50                   	push   %eax
 8052beb:	68 b7 13 05 08       	push   $0x80513b7
 8052bf0:	68 40 7d 06 08       	push   $0x8067d40
 8052bf5:	e8 4b d0 00 00       	call   805fc45 <k_work_init_delayable>
 8052bfa:	5a                   	pop    %edx
 8052bfb:	59                   	pop    %ecx
	k_work_init_delayable(&rs_timer, rs_timeout);
 8052bfc:	68 f5 11 05 08       	push   $0x80511f5
 8052c01:	68 00 7d 06 08       	push   $0x8067d00
	list->head = NULL;
 8052c06:	c7 05 c8 89 06 08 00 	movl   $0x0,0x80689c8
 8052c0d:	00 00 00 
	list->tail = NULL;
 8052c10:	c7 05 cc 89 06 08 00 	movl   $0x0,0x80689cc
 8052c17:	00 00 00 
 8052c1a:	e8 26 d0 00 00       	call   805fc45 <k_work_init_delayable>
 8052c1f:	5b                   	pop    %ebx
 8052c20:	5e                   	pop    %esi
	k_work_init_delayable(&address_lifetime_timer,
 8052c21:	68 a0 0b 05 08       	push   $0x8050ba0
 8052c26:	68 c0 7d 06 08       	push   $0x8067dc0
	list->head = NULL;
 8052c2b:	c7 05 c0 89 06 08 00 	movl   $0x0,0x80689c0
 8052c32:	00 00 00 
	list->tail = NULL;
 8052c35:	c7 05 c4 89 06 08 00 	movl   $0x0,0x80689c4
 8052c3c:	00 00 00 
 8052c3f:	e8 01 d0 00 00       	call   805fc45 <k_work_init_delayable>
 8052c44:	5f                   	pop    %edi
 8052c45:	58                   	pop    %eax
	k_work_init_delayable(&prefix_lifetime_timer, prefix_lifetime_timeout);
 8052c46:	68 ce 1b 05 08       	push   $0x8051bce
 8052c4b:	68 80 7d 06 08       	push   $0x8067d80
 8052c50:	e8 f0 cf 00 00       	call   805fc45 <k_work_init_delayable>
	ipv6->reachable_time = net_if_ipv6_calc_reachable_time(ipv6);
 8052c55:	c7 04 24 e0 7b 06 08 	movl   $0x8067be0,(%esp)
		ipv6_addresses[i].ipv6.hop_limit = CONFIG_NET_INITIAL_HOP_LIMIT;
 8052c5c:	c6 05 ed 7c 06 08 40 	movb   $0x40,0x8067ced
		ipv6_addresses[i].ipv6.base_reachable_time = REACHABLE_TIME;
 8052c63:	c7 05 d8 7c 06 08 30 	movl   $0x7530,0x8067cd8
 8052c6a:	75 00 00 
 8052c6d:	e8 3f f8 ff ff       	call   80524b1 <net_if_ipv6_calc_reachable_time>
 8052c72:	5a                   	pop    %edx
 8052c73:	59                   	pop    %ecx
	k_work_init_delayable(&router_timer, iface_router_expired);
 8052c74:	68 61 0f 05 08       	push   $0x8050f61
 8052c79:	68 00 7e 06 08       	push   $0x8067e00
 8052c7e:	a3 dc 7c 06 08       	mov    %eax,0x8067cdc
		ipv4_addresses[i].ipv4.ttl = CONFIG_NET_INITIAL_TTL;
 8052c83:	c6 05 d0 7b 06 08 40 	movb   $0x40,0x8067bd0
	k_work_init_delayable(&router_timer, iface_router_expired);
 8052c8a:	e8 b6 cf 00 00       	call   805fc45 <k_work_init_delayable>
 8052c8f:	83 c4 10             	add    $0x10,%esp
	list->head = NULL;
 8052c92:	c7 05 e0 89 06 08 00 	movl   $0x0,0x80689e0
 8052c99:	00 00 00 
	list->tail = NULL;
 8052c9c:	c7 05 e4 89 06 08 00 	movl   $0x0,0x80689e4
 8052ca3:	00 00 00 
	}
#endif

out:
	k_mutex_unlock(&lock);
}
 8052ca6:	8d 65 f4             	lea    -0xc(%ebp),%esp
 8052ca9:	5b                   	pop    %ebx
 8052caa:	5e                   	pop    %esi
 8052cab:	5f                   	pop    %edi
 8052cac:	5d                   	pop    %ebp
	k_mutex_unlock(&lock);
 8052cad:	e9 ea db ff ff       	jmp    805089c <k_mutex_unlock.constprop.0.isra.0>

08052cb2 <net_if_post_init>:

void net_if_post_init(void)
{
 8052cb2:	55                   	push   %ebp
 8052cb3:	89 e5                	mov    %esp,%ebp
 8052cb5:	53                   	push   %ebx
	NET_DBG("");

	/* After TX is running, attempt to bring the interface up */
	STRUCT_SECTION_FOREACH(net_if, iface) {
 8052cb6:	bb b0 76 06 08       	mov    $0x80676b0,%ebx
{
 8052cbb:	50                   	push   %eax
	STRUCT_SECTION_FOREACH(net_if, iface) {
 8052cbc:	81 fb bc 76 06 08    	cmp    $0x80676bc,%ebx
 8052cc2:	73 21                	jae    8052ce5 <net_if_post_init+0x33>
		if (!net_if_flag_is_set(iface, NET_IF_NO_AUTO_START)) {
 8052cc4:	ba 03 00 00 00       	mov    $0x3,%edx
 8052cc9:	89 d8                	mov    %ebx,%eax
 8052ccb:	e8 2a e0 ff ff       	call   8050cfa <net_if_flag_is_set>
 8052cd0:	84 c0                	test   %al,%al
 8052cd2:	75 0c                	jne    8052ce0 <net_if_post_init+0x2e>
			net_if_up(iface);
 8052cd4:	83 ec 0c             	sub    $0xc,%esp
 8052cd7:	53                   	push   %ebx
 8052cd8:	e8 cf fd ff ff       	call   8052aac <net_if_up>
 8052cdd:	83 c4 10             	add    $0x10,%esp
	STRUCT_SECTION_FOREACH(net_if, iface) {
 8052ce0:	83 c3 0c             	add    $0xc,%ebx
 8052ce3:	eb d7                	jmp    8052cbc <net_if_post_init+0xa>
		}
	}
}
 8052ce5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 8052ce8:	c9                   	leave  
 8052ce9:	c3                   	ret    

08052cea <net_timeout_set>:
#include <zephyr/sys_clock.h>

void net_timeout_set(struct net_timeout *timeout,
		     uint32_t lifetime,
		     uint32_t now)
{
 8052cea:	55                   	push   %ebp
 8052ceb:	89 e5                	mov    %esp,%ebp
 8052ced:	57                   	push   %edi
 8052cee:	56                   	push   %esi
 8052cef:	53                   	push   %ebx
 8052cf0:	83 ec 0c             	sub    $0xc,%esp
 8052cf3:	8b 5d 08             	mov    0x8(%ebp),%ebx
	uint64_t expire_timeout;

	timeout->timer_start = now;
 8052cf6:	8b 45 10             	mov    0x10(%ebp),%eax
{
 8052cf9:	8b 75 0c             	mov    0xc(%ebp),%esi
	timeout->timer_start = now;
 8052cfc:	89 43 04             	mov    %eax,0x4(%ebx)

	/* Highly unlikely, but a zero timeout isn't correctly handled by the
	 * standard calculation.
	 */
	if (lifetime == 0U) {
 8052cff:	85 f6                	test   %esi,%esi
 8052d01:	75 10                	jne    8052d13 <net_timeout_set+0x29>
		timeout->wrap_counter = 0;
 8052d03:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
		timeout->timer_timeout = 0;
 8052d0a:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
		return;
 8052d11:	eb 37                	jmp    8052d4a <net_timeout_set+0x60>
	}

	expire_timeout = (uint64_t)MSEC_PER_SEC * (uint64_t)lifetime;
 8052d13:	b8 e8 03 00 00       	mov    $0x3e8,%eax
	timeout->wrap_counter = expire_timeout /
 8052d18:	6a 00                	push   $0x0
	expire_timeout = (uint64_t)MSEC_PER_SEC * (uint64_t)lifetime;
 8052d1a:	f7 e6                	mul    %esi
	timeout->wrap_counter = expire_timeout /
 8052d1c:	68 ff ff ff 7f       	push   $0x7fffffff
 8052d21:	52                   	push   %edx
	expire_timeout = (uint64_t)MSEC_PER_SEC * (uint64_t)lifetime;
 8052d22:	89 c6                	mov    %eax,%esi
	timeout->wrap_counter = expire_timeout /
 8052d24:	50                   	push   %eax
 8052d25:	e8 26 68 ff ff       	call   8049550 <__udivdi3>
 8052d2a:	83 c4 10             	add    $0x10,%esp
		(uint64_t)NET_TIMEOUT_MAX_VALUE;
	timeout->timer_timeout = expire_timeout -
		(uint64_t)NET_TIMEOUT_MAX_VALUE *
 8052d2d:	69 d0 ff ff ff 7f    	imul   $0x7fffffff,%eax,%edx
	timeout->wrap_counter = expire_timeout /
 8052d33:	89 43 0c             	mov    %eax,0xc(%ebx)

	/* The implementation requires that the fractional timeout be zero
	 * only when the timeout has completed, so if the residual is zero
	 * copy over one timeout from the wrap.
	 */
	if (timeout->timer_timeout == 0U) {
 8052d36:	29 d6                	sub    %edx,%esi
 8052d38:	74 05                	je     8052d3f <net_timeout_set+0x55>
	timeout->timer_timeout = expire_timeout -
 8052d3a:	89 73 08             	mov    %esi,0x8(%ebx)
 8052d3d:	eb 0b                	jmp    8052d4a <net_timeout_set+0x60>
		timeout->timer_timeout = NET_TIMEOUT_MAX_VALUE;
		timeout->wrap_counter -= 1;
 8052d3f:	48                   	dec    %eax
		timeout->timer_timeout = NET_TIMEOUT_MAX_VALUE;
 8052d40:	c7 43 08 ff ff ff 7f 	movl   $0x7fffffff,0x8(%ebx)
		timeout->wrap_counter -= 1;
 8052d47:	89 43 0c             	mov    %eax,0xc(%ebx)
	}
}
 8052d4a:	8d 65 f4             	lea    -0xc(%ebp),%esp
 8052d4d:	5b                   	pop    %ebx
 8052d4e:	5e                   	pop    %esi
 8052d4f:	5f                   	pop    %edi
 8052d50:	5d                   	pop    %ebp
 8052d51:	c3                   	ret    

08052d52 <net_timeout_remaining>:
	return (int64_t)deadline;
}

uint32_t net_timeout_remaining(const struct net_timeout *timeout,
			       uint32_t now)
{
 8052d52:	55                   	push   %ebp
	int64_t ret = timeout->timer_timeout;

	ret += timeout->wrap_counter * (uint64_t)NET_TIMEOUT_MAX_VALUE;
 8052d53:	b8 ff ff ff 7f       	mov    $0x7fffffff,%eax
{
 8052d58:	89 e5                	mov    %esp,%ebp
 8052d5a:	56                   	push   %esi
 8052d5b:	8b 75 08             	mov    0x8(%ebp),%esi
 8052d5e:	53                   	push   %ebx
	ret += timeout->wrap_counter * (uint64_t)NET_TIMEOUT_MAX_VALUE;
 8052d5f:	31 db                	xor    %ebx,%ebx
 8052d61:	f7 66 0c             	mull   0xc(%esi)
 8052d64:	8b 4e 08             	mov    0x8(%esi),%ecx
 8052d67:	01 c1                	add    %eax,%ecx
	ret -= (int64_t)(int32_t)(now - timeout->timer_start);
 8052d69:	8b 45 0c             	mov    0xc(%ebp),%eax
	ret += timeout->wrap_counter * (uint64_t)NET_TIMEOUT_MAX_VALUE;
 8052d6c:	11 d3                	adc    %edx,%ebx
	ret -= (int64_t)(int32_t)(now - timeout->timer_start);
 8052d6e:	2b 46 04             	sub    0x4(%esi),%eax
 8052d71:	99                   	cltd   
 8052d72:	29 c1                	sub    %eax,%ecx
 8052d74:	19 d3                	sbb    %edx,%ebx
	if (ret <= 0) {
 8052d76:	31 c0                	xor    %eax,%eax
 8052d78:	39 c8                	cmp    %ecx,%eax
 8052d7a:	19 d8                	sbb    %ebx,%eax
 8052d7c:	7d 13                	jge    8052d91 <net_timeout_remaining+0x3f>
		return 0;
	}

	return (uint32_t)((uint64_t)ret / MSEC_PER_SEC);
 8052d7e:	6a 00                	push   $0x0
 8052d80:	68 e8 03 00 00       	push   $0x3e8
 8052d85:	53                   	push   %ebx
 8052d86:	51                   	push   %ecx
 8052d87:	e8 c4 67 ff ff       	call   8049550 <__udivdi3>
 8052d8c:	83 c4 10             	add    $0x10,%esp
 8052d8f:	eb 02                	jmp    8052d93 <net_timeout_remaining+0x41>
 8052d91:	31 c0                	xor    %eax,%eax
}
 8052d93:	8d 65 f8             	lea    -0x8(%ebp),%esp
 8052d96:	5b                   	pop    %ebx
 8052d97:	5e                   	pop    %esi
 8052d98:	5d                   	pop    %ebp
 8052d99:	c3                   	ret    

08052d9a <net_timeout_evaluate>:

uint32_t net_timeout_evaluate(struct net_timeout *timeout,
			      uint32_t now)
{
 8052d9a:	55                   	push   %ebp
 8052d9b:	89 e5                	mov    %esp,%ebp
 8052d9d:	57                   	push   %edi
 8052d9e:	bf ff ff ff 7f       	mov    $0x7fffffff,%edi
 8052da3:	8b 55 08             	mov    0x8(%ebp),%edx
 8052da6:	56                   	push   %esi
 8052da7:	53                   	push   %ebx
 8052da8:	8b 75 0c             	mov    0xc(%ebp),%esi

	/* Time since last evaluation or set. */
	elapsed = now - timeout->timer_start;

	/* The delay used the last time this was evaluated. */
	wraps = (timeout->wrap_counter > 0U);
 8052dab:	8b 4a 0c             	mov    0xc(%edx),%ecx
	elapsed = now - timeout->timer_start;
 8052dae:	8b 5a 04             	mov    0x4(%edx),%ebx
	last_delay = wraps
		? NET_TIMEOUT_MAX_VALUE
		: timeout->timer_timeout;
 8052db1:	85 c9                	test   %ecx,%ecx
 8052db3:	75 03                	jne    8052db8 <net_timeout_evaluate+0x1e>
 8052db5:	8b 7a 08             	mov    0x8(%edx),%edi

	/* Time remaining until completion of the last delay. */
	remains = (int32_t)(last_delay - elapsed);
 8052db8:	89 d8                	mov    %ebx,%eax
 8052dba:	29 f0                	sub    %esi,%eax
 8052dbc:	01 f8                	add    %edi,%eax

	/* If the deadline for the next event hasn't been reached yet just
	 * return the remaining time.
	 */
	if (remains > 0) {
 8052dbe:	85 c0                	test   %eax,%eax
 8052dc0:	7f 47                	jg     8052e09 <net_timeout_evaluate+0x6f>
	/* Deadline has been reached.  If we're not wrapping we've completed
	 * the last portion of the full timeout, so return zero to indicate
	 * the timeout has completed.
	 */
	if (!wraps) {
		return 0U;
 8052dc2:	31 c0                	xor    %eax,%eax
	if (!wraps) {
 8052dc4:	85 c9                	test   %ecx,%ecx
 8052dc6:	74 41                	je     8052e09 <net_timeout_evaluate+0x6f>
	 * that's at least NET_TIMEOUT_MAX_VALUE, and can apply the
	 * reduction by decrementing the wrap count.
	 */
	timeout->timer_start = now;
	elapsed -= NET_TIMEOUT_MAX_VALUE;
	timeout->wrap_counter -= 1;
 8052dc8:	8d 41 ff             	lea    -0x1(%ecx),%eax
 8052dcb:	8d be 01 00 00 80    	lea    -0x7fffffff(%esi),%edi
	timeout->timer_start = now;
 8052dd1:	89 72 04             	mov    %esi,0x4(%edx)
	 * NET_TIMEOUT_MAX_VALUE.  But if subtracting would reduce the
	 * counter to zero or go negative we need to reduce the the wrap
	 * counter once more and add the residual to the counter, so the
	 * counter remains positive.
	 */
	if (timeout->timer_timeout > elapsed) {
 8052dd4:	8b 72 08             	mov    0x8(%edx),%esi
	timeout->wrap_counter -= 1;
 8052dd7:	89 42 0c             	mov    %eax,0xc(%edx)
	if (timeout->timer_timeout > elapsed) {
 8052dda:	89 d8                	mov    %ebx,%eax
 8052ddc:	29 f8                	sub    %edi,%eax
	elapsed -= NET_TIMEOUT_MAX_VALUE;
 8052dde:	29 df                	sub    %ebx,%edi
	if (timeout->timer_timeout > elapsed) {
 8052de0:	39 fe                	cmp    %edi,%esi
 8052de2:	76 07                	jbe    8052deb <net_timeout_evaluate+0x51>
		timeout->timer_timeout -= elapsed;
 8052de4:	01 f0                	add    %esi,%eax
 8052de6:	89 42 08             	mov    %eax,0x8(%edx)
 8052de9:	eb 10                	jmp    8052dfb <net_timeout_evaluate+0x61>
	} else {
		timeout->timer_timeout += NET_TIMEOUT_MAX_VALUE - elapsed;
 8052deb:	8d 84 06 ff ff ff 7f 	lea    0x7fffffff(%esi,%eax,1),%eax
		timeout->wrap_counter -= 1U;
 8052df2:	83 e9 02             	sub    $0x2,%ecx
		timeout->timer_timeout += NET_TIMEOUT_MAX_VALUE - elapsed;
 8052df5:	89 42 08             	mov    %eax,0x8(%edx)
		timeout->wrap_counter -= 1U;
 8052df8:	89 4a 0c             	mov    %ecx,0xc(%edx)
	}

	return (timeout->wrap_counter == 0U)
		? timeout->timer_timeout
		: NET_TIMEOUT_MAX_VALUE;
 8052dfb:	83 7a 0c 00          	cmpl   $0x0,0xc(%edx)
 8052dff:	b8 ff ff ff 7f       	mov    $0x7fffffff,%eax
 8052e04:	75 03                	jne    8052e09 <net_timeout_evaluate+0x6f>
 8052e06:	8b 42 08             	mov    0x8(%edx),%eax
}
 8052e09:	5b                   	pop    %ebx
 8052e0a:	5e                   	pop    %esi
 8052e0b:	5f                   	pop    %edi
 8052e0c:	5d                   	pop    %ebp
 8052e0d:	c3                   	ret    

08052e0e <convert_port>:
}
#endif /* CONFIG_NET_IPV4_IGMP */

#if defined(CONFIG_NET_IP)
static bool convert_port(const char *buf, uint16_t *port)
{
 8052e0e:	55                   	push   %ebp
 8052e0f:	89 e5                	mov    %esp,%ebp
 8052e11:	57                   	push   %edi
 8052e12:	56                   	push   %esi
 8052e13:	89 d6                	mov    %edx,%esi
 8052e15:	53                   	push   %ebx
 8052e16:	89 c3                	mov    %eax,%ebx
 8052e18:	83 ec 20             	sub    $0x20,%esp
 8052e1b:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 8052e21:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 8052e24:	31 c0                	xor    %eax,%eax
	unsigned long tmp;
	char *endptr;

	tmp = strtoul(buf, &endptr, 10);
 8052e26:	8d 45 e0             	lea    -0x20(%ebp),%eax
 8052e29:	6a 0a                	push   $0xa
 8052e2b:	50                   	push   %eax
 8052e2c:	53                   	push   %ebx
 8052e2d:	e8 fe 63 ff ff       	call   8049230 <strtoul@plt>
	if ((endptr == buf && tmp == 0) ||
 8052e32:	8b 7d e0             	mov    -0x20(%ebp),%edi
	tmp = strtoul(buf, &endptr, 10);
 8052e35:	83 c4 10             	add    $0x10,%esp
 8052e38:	89 c2                	mov    %eax,%edx
	if ((endptr == buf && tmp == 0) ||
 8052e3a:	39 df                	cmp    %ebx,%edi
 8052e3c:	0f 94 c0             	sete   %al
 8052e3f:	85 d2                	test   %edx,%edx
 8052e41:	0f 94 c1             	sete   %cl
 8052e44:	20 c8                	and    %cl,%al
 8052e46:	75 19                	jne    8052e61 <convert_port+0x53>
 8052e48:	80 3b 00             	cmpb   $0x0,(%ebx)
 8052e4b:	74 16                	je     8052e63 <convert_port+0x55>
	    !(*buf != '\0' && *endptr == '\0') ||
 8052e4d:	80 3f 00             	cmpb   $0x0,(%edi)
 8052e50:	75 11                	jne    8052e63 <convert_port+0x55>
 8052e52:	f7 c2 00 00 ff ff    	test   $0xffff0000,%edx
 8052e58:	75 09                	jne    8052e63 <convert_port+0x55>
	    ((unsigned long)(unsigned short)tmp != tmp)) {
 8052e5a:	66 89 16             	mov    %dx,(%esi)
		return false;
	}

	*port = tmp;

	return true;
 8052e5d:	b0 01                	mov    $0x1,%al
 8052e5f:	eb 02                	jmp    8052e63 <convert_port+0x55>
		return false;
 8052e61:	31 c0                	xor    %eax,%eax
}
 8052e63:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 8052e66:	65 2b 15 14 00 00 00 	sub    %gs:0x14,%edx
 8052e6d:	74 05                	je     8052e74 <convert_port+0x66>
 8052e6f:	e8 8c 64 ff ff       	call   8049300 <__stack_chk_fail@plt>
 8052e74:	8d 65 f4             	lea    -0xc(%ebp),%esp
 8052e77:	5b                   	pop    %ebx
 8052e78:	5e                   	pop    %esi
 8052e79:	5f                   	pop    %edi
 8052e7a:	5d                   	pop    %ebp
 8052e7b:	c3                   	ret    

08052e7c <net_byte_to_hex>:
{
 8052e7c:	55                   	push   %ebp
 8052e7d:	89 e5                	mov    %esp,%ebp
 8052e7f:	57                   	push   %edi
 8052e80:	8b 45 0c             	mov    0xc(%ebp),%eax
			*ptr++ = (char) (val - 10 + base);
 8052e83:	8b 7d 08             	mov    0x8(%ebp),%edi
{
 8052e86:	56                   	push   %esi
 8052e87:	8b 4d 14             	mov    0x14(%ebp),%ecx
 8052e8a:	8b 75 10             	mov    0x10(%ebp),%esi
 8052e8d:	53                   	push   %ebx
		if (i == 0 && !pad && !val) {
 8052e8e:	89 c3                	mov    %eax,%ebx
			*ptr++ = (char) (val - 10 + base);
 8052e90:	8d 57 01             	lea    0x1(%edi),%edx
		if (i == 0 && !pad && !val) {
 8052e93:	c0 eb 04             	shr    $0x4,%bl
 8052e96:	75 04                	jne    8052e9c <net_byte_to_hex+0x20>
 8052e98:	fe c9                	dec    %cl
 8052e9a:	75 14                	jne    8052eb0 <net_byte_to_hex+0x34>
			*ptr++ = (char) (val - 10 + base);
 8052e9c:	8d 7b 30             	lea    0x30(%ebx),%edi
 8052e9f:	8d 4c 33 f6          	lea    -0xa(%ebx,%esi,1),%ecx
 8052ea3:	80 fb 09             	cmp    $0x9,%bl
 8052ea6:	0f 46 cf             	cmovbe %edi,%ecx
 8052ea9:	8b 7d 08             	mov    0x8(%ebp),%edi
 8052eac:	88 0f                	mov    %cl,(%edi)
 8052eae:	eb 03                	jmp    8052eb3 <net_byte_to_hex+0x37>
		if (i == 0 && !pad && !val) {
 8052eb0:	8b 55 08             	mov    0x8(%ebp),%edx
	for (i = 0, val = (byte & 0xf0) >> 4; i < 2; i++, val = byte & 0x0f) {
 8052eb3:	83 e0 0f             	and    $0xf,%eax
			*ptr++ = (char) (val - 10 + base);
 8052eb6:	8d 5a 01             	lea    0x1(%edx),%ebx
			*ptr++ = (char) (val + '0');
 8052eb9:	8d 48 30             	lea    0x30(%eax),%ecx
		if (val < 10) {
 8052ebc:	3c 09                	cmp    $0x9,%al
 8052ebe:	76 04                	jbe    8052ec4 <net_byte_to_hex+0x48>
			*ptr++ = (char) (val - 10 + base);
 8052ec0:	8d 4c 30 f6          	lea    -0xa(%eax,%esi,1),%ecx
 8052ec4:	88 0a                	mov    %cl,(%edx)
}
 8052ec6:	89 d8                	mov    %ebx,%eax
	*ptr = '\0';
 8052ec8:	c6 42 01 00          	movb   $0x0,0x1(%edx)
}
 8052ecc:	5b                   	pop    %ebx
 8052ecd:	5e                   	pop    %esi
 8052ece:	5f                   	pop    %edi
 8052ecf:	5d                   	pop    %ebp
 8052ed0:	c3                   	ret    

08052ed1 <net_sprint_ll_addr_buf>:
{
 8052ed1:	55                   	push   %ebp
		return "<unknown>";
 8052ed2:	ba 17 36 06 08       	mov    $0x8063617,%edx
{
 8052ed7:	89 e5                	mov    %esp,%ebp
 8052ed9:	57                   	push   %edi
 8052eda:	56                   	push   %esi
 8052edb:	53                   	push   %ebx
 8052edc:	83 ec 1c             	sub    $0x1c,%esp
 8052edf:	8b 75 08             	mov    0x8(%ebp),%esi
 8052ee2:	8b 45 0c             	mov    0xc(%ebp),%eax
	if (ll == NULL) {
 8052ee5:	85 f6                	test   %esi,%esi
 8052ee7:	74 5c                	je     8052f45 <net_sprint_ll_addr_buf+0x74>
	switch (ll_len) {
 8052ee9:	83 e8 02             	sub    $0x2,%eax
	if (ll == NULL) {
 8052eec:	b1 06                	mov    $0x6,%cl
 8052eee:	3c 06                	cmp    $0x6,%al
 8052ef0:	77 09                	ja     8052efb <net_sprint_ll_addr_buf+0x2a>
 8052ef2:	0f b6 c0             	movzbl %al,%eax
 8052ef5:	8a 88 38 24 06 08    	mov    0x8062438(%eax),%cl
	for (i = 0U, blen = buflen; i < len && blen > 0; i++) {
 8052efb:	8a 55 14             	mov    0x14(%ebp),%dl
 8052efe:	8b 45 10             	mov    0x10(%ebp),%eax
 8052f01:	31 db                	xor    %ebx,%ebx
 8052f03:	38 d9                	cmp    %bl,%cl
 8052f05:	76 30                	jbe    8052f37 <net_sprint_ll_addr_buf+0x66>
 8052f07:	84 d2                	test   %dl,%dl
 8052f09:	74 2c                	je     8052f37 <net_sprint_ll_addr_buf+0x66>
		ptr = net_byte_to_hex(ptr, (char)ll[i], 'A', true);
 8052f0b:	6a 01                	push   $0x1
 8052f0d:	6a 41                	push   $0x41
 8052f0f:	0f b6 3c 1e          	movzbl (%esi,%ebx,1),%edi
 8052f13:	43                   	inc    %ebx
 8052f14:	88 55 e6             	mov    %dl,-0x1a(%ebp)
 8052f17:	57                   	push   %edi
 8052f18:	50                   	push   %eax
 8052f19:	88 4d e7             	mov    %cl,-0x19(%ebp)
 8052f1c:	e8 5b ff ff ff       	call   8052e7c <net_byte_to_hex>
		blen -= 3U;
 8052f21:	8a 55 e6             	mov    -0x1a(%ebp),%dl
 8052f24:	8a 4d e7             	mov    -0x19(%ebp),%cl
		ptr = net_byte_to_hex(ptr, (char)ll[i], 'A', true);
 8052f27:	83 c4 10             	add    $0x10,%esp
 8052f2a:	89 c7                	mov    %eax,%edi
		*ptr++ = ':';
 8052f2c:	8d 40 01             	lea    0x1(%eax),%eax
 8052f2f:	c6 07 3a             	movb   $0x3a,(%edi)
		blen -= 3U;
 8052f32:	83 ea 03             	sub    $0x3,%edx
	for (i = 0U, blen = buflen; i < len && blen > 0; i++) {
 8052f35:	eb cc                	jmp    8052f03 <net_sprint_ll_addr_buf+0x32>
		return NULL;
 8052f37:	31 d2                	xor    %edx,%edx
	if (!(ptr - buf)) {
 8052f39:	3b 45 10             	cmp    0x10(%ebp),%eax
 8052f3c:	74 07                	je     8052f45 <net_sprint_ll_addr_buf+0x74>
	*(ptr - 1) = '\0';
 8052f3e:	c6 40 ff 00          	movb   $0x0,-0x1(%eax)
	return buf;
 8052f42:	8b 55 10             	mov    0x10(%ebp),%edx
}
 8052f45:	8d 65 f4             	lea    -0xc(%ebp),%esp
 8052f48:	89 d0                	mov    %edx,%eax
 8052f4a:	5b                   	pop    %ebx
 8052f4b:	5e                   	pop    %esi
 8052f4c:	5f                   	pop    %edi
 8052f4d:	5d                   	pop    %ebp
 8052f4e:	c3                   	ret    

08052f4f <z_impl_net_addr_pton>:
{
 8052f4f:	55                   	push   %ebp
 8052f50:	89 e5                	mov    %esp,%ebp
 8052f52:	57                   	push   %edi
 8052f53:	56                   	push   %esi
 8052f54:	53                   	push   %ebx
 8052f55:	83 ec 2c             	sub    $0x2c,%esp
 8052f58:	8b 7d 10             	mov    0x10(%ebp),%edi
 8052f5b:	8b 45 08             	mov    0x8(%ebp),%eax
 8052f5e:	8b 5d 0c             	mov    0xc(%ebp),%ebx
 8052f61:	89 7d d4             	mov    %edi,-0x2c(%ebp)
 8052f64:	65 8b 15 14 00 00 00 	mov    %gs:0x14,%edx
 8052f6b:	89 55 e4             	mov    %edx,-0x1c(%ebp)
 8052f6e:	31 d2                	xor    %edx,%edx
	if (family == AF_INET) {
 8052f70:	66 83 f8 01          	cmp    $0x1,%ax
 8052f74:	75 66                	jne    8052fdc <z_impl_net_addr_pton+0x8d>
		len = strlen(src);
 8052f76:	83 ec 0c             	sub    $0xc,%esp
 8052f79:	53                   	push   %ebx
 8052f7a:	e8 c1 62 ff ff       	call   8049240 <strlen@plt>
 8052f7f:	83 c4 10             	add    $0x10,%esp
		for (i = 0; i < len; i++) {
 8052f82:	31 d2                	xor    %edx,%edx
		len = strlen(src);
 8052f84:	89 c7                	mov    %eax,%edi
		for (i = 0; i < len; i++) {
 8052f86:	39 fa                	cmp    %edi,%edx
 8052f88:	74 1e                	je     8052fa8 <z_impl_net_addr_pton+0x59>
			if (!(src[i] >= '0' && src[i] <= '9') &&
 8052f8a:	8a 0c 13             	mov    (%ebx,%edx,1),%cl
 8052f8d:	8d 71 d0             	lea    -0x30(%ecx),%esi
 8052f90:	89 f0                	mov    %esi,%eax
 8052f92:	3c 09                	cmp    $0x9,%al
 8052f94:	76 0f                	jbe    8052fa5 <z_impl_net_addr_pton+0x56>
 8052f96:	80 f9 2e             	cmp    $0x2e,%cl
 8052f99:	74 0a                	je     8052fa5 <z_impl_net_addr_pton+0x56>
				return -EINVAL;
 8052f9b:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
 8052fa0:	e9 bf 01 00 00       	jmp    8053164 <z_impl_net_addr_pton+0x215>
		for (i = 0; i < len; i++) {
 8052fa5:	42                   	inc    %edx
 8052fa6:	eb de                	jmp    8052f86 <z_impl_net_addr_pton+0x37>
  return __builtin___memset_chk (__dest, __ch, __len,
 8052fa8:	8b 45 d4             	mov    -0x2c(%ebp),%eax
		for (i = 0; i < sizeof(struct in_addr); i++) {
 8052fab:	31 f6                	xor    %esi,%esi
 8052fad:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			addr->s4_addr[i] = strtol(src, &endptr, 10);
 8052fb3:	8d 45 e0             	lea    -0x20(%ebp),%eax
 8052fb6:	57                   	push   %edi
 8052fb7:	6a 0a                	push   $0xa
 8052fb9:	50                   	push   %eax
 8052fba:	53                   	push   %ebx
 8052fbb:	e8 c0 61 ff ff       	call   8049180 <strtol@plt>
 8052fc0:	8b 7d d4             	mov    -0x2c(%ebp),%edi
 8052fc3:	83 c4 10             	add    $0x10,%esp
 8052fc6:	88 04 37             	mov    %al,(%edi,%esi,1)
			src = ++endptr;
 8052fc9:	8b 45 e0             	mov    -0x20(%ebp),%eax
		for (i = 0; i < sizeof(struct in_addr); i++) {
 8052fcc:	46                   	inc    %esi
			src = ++endptr;
 8052fcd:	8d 58 01             	lea    0x1(%eax),%ebx
		for (i = 0; i < sizeof(struct in_addr); i++) {
 8052fd0:	83 fe 04             	cmp    $0x4,%esi
 8052fd3:	75 de                	jne    8052fb3 <z_impl_net_addr_pton+0x64>
	return 0;
 8052fd5:	31 c0                	xor    %eax,%eax
 8052fd7:	e9 88 01 00 00       	jmp    8053164 <z_impl_net_addr_pton+0x215>
	} else if (family == AF_INET6) {
 8052fdc:	66 83 f8 02          	cmp    $0x2,%ax
 8052fe0:	75 b9                	jne    8052f9b <z_impl_net_addr_pton+0x4c>
		int expected_groups = strchr(src, '.') ? 6 : 8;
 8052fe2:	56                   	push   %esi
 8052fe3:	56                   	push   %esi
 8052fe4:	6a 2e                	push   $0x2e
 8052fe6:	53                   	push   %ebx
 8052fe7:	e8 04 61 ff ff       	call   80490f0 <strchr@plt>
 8052fec:	83 c4 10             	add    $0x10,%esp
 8052fef:	83 f8 01             	cmp    $0x1,%eax
 8052ff2:	19 f6                	sbb    %esi,%esi
 8052ff4:	83 e6 02             	and    $0x2,%esi
 8052ff7:	83 c6 06             	add    $0x6,%esi
		if (*src == ':') {
 8052ffa:	80 3b 3a             	cmpb   $0x3a,(%ebx)
 8052ffd:	75 01                	jne    8053000 <z_impl_net_addr_pton+0xb1>
			src++;
 8052fff:	43                   	inc    %ebx
		len = strlen(src);
 8053000:	83 ec 0c             	sub    $0xc,%esp
 8053003:	53                   	push   %ebx
 8053004:	e8 37 62 ff ff       	call   8049240 <strlen@plt>
 8053009:	83 c4 10             	add    $0x10,%esp
 805300c:	89 c7                	mov    %eax,%edi
		for (i = 0; i < len; i++) {
 805300e:	31 c0                	xor    %eax,%eax
 8053010:	39 f8                	cmp    %edi,%eax
 8053012:	7d 24                	jge    8053038 <z_impl_net_addr_pton+0xe9>
			if (!(src[i] >= '0' && src[i] <= '9') &&
 8053014:	8a 14 03             	mov    (%ebx,%eax,1),%dl
 8053017:	89 d1                	mov    %edx,%ecx
 8053019:	83 e1 df             	and    $0xffffffdf,%ecx
 805301c:	83 e9 41             	sub    $0x41,%ecx
 805301f:	80 f9 05             	cmp    $0x5,%cl
 8053022:	76 11                	jbe    8053035 <z_impl_net_addr_pton+0xe6>
 8053024:	8d 4a d0             	lea    -0x30(%edx),%ecx
 8053027:	80 f9 0a             	cmp    $0xa,%cl
 805302a:	76 09                	jbe    8053035 <z_impl_net_addr_pton+0xe6>
			    src[i] != '.' && src[i] != ':') {
 805302c:	80 fa 2e             	cmp    $0x2e,%dl
 805302f:	0f 85 66 ff ff ff    	jne    8052f9b <z_impl_net_addr_pton+0x4c>
		for (i = 0; i < len; i++) {
 8053035:	40                   	inc    %eax
 8053036:	eb d8                	jmp    8053010 <z_impl_net_addr_pton+0xc1>
		for (i = 0; i < expected_groups; i++) {
 8053038:	31 d2                	xor    %edx,%edx
			if (!src || *src == '\0') {
 805303a:	8a 03                	mov    (%ebx),%al
 805303c:	84 c0                	test   %al,%al
 805303e:	0f 84 57 ff ff ff    	je     8052f9b <z_impl_net_addr_pton+0x4c>
			if (*src != ':') {
 8053044:	3c 3a                	cmp    $0x3a,%al
 8053046:	74 55                	je     805309d <z_impl_net_addr_pton+0x14e>
				UNALIGNED_PUT(htons(strtol(src, NULL, 16)),
 8053048:	50                   	push   %eax
 8053049:	6a 10                	push   $0x10
 805304b:	6a 00                	push   $0x0
 805304d:	53                   	push   %ebx
 805304e:	89 55 d0             	mov    %edx,-0x30(%ebp)
 8053051:	e8 2a 61 ff ff       	call   8049180 <strtol@plt>
 8053056:	83 c4 0c             	add    $0xc,%esp
 8053059:	6a 10                	push   $0x10
 805305b:	89 c7                	mov    %eax,%edi
 805305d:	6a 00                	push   $0x0
 805305f:	66 c1 ef 08          	shr    $0x8,%di
 8053063:	53                   	push   %ebx
 8053064:	e8 17 61 ff ff       	call   8049180 <strtol@plt>
 8053069:	5a                   	pop    %edx
 805306a:	8b 55 d0             	mov    -0x30(%ebp),%edx
 805306d:	c1 e0 08             	shl    $0x8,%eax
 8053070:	59                   	pop    %ecx
 8053071:	09 c7                	or     %eax,%edi
 8053073:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 8053076:	66 89 3c 50          	mov    %di,(%eax,%edx,2)
				src = strchr(src, ':');
 805307a:	6a 3a                	push   $0x3a
 805307c:	53                   	push   %ebx
 805307d:	e8 6e 60 ff ff       	call   80490f0 <strchr@plt>
 8053082:	83 c4 10             	add    $0x10,%esp
				if (src) {
 8053085:	8b 55 d0             	mov    -0x30(%ebp),%edx
 8053088:	85 c0                	test   %eax,%eax
				src = strchr(src, ':');
 805308a:	89 c3                	mov    %eax,%ebx
				if (src) {
 805308c:	74 03                	je     8053091 <z_impl_net_addr_pton+0x142>
					src++;
 805308e:	43                   	inc    %ebx
 805308f:	eb 69                	jmp    80530fa <z_impl_net_addr_pton+0x1ab>
					if (i < expected_groups - 1) {
 8053091:	8d 46 ff             	lea    -0x1(%esi),%eax
 8053094:	39 d0                	cmp    %edx,%eax
 8053096:	7e 62                	jle    80530fa <z_impl_net_addr_pton+0x1ab>
 8053098:	e9 fe fe ff ff       	jmp    8052f9b <z_impl_net_addr_pton+0x4c>
				UNALIGNED_PUT(0, &addr->s6_addr16[i]);
 805309d:	89 f1                	mov    %esi,%ecx
 805309f:	b8 02 00 00 00       	mov    $0x2,%eax
 80530a4:	29 d1                	sub    %edx,%ecx
 80530a6:	01 c9                	add    %ecx,%ecx
 80530a8:	39 d6                	cmp    %edx,%esi
 80530aa:	0f 4e c8             	cmovle %eax,%ecx
 80530ad:	01 d2                	add    %edx,%edx
 80530af:	03 55 d4             	add    -0x2c(%ebp),%edx
 80530b2:	31 c0                	xor    %eax,%eax
 80530b4:	89 d7                	mov    %edx,%edi
 80530b6:	f3 aa                	rep stos %al,%es:(%edi)
			tmp = strrchr(src, ':');
 80530b8:	57                   	push   %edi
 80530b9:	57                   	push   %edi
 80530ba:	6a 3a                	push   $0x3a
 80530bc:	53                   	push   %ebx
 80530bd:	e8 8e 60 ff ff       	call   8049150 <strrchr@plt>
 80530c2:	83 c4 10             	add    $0x10,%esp
			if (src == tmp && (expected_groups == 6 || !src[1])) {
 80530c5:	39 d8                	cmp    %ebx,%eax
 80530c7:	75 0e                	jne    80530d7 <z_impl_net_addr_pton+0x188>
 80530c9:	83 fe 06             	cmp    $0x6,%esi
 80530cc:	74 06                	je     80530d4 <z_impl_net_addr_pton+0x185>
 80530ce:	80 7b 01 00          	cmpb   $0x0,0x1(%ebx)
 80530d2:	75 09                	jne    80530dd <z_impl_net_addr_pton+0x18e>
				src++;
 80530d4:	43                   	inc    %ebx
				break;
 80530d5:	eb 35                	jmp    805310c <z_impl_net_addr_pton+0x1bd>
			if (expected_groups == 6) {
 80530d7:	83 fe 06             	cmp    $0x6,%esi
 80530da:	75 01                	jne    80530dd <z_impl_net_addr_pton+0x18e>
				tmp--;
 80530dc:	48                   	dec    %eax
			i = expected_groups - 1;
 80530dd:	8d 56 ff             	lea    -0x1(%esi),%edx
				if (*tmp == ':') {
 80530e0:	80 38 3a             	cmpb   $0x3a,(%eax)
 80530e3:	75 01                	jne    80530e6 <z_impl_net_addr_pton+0x197>
					i--;
 80530e5:	4a                   	dec    %edx
				if (i < 0) {
 80530e6:	83 fa ff             	cmp    $0xffffffff,%edx
 80530e9:	0f 84 ac fe ff ff    	je     8052f9b <z_impl_net_addr_pton+0x4c>
			} while (tmp-- != src);
 80530ef:	48                   	dec    %eax
 80530f0:	8d 48 01             	lea    0x1(%eax),%ecx
 80530f3:	39 cb                	cmp    %ecx,%ebx
 80530f5:	75 e9                	jne    80530e0 <z_impl_net_addr_pton+0x191>
			src++;
 80530f7:	8d 58 02             	lea    0x2(%eax),%ebx
		for (i = 0; i < expected_groups; i++) {
 80530fa:	42                   	inc    %edx
 80530fb:	39 d6                	cmp    %edx,%esi
 80530fd:	7e 0d                	jle    805310c <z_impl_net_addr_pton+0x1bd>
			if (!src || *src == '\0') {
 80530ff:	85 db                	test   %ebx,%ebx
 8053101:	0f 85 33 ff ff ff    	jne    805303a <z_impl_net_addr_pton+0xeb>
 8053107:	e9 8f fe ff ff       	jmp    8052f9b <z_impl_net_addr_pton+0x4c>
		if (expected_groups == 6) {
 805310c:	83 fe 06             	cmp    $0x6,%esi
 805310f:	0f 85 c0 fe ff ff    	jne    8052fd5 <z_impl_net_addr_pton+0x86>
			for (i = 0; i < 4; i++) {
 8053115:	31 f6                	xor    %esi,%esi
				if (!src || !*src) {
 8053117:	85 db                	test   %ebx,%ebx
 8053119:	0f 84 7c fe ff ff    	je     8052f9b <z_impl_net_addr_pton+0x4c>
 805311f:	80 3b 00             	cmpb   $0x0,(%ebx)
 8053122:	0f 84 73 fe ff ff    	je     8052f9b <z_impl_net_addr_pton+0x4c>
				addr->s6_addr[12 + i] = strtol(src, NULL, 10);
 8053128:	50                   	push   %eax
 8053129:	6a 0a                	push   $0xa
 805312b:	6a 00                	push   $0x0
 805312d:	53                   	push   %ebx
 805312e:	e8 4d 60 ff ff       	call   8049180 <strtol@plt>
 8053133:	8b 7d d4             	mov    -0x2c(%ebp),%edi
 8053136:	5a                   	pop    %edx
 8053137:	59                   	pop    %ecx
 8053138:	88 44 37 0c          	mov    %al,0xc(%edi,%esi,1)
				src = strchr(src, '.');
 805313c:	6a 2e                	push   $0x2e
 805313e:	53                   	push   %ebx
 805313f:	e8 ac 5f ff ff       	call   80490f0 <strchr@plt>
 8053144:	83 c4 10             	add    $0x10,%esp
 8053147:	89 c3                	mov    %eax,%ebx
				if (src) {
 8053149:	85 c0                	test   %eax,%eax
 805314b:	74 03                	je     8053150 <z_impl_net_addr_pton+0x201>
					src++;
 805314d:	43                   	inc    %ebx
 805314e:	eb 09                	jmp    8053159 <z_impl_net_addr_pton+0x20a>
					if (i < 3) {
 8053150:	83 fe 03             	cmp    $0x3,%esi
 8053153:	0f 85 42 fe ff ff    	jne    8052f9b <z_impl_net_addr_pton+0x4c>
			for (i = 0; i < 4; i++) {
 8053159:	46                   	inc    %esi
 805315a:	83 fe 04             	cmp    $0x4,%esi
 805315d:	75 b8                	jne    8053117 <z_impl_net_addr_pton+0x1c8>
 805315f:	e9 71 fe ff ff       	jmp    8052fd5 <z_impl_net_addr_pton+0x86>
}
 8053164:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 8053167:	65 2b 15 14 00 00 00 	sub    %gs:0x14,%edx
 805316e:	74 05                	je     8053175 <z_impl_net_addr_pton+0x226>
 8053170:	e8 8b 61 ff ff       	call   8049300 <__stack_chk_fail@plt>
 8053175:	8d 65 f4             	lea    -0xc(%ebp),%esp
 8053178:	5b                   	pop    %ebx
 8053179:	5e                   	pop    %esi
 805317a:	5f                   	pop    %edi
 805317b:	5d                   	pop    %ebp
 805317c:	c3                   	ret    

0805317d <parse_ipv6>:
#endif /* CONFIG_NET_IP */

#if defined(CONFIG_NET_IPV6)
static bool parse_ipv6(const char *str, size_t str_len,
		       struct sockaddr *addr, bool has_port)
{
 805317d:	55                   	push   %ebp
 805317e:	89 e5                	mov    %esp,%ebp
 8053180:	57                   	push   %edi
 8053181:	56                   	push   %esi
 8053182:	53                   	push   %ebx
 8053183:	89 c3                	mov    %eax,%ebx
 8053185:	83 ec 6c             	sub    $0x6c,%esp
 8053188:	8b 45 08             	mov    0x8(%ebp),%eax
 805318b:	89 55 a0             	mov    %edx,-0x60(%ebp)
 805318e:	89 4d 9c             	mov    %ecx,-0x64(%ebp)
 8053191:	89 45 98             	mov    %eax,-0x68(%ebp)
 8053194:	8a 45 98             	mov    -0x68(%ebp),%al
 8053197:	88 45 a7             	mov    %al,-0x59(%ebp)
	struct in6_addr *addr6;
	char ipaddr[INET6_ADDRSTRLEN + 1];
	int end, len, ret, i;
	uint16_t port;

	len = MIN(INET6_ADDRSTRLEN, str_len);
 805319a:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 80531a0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 80531a3:	b8 2e 00 00 00       	mov    $0x2e,%eax
 80531a8:	39 c2                	cmp    %eax,%edx
 80531aa:	0f 46 c2             	cmovbe %edx,%eax

	for (i = 0; i < len; i++) {
 80531ad:	31 f6                	xor    %esi,%esi
 80531af:	39 f0                	cmp    %esi,%eax
 80531b1:	7e 09                	jle    80531bc <parse_ipv6+0x3f>
		if (!str[i]) {
 80531b3:	80 3c 33 00          	cmpb   $0x0,(%ebx,%esi,1)
 80531b7:	74 05                	je     80531be <parse_ipv6+0x41>
	for (i = 0; i < len; i++) {
 80531b9:	46                   	inc    %esi
 80531ba:	eb f3                	jmp    80531af <parse_ipv6+0x32>
 80531bc:	89 c6                	mov    %eax,%esi
			len = i;
			break;
		}
	}

	if (has_port) {
 80531be:	80 7d 98 00          	cmpb   $0x0,-0x68(%ebp)
 80531c2:	74 40                	je     8053204 <parse_ipv6+0x87>
		/* IPv6 address with port number */
		ptr = memchr(str, ']', len);
 80531c4:	52                   	push   %edx
 80531c5:	56                   	push   %esi
 80531c6:	6a 5d                	push   $0x5d
 80531c8:	53                   	push   %ebx
 80531c9:	e8 82 61 ff ff       	call   8049350 <memchr@plt>
 80531ce:	83 c4 10             	add    $0x10,%esp
 80531d1:	89 c1                	mov    %eax,%ecx
		if (!ptr) {
 80531d3:	85 c0                	test   %eax,%eax
 80531d5:	75 09                	jne    80531e0 <parse_ipv6+0x63>
			return false;
 80531d7:	c6 45 a7 00          	movb   $0x0,-0x59(%ebp)
 80531db:	e9 d0 00 00 00       	jmp    80532b0 <parse_ipv6+0x133>
		}

		end = MIN(len, ptr - (str + 1));
 80531e0:	8d 43 01             	lea    0x1(%ebx),%eax
 80531e3:	89 cf                	mov    %ecx,%edi
  return __builtin___memcpy_chk (__dest, __src, __len,
 80531e5:	6a 2f                	push   $0x2f
 80531e7:	29 c7                	sub    %eax,%edi
 80531e9:	89 4d 94             	mov    %ecx,-0x6c(%ebp)
 80531ec:	39 fe                	cmp    %edi,%esi
 80531ee:	0f 4f f7             	cmovg  %edi,%esi
 80531f1:	56                   	push   %esi
 80531f2:	50                   	push   %eax
 80531f3:	8d 45 b5             	lea    -0x4b(%ebp),%eax
 80531f6:	50                   	push   %eax
 80531f7:	e8 44 5f ff ff       	call   8049140 <__memcpy_chk@plt>
 80531fc:	8b 4d 94             	mov    -0x6c(%ebp),%ecx
 80531ff:	83 c4 10             	add    $0x10,%esp
 8053202:	eb 12                	jmp    8053216 <parse_ipv6+0x99>
 8053204:	8d 45 b5             	lea    -0x4b(%ebp),%eax
 8053207:	6a 2f                	push   $0x2f
 8053209:	56                   	push   %esi
 805320a:	53                   	push   %ebx
 805320b:	50                   	push   %eax
 805320c:	e8 2f 5f ff ff       	call   8049140 <__memcpy_chk@plt>
 8053211:	83 c4 10             	add    $0x10,%esp
	char *ptr = NULL;
 8053214:	31 c9                	xor    %ecx,%ecx
 8053216:	89 4d 94             	mov    %ecx,-0x6c(%ebp)
	} else {
		end = len;
		memcpy(ipaddr, str, end);
	}

	ipaddr[end] = '\0';
 8053219:	c6 44 35 b5 00       	movb   $0x0,-0x4b(%ebp,%esi,1)
		union { uintptr_t x; void * val; } parm2 = { .val = dst };
		return (int) arch_syscall_invoke3(parm0.x, parm1.x, parm2.x, K_SYSCALL_NET_ADDR_PTON);
	}
#endif
	compiler_barrier();
	return z_impl_net_addr_pton(family, src, dst);
 805321e:	50                   	push   %eax

	addr6 = &net_sin6(addr)->sin6_addr;
 805321f:	8b 45 9c             	mov    -0x64(%ebp),%eax
 8053222:	8d 7d b5             	lea    -0x4b(%ebp),%edi
 8053225:	83 c0 04             	add    $0x4,%eax
 8053228:	50                   	push   %eax
 8053229:	57                   	push   %edi
 805322a:	6a 02                	push   $0x2
 805322c:	e8 1e fd ff ff       	call   8052f4f <z_impl_net_addr_pton>
 8053231:	83 c4 10             	add    $0x10,%esp

	ret = net_addr_pton(AF_INET6, ipaddr, addr6);
	if (ret < 0) {
 8053234:	85 c0                	test   %eax,%eax
 8053236:	78 9f                	js     80531d7 <parse_ipv6+0x5a>
		return false;
	}

	net_sin6(addr)->sin6_family = AF_INET6;
 8053238:	8b 45 9c             	mov    -0x64(%ebp),%eax

	if (!has_port) {
 805323b:	80 7d 98 00          	cmpb   $0x0,-0x68(%ebp)
	net_sin6(addr)->sin6_family = AF_INET6;
 805323f:	66 c7 00 02 00       	movw   $0x2,(%eax)
	if (!has_port) {
 8053244:	74 66                	je     80532ac <parse_ipv6+0x12f>
		return true;
	}

	if ((ptr + 1) < (str + str_len) && *(ptr + 1) == ':') {
 8053246:	8b 4d 94             	mov    -0x6c(%ebp),%ecx
 8053249:	03 5d a0             	add    -0x60(%ebp),%ebx
 805324c:	8d 41 01             	lea    0x1(%ecx),%eax
 805324f:	39 d8                	cmp    %ebx,%eax
 8053251:	73 5d                	jae    80532b0 <parse_ipv6+0x133>
 8053253:	80 79 01 3a          	cmpb   $0x3a,0x1(%ecx)
 8053257:	75 57                	jne    80532b0 <parse_ipv6+0x133>
		/* -1 as end does not contain first [
		 * -2 as pointer is advanced by 2, skipping ]:
		 */
		len = str_len - end - 1 - 2;
 8053259:	8b 45 a0             	mov    -0x60(%ebp),%eax

		ptr += 2;
 805325c:	8d 51 02             	lea    0x2(%ecx),%edx

		for (i = 0; i < len; i++) {
 805325f:	31 db                	xor    %ebx,%ebx
		len = str_len - end - 1 - 2;
 8053261:	83 e8 03             	sub    $0x3,%eax
 8053264:	29 f0                	sub    %esi,%eax
		for (i = 0; i < len; i++) {
 8053266:	39 d8                	cmp    %ebx,%eax
 8053268:	7e 0a                	jle    8053274 <parse_ipv6+0xf7>
			if (!ptr[i]) {
 805326a:	80 7c 19 02 00       	cmpb   $0x0,0x2(%ecx,%ebx,1)
 805326f:	74 05                	je     8053276 <parse_ipv6+0xf9>
		for (i = 0; i < len; i++) {
 8053271:	43                   	inc    %ebx
 8053272:	eb f2                	jmp    8053266 <parse_ipv6+0xe9>
 8053274:	89 c3                	mov    %eax,%ebx
 8053276:	6a 2f                	push   $0x2f
 8053278:	53                   	push   %ebx
 8053279:	52                   	push   %edx
 805327a:	57                   	push   %edi
 805327b:	e8 c0 5e ff ff       	call   8049140 <__memcpy_chk@plt>
 8053280:	83 c4 10             	add    $0x10,%esp

		/* Re-use the ipaddr buf for port conversion */
		memcpy(ipaddr, ptr, len);
		ipaddr[len] = '\0';

		ret = convert_port(ipaddr, &port);
 8053283:	8d 55 b2             	lea    -0x4e(%ebp),%edx
 8053286:	89 f8                	mov    %edi,%eax
		ipaddr[len] = '\0';
 8053288:	c6 44 1d b5 00       	movb   $0x0,-0x4b(%ebp,%ebx,1)
		ret = convert_port(ipaddr, &port);
 805328d:	e8 7c fb ff ff       	call   8052e0e <convert_port>
 8053292:	88 45 a7             	mov    %al,-0x59(%ebp)
		if (!ret) {
 8053295:	84 c0                	test   %al,%al
 8053297:	0f 84 3a ff ff ff    	je     80531d7 <parse_ipv6+0x5a>
			return false;
		}

		net_sin6(addr)->sin6_port = htons(port);
 805329d:	66 8b 45 b2          	mov    -0x4e(%ebp),%ax
 80532a1:	8b 7d 9c             	mov    -0x64(%ebp),%edi
 80532a4:	86 e0                	xchg   %ah,%al
 80532a6:	66 89 47 02          	mov    %ax,0x2(%edi)

		NET_DBG("IPv6 host %s port %d",
 80532aa:	eb 04                	jmp    80532b0 <parse_ipv6+0x133>
		return true;
 80532ac:	c6 45 a7 01          	movb   $0x1,-0x59(%ebp)
		NET_DBG("IPv6 host %s",
			net_addr_ntop(AF_INET6, addr6, ipaddr, sizeof(ipaddr) - 1));
	}

	return true;
}
 80532b0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 80532b3:	65 2b 05 14 00 00 00 	sub    %gs:0x14,%eax
 80532ba:	74 05                	je     80532c1 <parse_ipv6+0x144>
 80532bc:	e8 3f 60 ff ff       	call   8049300 <__stack_chk_fail@plt>
 80532c1:	8a 45 a7             	mov    -0x59(%ebp),%al
 80532c4:	8d 65 f4             	lea    -0xc(%ebp),%esp
 80532c7:	5b                   	pop    %ebx
 80532c8:	5e                   	pop    %esi
 80532c9:	5f                   	pop    %edi
 80532ca:	5d                   	pop    %ebp
 80532cb:	c3                   	ret    

080532cc <parse_ipv4>:
#endif /* CONFIG_NET_IPV6 */

#if defined(CONFIG_NET_IPV4)
static bool parse_ipv4(const char *str, size_t str_len,
		       struct sockaddr *addr, bool has_port)
{
 80532cc:	55                   	push   %ebp
 80532cd:	89 e5                	mov    %esp,%ebp
 80532cf:	57                   	push   %edi
 80532d0:	56                   	push   %esi
 80532d1:	89 ce                	mov    %ecx,%esi
 80532d3:	53                   	push   %ebx
 80532d4:	89 c3                	mov    %eax,%ebx
 80532d6:	83 ec 3c             	sub    $0x3c,%esp
 80532d9:	8b 45 08             	mov    0x8(%ebp),%eax
 80532dc:	89 55 c4             	mov    %edx,-0x3c(%ebp)
 80532df:	89 45 c0             	mov    %eax,-0x40(%ebp)
	char ipaddr[NET_IPV4_ADDR_LEN + 1];
	struct in_addr *addr4;
	int end, len, ret, i;
	uint16_t port;

	len = MIN(NET_IPV4_ADDR_LEN, str_len);
 80532e2:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 80532e8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 80532eb:	b8 10 00 00 00       	mov    $0x10,%eax
 80532f0:	39 c2                	cmp    %eax,%edx
 80532f2:	0f 46 c2             	cmovbe %edx,%eax

	for (i = 0; i < len; i++) {
 80532f5:	31 ff                	xor    %edi,%edi
 80532f7:	39 f8                	cmp    %edi,%eax
 80532f9:	7e 09                	jle    8053304 <parse_ipv4+0x38>
		if (!str[i]) {
 80532fb:	80 3c 3b 00          	cmpb   $0x0,(%ebx,%edi,1)
 80532ff:	74 05                	je     8053306 <parse_ipv4+0x3a>
	for (i = 0; i < len; i++) {
 8053301:	47                   	inc    %edi
 8053302:	eb f3                	jmp    80532f7 <parse_ipv4+0x2b>
 8053304:	89 c7                	mov    %eax,%edi
			len = i;
			break;
		}
	}

	if (has_port) {
 8053306:	80 7d c0 00          	cmpb   $0x0,-0x40(%ebp)
 805330a:	74 20                	je     805332c <parse_ipv4+0x60>
		/* IPv4 address with port number */
		ptr = memchr(str, ':', len);
 805330c:	50                   	push   %eax
 805330d:	57                   	push   %edi
 805330e:	6a 3a                	push   $0x3a
 8053310:	53                   	push   %ebx
 8053311:	e8 3a 60 ff ff       	call   8049350 <memchr@plt>
 8053316:	83 c4 10             	add    $0x10,%esp
 8053319:	89 c1                	mov    %eax,%ecx
		if (!ptr) {
 805331b:	85 c0                	test   %eax,%eax
 805331d:	75 04                	jne    8053323 <parse_ipv4+0x57>
			return false;
 805331f:	31 c0                	xor    %eax,%eax
 8053321:	eb 7b                	jmp    805339e <parse_ipv4+0xd2>
		}

		end = MIN(len, ptr - str);
 8053323:	29 d8                	sub    %ebx,%eax
 8053325:	39 c7                	cmp    %eax,%edi
 8053327:	0f 4f f8             	cmovg  %eax,%edi
 805332a:	eb 02                	jmp    805332e <parse_ipv4+0x62>
	char *ptr = NULL;
 805332c:	31 c9                	xor    %ecx,%ecx
 805332e:	6a 11                	push   $0x11
 8053330:	57                   	push   %edi
 8053331:	53                   	push   %ebx
 8053332:	8d 5d d3             	lea    -0x2d(%ebp),%ebx
 8053335:	53                   	push   %ebx
 8053336:	89 4d bc             	mov    %ecx,-0x44(%ebp)
 8053339:	e8 02 5e ff ff       	call   8049140 <__memcpy_chk@plt>
 805333e:	83 c4 0c             	add    $0xc,%esp
	} else {
		end = len;
	}

	memcpy(ipaddr, str, end);
	ipaddr[end] = '\0';
 8053341:	c6 44 3d d3 00       	movb   $0x0,-0x2d(%ebp,%edi,1)

	addr4 = &net_sin(addr)->sin_addr;
 8053346:	8d 46 04             	lea    0x4(%esi),%eax
 8053349:	50                   	push   %eax
 805334a:	53                   	push   %ebx
 805334b:	6a 01                	push   $0x1
 805334d:	e8 fd fb ff ff       	call   8052f4f <z_impl_net_addr_pton>
 8053352:	83 c4 10             	add    $0x10,%esp

	ret = net_addr_pton(AF_INET, ipaddr, addr4);
	if (ret < 0) {
 8053355:	85 c0                	test   %eax,%eax
 8053357:	78 c6                	js     805331f <parse_ipv4+0x53>
		return false;
	}

	net_sin(addr)->sin_family = AF_INET;

	if (!has_port) {
 8053359:	80 7d c0 00          	cmpb   $0x0,-0x40(%ebp)
	net_sin(addr)->sin_family = AF_INET;
 805335d:	66 c7 06 01 00       	movw   $0x1,(%esi)
		return true;
 8053362:	b0 01                	mov    $0x1,%al
	if (!has_port) {
 8053364:	74 38                	je     805339e <parse_ipv4+0xd2>
	}

	memcpy(ipaddr, ptr + 1, str_len - end);
 8053366:	8b 55 c4             	mov    -0x3c(%ebp),%edx
 8053369:	8b 4d bc             	mov    -0x44(%ebp),%ecx
 805336c:	6a 11                	push   $0x11
 805336e:	29 fa                	sub    %edi,%edx
 8053370:	41                   	inc    %ecx
 8053371:	52                   	push   %edx
 8053372:	51                   	push   %ecx
 8053373:	53                   	push   %ebx
 8053374:	89 55 c4             	mov    %edx,-0x3c(%ebp)
 8053377:	e8 c4 5d ff ff       	call   8049140 <__memcpy_chk@plt>
	ipaddr[str_len - end] = '\0';
 805337c:	8b 55 c4             	mov    -0x3c(%ebp),%edx
 805337f:	83 c4 10             	add    $0x10,%esp

	ret = convert_port(ipaddr, &port);
 8053382:	89 d8                	mov    %ebx,%eax
	ipaddr[str_len - end] = '\0';
 8053384:	c6 44 15 d3 00       	movb   $0x0,-0x2d(%ebp,%edx,1)
	ret = convert_port(ipaddr, &port);
 8053389:	8d 55 d0             	lea    -0x30(%ebp),%edx
 805338c:	e8 7d fa ff ff       	call   8052e0e <convert_port>
	if (!ret) {
 8053391:	84 c0                	test   %al,%al
 8053393:	74 8a                	je     805331f <parse_ipv4+0x53>
		return false;
	}

	net_sin(addr)->sin_port = htons(port);
 8053395:	8b 55 d0             	mov    -0x30(%ebp),%edx
 8053398:	86 f2                	xchg   %dh,%dl
 805339a:	66 89 56 02          	mov    %dx,0x2(%esi)

	NET_DBG("IPv4 host %s port %d",
		net_addr_ntop(AF_INET, addr4, ipaddr, sizeof(ipaddr) - 1),
		port);
	return true;
}
 805339e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 80533a1:	65 2b 15 14 00 00 00 	sub    %gs:0x14,%edx
 80533a8:	74 05                	je     80533af <parse_ipv4+0xe3>
 80533aa:	e8 51 5f ff ff       	call   8049300 <__stack_chk_fail@plt>
 80533af:	8d 65 f4             	lea    -0xc(%ebp),%esp
 80533b2:	5b                   	pop    %ebx
 80533b3:	5e                   	pop    %esi
 80533b4:	5f                   	pop    %edi
 80533b5:	5d                   	pop    %ebp
 80533b6:	c3                   	ret    

080533b7 <calc_chksum>:
{
 80533b7:	55                   	push   %ebp
 80533b8:	89 e5                	mov    %esp,%ebp
 80533ba:	57                   	push   %edi
 80533bb:	56                   	push   %esi
 80533bc:	53                   	push   %ebx
 80533bd:	83 ec 1c             	sub    $0x1c,%esp
	if (odd_start == CHECKSUM_BIG_ENDIAN) {
 80533c0:	8b 5d 0c             	mov    0xc(%ebp),%ebx
{
 80533c3:	8b 45 08             	mov    0x8(%ebp),%eax
 80533c6:	8b 7d 10             	mov    0x10(%ebp),%edi
	if (odd_start == CHECKSUM_BIG_ENDIAN) {
 80533c9:	83 e3 01             	and    $0x1,%ebx
 80533cc:	89 5d e8             	mov    %ebx,-0x18(%ebp)
 80533cf:	75 02                	jne    80533d3 <calc_chksum+0x1c>
		sum = __bswap_16(sum_in);
 80533d1:	86 e0                	xchg   %ah,%al
		sum = sum_in;
 80533d3:	0f b7 c0             	movzwl %ax,%eax
 80533d6:	31 db                	xor    %ebx,%ebx
 80533d8:	89 c1                	mov    %eax,%ecx
	if ((((uintptr_t)data & 0x01) != 0) && (pending >= 1)) {
 80533da:	f6 45 0c 01          	testb  $0x1,0xc(%ebp)
 80533de:	74 1a                	je     80533fa <calc_chksum+0x43>
 80533e0:	85 ff                	test   %edi,%edi
 80533e2:	74 16                	je     80533fa <calc_chksum+0x43>
	uint16_t data16 = (uint16_t)*data;
 80533e4:	8b 45 0c             	mov    0xc(%ebp),%eax
		sum += offset_based_swap8(data);
 80533e7:	31 d2                	xor    %edx,%edx
	uint16_t data16 = (uint16_t)*data;
 80533e9:	0f b6 00             	movzbl (%eax),%eax
		return data16 << 8;
 80533ec:	c1 e0 08             	shl    $0x8,%eax
		sum += offset_based_swap8(data);
 80533ef:	0f b7 c0             	movzwl %ax,%eax
 80533f2:	01 c1                	add    %eax,%ecx
 80533f4:	11 d3                	adc    %edx,%ebx
		data++;
 80533f6:	ff 45 0c             	incl   0xc(%ebp)
		pending--;
 80533f9:	4f                   	dec    %edi
	if ((((uintptr_t)data & 0x02) != 0) && (pending >= sizeof(uint16_t))) {
 80533fa:	f6 45 0c 02          	testb  $0x2,0xc(%ebp)
 80533fe:	74 18                	je     8053418 <calc_chksum+0x61>
 8053400:	83 ff 01             	cmp    $0x1,%edi
 8053403:	76 13                	jbe    8053418 <calc_chksum+0x61>
		sum = sum + *((uint16_t *)data);
 8053405:	8b 45 0c             	mov    0xc(%ebp),%eax
 8053408:	31 d2                	xor    %edx,%edx
		pending -= sizeof(uint16_t);
 805340a:	83 ef 02             	sub    $0x2,%edi
		sum = sum + *((uint16_t *)data);
 805340d:	0f b7 00             	movzwl (%eax),%eax
 8053410:	01 c1                	add    %eax,%ecx
 8053412:	11 d3                	adc    %edx,%ebx
		data += sizeof(uint16_t);
 8053414:	83 45 0c 02          	addl   $0x2,0xc(%ebp)
	while (pending >= sizeof(uint32_t) * 4) {
 8053418:	8b 75 0c             	mov    0xc(%ebp),%esi
 805341b:	89 f8                	mov    %edi,%eax
 805341d:	01 f0                	add    %esi,%eax
 805341f:	89 45 ec             	mov    %eax,-0x14(%ebp)
 8053422:	8b 45 ec             	mov    -0x14(%ebp),%eax
 8053425:	29 f0                	sub    %esi,%eax
 8053427:	83 f8 0f             	cmp    $0xf,%eax
 805342a:	76 30                	jbe    805345c <calc_chksum+0xa5>
		uint64_t sum_a = p[i];
 805342c:	8b 06                	mov    (%esi),%eax
 805342e:	31 d2                	xor    %edx,%edx
 8053430:	89 55 dc             	mov    %edx,-0x24(%ebp)
		uint64_t sum_b = p[i + 1];
 8053433:	31 d2                	xor    %edx,%edx
		uint64_t sum_a = p[i];
 8053435:	89 45 d8             	mov    %eax,-0x28(%ebp)
		uint64_t sum_b = p[i + 1];
 8053438:	8b 46 04             	mov    0x4(%esi),%eax
 805343b:	03 45 d8             	add    -0x28(%ebp),%eax
 805343e:	13 55 dc             	adc    -0x24(%ebp),%edx
 8053441:	01 c8                	add    %ecx,%eax
		sum_a += p[i + 2];
 8053443:	8b 4e 08             	mov    0x8(%esi),%ecx
 8053446:	11 da                	adc    %ebx,%edx
 8053448:	31 db                	xor    %ebx,%ebx
 805344a:	01 c8                	add    %ecx,%eax
		sum_b += p[i + 3];
 805344c:	8b 4e 0c             	mov    0xc(%esi),%ecx
 805344f:	11 da                	adc    %ebx,%edx
 8053451:	31 db                	xor    %ebx,%ebx
		sum += sum_a + sum_b;
 8053453:	01 c1                	add    %eax,%ecx
 8053455:	11 d3                	adc    %edx,%ebx
 8053457:	83 c6 10             	add    $0x10,%esi
 805345a:	eb c6                	jmp    8053422 <calc_chksum+0x6b>
 805345c:	89 fa                	mov    %edi,%edx
 805345e:	c1 ea 04             	shr    $0x4,%edx
 8053461:	6b c2 f0             	imul   $0xfffffff0,%edx,%eax
 8053464:	c1 e2 04             	shl    $0x4,%edx
 8053467:	89 55 d8             	mov    %edx,-0x28(%ebp)
 805346a:	01 f8                	add    %edi,%eax
 805346c:	8b 7d 0c             	mov    0xc(%ebp),%edi
 805346f:	89 45 ec             	mov    %eax,-0x14(%ebp)
	while (pending >= sizeof(uint32_t) * 4) {
 8053472:	89 c6                	mov    %eax,%esi
 8053474:	01 d7                	add    %edx,%edi
	while (pending >= sizeof(uint32_t)) {
 8053476:	83 fe 03             	cmp    $0x3,%esi
 8053479:	76 10                	jbe    805348b <calc_chksum+0xd4>
		sum = sum + p[i++];
 805347b:	8b 07                	mov    (%edi),%eax
 805347d:	31 d2                	xor    %edx,%edx
		pending -= sizeof(uint32_t);
 805347f:	83 ee 04             	sub    $0x4,%esi
		sum = sum + p[i++];
 8053482:	01 c1                	add    %eax,%ecx
 8053484:	11 d3                	adc    %edx,%ebx
 8053486:	83 c7 04             	add    $0x4,%edi
 8053489:	eb eb                	jmp    8053476 <calc_chksum+0xbf>
 805348b:	8b 45 ec             	mov    -0x14(%ebp),%eax
 805348e:	c1 e8 02             	shr    $0x2,%eax
 8053491:	6b f0 fc             	imul   $0xfffffffc,%eax,%esi
 8053494:	8b 45 ec             	mov    -0x14(%ebp),%eax
 8053497:	01 f0                	add    %esi,%eax
 8053499:	89 c2                	mov    %eax,%edx
 805349b:	8b 45 ec             	mov    -0x14(%ebp),%eax
 805349e:	83 e0 fc             	and    $0xfffffffc,%eax
 80534a1:	03 45 d8             	add    -0x28(%ebp),%eax
 80534a4:	03 45 0c             	add    0xc(%ebp),%eax
	if (pending >= 2) {
 80534a7:	83 fa 01             	cmp    $0x1,%edx
 80534aa:	76 13                	jbe    80534bf <calc_chksum+0x108>
		sum = sum + *((uint16_t *)data);
 80534ac:	0f b7 30             	movzwl (%eax),%esi
		pending -= sizeof(uint16_t);
 80534af:	89 d7                	mov    %edx,%edi
 80534b1:	83 ef 02             	sub    $0x2,%edi
 80534b4:	89 fa                	mov    %edi,%edx
		sum = sum + *((uint16_t *)data);
 80534b6:	31 ff                	xor    %edi,%edi
 80534b8:	01 f1                	add    %esi,%ecx
 80534ba:	11 fb                	adc    %edi,%ebx
		data += sizeof(uint16_t);
 80534bc:	83 c0 02             	add    $0x2,%eax
	if (pending == 1) {
 80534bf:	89 d7                	mov    %edx,%edi
 80534c1:	4f                   	dec    %edi
 80534c2:	75 13                	jne    80534d7 <calc_chksum+0x120>
	uint16_t data16 = (uint16_t)*data;
 80534c4:	0f b6 10             	movzbl (%eax),%edx
	if (((uintptr_t)(data) & 1) == CHECKSUM_BIG_ENDIAN) {
 80534c7:	a8 01                	test   $0x1,%al
 80534c9:	74 03                	je     80534ce <calc_chksum+0x117>
		return data16 << 8;
 80534cb:	c1 e2 08             	shl    $0x8,%edx
		sum += offset_based_swap8(data);
 80534ce:	0f b7 c2             	movzwl %dx,%eax
 80534d1:	31 d2                	xor    %edx,%edx
 80534d3:	01 c1                	add    %eax,%ecx
 80534d5:	11 d3                	adc    %edx,%ebx
	while (sum >> 16) {
 80534d7:	89 da                	mov    %ebx,%edx
 80534d9:	89 c8                	mov    %ecx,%eax
 80534db:	c1 ea 10             	shr    $0x10,%edx
 80534de:	0f ac d8 10          	shrd   $0x10,%ebx,%eax
 80534e2:	89 d6                	mov    %edx,%esi
 80534e4:	09 c6                	or     %eax,%esi
 80534e6:	74 19                	je     8053501 <calc_chksum+0x14a>
		sum = (sum & 0xffff) + (sum >> 16);
 80534e8:	0f b7 d9             	movzwl %cx,%ebx
 80534eb:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
 80534f2:	89 5d e0             	mov    %ebx,-0x20(%ebp)
 80534f5:	03 45 e0             	add    -0x20(%ebp),%eax
 80534f8:	13 55 e4             	adc    -0x1c(%ebp),%edx
 80534fb:	89 c1                	mov    %eax,%ecx
 80534fd:	89 d3                	mov    %edx,%ebx
 80534ff:	eb d6                	jmp    80534d7 <calc_chksum+0x120>
	if (odd_start == CHECKSUM_BIG_ENDIAN) {
 8053501:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
		return __bswap_16((uint16_t)sum);
 8053505:	89 c8                	mov    %ecx,%eax
	if (odd_start == CHECKSUM_BIG_ENDIAN) {
 8053507:	75 02                	jne    805350b <calc_chksum+0x154>
		return __bswap_16((uint16_t)sum);
 8053509:	86 e0                	xchg   %ah,%al
}
 805350b:	83 c4 1c             	add    $0x1c,%esp
 805350e:	5b                   	pop    %ebx
 805350f:	5e                   	pop    %esi
 8053510:	5f                   	pop    %edi
 8053511:	5d                   	pop    %ebp
 8053512:	c3                   	ret    

08053513 <net_calc_chksum>:
{
 8053513:	55                   	push   %ebp
 8053514:	89 e5                	mov    %esp,%ebp
 8053516:	57                   	push   %edi
 8053517:	56                   	push   %esi
 8053518:	53                   	push   %ebx
 8053519:	83 ec 1c             	sub    $0x1c,%esp
 805351c:	8b 5d 08             	mov    0x8(%ebp),%ebx
 805351f:	8b 55 0c             	mov    0xc(%ebp),%edx
	return pkt->family;
 8053522:	8a 4b 33             	mov    0x33(%ebx),%cl
 8053525:	c0 e9 05             	shr    $0x5,%cl
	if (IS_ENABLED(CONFIG_NET_IPV4) &&
 8053528:	80 f9 01             	cmp    $0x1,%cl
 805352b:	75 31                	jne    805355e <net_calc_chksum+0x4b>
		if (proto != IPPROTO_ICMP) {
 805352d:	80 fa 01             	cmp    $0x1,%dl
 8053530:	74 61                	je     8053593 <net_calc_chksum+0x80>
			sum = net_pkt_get_len(pkt) -
 8053532:	8b 43 08             	mov    0x8(%ebx),%eax
	size_t bytes = 0;
 8053535:	31 c9                	xor    %ecx,%ecx
	while (buf) {
 8053537:	85 c0                	test   %eax,%eax
 8053539:	74 0b                	je     8053546 <net_calc_chksum+0x33>
		bytes += buf->len;
 805353b:	0f b7 70 10          	movzwl 0x10(%eax),%esi
		buf = buf->frags;
 805353f:	8b 40 04             	mov    0x4(%eax),%eax
		bytes += buf->len;
 8053542:	01 f1                	add    %esi,%ecx
		buf = buf->frags;
 8053544:	eb f1                	jmp    8053537 <net_calc_chksum+0x24>
				net_pkt_ipv4_opts_len(pkt) + proto;
 8053546:	0f b6 73 36          	movzbl 0x36(%ebx),%esi
				net_pkt_ip_hdr_len(pkt) -
 805354a:	0f b6 43 32          	movzbl 0x32(%ebx),%eax
				net_pkt_ipv4_opts_len(pkt) + proto;
 805354e:	0f b6 d2             	movzbl %dl,%edx
			sum = net_pkt_get_len(pkt) -
 8053551:	01 f0                	add    %esi,%eax
			len = 2 * sizeof(struct in_addr);
 8053553:	be 08 00 00 00       	mov    $0x8,%esi
			sum = net_pkt_get_len(pkt) -
 8053558:	29 c2                	sub    %eax,%edx
 805355a:	01 ca                	add    %ecx,%edx
 805355c:	eb 39                	jmp    8053597 <net_calc_chksum+0x84>
		return 0;
 805355e:	31 c0                	xor    %eax,%eax
	} else if (IS_ENABLED(CONFIG_NET_IPV6) &&
 8053560:	80 f9 02             	cmp    $0x2,%cl
 8053563:	0f 85 23 01 00 00    	jne    805368c <net_calc_chksum+0x179>
		sum =  net_pkt_get_len(pkt) -
 8053569:	8b 4b 08             	mov    0x8(%ebx),%ecx
	size_t bytes = 0;
 805356c:	31 c0                	xor    %eax,%eax
	while (buf) {
 805356e:	85 c9                	test   %ecx,%ecx
 8053570:	74 0b                	je     805357d <net_calc_chksum+0x6a>
		bytes += buf->len;
 8053572:	0f b7 71 10          	movzwl 0x10(%ecx),%esi
		buf = buf->frags;
 8053576:	8b 49 04             	mov    0x4(%ecx),%ecx
		bytes += buf->len;
 8053579:	01 f0                	add    %esi,%eax
		buf = buf->frags;
 805357b:	eb f1                	jmp    805356e <net_calc_chksum+0x5b>
			net_pkt_ip_hdr_len(pkt) -
 805357d:	0f b6 4b 32          	movzbl 0x32(%ebx),%ecx
			net_pkt_ipv6_ext_len(pkt) + proto;
 8053581:	0f b6 d2             	movzbl %dl,%edx
		sum =  net_pkt_get_len(pkt) -
 8053584:	66 2b 53 36          	sub    0x36(%ebx),%dx
		len = 2 * sizeof(struct in6_addr);
 8053588:	be 20 00 00 00       	mov    $0x20,%esi
		sum =  net_pkt_get_len(pkt) -
 805358d:	29 ca                	sub    %ecx,%edx
 805358f:	01 c2                	add    %eax,%edx
 8053591:	eb 04                	jmp    8053597 <net_calc_chksum+0x84>
	uint16_t sum = 0U;
 8053593:	31 d2                	xor    %edx,%edx
	size_t len = 0U;
 8053595:	31 f6                	xor    %esi,%esi
	net_pkt_cursor_init(pkt);
 8053597:	83 ec 0c             	sub    $0xc,%esp
	backup->pos = pkt->cursor.pos;
 805359a:	8b 43 10             	mov    0x10(%ebx),%eax
	backup->buf = pkt->cursor.buf;
 805359d:	8b 7b 0c             	mov    0xc(%ebx),%edi
 80535a0:	89 55 dc             	mov    %edx,-0x24(%ebp)
 80535a3:	53                   	push   %ebx
	backup->pos = pkt->cursor.pos;
 80535a4:	89 45 e0             	mov    %eax,-0x20(%ebp)
 80535a7:	e8 a8 19 00 00       	call   8054f54 <net_pkt_cursor_init>
	return pkt->overwrite;
 80535ac:	8a 43 33             	mov    0x33(%ebx),%al
 80535af:	5a                   	pop    %edx
 80535b0:	59                   	pop    %ecx
 80535b1:	89 c1                	mov    %eax,%ecx
	pkt->overwrite = overwrite;
 80535b3:	83 c8 01             	or     $0x1,%eax
 80535b6:	88 43 33             	mov    %al,0x33(%ebx)
	net_pkt_skip(pkt, net_pkt_ip_hdr_len(pkt) - len);
 80535b9:	0f b6 43 32          	movzbl 0x32(%ebx),%eax
	return pkt->overwrite;
 80535bd:	83 e1 01             	and    $0x1,%ecx
 80535c0:	88 4d e7             	mov    %cl,-0x19(%ebp)
 80535c3:	29 f0                	sub    %esi,%eax
 80535c5:	50                   	push   %eax
 80535c6:	53                   	push   %ebx
 80535c7:	e8 a5 1d 00 00       	call   8055371 <net_pkt_skip>
	sum = calc_chksum(sum, pkt->cursor.pos, len);
 80535cc:	8b 55 dc             	mov    -0x24(%ebp),%edx
	net_pkt_skip(pkt, net_pkt_ip_hdr_len(pkt) - len);
 80535cf:	83 c4 0c             	add    $0xc,%esp
	sum = calc_chksum(sum, pkt->cursor.pos, len);
 80535d2:	56                   	push   %esi
 80535d3:	0f b7 d2             	movzwl %dx,%edx
 80535d6:	ff 73 10             	push   0x10(%ebx)
 80535d9:	52                   	push   %edx
 80535da:	e8 d8 fd ff ff       	call   80533b7 <calc_chksum>
 80535df:	5a                   	pop    %edx
 80535e0:	59                   	pop    %ecx
 80535e1:	89 c2                	mov    %eax,%edx
	net_pkt_skip(pkt, len + net_pkt_ip_opts_len(pkt));
 80535e3:	0f b7 43 36          	movzwl 0x36(%ebx),%eax
	sum = calc_chksum(sum, pkt->cursor.pos, len);
 80535e7:	89 55 dc             	mov    %edx,-0x24(%ebp)
	net_pkt_skip(pkt, len + net_pkt_ip_opts_len(pkt));
 80535ea:	01 f0                	add    %esi,%eax
 80535ec:	50                   	push   %eax
 80535ed:	53                   	push   %ebx
 80535ee:	e8 7e 1d 00 00       	call   8055371 <net_pkt_skip>
	if (!cur->buf || !cur->pos) {
 80535f3:	8b 4b 0c             	mov    0xc(%ebx),%ecx
	net_pkt_skip(pkt, len + net_pkt_ip_opts_len(pkt));
 80535f6:	83 c4 10             	add    $0x10,%esp
	if (!cur->buf || !cur->pos) {
 80535f9:	8b 55 dc             	mov    -0x24(%ebp),%edx
 80535fc:	85 c9                	test   %ecx,%ecx
 80535fe:	74 69                	je     8053669 <net_calc_chksum+0x156>
 8053600:	8b 43 10             	mov    0x10(%ebx),%eax
 8053603:	85 c0                	test   %eax,%eax
 8053605:	74 62                	je     8053669 <net_calc_chksum+0x156>
	len = cur->buf->len - (cur->pos - cur->buf->data);
 8053607:	0f b7 71 10          	movzwl 0x10(%ecx),%esi
 805360b:	2b 41 0c             	sub    0xc(%ecx),%eax
 805360e:	29 c6                	sub    %eax,%esi
	while (cur->buf) {
 8053610:	8b 4b 0c             	mov    0xc(%ebx),%ecx
 8053613:	85 c9                	test   %ecx,%ecx
 8053615:	74 52                	je     8053669 <net_calc_chksum+0x156>
		sum = calc_chksum(sum, cur->pos, len);
 8053617:	0f b7 d2             	movzwl %dx,%edx
 805361a:	50                   	push   %eax
 805361b:	56                   	push   %esi
 805361c:	ff 73 10             	push   0x10(%ebx)
 805361f:	52                   	push   %edx
 8053620:	89 4d dc             	mov    %ecx,-0x24(%ebp)
 8053623:	e8 8f fd ff ff       	call   80533b7 <calc_chksum>
		cur->buf = cur->buf->frags;
 8053628:	8b 4d dc             	mov    -0x24(%ebp),%ecx
		sum = calc_chksum(sum, cur->pos, len);
 805362b:	83 c4 10             	add    $0x10,%esp
 805362e:	89 c2                	mov    %eax,%edx
		cur->buf = cur->buf->frags;
 8053630:	8b 41 04             	mov    0x4(%ecx),%eax
 8053633:	89 43 0c             	mov    %eax,0xc(%ebx)
		if (!cur->buf || !cur->buf->len) {
 8053636:	85 c0                	test   %eax,%eax
 8053638:	74 2f                	je     8053669 <net_calc_chksum+0x156>
 805363a:	66 83 78 10 00       	cmpw   $0x0,0x10(%eax)
 805363f:	74 28                	je     8053669 <net_calc_chksum+0x156>
		cur->pos = cur->buf->data;
 8053641:	8b 48 0c             	mov    0xc(%eax),%ecx
		if (len % 2) {
 8053644:	83 e6 01             	and    $0x1,%esi
		cur->pos = cur->buf->data;
 8053647:	89 4b 10             	mov    %ecx,0x10(%ebx)
		if (len % 2) {
 805364a:	74 17                	je     8053663 <net_calc_chksum+0x150>
			sum += *cur->pos;
 805364c:	0f b6 31             	movzbl (%ecx),%esi
 805364f:	66 01 d6             	add    %dx,%si
				sum++;
 8053652:	66 83 d6 00          	adc    $0x0,%si
			cur->pos++;
 8053656:	41                   	inc    %ecx
 8053657:	89 4b 10             	mov    %ecx,0x10(%ebx)
				sum++;
 805365a:	89 f2                	mov    %esi,%edx
			len = cur->buf->len - 1;
 805365c:	0f b7 70 10          	movzwl 0x10(%eax),%esi
 8053660:	4e                   	dec    %esi
 8053661:	eb ad                	jmp    8053610 <net_calc_chksum+0xfd>
			len = cur->buf->len;
 8053663:	0f b7 70 10          	movzwl 0x10(%eax),%esi
 8053667:	eb a7                	jmp    8053610 <net_calc_chksum+0xfd>
	sum = (sum == 0U) ? 0xffff : htons(sum);
 8053669:	83 c8 ff             	or     $0xffffffff,%eax
 805366c:	66 85 d2             	test   %dx,%dx
 805366f:	74 04                	je     8053675 <net_calc_chksum+0x162>
 8053671:	89 d0                	mov    %edx,%eax
 8053673:	86 e0                	xchg   %ah,%al
	pkt->overwrite = overwrite;
 8053675:	8a 53 33             	mov    0x33(%ebx),%dl
	pkt->cursor.buf = backup->buf;
 8053678:	89 7b 0c             	mov    %edi,0xc(%ebx)
	return ~sum;
 805367b:	f7 d0                	not    %eax
	pkt->cursor.pos = backup->pos;
 805367d:	8b 7d e0             	mov    -0x20(%ebp),%edi
	pkt->overwrite = overwrite;
 8053680:	83 e2 fe             	and    $0xfffffffe,%edx
 8053683:	0a 55 e7             	or     -0x19(%ebp),%dl
	pkt->cursor.pos = backup->pos;
 8053686:	89 7b 10             	mov    %edi,0x10(%ebx)
	pkt->overwrite = overwrite;
 8053689:	88 53 33             	mov    %dl,0x33(%ebx)
}
 805368c:	8d 65 f4             	lea    -0xc(%ebp),%esp
 805368f:	5b                   	pop    %ebx
 8053690:	5e                   	pop    %esi
 8053691:	5f                   	pop    %edi
 8053692:	5d                   	pop    %ebp
 8053693:	c3                   	ret    

08053694 <net_calc_chksum_ipv4>:
{
 8053694:	55                   	push   %ebp
 8053695:	89 e5                	mov    %esp,%ebp
	sum = calc_chksum(0, pkt->buffer->data,
 8053697:	52                   	push   %edx
{
 8053698:	8b 45 08             	mov    0x8(%ebp),%eax
			  net_pkt_ipv4_opts_len(pkt));
 805369b:	0f b6 48 36          	movzbl 0x36(%eax),%ecx
			  net_pkt_ip_hdr_len(pkt) +
 805369f:	0f b6 50 32          	movzbl 0x32(%eax),%edx
 80536a3:	01 ca                	add    %ecx,%edx
	sum = calc_chksum(0, pkt->buffer->data,
 80536a5:	52                   	push   %edx
 80536a6:	8b 40 08             	mov    0x8(%eax),%eax
 80536a9:	ff 70 0c             	push   0xc(%eax)
 80536ac:	6a 00                	push   $0x0
 80536ae:	e8 04 fd ff ff       	call   80533b7 <calc_chksum>
 80536b3:	83 c4 10             	add    $0x10,%esp
 80536b6:	89 c2                	mov    %eax,%edx
	sum = (sum == 0U) ? 0xffff : htons(sum);
 80536b8:	83 c8 ff             	or     $0xffffffff,%eax
 80536bb:	66 85 d2             	test   %dx,%dx
 80536be:	74 04                	je     80536c4 <net_calc_chksum_ipv4+0x30>
 80536c0:	89 d0                	mov    %edx,%eax
 80536c2:	86 e0                	xchg   %ah,%al
}
 80536c4:	c9                   	leave  
	return ~sum;
 80536c5:	f7 d0                	not    %eax
}
 80536c7:	c3                   	ret    

080536c8 <net_ipaddr_parse>:
	return false;
}
#endif /* CONFIG_NET_IPV4 */

bool net_ipaddr_parse(const char *str, size_t str_len, struct sockaddr *addr)
{
 80536c8:	55                   	push   %ebp
 80536c9:	89 e5                	mov    %esp,%ebp
 80536cb:	57                   	push   %edi
 80536cc:	56                   	push   %esi
 80536cd:	53                   	push   %ebx
 80536ce:	83 ec 1c             	sub    $0x1c,%esp
 80536d1:	8b 5d 08             	mov    0x8(%ebp),%ebx
 80536d4:	8b 55 0c             	mov    0xc(%ebp),%edx
 80536d7:	8b 4d 10             	mov    0x10(%ebp),%ecx
	int i, count;

	if (!str || str_len == 0) {
 80536da:	85 db                	test   %ebx,%ebx
 80536dc:	0f 94 c0             	sete   %al
 80536df:	85 d2                	test   %edx,%edx
 80536e1:	0f 94 45 e4          	sete   -0x1c(%ebp)
 80536e5:	0a 45 e4             	or     -0x1c(%ebp),%al
 80536e8:	75 78                	jne    8053762 <net_ipaddr_parse+0x9a>
 80536ea:	89 c7                	mov    %eax,%edi
		return false;
	}

	/* We cannot accept empty string here */
	if (*str == '\0') {
 80536ec:	8a 03                	mov    (%ebx),%al
 80536ee:	84 c0                	test   %al,%al
 80536f0:	74 72                	je     8053764 <net_ipaddr_parse+0x9c>

	if (*str == '[') {
		return parse_ipv6(str, str_len, addr, true);
	}

	for (count = i = 0; str[i] && i < str_len; i++) {
 80536f2:	31 ff                	xor    %edi,%edi
 80536f4:	31 f6                	xor    %esi,%esi
	if (*str == '[') {
 80536f6:	3c 5b                	cmp    $0x5b,%al
 80536f8:	75 13                	jne    805370d <net_ipaddr_parse+0x45>
		return parse_ipv6(str, str_len, addr, true);
 80536fa:	c7 45 08 01 00 00 00 	movl   $0x1,0x8(%ebp)
 8053701:	eb 51                	jmp    8053754 <net_ipaddr_parse+0x8c>
	for (count = i = 0; str[i] && i < str_len; i++) {
 8053703:	84 c0                	test   %al,%al
 8053705:	74 0d                	je     8053714 <net_ipaddr_parse+0x4c>
		if (str[i] == ':') {
 8053707:	3c 3a                	cmp    $0x3a,%al
 8053709:	75 01                	jne    805370c <net_ipaddr_parse+0x44>
			count++;
 805370b:	47                   	inc    %edi
	for (count = i = 0; str[i] && i < str_len; i++) {
 805370c:	46                   	inc    %esi
 805370d:	8a 04 33             	mov    (%ebx,%esi,1),%al
 8053710:	39 f2                	cmp    %esi,%edx
 8053712:	77 ef                	ja     8053703 <net_ipaddr_parse+0x3b>
		}
	}

	if (count == 1) {
 8053714:	4f                   	dec    %edi
 8053715:	75 15                	jne    805372c <net_ipaddr_parse+0x64>
		return parse_ipv4(str, str_len, addr, true);
 8053717:	c7 45 08 01 00 00 00 	movl   $0x1,0x8(%ebp)

#if defined(CONFIG_NET_IPV6) && !defined(CONFIG_NET_IPV4)
	return parse_ipv6(str, str_len, addr, false);
#endif
	return false;
}
 805371e:	8d 65 f4             	lea    -0xc(%ebp),%esp
		return parse_ipv4(str, str_len, addr, true);
 8053721:	89 d8                	mov    %ebx,%eax
}
 8053723:	5b                   	pop    %ebx
 8053724:	5e                   	pop    %esi
 8053725:	5f                   	pop    %edi
 8053726:	5d                   	pop    %ebp
		return parse_ipv4(str, str_len, addr, true);
 8053727:	e9 a0 fb ff ff       	jmp    80532cc <parse_ipv4>
	if (!parse_ipv4(str, str_len, addr, false)) {
 805372c:	83 ec 0c             	sub    $0xc,%esp
 805372f:	89 d8                	mov    %ebx,%eax
 8053731:	89 4d e0             	mov    %ecx,-0x20(%ebp)
 8053734:	6a 00                	push   $0x0
 8053736:	89 55 e4             	mov    %edx,-0x1c(%ebp)
 8053739:	e8 8e fb ff ff       	call   80532cc <parse_ipv4>
 805373e:	83 c4 10             	add    $0x10,%esp
 8053741:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 8053744:	8b 4d e0             	mov    -0x20(%ebp),%ecx
 8053747:	84 c0                	test   %al,%al
 8053749:	89 c7                	mov    %eax,%edi
 805374b:	75 17                	jne    8053764 <net_ipaddr_parse+0x9c>
		return parse_ipv6(str, str_len, addr, false);
 805374d:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
}
 8053754:	8d 65 f4             	lea    -0xc(%ebp),%esp
		return parse_ipv6(str, str_len, addr, false);
 8053757:	89 d8                	mov    %ebx,%eax
}
 8053759:	5b                   	pop    %ebx
 805375a:	5e                   	pop    %esi
 805375b:	5f                   	pop    %edi
 805375c:	5d                   	pop    %ebp
		return parse_ipv6(str, str_len, addr, false);
 805375d:	e9 1b fa ff ff       	jmp    805317d <parse_ipv6>
		return false;
 8053762:	31 ff                	xor    %edi,%edi
}
 8053764:	8d 65 f4             	lea    -0xc(%ebp),%esp
 8053767:	89 f8                	mov    %edi,%eax
 8053769:	5b                   	pop    %ebx
 805376a:	5e                   	pop    %esi
 805376b:	5f                   	pop    %edi
 805376c:	5d                   	pop    %ebp
 805376d:	c3                   	ret    

0805376e <net_ipv4_unspecified_address>:
const struct in_addr *net_ipv4_unspecified_address(void)
{
	static const struct in_addr addr;

	return &addr;
}
 805376e:	b8 44 24 06 08       	mov    $0x8062444,%eax
 8053773:	c3                   	ret    

08053774 <net_ipv4_broadcast_address>:
const struct in_addr *net_ipv4_broadcast_address(void)
{
	static const struct in_addr addr = { { { 255, 255, 255, 255 } } };

	return &addr;
}
 8053774:	b8 40 24 06 08       	mov    $0x8062440,%eax
 8053779:	c3                   	ret    

0805377a <net_ipv6_unspecified_address>:
const struct in6_addr in6addr_loopback = IN6ADDR_LOOPBACK_INIT;

const struct in6_addr *net_ipv6_unspecified_address(void)
{
	return &in6addr_any;
}
 805377a:	b8 58 24 06 08       	mov    $0x8062458,%eax
 805377f:	c3                   	ret    

08053780 <net_ipv4_is_addr_mcast>:
	return (ntohl(UNALIGNED_GET(&addr->s_addr)) & 0xF0000000) == 0xE0000000;
 8053780:	8b 00                	mov    (%eax),%eax
 8053782:	25 f0 00 00 00       	and    $0xf0,%eax
 8053787:	3d e0 00 00 00       	cmp    $0xe0,%eax
 805378c:	0f 94 c0             	sete   %al
}
 805378f:	c3                   	ret    

08053790 <net_ipv6_is_addr_unspecified>:
{
 8053790:	89 c2                	mov    %eax,%edx
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
 8053792:	31 c0                	xor    %eax,%eax
 8053794:	83 3a 00             	cmpl   $0x0,(%edx)
 8053797:	75 15                	jne    80537ae <net_ipv6_is_addr_unspecified+0x1e>
	return UNALIGNED_GET(&addr->s6_addr32[0]) == 0 &&
 8053799:	83 7a 04 00          	cmpl   $0x0,0x4(%edx)
 805379d:	75 0f                	jne    80537ae <net_ipv6_is_addr_unspecified+0x1e>
		UNALIGNED_GET(&addr->s6_addr32[1]) == 0 &&
 805379f:	83 7a 08 00          	cmpl   $0x0,0x8(%edx)
 80537a3:	75 09                	jne    80537ae <net_ipv6_is_addr_unspecified+0x1e>
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
 80537a5:	31 c0                	xor    %eax,%eax
 80537a7:	83 7a 0c 00          	cmpl   $0x0,0xc(%edx)
 80537ab:	0f 94 c0             	sete   %al
 80537ae:	83 e0 01             	and    $0x1,%eax
}
 80537b1:	c3                   	ret    

080537b2 <check_used_port>:
#if defined(CONFIG_NET_UDP) || defined(CONFIG_NET_TCP)
static int check_used_port(enum net_ip_protocol proto,
			   uint16_t local_port,
			   const struct sockaddr *local_addr)

{
 80537b2:	55                   	push   %ebp
 80537b3:	89 e5                	mov    %esp,%ebp
 80537b5:	57                   	push   %edi
	return !memcmp(addr1, addr2, sizeof(struct in6_addr));
 80537b6:	8d 79 04             	lea    0x4(%ecx),%edi
 80537b9:	56                   	push   %esi
 80537ba:	89 ce                	mov    %ecx,%esi
 80537bc:	53                   	push   %ebx
 80537bd:	31 db                	xor    %ebx,%ebx
 80537bf:	83 ec 1c             	sub    $0x1c,%esp
 80537c2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	int i;

	for (i = 0; i < NET_MAX_CONTEXT; i++) {
		if (!net_context_is_used(&contexts[i])) {
 80537c5:	f6 83 38 7f 06 08 01 	testb  $0x1,0x8067f38(%ebx)
 80537cc:	74 54                	je     8053822 <check_used_port+0x70>
			continue;
		}

		if (!(net_context_get_proto(&contexts[i]) == proto &&
 80537ce:	0f b7 83 36 7f 06 08 	movzwl 0x8067f36(%ebx),%eax
 80537d5:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
 80537d8:	75 48                	jne    8053822 <check_used_port+0x70>
 80537da:	66 39 93 c2 7e 06 08 	cmp    %dx,0x8067ec2(%ebx)
 80537e1:	75 3f                	jne    8053822 <check_used_port+0x70>
			      contexts[i].local)->sin_port == local_port)) {
			continue;
		}

		if (IS_ENABLED(CONFIG_NET_IPV6) &&
		    local_addr->sa_family == AF_INET6) {
 80537e3:	66 8b 06             	mov    (%esi),%ax
		if (IS_ENABLED(CONFIG_NET_IPV6) &&
 80537e6:	66 83 f8 02          	cmp    $0x2,%ax
 80537ea:	75 21                	jne    805380d <check_used_port+0x5b>
			if (net_sin6_ptr(&contexts[i].local)->sin6_addr == NULL) {
 80537ec:	8b 83 c4 7e 06 08    	mov    0x8067ec4(%ebx),%eax
 80537f2:	85 c0                	test   %eax,%eax
 80537f4:	74 2c                	je     8053822 <check_used_port+0x70>
 80537f6:	89 55 e0             	mov    %edx,-0x20(%ebp)
 80537f9:	52                   	push   %edx
 80537fa:	6a 10                	push   $0x10
 80537fc:	57                   	push   %edi
 80537fd:	50                   	push   %eax
 80537fe:	e8 6d 58 ff ff       	call   8049070 <memcmp@plt>
 8053803:	83 c4 10             	add    $0x10,%esp
				continue;
			}

			if (net_ipv6_addr_cmp(
 8053806:	8b 55 e0             	mov    -0x20(%ebp),%edx
 8053809:	85 c0                	test   %eax,%eax
 805380b:	eb 13                	jmp    8053820 <check_used_port+0x6e>
							     sin6_addr,
				    &((struct sockaddr_in6 *)
				      local_addr)->sin6_addr)) {
				return -EEXIST;
			}
		} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
 805380d:	66 48                	dec    %ax
 805380f:	75 11                	jne    8053822 <check_used_port+0x70>
			   local_addr->sa_family == AF_INET) {
			if (net_sin_ptr(&contexts[i].local)->sin_addr == NULL) {
 8053811:	8b 83 c4 7e 06 08    	mov    0x8067ec4(%ebx),%eax
 8053817:	85 c0                	test   %eax,%eax
 8053819:	74 07                	je     8053822 <check_used_port+0x70>
				continue;
			}

			if (net_ipv4_addr_cmp(
 805381b:	8b 00                	mov    (%eax),%eax
 805381d:	39 46 04             	cmp    %eax,0x4(%esi)
 8053820:	74 12                	je     8053834 <check_used_port+0x82>
	for (i = 0; i < NET_MAX_CONTEXT; i++) {
 8053822:	81 c3 9c 00 00 00    	add    $0x9c,%ebx
 8053828:	81 fb a8 03 00 00    	cmp    $0x3a8,%ebx
 805382e:	75 95                	jne    80537c5 <check_used_port+0x13>
				return -EEXIST;
			}
		}
	}

	return 0;
 8053830:	31 c0                	xor    %eax,%eax
 8053832:	eb 05                	jmp    8053839 <check_used_port+0x87>
				return -EEXIST;
 8053834:	b8 ef ff ff ff       	mov    $0xffffffef,%eax
}
 8053839:	8d 65 f4             	lea    -0xc(%ebp),%esp
 805383c:	5b                   	pop    %ebx
 805383d:	5e                   	pop    %esi
 805383e:	5f                   	pop    %edi
 805383f:	5d                   	pop    %ebp
 8053840:	c3                   	ret    

08053841 <find_available_port>:

static uint16_t find_available_port(struct net_context *context,
				    const struct sockaddr *addr)
{
 8053841:	55                   	push   %ebp
 8053842:	89 e5                	mov    %esp,%ebp
 8053844:	57                   	push   %edi
 8053845:	89 c7                	mov    %eax,%edi
 8053847:	56                   	push   %esi
 8053848:	89 d6                	mov    %edx,%esi
 805384a:	53                   	push   %ebx
 805384b:	83 ec 0c             	sub    $0xc,%esp
 805384e:	e8 cd b6 ff ff       	call   804ef20 <z_impl_sys_rand32_get>
	uint16_t local_port;

	do {
		local_port = sys_rand32_get() | 0x8000;
	} while (check_used_port(net_context_get_proto(context),
 8053853:	89 f1                	mov    %esi,%ecx
		local_port = sys_rand32_get() | 0x8000;
 8053855:	89 c3                	mov    %eax,%ebx
	} while (check_used_port(net_context_get_proto(context),
 8053857:	0f b7 87 96 00 00 00 	movzwl 0x96(%edi),%eax
		local_port = sys_rand32_get() | 0x8000;
 805385e:	66 81 cb 00 80       	or     $0x8000,%bx
 8053863:	86 fb                	xchg   %bh,%bl
	} while (check_used_port(net_context_get_proto(context),
 8053865:	0f b7 d3             	movzwl %bx,%edx
 8053868:	e8 45 ff ff ff       	call   80537b2 <check_used_port>
				 htons(local_port), addr) == -EEXIST);
 805386d:	83 f8 ef             	cmp    $0xffffffef,%eax
 8053870:	74 dc                	je     805384e <find_available_port+0xd>

	return htons(local_port);
}
 8053872:	83 c4 0c             	add    $0xc,%esp
 8053875:	89 d8                	mov    %ebx,%eax
 8053877:	5b                   	pop    %ebx
 8053878:	5e                   	pop    %esi
 8053879:	5f                   	pop    %edi
 805387a:	5d                   	pop    %ebp
 805387b:	c3                   	ret    

0805387c <k_mutex_lock.constprop.0.isra.0>:
static inline int k_mutex_lock(struct k_mutex * mutex, k_timeout_t timeout)
 805387c:	55                   	push   %ebp
 805387d:	89 e5                	mov    %esp,%ebp
 805387f:	53                   	push   %ebx
 8053880:	83 ec 08             	sub    $0x8,%esp
	return z_impl_k_mutex_lock(mutex, timeout);
 8053883:	51                   	push   %ecx
 8053884:	52                   	push   %edx
 8053885:	50                   	push   %eax
 8053886:	e8 0d b9 00 00       	call   805f198 <z_impl_k_mutex_lock>
}
 805388b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
	return z_impl_k_mutex_lock(mutex, timeout);
 805388e:	83 c4 10             	add    $0x10,%esp
}
 8053891:	c9                   	leave  
 8053892:	c3                   	ret    

08053893 <k_mutex_unlock.isra.0>:
static inline int k_mutex_unlock(struct k_mutex * mutex)
 8053893:	55                   	push   %ebp
 8053894:	89 e5                	mov    %esp,%ebp
 8053896:	83 ec 14             	sub    $0x14,%esp
	return z_impl_k_mutex_unlock(mutex);
 8053899:	50                   	push   %eax
 805389a:	e8 07 ba 00 00       	call   805f2a6 <z_impl_k_mutex_unlock>
 805389f:	83 c4 10             	add    $0x10,%esp
}
 80538a2:	c9                   	leave  
 80538a3:	c3                   	ret    

080538a4 <net_context_packet_received>:
enum net_verdict net_context_packet_received(struct net_conn *conn,
					     struct net_pkt *pkt,
					     union net_ip_header *ip_hdr,
					     union net_proto_header *proto_hdr,
					     void *user_data)
{
 80538a4:	55                   	push   %ebp
 80538a5:	b8 a0 7e 06 08       	mov    $0x8067ea0,%eax
 80538aa:	89 e5                	mov    %esp,%ebp
 80538ac:	57                   	push   %edi
 80538ad:	56                   	push   %esi
 80538ae:	53                   	push   %ebx
	for (i = 0; i < NET_MAX_CONTEXT; i++) {
 80538af:	31 db                	xor    %ebx,%ebx
{
 80538b1:	83 ec 1c             	sub    $0x1c,%esp
 80538b4:	8b 55 08             	mov    0x8(%ebp),%edx
 80538b7:	8b 7d 0c             	mov    0xc(%ebp),%edi
		if (!net_context_is_used(&contexts[i])) {
 80538ba:	f6 80 98 00 00 00 01 	testb  $0x1,0x98(%eax)
 80538c1:	74 50                	je     8053913 <net_context_packet_received+0x6f>
		if (contexts[i].conn_handler == conn_handler) {
 80538c3:	3b 50 44             	cmp    0x44(%eax),%edx
 80538c6:	75 4b                	jne    8053913 <net_context_packet_received+0x6f>
			return &contexts[i];
 80538c8:	69 db 9c 00 00 00    	imul   $0x9c,%ebx,%ebx
	enum net_verdict verdict = NET_DROP;

	NET_ASSERT(context);
	NET_ASSERT(net_pkt_iface(pkt));

	k_mutex_lock(&context->lock, K_FOREVER);
 80538ce:	83 ca ff             	or     $0xffffffff,%edx
 80538d1:	89 d1                	mov    %edx,%ecx
 80538d3:	8d 83 ac 7e 06 08    	lea    0x8067eac(%ebx),%eax
			return &contexts[i];
 80538d9:	8d b3 a0 7e 06 08    	lea    0x8067ea0(%ebx),%esi
	k_mutex_lock(&context->lock, K_FOREVER);
 80538df:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 80538e2:	e8 95 ff ff ff       	call   805387c <k_mutex_lock.constprop.0.isra.0>
	context->iface = net_if_get_by_iface(iface);
 80538e7:	83 ec 0c             	sub    $0xc,%esp
 80538ea:	ff 77 18             	push   0x18(%edi)
 80538ed:	e8 90 f1 ff ff       	call   8052a82 <net_if_get_by_iface>
 80538f2:	83 c4 10             	add    $0x10,%esp
 80538f5:	88 86 9a 00 00 00    	mov    %al,0x9a(%esi)
	pkt->context = ctx;
 80538fb:	89 77 14             	mov    %esi,0x14(%edi)
	net_pkt_set_context(pkt, context);

	/* If there is no callback registered, then we can only drop
	 * the packet.
	 */
	if (!context->recv_cb) {
 80538fe:	83 7e 48 00          	cmpl   $0x0,0x48(%esi)
 8053902:	75 40                	jne    8053944 <net_context_packet_received+0xa0>
	verdict = NET_OK;

	return verdict;

unlock:
	k_mutex_unlock(&context->lock);
 8053904:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8053907:	e8 87 ff ff ff       	call   8053893 <k_mutex_unlock.isra.0>

	return verdict;
 805390c:	b8 02 00 00 00       	mov    $0x2,%eax
 8053911:	eb 62                	jmp    8053975 <net_context_packet_received+0xd1>
	for (i = 0; i < NET_MAX_CONTEXT; i++) {
 8053913:	43                   	inc    %ebx
 8053914:	05 9c 00 00 00       	add    $0x9c,%eax
 8053919:	83 fb 06             	cmp    $0x6,%ebx
 805391c:	75 9c                	jne    80538ba <net_context_packet_received+0x16>
	k_mutex_lock(&context->lock, K_FOREVER);
 805391e:	83 ca ff             	or     $0xffffffff,%edx
 8053921:	b8 0c 00 00 00       	mov    $0xc,%eax
 8053926:	89 d1                	mov    %edx,%ecx
 8053928:	e8 4f ff ff ff       	call   805387c <k_mutex_lock.constprop.0.isra.0>
 805392d:	83 ec 0c             	sub    $0xc,%esp
 8053930:	ff 77 18             	push   0x18(%edi)
 8053933:	e8 4a f1 ff ff       	call   8052a82 <net_if_get_by_iface>
 8053938:	c6 05 9a 00 00 00 00 	movb   $0x0,0x9a
 805393f:	83 c4 10             	add    $0x10,%esp
 8053942:	0f 0b                	ud2    
	z_impl_k_sem_give(sem);
 8053944:	83 ec 0c             	sub    $0xc,%esp
	k_sem_give(&context->recv_data_wait);
 8053947:	81 c3 f4 7e 06 08    	add    $0x8067ef4,%ebx
 805394d:	53                   	push   %ebx
 805394e:	e8 f7 bc 00 00       	call   805f64a <z_impl_k_sem_give>
	k_mutex_unlock(&context->lock);
 8053953:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8053956:	83 c4 10             	add    $0x10,%esp
 8053959:	e8 35 ff ff ff       	call   8053893 <k_mutex_unlock.isra.0>
	context->recv_cb(context, pkt, ip_hdr, proto_hdr, 0, user_data);
 805395e:	50                   	push   %eax
 805395f:	50                   	push   %eax
 8053960:	ff 75 18             	push   0x18(%ebp)
 8053963:	6a 00                	push   $0x0
 8053965:	ff 75 14             	push   0x14(%ebp)
 8053968:	ff 75 10             	push   0x10(%ebp)
 805396b:	57                   	push   %edi
 805396c:	56                   	push   %esi
 805396d:	ff 56 48             	call   *0x48(%esi)
	return verdict;
 8053970:	31 c0                	xor    %eax,%eax
	context->recv_cb(context, pkt, ip_hdr, proto_hdr, 0, user_data);
 8053972:	83 c4 20             	add    $0x20,%esp
}
 8053975:	8d 65 f4             	lea    -0xc(%ebp),%esp
 8053978:	5b                   	pop    %ebx
 8053979:	5e                   	pop    %esi
 805397a:	5f                   	pop    %edi
 805397b:	5d                   	pop    %ebp
 805397c:	c3                   	ret    

0805397d <net_context_get>:
{
 805397d:	55                   	push   %ebp
 805397e:	89 e5                	mov    %esp,%ebp
 8053980:	57                   	push   %edi
 8053981:	56                   	push   %esi
 8053982:	53                   	push   %ebx
 8053983:	83 ec 1c             	sub    $0x1c,%esp
 8053986:	8b 45 10             	mov    0x10(%ebp),%eax
 8053989:	8b 55 08             	mov    0x8(%ebp),%edx
 805398c:	8b 75 0c             	mov    0xc(%ebp),%esi
 805398f:	89 45 dc             	mov    %eax,-0x24(%ebp)
	switch (family) {
 8053992:	66 83 fa 02          	cmp    $0x2,%dx
 8053996:	77 10                	ja     80539a8 <net_context_get+0x2b>
		return -EAFNOSUPPORT;
 8053998:	b8 9f ff ff ff       	mov    $0xffffff9f,%eax
	switch (family) {
 805399d:	66 85 d2             	test   %dx,%dx
 80539a0:	0f 84 ab 01 00 00    	je     8053b51 <net_context_get+0x1d4>
 80539a6:	eb 13                	jmp    80539bb <net_context_get+0x3e>
 80539a8:	83 ea 03             	sub    $0x3,%edx
		return -EAFNOSUPPORT;
 80539ab:	66 83 fa 02          	cmp    $0x2,%dx
 80539af:	19 c0                	sbb    %eax,%eax
 80539b1:	f7 d0                	not    %eax
 80539b3:	83 e8 60             	sub    $0x60,%eax
 80539b6:	e9 96 01 00 00       	jmp    8053b51 <net_context_get+0x1d4>
				return -EPROTOTYPE;
 80539bb:	b8 a5 ff ff ff       	mov    $0xffffffa5,%eax
			if (type == SOCK_STREAM) {
 80539c0:	83 fe 01             	cmp    $0x1,%esi
 80539c3:	0f 84 88 01 00 00    	je     8053b51 <net_context_get+0x1d4>
			if (proto == IPPROTO_TCP) {
 80539c9:	66 83 7d dc 06       	cmpw   $0x6,-0x24(%ebp)
				return -EPROTONOSUPPORT;
 80539ce:	b8 a3 ff ff ff       	mov    $0xffffffa3,%eax
			if (proto == IPPROTO_TCP) {
 80539d3:	0f 84 78 01 00 00    	je     8053b51 <net_context_get+0x1d4>
		switch (type) {
 80539d9:	83 fe 02             	cmp    $0x2,%esi
 80539dc:	74 10                	je     80539ee <net_context_get+0x71>
 80539de:	b8 a5 ff ff ff       	mov    $0xffffffa5,%eax
 80539e3:	83 fe 03             	cmp    $0x3,%esi
 80539e6:	0f 85 65 01 00 00    	jne    8053b51 <net_context_get+0x1d4>
 80539ec:	eb 10                	jmp    80539fe <net_context_get+0x81>
			if (proto != IPPROTO_UDP) {
 80539ee:	66 83 7d dc 11       	cmpw   $0x11,-0x24(%ebp)
				return -EPROTONOSUPPORT;
 80539f3:	b8 a3 ff ff ff       	mov    $0xffffffa3,%eax
			if (proto != IPPROTO_UDP) {
 80539f8:	0f 85 53 01 00 00    	jne    8053b51 <net_context_get+0x1d4>
	if (!context) {
 80539fe:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
 8053a02:	89 55 e0             	mov    %edx,-0x20(%ebp)
		return -EINVAL;
 8053a05:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
	if (!context) {
 8053a0a:	0f 84 41 01 00 00    	je     8053b51 <net_context_get+0x1d4>
	return z_impl_k_sem_take(sem, timeout);
 8053a10:	52                   	push   %edx
 8053a11:	6a ff                	push   $0xffffffff
 8053a13:	6a ff                	push   $0xffffffff
 8053a15:	68 ec 89 06 08       	push   $0x80689ec
 8053a1a:	e8 93 bc 00 00       	call   805f6b2 <z_impl_k_sem_take>
	for (i = 0; i < NET_MAX_CONTEXT; i++) {
 8053a1f:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
 8053a26:	8b 55 e0             	mov    -0x20(%ebp),%edx
 8053a29:	83 c4 10             	add    $0x10,%esp
	return context->flags & NET_CONTEXT_IN_USE;
 8053a2c:	69 5d e4 9c 00 00 00 	imul   $0x9c,-0x1c(%ebp),%ebx
		if (net_context_is_used(&contexts[i])) {
 8053a33:	f6 83 38 7f 06 08 01 	testb  $0x1,0x8067f38(%ebx)
 8053a3a:	74 13                	je     8053a4f <net_context_get+0xd2>
	for (i = 0; i < NET_MAX_CONTEXT; i++) {
 8053a3c:	ff 45 e4             	incl   -0x1c(%ebp)
 8053a3f:	83 7d e4 06          	cmpl   $0x6,-0x1c(%ebp)
 8053a43:	75 e7                	jne    8053a2c <net_context_get+0xaf>
	ret = -ENOENT;
 8053a45:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
 8053a4a:	e9 ec 00 00 00       	jmp    8053b3b <net_context_get+0x1be>
		memset(&contexts[i], 0, sizeof(contexts[i]));
 8053a4f:	8d 83 a0 7e 06 08    	lea    0x8067ea0(%ebx),%eax
  return __builtin___memset_chk (__dest, __ch, __len,
 8053a55:	8d bb a0 7e 06 08    	lea    0x8067ea0(%ebx),%edi
 8053a5b:	b9 27 00 00 00       	mov    $0x27,%ecx
 8053a60:	89 55 d8             	mov    %edx,-0x28(%ebp)
 8053a63:	89 45 e0             	mov    %eax,-0x20(%ebp)
 8053a66:	31 c0                	xor    %eax,%eax
 8053a68:	f3 ab                	rep stos %eax,%es:(%edi)
		if (!net_if_is_ip_offloaded(net_if_get_default())
 8053a6a:	e8 2a d6 ff ff       	call   8051099 <net_if_get_default>
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
 8053a6f:	b8 01 00 00 00       	mov    $0x1,%eax
		contexts[i].iface = -1;
 8053a74:	c6 83 3a 7f 06 08 ff 	movb   $0xff,0x8067f3a(%ebx)
		contexts[i].flags = 0U;
 8053a7b:	66 c7 83 38 7f 06 08 	movw   $0x0,0x8067f38(%ebx)
 8053a82:	00 00 
 8053a84:	87 83 a8 7e 06 08    	xchg   %eax,0x8067ea8(%ebx)
	uint16_t flag = 0U;
 8053a8a:	31 ff                	xor    %edi,%edi
	if (type == SOCK_DGRAM || type == SOCK_STREAM || type == SOCK_RAW) {
 8053a8c:	8b 55 d8             	mov    -0x28(%ebp),%edx
 8053a8f:	8d 46 ff             	lea    -0x1(%esi),%eax
 8053a92:	83 f8 02             	cmp    $0x2,%eax
 8053a95:	77 05                	ja     8053a9c <net_context_get+0x11f>
		flag = type << 6;
 8053a97:	89 f7                	mov    %esi,%edi
 8053a99:	c1 e7 06             	shl    $0x6,%edi
	context->flags |= flag;
 8053a9c:	69 75 e4 9c 00 00 00 	imul   $0x9c,-0x1c(%ebp),%esi
		flag = family << 3;
 8053aa3:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
 8053aaa:	b9 06 00 00 00       	mov    $0x6,%ecx
	context->flags |= flag;
 8053aaf:	0f b6 c0             	movzbl %al,%eax
 8053ab2:	0b 86 38 7f 06 08    	or     0x8067f38(%esi),%eax
	context->flags |= flag;
 8053ab8:	09 f8                	or     %edi,%eax
 8053aba:	66 89 86 38 7f 06 08 	mov    %ax,0x8067f38(%esi)
	context->proto = proto;
 8053ac1:	8b 45 dc             	mov    -0x24(%ebp),%eax
 8053ac4:	66 89 86 36 7f 06 08 	mov    %ax,0x8067f36(%esi)
			(void)memset(&contexts[i].remote, 0, sizeof(struct sockaddr));
 8053acb:	8d b3 cc 7e 06 08    	lea    0x8067ecc(%ebx),%esi
 8053ad1:	31 c0                	xor    %eax,%eax
 8053ad3:	89 f7                	mov    %esi,%edi
			(void)memset(&contexts[i].local, 0, sizeof(struct sockaddr_ptr));
 8053ad5:	8d b3 c0 7e 06 08    	lea    0x8067ec0(%ebx),%esi
 8053adb:	f3 ab                	rep stos %eax,%es:(%edi)
 8053add:	b9 03 00 00 00       	mov    $0x3,%ecx
 8053ae2:	89 f7                	mov    %esi,%edi
					find_available_port(&contexts[i], (struct sockaddr *)addr6);
 8053ae4:	89 f2                	mov    %esi,%edx
 8053ae6:	f3 ab                	rep stos %eax,%es:(%edi)
 8053ae8:	8b 45 e0             	mov    -0x20(%ebp),%eax
 8053aeb:	e8 51 fd ff ff       	call   8053841 <find_available_port>
				addr6->sin6_port =
 8053af0:	66 89 46 02          	mov    %ax,0x2(%esi)
				if (!addr6->sin6_port) {
 8053af4:	66 85 c0             	test   %ax,%ax
 8053af7:	75 07                	jne    8053b00 <net_context_get+0x183>
					ret = -EADDRINUSE;
 8053af9:	b8 9e ff ff ff       	mov    $0xffffff9e,%eax
 8053afe:	eb 3b                	jmp    8053b3b <net_context_get+0x1be>
	return z_impl_k_sem_init(sem, initial_count, limit);
 8053b00:	50                   	push   %eax
			k_sem_init(&contexts[i].recv_data_wait, 1, K_SEM_MAX_LIMIT);
 8053b01:	8d 83 f4 7e 06 08    	lea    0x8067ef4(%ebx),%eax
 8053b07:	6a ff                	push   $0xffffffff
 8053b09:	6a 01                	push   $0x1
 8053b0b:	50                   	push   %eax
 8053b0c:	e8 06 bb 00 00       	call   805f617 <z_impl_k_sem_init>
		k_mutex_init(&contexts[i].lock);
 8053b11:	81 c3 ac 7e 06 08    	add    $0x8067eac,%ebx
	return z_impl_k_mutex_init(mutex);
 8053b17:	89 1c 24             	mov    %ebx,(%esp)
 8053b1a:	e8 5c b6 00 00       	call   805f17b <z_impl_k_mutex_init>
		contexts[i].flags |= NET_CONTEXT_IN_USE;
 8053b1f:	69 45 e4 9c 00 00 00 	imul   $0x9c,-0x1c(%ebp),%eax
		*context = &contexts[i];
 8053b26:	8b 4d e0             	mov    -0x20(%ebp),%ecx
 8053b29:	83 c4 10             	add    $0x10,%esp
		contexts[i].flags |= NET_CONTEXT_IN_USE;
 8053b2c:	66 83 88 38 7f 06 08 	orw    $0x1,0x8067f38(%eax)
 8053b33:	01 
		*context = &contexts[i];
 8053b34:	8b 45 14             	mov    0x14(%ebp),%eax
 8053b37:	89 08                	mov    %ecx,(%eax)
		ret = 0;
 8053b39:	31 c0                	xor    %eax,%eax
 8053b3b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	z_impl_k_sem_give(sem);
 8053b3e:	83 ec 0c             	sub    $0xc,%esp
 8053b41:	68 ec 89 06 08       	push   $0x80689ec
 8053b46:	e8 ff ba 00 00       	call   805f64a <z_impl_k_sem_give>
 8053b4b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8053b4e:	83 c4 10             	add    $0x10,%esp
}
 8053b51:	8d 65 f4             	lea    -0xc(%ebp),%esp
 8053b54:	5b                   	pop    %ebx
 8053b55:	5e                   	pop    %esi
 8053b56:	5f                   	pop    %edi
 8053b57:	5d                   	pop    %ebp
 8053b58:	c3                   	ret    

08053b59 <net_context_ref>:
{
 8053b59:	55                   	push   %ebp
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
 8053b5a:	b8 01 00 00 00       	mov    $0x1,%eax
 8053b5f:	89 e5                	mov    %esp,%ebp
 8053b61:	8b 55 08             	mov    0x8(%ebp),%edx
 8053b64:	f0 0f c1 42 08       	lock xadd %eax,0x8(%edx)
}
 8053b69:	5d                   	pop    %ebp
	return old_rc + 1;
 8053b6a:	40                   	inc    %eax
}
 8053b6b:	c3                   	ret    

08053b6c <net_context_unref>:
{
 8053b6c:	55                   	push   %ebp
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
 8053b6d:	83 c8 ff             	or     $0xffffffff,%eax
 8053b70:	89 e5                	mov    %esp,%ebp
 8053b72:	56                   	push   %esi
 8053b73:	53                   	push   %ebx
 8053b74:	8b 5d 08             	mov    0x8(%ebp),%ebx
 8053b77:	f0 0f c1 43 08       	lock xadd %eax,0x8(%ebx)
	if (old_rc != 1) {
 8053b7c:	83 f8 01             	cmp    $0x1,%eax
 8053b7f:	74 03                	je     8053b84 <net_context_unref+0x18>
		return old_rc - 1;
 8053b81:	48                   	dec    %eax
 8053b82:	eb 3a                	jmp    8053bbe <net_context_unref+0x52>
	k_mutex_lock(&context->lock, K_FOREVER);
 8053b84:	83 ca ff             	or     $0xffffffff,%edx
 8053b87:	8d 73 0c             	lea    0xc(%ebx),%esi
 8053b8a:	89 f0                	mov    %esi,%eax
 8053b8c:	89 d1                	mov    %edx,%ecx
 8053b8e:	e8 e9 fc ff ff       	call   805387c <k_mutex_lock.constprop.0.isra.0>
	if (context->conn_handler) {
 8053b93:	8b 43 44             	mov    0x44(%ebx),%eax
 8053b96:	85 c0                	test   %eax,%eax
 8053b98:	74 13                	je     8053bad <net_context_unref+0x41>
			net_conn_unregister(context->conn_handler);
 8053b9a:	83 ec 0c             	sub    $0xc,%esp
 8053b9d:	50                   	push   %eax
 8053b9e:	e8 a4 22 00 00       	call   8055e47 <net_conn_unregister>
		context->conn_handler = NULL;
 8053ba3:	c7 43 44 00 00 00 00 	movl   $0x0,0x44(%ebx)
			net_conn_unregister(context->conn_handler);
 8053baa:	83 c4 10             	add    $0x10,%esp
	context->flags &= ~NET_CONTEXT_IN_USE;
 8053bad:	66 83 a3 98 00 00 00 	andw   $0xfff8,0x98(%ebx)
 8053bb4:	f8 
	k_mutex_unlock(&context->lock);
 8053bb5:	89 f0                	mov    %esi,%eax
 8053bb7:	e8 d7 fc ff ff       	call   8053893 <k_mutex_unlock.isra.0>
	return 0;
 8053bbc:	31 c0                	xor    %eax,%eax
}
 8053bbe:	8d 65 f8             	lea    -0x8(%ebp),%esp
 8053bc1:	5b                   	pop    %ebx
 8053bc2:	5e                   	pop    %esi
 8053bc3:	5d                   	pop    %ebp
 8053bc4:	c3                   	ret    

08053bc5 <net_context_put>:
{
 8053bc5:	55                   	push   %ebp
		return -EINVAL;
 8053bc6:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
{
 8053bcb:	89 e5                	mov    %esp,%ebp
 8053bcd:	56                   	push   %esi
 8053bce:	53                   	push   %ebx
 8053bcf:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (!PART_OF_ARRAY(contexts, context)) {
 8053bd2:	85 db                	test   %ebx,%ebx
 8053bd4:	74 49                	je     8053c1f <net_context_put+0x5a>
 8053bd6:	81 fb a0 7e 06 08    	cmp    $0x8067ea0,%ebx
 8053bdc:	72 41                	jb     8053c1f <net_context_put+0x5a>
 8053bde:	81 fb 48 82 06 08    	cmp    $0x8068248,%ebx
 8053be4:	73 39                	jae    8053c1f <net_context_put+0x5a>
	k_mutex_lock(&context->lock, K_FOREVER);
 8053be6:	83 ca ff             	or     $0xffffffff,%edx
 8053be9:	8d 73 0c             	lea    0xc(%ebx),%esi
 8053bec:	89 d1                	mov    %edx,%ecx
 8053bee:	89 f0                	mov    %esi,%eax
 8053bf0:	e8 87 fc ff ff       	call   805387c <k_mutex_lock.constprop.0.isra.0>
	net_context_unref(context);
 8053bf5:	83 ec 0c             	sub    $0xc,%esp
	context->connect_cb = NULL;
 8053bf8:	c7 43 50 00 00 00 00 	movl   $0x0,0x50(%ebx)
	context->recv_cb = NULL;
 8053bff:	c7 43 48 00 00 00 00 	movl   $0x0,0x48(%ebx)
	context->send_cb = NULL;
 8053c06:	c7 43 4c 00 00 00 00 	movl   $0x0,0x4c(%ebx)
	net_context_unref(context);
 8053c0d:	53                   	push   %ebx
 8053c0e:	e8 59 ff ff ff       	call   8053b6c <net_context_unref>
	k_mutex_unlock(&context->lock);
 8053c13:	89 f0                	mov    %esi,%eax
	net_context_unref(context);
 8053c15:	83 c4 10             	add    $0x10,%esp
	k_mutex_unlock(&context->lock);
 8053c18:	e8 76 fc ff ff       	call   8053893 <k_mutex_unlock.isra.0>
	return ret;
 8053c1d:	31 c0                	xor    %eax,%eax
}
 8053c1f:	8d 65 f8             	lea    -0x8(%ebp),%esp
 8053c22:	5b                   	pop    %ebx
 8053c23:	5e                   	pop    %esi
 8053c24:	5d                   	pop    %ebp
 8053c25:	c3                   	ret    

08053c26 <net_context_bind>:
{
 8053c26:	55                   	push   %ebp
 8053c27:	89 e5                	mov    %esp,%ebp
 8053c29:	57                   	push   %edi
 8053c2a:	56                   	push   %esi
 8053c2b:	53                   	push   %ebx
 8053c2c:	83 ec 2c             	sub    $0x2c,%esp
 8053c2f:	8b 5d 08             	mov    0x8(%ebp),%ebx
 8053c32:	8b 75 0c             	mov    0xc(%ebp),%esi
 8053c35:	65 8b 15 14 00 00 00 	mov    %gs:0x14,%edx
 8053c3c:	89 55 e4             	mov    %edx,-0x1c(%ebp)
 8053c3f:	31 d2                	xor    %edx,%edx
 8053c41:	8b 45 10             	mov    0x10(%ebp),%eax
		return -EISCONN;
 8053c44:	ba 96 ff ff ff       	mov    $0xffffff96,%edx
	if (context->conn_handler) {
 8053c49:	8b 7b 44             	mov    0x44(%ebx),%edi
 8053c4c:	85 ff                	test   %edi,%edi
 8053c4e:	0f 85 2a 02 00 00    	jne    8053e7e <net_context_bind+0x258>
	if (IS_ENABLED(CONFIG_NET_IPV6) && addr->sa_family == AF_INET6) {
 8053c54:	66 8b 0e             	mov    (%esi),%cx
 8053c57:	66 83 f9 02          	cmp    $0x2,%cx
 8053c5b:	0f 85 fd 00 00 00    	jne    8053d5e <net_context_bind+0x138>
		struct net_if *iface = NULL;
 8053c61:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			return -EINVAL;
 8053c68:	ba ea ff ff ff       	mov    $0xffffffea,%edx
		if (addrlen < sizeof(struct sockaddr_in6)) {
 8053c6d:	83 f8 17             	cmp    $0x17,%eax
 8053c70:	0f 86 08 02 00 00    	jbe    8053e7e <net_context_bind+0x258>
		if (net_context_is_bound_to_iface(context)) {
 8053c76:	f6 83 99 00 00 00 08 	testb  $0x8,0x99(%ebx)
 8053c7d:	74 16                	je     8053c95 <net_context_bind+0x6f>
	return net_if_get_by_index(context->iface);
 8053c7f:	0f be 83 9a 00 00 00 	movsbl 0x9a(%ebx),%eax
		union { uintptr_t x; int val; } parm0 = { .val = index };
		return (struct net_if *) arch_syscall_invoke1(parm0.x, K_SYSCALL_NET_IF_GET_BY_INDEX);
	}
#endif
	compiler_barrier();
	return z_impl_net_if_get_by_index(index);
 8053c86:	83 ec 0c             	sub    $0xc,%esp
 8053c89:	50                   	push   %eax
 8053c8a:	e8 6b d3 ff ff       	call   8050ffa <z_impl_net_if_get_by_index>
 8053c8f:	83 c4 10             	add    $0x10,%esp
			iface = net_context_get_iface(context);
 8053c92:	89 45 e0             	mov    %eax,-0x20(%ebp)
		if (net_ipv6_is_addr_mcast(&addr6->sin6_addr)) {
 8053c95:	80 7e 04 ff          	cmpb   $0xff,0x4(%esi)
			maddr = net_if_ipv6_maddr_lookup(&addr6->sin6_addr,
 8053c99:	8d 4e 04             	lea    0x4(%esi),%ecx
		if (net_ipv6_is_addr_mcast(&addr6->sin6_addr)) {
 8053c9c:	75 1b                	jne    8053cb9 <net_context_bind+0x93>
			maddr = net_if_ipv6_maddr_lookup(&addr6->sin6_addr,
 8053c9e:	50                   	push   %eax
 8053c9f:	50                   	push   %eax
 8053ca0:	8d 45 e0             	lea    -0x20(%ebp),%eax
 8053ca3:	50                   	push   %eax
 8053ca4:	51                   	push   %ecx
 8053ca5:	e8 05 e0 ff ff       	call   8051caf <net_if_ipv6_maddr_lookup>
 8053caa:	83 c4 10             	add    $0x10,%esp
			ptr = &maddr->address.in6_addr;
 8053cad:	8d 78 04             	lea    0x4(%eax),%edi
			if (!maddr) {
 8053cb0:	85 c0                	test   %eax,%eax
 8053cb2:	75 52                	jne    8053d06 <net_context_bind+0xe0>
 8053cb4:	e9 05 01 00 00       	jmp    8053dbe <net_context_bind+0x198>
		} else if (net_ipv6_is_addr_unspecified(&addr6->sin6_addr)) {
 8053cb9:	89 c8                	mov    %ecx,%eax
 8053cbb:	e8 d0 fa ff ff       	call   8053790 <net_ipv6_is_addr_unspecified>
 8053cc0:	89 c2                	mov    %eax,%edx
			if (iface == NULL) {
 8053cc2:	8b 45 e0             	mov    -0x20(%ebp),%eax
		} else if (net_ipv6_is_addr_unspecified(&addr6->sin6_addr)) {
 8053cc5:	84 d2                	test   %dl,%dl
 8053cc7:	74 1f                	je     8053ce8 <net_context_bind+0xc2>
			if (iface == NULL) {
 8053cc9:	85 c0                	test   %eax,%eax
 8053ccb:	75 12                	jne    8053cdf <net_context_bind+0xb9>
				iface = net_if_ipv6_select_src_iface(
 8053ccd:	83 ec 0c             	sub    $0xc,%esp
					&net_sin6(&context->remote)->sin6_addr);
 8053cd0:	8d 43 30             	lea    0x30(%ebx),%eax
				iface = net_if_ipv6_select_src_iface(
 8053cd3:	50                   	push   %eax
 8053cd4:	e8 5d e7 ff ff       	call   8052436 <net_if_ipv6_select_src_iface>
 8053cd9:	83 c4 10             	add    $0x10,%esp
 8053cdc:	89 45 e0             	mov    %eax,-0x20(%ebp)
			ptr = (struct in6_addr *)net_ipv6_unspecified_address();
 8053cdf:	e8 96 fa ff ff       	call   805377a <net_ipv6_unspecified_address>
 8053ce4:	89 c7                	mov    %eax,%edi
 8053ce6:	eb 1e                	jmp    8053d06 <net_context_bind+0xe0>
			ifaddr = net_if_ipv6_addr_lookup(
 8053ce8:	85 c0                	test   %eax,%eax
 8053cea:	75 03                	jne    8053cef <net_context_bind+0xc9>
 8053cec:	8d 7d e0             	lea    -0x20(%ebp),%edi
 8053cef:	50                   	push   %eax
 8053cf0:	50                   	push   %eax
 8053cf1:	57                   	push   %edi
 8053cf2:	51                   	push   %ecx
 8053cf3:	e8 27 d6 ff ff       	call   805131f <net_if_ipv6_addr_lookup>
 8053cf8:	83 c4 10             	add    $0x10,%esp
			if (!ifaddr) {
 8053cfb:	85 c0                	test   %eax,%eax
 8053cfd:	0f 84 bb 00 00 00    	je     8053dbe <net_context_bind+0x198>
			ptr = &ifaddr->address.in6_addr;
 8053d03:	8d 78 04             	lea    0x4(%eax),%edi
		if (!iface) {
 8053d06:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
			return -EADDRNOTAVAIL;
 8053d0a:	ba 9d ff ff ff       	mov    $0xffffff9d,%edx
		if (!iface) {
 8053d0f:	0f 84 69 01 00 00    	je     8053e7e <net_context_bind+0x258>
		k_mutex_lock(&context->lock, K_FOREVER);
 8053d15:	83 ca ff             	or     $0xffffffff,%edx
 8053d18:	8d 43 0c             	lea    0xc(%ebx),%eax
 8053d1b:	89 d1                	mov    %edx,%ecx
 8053d1d:	89 45 d4             	mov    %eax,-0x2c(%ebp)
 8053d20:	e8 57 fb ff ff       	call   805387c <k_mutex_lock.constprop.0.isra.0>
	context->iface = net_if_get_by_iface(iface);
 8053d25:	83 ec 0c             	sub    $0xc,%esp
 8053d28:	ff 75 e0             	push   -0x20(%ebp)
 8053d2b:	e8 52 ed ff ff       	call   8052a82 <net_if_get_by_iface>
		net_sin6_ptr(&context->local)->sin6_family = AF_INET6;
 8053d30:	66 c7 43 20 02 00    	movw   $0x2,0x20(%ebx)
 8053d36:	83 c4 10             	add    $0x10,%esp
 8053d39:	88 83 9a 00 00 00    	mov    %al,0x9a(%ebx)
		net_sin6_ptr(&context->local)->sin6_addr = ptr;
 8053d3f:	89 7b 24             	mov    %edi,0x24(%ebx)
		if (addr6->sin6_port) {
 8053d42:	66 8b 7e 02          	mov    0x2(%esi),%di
 8053d46:	66 85 ff             	test   %di,%di
 8053d49:	0f 84 17 01 00 00    	je     8053e66 <net_context_bind+0x240>
			ret = check_used_port(AF_INET6, addr6->sin6_port,
 8053d4f:	0f b7 d7             	movzwl %di,%edx
 8053d52:	89 f1                	mov    %esi,%ecx
 8053d54:	b8 02 00 00 00       	mov    $0x2,%eax
 8053d59:	e9 f7 00 00 00       	jmp    8053e55 <net_context_bind+0x22f>
	if (IS_ENABLED(CONFIG_NET_IPV4) && addr->sa_family == AF_INET) {
 8053d5e:	66 49                	dec    %cx
	return -EINVAL;
 8053d60:	ba ea ff ff ff       	mov    $0xffffffea,%edx
	if (IS_ENABLED(CONFIG_NET_IPV4) && addr->sa_family == AF_INET) {
 8053d65:	0f 85 13 01 00 00    	jne    8053e7e <net_context_bind+0x258>
		struct net_if *iface = NULL;
 8053d6b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		if (addrlen < sizeof(struct sockaddr_in)) {
 8053d72:	83 f8 07             	cmp    $0x7,%eax
 8053d75:	0f 86 03 01 00 00    	jbe    8053e7e <net_context_bind+0x258>
		if (net_context_is_bound_to_iface(context)) {
 8053d7b:	f6 83 99 00 00 00 08 	testb  $0x8,0x99(%ebx)
 8053d82:	74 16                	je     8053d9a <net_context_bind+0x174>
	return net_if_get_by_index(context->iface);
 8053d84:	0f be 83 9a 00 00 00 	movsbl 0x9a(%ebx),%eax
 8053d8b:	83 ec 0c             	sub    $0xc,%esp
 8053d8e:	50                   	push   %eax
 8053d8f:	e8 66 d2 ff ff       	call   8050ffa <z_impl_net_if_get_by_index>
 8053d94:	83 c4 10             	add    $0x10,%esp
			iface = net_context_get_iface(context);
 8053d97:	89 45 e0             	mov    %eax,-0x20(%ebp)
		if (net_ipv4_is_addr_mcast(&addr4->sin_addr)) {
 8053d9a:	8d 56 04             	lea    0x4(%esi),%edx
 8053d9d:	89 d0                	mov    %edx,%eax
 8053d9f:	e8 dc f9 ff ff       	call   8053780 <net_ipv4_is_addr_mcast>
 8053da4:	84 c0                	test   %al,%al
 8053da6:	74 20                	je     8053dc8 <net_context_bind+0x1a2>
			maddr = net_if_ipv4_maddr_lookup(&addr4->sin_addr,
 8053da8:	8d 45 e0             	lea    -0x20(%ebp),%eax
 8053dab:	51                   	push   %ecx
 8053dac:	51                   	push   %ecx
 8053dad:	50                   	push   %eax
 8053dae:	52                   	push   %edx
 8053daf:	e8 ef e9 ff ff       	call   80527a3 <net_if_ipv4_maddr_lookup>
 8053db4:	83 c4 10             	add    $0x10,%esp
			ptr = &maddr->address.in_addr;
 8053db7:	8d 78 04             	lea    0x4(%eax),%edi
			if (!maddr) {
 8053dba:	85 c0                	test   %eax,%eax
 8053dbc:	75 4c                	jne    8053e0a <net_context_bind+0x1e4>
				return -ENOENT;
 8053dbe:	ba fe ff ff ff       	mov    $0xfffffffe,%edx
 8053dc3:	e9 b6 00 00 00       	jmp    8053e7e <net_context_bind+0x258>
		} else if (addr4->sin_addr.s_addr == INADDR_ANY) {
 8053dc8:	83 7e 04 00          	cmpl   $0x0,0x4(%esi)
			if (iface == NULL) {
 8053dcc:	8b 45 e0             	mov    -0x20(%ebp),%eax
		} else if (addr4->sin_addr.s_addr == INADDR_ANY) {
 8053dcf:	75 1f                	jne    8053df0 <net_context_bind+0x1ca>
			if (iface == NULL) {
 8053dd1:	85 c0                	test   %eax,%eax
 8053dd3:	75 12                	jne    8053de7 <net_context_bind+0x1c1>
				iface = net_if_ipv4_select_src_iface(
 8053dd5:	83 ec 0c             	sub    $0xc,%esp
					&net_sin(&context->remote)->sin_addr);
 8053dd8:	8d 43 30             	lea    0x30(%ebx),%eax
				iface = net_if_ipv4_select_src_iface(
 8053ddb:	50                   	push   %eax
 8053ddc:	e8 0d e8 ff ff       	call   80525ee <net_if_ipv4_select_src_iface>
 8053de1:	83 c4 10             	add    $0x10,%esp
 8053de4:	89 45 e0             	mov    %eax,-0x20(%ebp)
			ptr = (struct in_addr *)net_ipv4_unspecified_address();
 8053de7:	e8 82 f9 ff ff       	call   805376e <net_ipv4_unspecified_address>
 8053dec:	89 c7                	mov    %eax,%edi
 8053dee:	eb 1a                	jmp    8053e0a <net_context_bind+0x1e4>
			ifaddr = net_if_ipv4_addr_lookup(
 8053df0:	85 c0                	test   %eax,%eax
 8053df2:	75 03                	jne    8053df7 <net_context_bind+0x1d1>
 8053df4:	8d 7d e0             	lea    -0x20(%ebp),%edi
 8053df7:	50                   	push   %eax
 8053df8:	50                   	push   %eax
 8053df9:	57                   	push   %edi
 8053dfa:	52                   	push   %edx
 8053dfb:	e8 45 e9 ff ff       	call   8052745 <net_if_ipv4_addr_lookup>
 8053e00:	83 c4 10             	add    $0x10,%esp
			if (!ifaddr) {
 8053e03:	85 c0                	test   %eax,%eax
 8053e05:	74 b7                	je     8053dbe <net_context_bind+0x198>
			ptr = &ifaddr->address.in_addr;
 8053e07:	8d 78 04             	lea    0x4(%eax),%edi
		if (!iface) {
 8053e0a:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
			return -EADDRNOTAVAIL;
 8053e0e:	ba 9d ff ff ff       	mov    $0xffffff9d,%edx
		if (!iface) {
 8053e13:	74 69                	je     8053e7e <net_context_bind+0x258>
		k_mutex_lock(&context->lock, K_FOREVER);
 8053e15:	83 ca ff             	or     $0xffffffff,%edx
 8053e18:	8d 43 0c             	lea    0xc(%ebx),%eax
 8053e1b:	89 d1                	mov    %edx,%ecx
 8053e1d:	89 45 d4             	mov    %eax,-0x2c(%ebp)
 8053e20:	e8 57 fa ff ff       	call   805387c <k_mutex_lock.constprop.0.isra.0>
	context->iface = net_if_get_by_iface(iface);
 8053e25:	83 ec 0c             	sub    $0xc,%esp
 8053e28:	ff 75 e0             	push   -0x20(%ebp)
 8053e2b:	e8 52 ec ff ff       	call   8052a82 <net_if_get_by_iface>
		net_sin_ptr(&context->local)->sin_family = AF_INET;
 8053e30:	66 c7 43 20 01 00    	movw   $0x1,0x20(%ebx)
 8053e36:	83 c4 10             	add    $0x10,%esp
 8053e39:	88 83 9a 00 00 00    	mov    %al,0x9a(%ebx)
		net_sin_ptr(&context->local)->sin_addr = ptr;
 8053e3f:	89 7b 24             	mov    %edi,0x24(%ebx)
		if (addr4->sin_port) {
 8053e42:	66 8b 7e 02          	mov    0x2(%esi),%di
 8053e46:	66 85 ff             	test   %di,%di
 8053e49:	74 1b                	je     8053e66 <net_context_bind+0x240>
			ret = check_used_port(AF_INET, addr4->sin_port,
 8053e4b:	0f b7 d7             	movzwl %di,%edx
 8053e4e:	89 f1                	mov    %esi,%ecx
 8053e50:	b8 01 00 00 00       	mov    $0x1,%eax
 8053e55:	e8 58 f9 ff ff       	call   80537b2 <check_used_port>
 8053e5a:	89 c2                	mov    %eax,%edx
			if (!ret) {
 8053e5c:	85 c0                	test   %eax,%eax
 8053e5e:	75 10                	jne    8053e70 <net_context_bind+0x24a>
				net_sin_ptr(&context->local)->sin_port =
 8053e60:	66 89 7b 22          	mov    %di,0x22(%ebx)
 8053e64:	eb 0a                	jmp    8053e70 <net_context_bind+0x24a>
				net_sin_ptr(&context->local)->sin_port;
 8053e66:	66 8b 43 22          	mov    0x22(%ebx),%ax
			addr4->sin_port =
 8053e6a:	31 d2                	xor    %edx,%edx
 8053e6c:	66 89 46 02          	mov    %ax,0x2(%esi)
		k_mutex_unlock(&context->lock);
 8053e70:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 8053e73:	89 55 d0             	mov    %edx,-0x30(%ebp)
 8053e76:	e8 18 fa ff ff       	call   8053893 <k_mutex_unlock.isra.0>
 8053e7b:	8b 55 d0             	mov    -0x30(%ebp),%edx
}
 8053e7e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8053e81:	65 2b 05 14 00 00 00 	sub    %gs:0x14,%eax
 8053e88:	74 05                	je     8053e8f <net_context_bind+0x269>
 8053e8a:	e8 71 54 ff ff       	call   8049300 <__stack_chk_fail@plt>
 8053e8f:	8d 65 f4             	lea    -0xc(%ebp),%esp
 8053e92:	89 d0                	mov    %edx,%eax
 8053e94:	5b                   	pop    %ebx
 8053e95:	5e                   	pop    %esi
 8053e96:	5f                   	pop    %edi
 8053e97:	5d                   	pop    %ebp
 8053e98:	c3                   	ret    

08053e99 <bind_default>:
{
 8053e99:	55                   	push   %ebp
 8053e9a:	89 e5                	mov    %esp,%ebp
 8053e9c:	57                   	push   %edi
 8053e9d:	56                   	push   %esi
 8053e9e:	53                   	push   %ebx
 8053e9f:	89 c3                	mov    %eax,%ebx
 8053ea1:	83 ec 2c             	sub    $0x2c,%esp
	return ((context->flags & NET_CONTEXT_FAMILY) >> 3);
 8053ea4:	0f b7 93 98 00 00 00 	movzwl 0x98(%ebx),%edx
 8053eab:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 8053eb1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 8053eb4:	31 c0                	xor    %eax,%eax
 8053eb6:	c1 ea 03             	shr    $0x3,%edx
 8053eb9:	83 e2 07             	and    $0x7,%edx
	if (IS_ENABLED(CONFIG_NET_IPV6) && family == AF_INET6) {
 8053ebc:	66 83 fa 02          	cmp    $0x2,%dx
 8053ec0:	75 36                	jne    8053ef8 <bind_default+0x5f>
		if (net_sin6_ptr(&context->local)->sin6_addr) {
 8053ec2:	83 7b 24 00          	cmpl   $0x0,0x24(%ebx)
 8053ec6:	75 6b                	jne    8053f33 <bind_default+0x9a>
		addr6.sin6_family = AF_INET6;
 8053ec8:	66 c7 45 cc 02 00    	movw   $0x2,-0x34(%ebp)
		memcpy(&addr6.sin6_addr, net_ipv6_unspecified_address(),
 8053ece:	e8 a7 f8 ff ff       	call   805377a <net_ipv6_unspecified_address>
  return __builtin___memcpy_chk (__dest, __src, __len,
 8053ed3:	8d 55 d0             	lea    -0x30(%ebp),%edx
 8053ed6:	b9 04 00 00 00       	mov    $0x4,%ecx
 8053edb:	89 d7                	mov    %edx,%edi
 8053edd:	89 c6                	mov    %eax,%esi
			find_available_port(context,
 8053edf:	8d 55 cc             	lea    -0x34(%ebp),%edx
 8053ee2:	89 d8                	mov    %ebx,%eax
 8053ee4:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
 8053ee6:	e8 56 f9 ff ff       	call   8053841 <find_available_port>
		addr6.sin6_port =
 8053eeb:	66 89 45 ce          	mov    %ax,-0x32(%ebp)
		return net_context_bind(context, (struct sockaddr *)&addr6,
 8053eef:	8d 45 cc             	lea    -0x34(%ebp),%eax
 8053ef2:	52                   	push   %edx
 8053ef3:	6a 18                	push   $0x18
 8053ef5:	50                   	push   %eax
 8053ef6:	eb 32                	jmp    8053f2a <bind_default+0x91>
	if (IS_ENABLED(CONFIG_NET_IPV4) && family == AF_INET) {
 8053ef8:	66 4a                	dec    %dx
	return -EINVAL;
 8053efa:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
	if (IS_ENABLED(CONFIG_NET_IPV4) && family == AF_INET) {
 8053eff:	75 32                	jne    8053f33 <bind_default+0x9a>
			return 0;
 8053f01:	31 c0                	xor    %eax,%eax
		if (net_sin_ptr(&context->local)->sin_addr) {
 8053f03:	83 7b 24 00          	cmpl   $0x0,0x24(%ebx)
 8053f07:	75 2a                	jne    8053f33 <bind_default+0x9a>
			find_available_port(context,
 8053f09:	8d 75 cc             	lea    -0x34(%ebp),%esi
 8053f0c:	89 d8                	mov    %ebx,%eax
		addr4.sin_family = AF_INET;
 8053f0e:	66 c7 45 cc 01 00    	movw   $0x1,-0x34(%ebp)
			find_available_port(context,
 8053f14:	89 f2                	mov    %esi,%edx
		addr4.sin_addr.s_addr = INADDR_ANY;
 8053f16:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
			find_available_port(context,
 8053f1d:	e8 1f f9 ff ff       	call   8053841 <find_available_port>
		addr4.sin_port =
 8053f22:	66 89 45 ce          	mov    %ax,-0x32(%ebp)
		return net_context_bind(context, (struct sockaddr *)&addr4,
 8053f26:	50                   	push   %eax
 8053f27:	6a 08                	push   $0x8
 8053f29:	56                   	push   %esi
 8053f2a:	53                   	push   %ebx
 8053f2b:	e8 f6 fc ff ff       	call   8053c26 <net_context_bind>
 8053f30:	83 c4 10             	add    $0x10,%esp
}
 8053f33:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 8053f36:	65 2b 15 14 00 00 00 	sub    %gs:0x14,%edx
 8053f3d:	74 05                	je     8053f44 <bind_default+0xab>
 8053f3f:	e8 bc 53 ff ff       	call   8049300 <__stack_chk_fail@plt>
 8053f44:	8d 65 f4             	lea    -0xc(%ebp),%esp
 8053f47:	5b                   	pop    %ebx
 8053f48:	5e                   	pop    %esi
 8053f49:	5f                   	pop    %edi
 8053f4a:	5d                   	pop    %ebp
 8053f4b:	c3                   	ret    

08053f4c <net_context_listen>:
{
 8053f4c:	55                   	push   %ebp
 8053f4d:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
 8053f52:	89 e5                	mov    %esp,%ebp
 8053f54:	83 ec 18             	sub    $0x18,%esp
 8053f57:	8b 55 08             	mov    0x8(%ebp),%edx
	if (!net_context_is_used(context)) {
 8053f5a:	f6 82 98 00 00 00 01 	testb  $0x1,0x98(%edx)
 8053f61:	74 1d                	je     8053f80 <net_context_listen+0x34>
	k_mutex_lock(&context->lock, K_FOREVER);
 8053f63:	8d 42 0c             	lea    0xc(%edx),%eax
 8053f66:	83 ca ff             	or     $0xffffffff,%edx
 8053f69:	89 d1                	mov    %edx,%ecx
 8053f6b:	89 45 f4             	mov    %eax,-0xc(%ebp)
 8053f6e:	e8 09 f9 ff ff       	call   805387c <k_mutex_lock.constprop.0.isra.0>
	k_mutex_unlock(&context->lock);
 8053f73:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8053f76:	e8 18 f9 ff ff       	call   8053893 <k_mutex_unlock.isra.0>
	return -EOPNOTSUPP;
 8053f7b:	b8 a1 ff ff ff       	mov    $0xffffffa1,%eax
}
 8053f80:	c9                   	leave  
 8053f81:	c3                   	ret    

08053f82 <net_context_create_ipv4_new>:
{
 8053f82:	55                   	push   %ebp
 8053f83:	89 e5                	mov    %esp,%ebp
 8053f85:	57                   	push   %edi
 8053f86:	56                   	push   %esi
 8053f87:	53                   	push   %ebx
 8053f88:	83 ec 0c             	sub    $0xc,%esp
 8053f8b:	8b 55 10             	mov    0x10(%ebp),%edx
 8053f8e:	8b 7d 08             	mov    0x8(%ebp),%edi
 8053f91:	8b 75 0c             	mov    0xc(%ebp),%esi
 8053f94:	8b 5d 14             	mov    0x14(%ebp),%ebx
	if (!src) {
 8053f97:	85 d2                	test   %edx,%edx
 8053f99:	75 03                	jne    8053f9e <net_context_create_ipv4_new+0x1c>
		src = ((struct sockaddr_in_ptr *)&context->local)->sin_addr;
 8053f9b:	8b 57 24             	mov    0x24(%edi),%edx
	if (net_ipv4_is_addr_unspecified(src)
 8053f9e:	83 3a 00             	cmpl   $0x0,(%edx)
 8053fa1:	74 0b                	je     8053fae <net_context_create_ipv4_new+0x2c>
	    || net_ipv4_is_addr_mcast(src)) {
 8053fa3:	89 d0                	mov    %edx,%eax
 8053fa5:	e8 d6 f7 ff ff       	call   8053780 <net_ipv4_is_addr_mcast>
 8053faa:	84 c0                	test   %al,%al
 8053fac:	74 15                	je     8053fc3 <net_context_create_ipv4_new+0x41>
		src = net_if_ipv4_select_src_addr(net_pkt_iface(pkt),
 8053fae:	50                   	push   %eax
 8053faf:	50                   	push   %eax
 8053fb0:	53                   	push   %ebx
 8053fb1:	ff 76 18             	push   0x18(%esi)
 8053fb4:	e8 a2 e6 ff ff       	call   805265b <net_if_ipv4_select_src_addr>
 8053fb9:	83 c4 10             	add    $0x10,%esp
		if (net_ipv4_is_addr_unspecified(src)) {
 8053fbc:	83 38 00             	cmpl   $0x0,(%eax)
		src = net_if_ipv4_select_src_addr(net_pkt_iface(pkt),
 8053fbf:	89 c2                	mov    %eax,%edx
		if (net_ipv4_is_addr_unspecified(src)) {
 8053fc1:	74 4f                	je     8054012 <net_context_create_ipv4_new+0x90>
}

static inline uint8_t net_context_get_ipv4_ttl(struct net_context *context)
{
	return context->ipv4_ttl;
 8053fc3:	8a 87 9b 00 00 00    	mov    0x9b(%edi),%al
	pkt->ipv4_ttl = ttl;
 8053fc9:	88 46 35             	mov    %al,0x35(%esi)
	pkt->ip_dscp = dscp;
 8053fcc:	8a 46 3c             	mov    0x3c(%esi),%al
 8053fcf:	8a 8f 94 00 00 00    	mov    0x94(%edi),%cl
 8053fd5:	83 e0 c0             	and    $0xffffffc0,%eax
 8053fd8:	c0 e9 02             	shr    $0x2,%cl
 8053fdb:	09 c8                	or     %ecx,%eax
 8053fdd:	88 46 3c             	mov    %al,0x3c(%esi)
	pkt->ip_ecn = ecn;
 8053fe0:	8a 8f 94 00 00 00    	mov    0x94(%edi),%cl
 8053fe6:	83 e0 3f             	and    $0x3f,%eax
 8053fe9:	c1 e1 06             	shl    $0x6,%ecx
 8053fec:	09 c8                	or     %ecx,%eax
 8053fee:	88 46 3c             	mov    %al,0x3c(%esi)
 *
 * @param dscp DSCP value.
 */
static inline uint8_t net_ipv4_dscp_to_priority(uint8_t dscp)
{
	return dscp >> 3;
 8053ff1:	8a 87 94 00 00 00    	mov    0x94(%edi),%al
 8053ff7:	c0 e8 05             	shr    $0x5,%al
	pkt->priority = priority;
 8053ffa:	88 46 3d             	mov    %al,0x3d(%esi)
	return net_ipv4_create(pkt, src, dst);
 8053ffd:	89 5d 10             	mov    %ebx,0x10(%ebp)
 8054000:	89 75 08             	mov    %esi,0x8(%ebp)
 8054003:	89 55 0c             	mov    %edx,0xc(%ebp)
}
 8054006:	8d 65 f4             	lea    -0xc(%ebp),%esp
 8054009:	5b                   	pop    %ebx
 805400a:	5e                   	pop    %esi
 805400b:	5f                   	pop    %edi
 805400c:	5d                   	pop    %ebp
	return net_ipv4_create(pkt, src, dst);
 805400d:	e9 80 28 00 00       	jmp    8056892 <net_ipv4_create>
}
 8054012:	8d 65 f4             	lea    -0xc(%ebp),%esp
 8054015:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
 805401a:	5b                   	pop    %ebx
 805401b:	5e                   	pop    %esi
 805401c:	5f                   	pop    %edi
 805401d:	5d                   	pop    %ebp
 805401e:	c3                   	ret    

0805401f <net_context_create_ipv6_new>:
{
 805401f:	55                   	push   %ebp
 8054020:	89 e5                	mov    %esp,%ebp
 8054022:	57                   	push   %edi
 8054023:	56                   	push   %esi
 8054024:	53                   	push   %ebx
 8054025:	83 ec 0c             	sub    $0xc,%esp
 8054028:	8b 4d 10             	mov    0x10(%ebp),%ecx
 805402b:	8b 7d 08             	mov    0x8(%ebp),%edi
 805402e:	8b 75 0c             	mov    0xc(%ebp),%esi
 8054031:	8b 5d 14             	mov    0x14(%ebp),%ebx
	if (!src) {
 8054034:	85 c9                	test   %ecx,%ecx
 8054036:	75 03                	jne    805403b <net_context_create_ipv6_new+0x1c>
		src = ((struct sockaddr_in6_ptr *)&context->local)->sin6_addr;
 8054038:	8b 4f 24             	mov    0x24(%edi),%ecx
	if (net_ipv6_is_addr_unspecified(src)
 805403b:	89 c8                	mov    %ecx,%eax
 805403d:	e8 4e f7 ff ff       	call   8053790 <net_ipv6_is_addr_unspecified>
 8054042:	84 c0                	test   %al,%al
 8054044:	75 05                	jne    805404b <net_context_create_ipv6_new+0x2c>
	    || net_ipv6_is_addr_mcast(src)) {
 8054046:	80 39 ff             	cmpb   $0xff,(%ecx)
 8054049:	75 10                	jne    805405b <net_context_create_ipv6_new+0x3c>
		src = net_if_ipv6_select_src_addr(net_pkt_iface(pkt),
 805404b:	50                   	push   %eax
 805404c:	50                   	push   %eax
 805404d:	53                   	push   %ebx
 805404e:	ff 76 18             	push   0x18(%esi)
 8054051:	e8 0a e3 ff ff       	call   8052360 <net_if_ipv6_select_src_addr>
 8054056:	83 c4 10             	add    $0x10,%esp
 8054059:	89 c1                	mov    %eax,%ecx
	context->ipv4_ttl = ttl;
}

static inline uint8_t net_context_get_ipv6_hop_limit(struct net_context *context)
{
	return context->ipv6_hop_limit;
 805405b:	8a 87 9b 00 00 00    	mov    0x9b(%edi),%al
	pkt->ipv6_hop_limit = hop_limit;
 8054061:	88 46 35             	mov    %al,0x35(%esi)
	pkt->ip_dscp = dscp;
 8054064:	8a 46 3c             	mov    0x3c(%esi),%al
 8054067:	8a 97 94 00 00 00    	mov    0x94(%edi),%dl
 805406d:	83 e0 c0             	and    $0xffffffc0,%eax
 8054070:	c0 ea 02             	shr    $0x2,%dl
 8054073:	09 d0                	or     %edx,%eax
 8054075:	88 46 3c             	mov    %al,0x3c(%esi)
	pkt->ip_ecn = ecn;
 8054078:	8a 97 94 00 00 00    	mov    0x94(%edi),%dl
 805407e:	83 e0 3f             	and    $0x3f,%eax
 8054081:	c1 e2 06             	shl    $0x6,%edx
 8054084:	09 d0                	or     %edx,%eax
 8054086:	88 46 3c             	mov    %al,0x3c(%esi)
 *
 * @param dscp DSCP value.
 */
static inline uint8_t net_ipv6_dscp_to_priority(uint8_t dscp)
{
	return dscp >> 3;
 8054089:	8a 87 94 00 00 00    	mov    0x94(%edi),%al
 805408f:	c0 e8 05             	shr    $0x5,%al
	pkt->priority = priority;
 8054092:	88 46 3d             	mov    %al,0x3d(%esi)
	return net_ipv6_create(pkt, src, dst);
 8054095:	89 5d 10             	mov    %ebx,0x10(%ebp)
 8054098:	89 75 08             	mov    %esi,0x8(%ebp)
 805409b:	89 4d 0c             	mov    %ecx,0xc(%ebp)
}
 805409e:	8d 65 f4             	lea    -0xc(%ebp),%esp
 80540a1:	5b                   	pop    %ebx
 80540a2:	5e                   	pop    %esi
 80540a3:	5f                   	pop    %edi
 80540a4:	5d                   	pop    %ebp
	return net_ipv6_create(pkt, src, dst);
 80540a5:	e9 a8 32 00 00       	jmp    8057352 <net_ipv6_create>

080540aa <context_sendto.constprop.0>:
static int context_sendto(struct net_context *context,
 80540aa:	55                   	push   %ebp
 80540ab:	89 e5                	mov    %esp,%ebp
 80540ad:	57                   	push   %edi
 80540ae:	56                   	push   %esi
 80540af:	53                   	push   %ebx
 80540b0:	89 c3                	mov    %eax,%ebx
 80540b2:	83 ec 1c             	sub    $0x1c,%esp
	return context->flags & NET_CONTEXT_IN_USE;
 80540b5:	8b b3 98 00 00 00    	mov    0x98(%ebx),%esi
 80540bb:	8b 45 18             	mov    0x18(%ebp),%eax
 80540be:	89 55 dc             	mov    %edx,-0x24(%ebp)
 80540c1:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
 80540c4:	8b 55 0c             	mov    0xc(%ebp),%edx
	if (!net_context_is_used(context)) {
 80540c7:	f7 c6 01 00 00 00    	test   $0x1,%esi
 80540cd:	0f 84 6b 03 00 00    	je     805443e <context_sendto.constprop.0+0x394>
	if (sendto && addrlen == 0 && dst_addr == NULL && buf != NULL) {
 80540d3:	89 d7                	mov    %edx,%edi
 80540d5:	0b 7d 08             	or     0x8(%ebp),%edi
 80540d8:	75 09                	jne    80540e3 <context_sendto.constprop.0+0x39>
 80540da:	84 c0                	test   %al,%al
 80540dc:	74 05                	je     80540e3 <context_sendto.constprop.0+0x39>
	const struct msghdr *msghdr = NULL;
 80540de:	8b 7d dc             	mov    -0x24(%ebp),%edi
 80540e1:	eb 02                	jmp    80540e5 <context_sendto.constprop.0+0x3b>
 80540e3:	31 ff                	xor    %edi,%edi
	if (!msghdr && !dst_addr) {
 80540e5:	89 f9                	mov    %edi,%ecx
 80540e7:	0b 4d 08             	or     0x8(%ebp),%ecx
		return -EDESTADDRREQ;
 80540ea:	b8 a7 ff ff ff       	mov    $0xffffffa7,%eax
	if (!msghdr && !dst_addr) {
 80540ef:	0f 84 55 03 00 00    	je     805444a <context_sendto.constprop.0+0x3a0>
	return ((context->flags & NET_CONTEXT_FAMILY) >> 3);
 80540f5:	89 f1                	mov    %esi,%ecx
 80540f7:	66 c1 e9 03          	shr    $0x3,%cx
 80540fb:	83 e1 07             	and    $0x7,%ecx
	if (IS_ENABLED(CONFIG_NET_IPV6) &&
 80540fe:	66 83 f9 02          	cmp    $0x2,%cx
 8054102:	75 66                	jne    805416a <context_sendto.constprop.0+0xc0>
		if (msghdr) {
 8054104:	85 ff                	test   %edi,%edi
 8054106:	74 16                	je     805411e <context_sendto.constprop.0+0x74>
			addr6 = msghdr->msg_name;
 8054108:	8b 07                	mov    (%edi),%eax
 805410a:	89 45 08             	mov    %eax,0x8(%ebp)
			if (!addr6) {
 805410d:	85 c0                	test   %eax,%eax
 805410f:	74 05                	je     8054116 <context_sendto.constprop.0+0x6c>
			addrlen = msghdr->msg_namelen;
 8054111:	8b 57 04             	mov    0x4(%edi),%edx
 8054114:	eb 08                	jmp    805411e <context_sendto.constprop.0+0x74>
				addr6 = net_sin6(&context->remote);
 8054116:	8d 43 2c             	lea    0x2c(%ebx),%eax
 8054119:	89 45 08             	mov    %eax,0x8(%ebp)
		if (addrlen < sizeof(struct sockaddr_in6)) {
 805411c:	eb 0e                	jmp    805412c <context_sendto.constprop.0+0x82>
			return -EINVAL;
 805411e:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
		if (addrlen < sizeof(struct sockaddr_in6)) {
 8054123:	83 fa 17             	cmp    $0x17,%edx
 8054126:	0f 86 1e 03 00 00    	jbe    805444a <context_sendto.constprop.0+0x3a0>
		if (net_ipv6_is_addr_unspecified(&addr6->sin6_addr)) {
 805412c:	8b 45 08             	mov    0x8(%ebp),%eax
 805412f:	8d 48 04             	lea    0x4(%eax),%ecx
 8054132:	89 c8                	mov    %ecx,%eax
 8054134:	e8 57 f6 ff ff       	call   8053790 <net_ipv6_is_addr_unspecified>
 8054139:	89 c2                	mov    %eax,%edx
		return -EDESTADDRREQ;
 805413b:	b8 a7 ff ff ff       	mov    $0xffffffa7,%eax
		if (net_ipv6_is_addr_unspecified(&addr6->sin6_addr)) {
 8054140:	84 d2                	test   %dl,%dl
 8054142:	0f 85 02 03 00 00    	jne    805444a <context_sendto.constprop.0+0x3a0>
				&net_sin6(&context->remote)->sin6_addr) &&
 8054148:	8d 43 30             	lea    0x30(%ebx),%eax
		if (net_ipv6_is_addr_unspecified(
 805414b:	e8 40 f6 ff ff       	call   8053790 <net_ipv6_is_addr_unspecified>
 8054150:	84 c0                	test   %al,%al
 8054152:	0f 84 85 00 00 00    	je     80541dd <context_sendto.constprop.0+0x133>
				&net_sin6(&context->remote)->sin6_addr) &&
 8054158:	66 f7 c6 00 08       	test   $0x800,%si
 805415d:	75 7e                	jne    80541dd <context_sendto.constprop.0+0x133>
			iface = net_if_ipv6_select_src_iface(&addr6->sin6_addr);
 805415f:	83 ec 0c             	sub    $0xc,%esp
 8054162:	51                   	push   %ecx
 8054163:	e8 ce e2 ff ff       	call   8052436 <net_if_ipv6_select_src_iface>
 8054168:	eb 62                	jmp    80541cc <context_sendto.constprop.0+0x122>
	} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
 805416a:	66 49                	dec    %cx
			return -EINVAL;
 805416c:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
	} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
 8054171:	0f 85 d3 02 00 00    	jne    805444a <context_sendto.constprop.0+0x3a0>
		if (msghdr) {
 8054177:	85 ff                	test   %edi,%edi
 8054179:	74 16                	je     8054191 <context_sendto.constprop.0+0xe7>
			addr4 = msghdr->msg_name;
 805417b:	8b 07                	mov    (%edi),%eax
 805417d:	89 45 08             	mov    %eax,0x8(%ebp)
			if (!addr4) {
 8054180:	85 c0                	test   %eax,%eax
 8054182:	74 05                	je     8054189 <context_sendto.constprop.0+0xdf>
			addrlen = msghdr->msg_namelen;
 8054184:	8b 57 04             	mov    0x4(%edi),%edx
 8054187:	eb 08                	jmp    8054191 <context_sendto.constprop.0+0xe7>
				addr4 = net_sin(&context->remote);
 8054189:	8d 43 2c             	lea    0x2c(%ebx),%eax
 805418c:	89 45 08             	mov    %eax,0x8(%ebp)
		if (addrlen < sizeof(struct sockaddr_in)) {
 805418f:	eb 0e                	jmp    805419f <context_sendto.constprop.0+0xf5>
			return -EINVAL;
 8054191:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
		if (addrlen < sizeof(struct sockaddr_in)) {
 8054196:	83 fa 07             	cmp    $0x7,%edx
 8054199:	0f 86 ab 02 00 00    	jbe    805444a <context_sendto.constprop.0+0x3a0>
		if (!addr4->sin_addr.s_addr) {
 805419f:	8b 4d 08             	mov    0x8(%ebp),%ecx
		return -EDESTADDRREQ;
 80541a2:	b8 a7 ff ff ff       	mov    $0xffffffa7,%eax
		if (!addr4->sin_addr.s_addr) {
 80541a7:	83 79 04 00          	cmpl   $0x0,0x4(%ecx)
 80541ab:	0f 84 99 02 00 00    	je     805444a <context_sendto.constprop.0+0x3a0>
		if (net_sin(&context->remote)->sin_addr.s_addr == 0U &&
 80541b1:	83 7b 30 00          	cmpl   $0x0,0x30(%ebx)
 80541b5:	75 26                	jne    80541dd <context_sendto.constprop.0+0x133>
 80541b7:	66 f7 c6 00 08       	test   $0x800,%si
 80541bc:	75 1f                	jne    80541dd <context_sendto.constprop.0+0x133>
			iface = net_if_ipv4_select_src_iface(&addr4->sin_addr);
 80541be:	89 c8                	mov    %ecx,%eax
 80541c0:	83 ec 0c             	sub    $0xc,%esp
 80541c3:	83 c0 04             	add    $0x4,%eax
 80541c6:	50                   	push   %eax
 80541c7:	e8 22 e4 ff ff       	call   80525ee <net_if_ipv4_select_src_iface>
	context->iface = net_if_get_by_iface(iface);
 80541cc:	89 04 24             	mov    %eax,(%esp)
 80541cf:	e8 ae e8 ff ff       	call   8052a82 <net_if_get_by_iface>
 80541d4:	83 c4 10             	add    $0x10,%esp
 80541d7:	88 83 9a 00 00 00    	mov    %al,0x9a(%ebx)
	if (msghdr && len == 0) {
 80541dd:	85 ff                	test   %edi,%edi
 80541df:	74 23                	je     8054204 <context_sendto.constprop.0+0x15a>
 80541e1:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
 80541e5:	75 1d                	jne    8054204 <context_sendto.constprop.0+0x15a>
		for (i = 0; i < msghdr->msg_iovlen; i++) {
 80541e7:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
 80541ee:	8b 57 0c             	mov    0xc(%edi),%edx
 80541f1:	31 c0                	xor    %eax,%eax
 80541f3:	39 d0                	cmp    %edx,%eax
 80541f5:	74 0d                	je     8054204 <context_sendto.constprop.0+0x15a>
			len += msghdr->msg_iov[i].iov_len;
 80541f7:	8b 4f 08             	mov    0x8(%edi),%ecx
 80541fa:	8b 4c c1 04          	mov    0x4(%ecx,%eax,8),%ecx
		for (i = 0; i < msghdr->msg_iovlen; i++) {
 80541fe:	40                   	inc    %eax
			len += msghdr->msg_iov[i].iov_len;
 80541ff:	01 4d e4             	add    %ecx,-0x1c(%ebp)
 8054202:	eb ef                	jmp    80541f3 <context_sendto.constprop.0+0x149>
	return net_if_get_by_index(context->iface);
 8054204:	0f be 83 9a 00 00 00 	movsbl 0x9a(%ebx),%eax
 805420b:	83 ec 0c             	sub    $0xc,%esp
 805420e:	50                   	push   %eax
 805420f:	e8 e6 cd ff ff       	call   8050ffa <z_impl_net_if_get_by_index>
 8054214:	83 c4 10             	add    $0x10,%esp
	if (iface && !net_if_is_up(iface)) {
 8054217:	85 c0                	test   %eax,%eax
 8054219:	75 49                	jne    8054264 <context_sendto.constprop.0+0x1ba>
	return ((context->flags & NET_CONTEXT_FAMILY) >> 3);
 805421b:	0f b7 b3 98 00 00 00 	movzwl 0x98(%ebx),%esi
	pkt = net_pkt_alloc_with_buffer(net_context_get_iface(context), len,
 8054222:	0f b7 93 96 00 00 00 	movzwl 0x96(%ebx),%edx
	return net_if_get_by_index(context->iface);
 8054229:	0f be 83 9a 00 00 00 	movsbl 0x9a(%ebx),%eax
	return ((context->flags & NET_CONTEXT_FAMILY) >> 3);
 8054230:	c1 ee 03             	shr    $0x3,%esi
 8054233:	89 55 e0             	mov    %edx,-0x20(%ebp)
 8054236:	83 e6 07             	and    $0x7,%esi
 8054239:	83 ec 0c             	sub    $0xc,%esp
 805423c:	50                   	push   %eax
 805423d:	e8 b8 cd ff ff       	call   8050ffa <z_impl_net_if_get_by_index>
 8054242:	5a                   	pop    %edx
 8054243:	8b 55 e0             	mov    -0x20(%ebp),%edx
 8054246:	59                   	pop    %ecx
 8054247:	6a 00                	push   $0x0
 8054249:	6a 64                	push   $0x64
 805424b:	52                   	push   %edx
 805424c:	56                   	push   %esi
 805424d:	ff 75 e4             	push   -0x1c(%ebp)
 8054250:	50                   	push   %eax
 8054251:	e8 b1 10 00 00       	call   8055307 <net_pkt_alloc_with_buffer>
 8054256:	83 c4 20             	add    $0x20,%esp
 8054259:	89 c6                	mov    %eax,%esi
	if (pkt) {
 805425b:	85 c0                	test   %eax,%eax
 805425d:	75 26                	jne    8054285 <context_sendto.constprop.0+0x1db>
 805425f:	e9 e1 01 00 00       	jmp    8054445 <context_sendto.constprop.0+0x39b>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
 8054264:	8b 10                	mov    (%eax),%edx
 8054266:	8b 52 0c             	mov    0xc(%edx),%edx
	return net_if_flag_is_set(iface, NET_IF_UP) &&
 8054269:	80 e2 01             	and    $0x1,%dl
 805426c:	75 0a                	jne    8054278 <context_sendto.constprop.0+0x1ce>
		return -ENETDOWN;
 805426e:	b8 9c ff ff ff       	mov    $0xffffff9c,%eax
 8054273:	e9 d2 01 00 00       	jmp    805444a <context_sendto.constprop.0+0x3a0>
 8054278:	8b 00                	mov    (%eax),%eax
 805427a:	8b 40 0c             	mov    0xc(%eax),%eax
	if (iface && !net_if_is_up(iface)) {
 805427d:	0f ba e0 08          	bt     $0x8,%eax
 8054281:	72 98                	jb     805421b <context_sendto.constprop.0+0x171>
 8054283:	eb e9                	jmp    805426e <context_sendto.constprop.0+0x1c4>
	pkt->context = ctx;
 8054285:	89 58 14             	mov    %ebx,0x14(%eax)
	tmp_len = net_pkt_available_payload_buffer(
 8054288:	50                   	push   %eax
 8054289:	50                   	push   %eax
 805428a:	0f b7 83 96 00 00 00 	movzwl 0x96(%ebx),%eax
 8054291:	50                   	push   %eax
 8054292:	56                   	push   %esi
 8054293:	e8 17 0c 00 00       	call   8054eaf <net_pkt_available_payload_buffer>
 8054298:	83 c4 10             	add    $0x10,%esp
 805429b:	89 c2                	mov    %eax,%edx
	if (tmp_len < len) {
 805429d:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
 80542a0:	76 19                	jbe    80542bb <context_sendto.constprop.0+0x211>
	return (enum net_sock_type)((context->flags & NET_CONTEXT_TYPE) >> 6);
 80542a2:	0f b7 83 98 00 00 00 	movzwl 0x98(%ebx),%eax
 80542a9:	c1 e8 06             	shr    $0x6,%eax
 80542ac:	83 e0 03             	and    $0x3,%eax
		if (net_context_get_type(context) == SOCK_DGRAM) {
 80542af:	83 f8 02             	cmp    $0x2,%eax
 80542b2:	0f 84 6d 01 00 00    	je     8054425 <context_sendto.constprop.0+0x37b>
 80542b8:	89 55 e4             	mov    %edx,-0x1c(%ebp)
	context->send_cb = cb;
 80542bb:	8b 45 10             	mov    0x10(%ebp),%eax
	} else if (IS_ENABLED(CONFIG_NET_UDP) &&
 80542be:	66 83 bb 96 00 00 00 	cmpw   $0x11,0x96(%ebx)
 80542c5:	11 
	context->send_cb = cb;
 80542c6:	89 43 4c             	mov    %eax,0x4c(%ebx)
	context->user_data = user_data;
 80542c9:	8b 45 14             	mov    0x14(%ebp),%eax
 80542cc:	89 43 04             	mov    %eax,0x4(%ebx)
		ret = -EPROTONOSUPPORT;
 80542cf:	b8 a3 ff ff ff       	mov    $0xffffffa3,%eax
	} else if (IS_ENABLED(CONFIG_NET_UDP) &&
 80542d4:	0f 85 50 01 00 00    	jne    805442a <context_sendto.constprop.0+0x380>
	return ((context->flags & NET_CONTEXT_FAMILY) >> 3);
 80542da:	0f b7 93 98 00 00 00 	movzwl 0x98(%ebx),%edx
 80542e1:	c1 ea 03             	shr    $0x3,%edx
 80542e4:	83 e2 07             	and    $0x7,%edx
	if (IS_ENABLED(CONFIG_NET_IPV6) &&
 80542e7:	66 83 fa 02          	cmp    $0x2,%dx
 80542eb:	75 1d                	jne    805430a <context_sendto.constprop.0+0x260>
		dst_port = addr6->sin6_port;
 80542ed:	8b 45 08             	mov    0x8(%ebp),%eax
 80542f0:	66 8b 40 02          	mov    0x2(%eax),%ax
 80542f4:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
						  NULL, &addr6->sin6_addr);
 80542f8:	8b 45 08             	mov    0x8(%ebp),%eax
 80542fb:	83 c0 04             	add    $0x4,%eax
		ret = net_context_create_ipv6_new(context, pkt,
 80542fe:	50                   	push   %eax
 80542ff:	6a 00                	push   $0x0
 8054301:	56                   	push   %esi
 8054302:	53                   	push   %ebx
 8054303:	e8 17 fd ff ff       	call   805401f <net_context_create_ipv6_new>
 8054308:	eb 28                	jmp    8054332 <context_sendto.constprop.0+0x288>
	} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
 805430a:	66 4a                	dec    %dx
	int ret = -EINVAL;
 805430c:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
	} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
 8054311:	0f 85 13 01 00 00    	jne    805442a <context_sendto.constprop.0+0x380>
		dst_port = addr4->sin_port;
 8054317:	8b 45 08             	mov    0x8(%ebp),%eax
 805431a:	66 8b 40 02          	mov    0x2(%eax),%ax
 805431e:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
						  NULL, &addr4->sin_addr);
 8054322:	8b 45 08             	mov    0x8(%ebp),%eax
 8054325:	83 c0 04             	add    $0x4,%eax
		ret = net_context_create_ipv4_new(context, pkt,
 8054328:	50                   	push   %eax
 8054329:	6a 00                	push   $0x0
 805432b:	56                   	push   %esi
 805432c:	53                   	push   %ebx
 805432d:	e8 50 fc ff ff       	call   8053f82 <net_context_create_ipv4_new>
 8054332:	83 c4 10             	add    $0x10,%esp
	if (ret < 0) {
 8054335:	85 c0                	test   %eax,%eax
 8054337:	0f 88 ed 00 00 00    	js     805442a <context_sendto.constprop.0+0x380>
	ret = bind_default(context);
 805433d:	89 d8                	mov    %ebx,%eax
 805433f:	e8 55 fb ff ff       	call   8053e99 <bind_default>
	if (ret) {
 8054344:	85 c0                	test   %eax,%eax
 8054346:	0f 85 aa 00 00 00    	jne    80543f6 <context_sendto.constprop.0+0x34c>
	ret = net_udp_create(pkt,
 805434c:	50                   	push   %eax
 805434d:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
 8054351:	50                   	push   %eax
 8054352:	0f b7 43 22          	movzwl 0x22(%ebx),%eax
 8054356:	50                   	push   %eax
 8054357:	56                   	push   %esi
 8054358:	e8 0b 63 00 00       	call   805a668 <net_udp_create>
 805435d:	83 c4 10             	add    $0x10,%esp
	if (ret) {
 8054360:	85 c0                	test   %eax,%eax
 8054362:	0f 85 8e 00 00 00    	jne    80543f6 <context_sendto.constprop.0+0x34c>
	ret = context_write_data(pkt, buf, len, msg);
 8054368:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
		for (i = 0; i < msghdr->msg_iovlen; i++) {
 805436b:	31 d2                	xor    %edx,%edx
	if (msghdr) {
 805436d:	85 ff                	test   %edi,%edi
 805436f:	74 40                	je     80543b1 <context_sendto.constprop.0+0x307>
		for (i = 0; i < msghdr->msg_iovlen; i++) {
 8054371:	3b 57 0c             	cmp    0xc(%edi),%edx
 8054374:	73 4b                	jae    80543c1 <context_sendto.constprop.0+0x317>
			int len = MIN(msghdr->msg_iov[i].iov_len, buf_len);
 8054376:	8b 47 08             	mov    0x8(%edi),%eax
 8054379:	89 55 d8             	mov    %edx,-0x28(%ebp)
 805437c:	89 4d dc             	mov    %ecx,-0x24(%ebp)
 805437f:	8d 04 d0             	lea    (%eax,%edx,8),%eax
 8054382:	89 ca                	mov    %ecx,%edx
 8054384:	3b 48 04             	cmp    0x4(%eax),%ecx
 8054387:	0f 47 50 04          	cmova  0x4(%eax),%edx
			ret = net_pkt_write(pkt, msghdr->msg_iov[i].iov_base,
 805438b:	51                   	push   %ecx
 805438c:	52                   	push   %edx
 805438d:	ff 30                	push   (%eax)
 805438f:	56                   	push   %esi
			int len = MIN(msghdr->msg_iov[i].iov_len, buf_len);
 8054390:	89 55 e0             	mov    %edx,-0x20(%ebp)
			ret = net_pkt_write(pkt, msghdr->msg_iov[i].iov_base,
 8054393:	e8 e1 14 00 00       	call   8055879 <net_pkt_write>
 8054398:	83 c4 10             	add    $0x10,%esp
			if (ret < 0) {
 805439b:	85 c0                	test   %eax,%eax
 805439d:	0f 88 87 00 00 00    	js     805442a <context_sendto.constprop.0+0x380>
			if (buf_len == 0) {
 80543a3:	8b 4d dc             	mov    -0x24(%ebp),%ecx
 80543a6:	2b 4d e0             	sub    -0x20(%ebp),%ecx
 80543a9:	74 16                	je     80543c1 <context_sendto.constprop.0+0x317>
		for (i = 0; i < msghdr->msg_iovlen; i++) {
 80543ab:	8b 55 d8             	mov    -0x28(%ebp),%edx
 80543ae:	42                   	inc    %edx
 80543af:	eb c0                	jmp    8054371 <context_sendto.constprop.0+0x2c7>
		ret = net_pkt_write(pkt, buf, buf_len);
 80543b1:	51                   	push   %ecx
 80543b2:	ff 75 e4             	push   -0x1c(%ebp)
 80543b5:	ff 75 dc             	push   -0x24(%ebp)
 80543b8:	56                   	push   %esi
 80543b9:	e8 bb 14 00 00       	call   8055879 <net_pkt_write>
 80543be:	83 c4 10             	add    $0x10,%esp
	if (ret) {
 80543c1:	85 c0                	test   %eax,%eax
 80543c3:	75 31                	jne    80543f6 <context_sendto.constprop.0+0x34c>
	net_pkt_cursor_init(pkt);
 80543c5:	83 ec 0c             	sub    $0xc,%esp
 80543c8:	56                   	push   %esi
 80543c9:	e8 86 0b 00 00       	call   8054f54 <net_pkt_cursor_init>
 80543ce:	0f b7 83 98 00 00 00 	movzwl 0x98(%ebx),%eax
 80543d5:	83 c4 10             	add    $0x10,%esp
 80543d8:	c1 e8 03             	shr    $0x3,%eax
 80543db:	83 e0 07             	and    $0x7,%eax
	if (IS_ENABLED(CONFIG_NET_IPV6) &&
 80543de:	66 83 f8 02          	cmp    $0x2,%ax
 80543e2:	75 18                	jne    80543fc <context_sendto.constprop.0+0x352>
		net_ipv6_finalize(pkt, net_context_get_proto(context));
 80543e4:	0f b6 83 96 00 00 00 	movzbl 0x96(%ebx),%eax
 80543eb:	52                   	push   %edx
 80543ec:	52                   	push   %edx
 80543ed:	50                   	push   %eax
 80543ee:	56                   	push   %esi
 80543ef:	e8 39 30 00 00       	call   805742d <net_ipv6_finalize>
 80543f4:	eb 1a                	jmp    8054410 <context_sendto.constprop.0+0x366>
		if (ret < 0) {
 80543f6:	85 c0                	test   %eax,%eax
 80543f8:	79 cb                	jns    80543c5 <context_sendto.constprop.0+0x31b>
 80543fa:	eb 2e                	jmp    805442a <context_sendto.constprop.0+0x380>
	} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
 80543fc:	66 48                	dec    %ax
 80543fe:	75 13                	jne    8054413 <context_sendto.constprop.0+0x369>
		net_ipv4_finalize(pkt, net_context_get_proto(context));
 8054400:	50                   	push   %eax
 8054401:	50                   	push   %eax
 8054402:	0f b6 83 96 00 00 00 	movzbl 0x96(%ebx),%eax
 8054409:	50                   	push   %eax
 805440a:	56                   	push   %esi
 805440b:	e8 b1 24 00 00       	call   80568c1 <net_ipv4_finalize>
 8054410:	83 c4 10             	add    $0x10,%esp
		ret = net_send_data(pkt);
 8054413:	83 ec 0c             	sub    $0xc,%esp
 8054416:	56                   	push   %esi
 8054417:	e8 14 c0 ff ff       	call   8050430 <net_send_data>
 805441c:	83 c4 10             	add    $0x10,%esp
	if (ret < 0) {
 805441f:	85 c0                	test   %eax,%eax
 8054421:	79 16                	jns    8054439 <context_sendto.constprop.0+0x38f>
 8054423:	eb 05                	jmp    805442a <context_sendto.constprop.0+0x380>
			ret = -ENOMEM;
 8054425:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
	net_pkt_unref(pkt);
 805442a:	83 ec 0c             	sub    $0xc,%esp
 805442d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 8054430:	56                   	push   %esi
 8054431:	e8 b2 09 00 00       	call   8054de8 <net_pkt_unref>
 8054436:	83 c4 10             	add    $0x10,%esp
	return ret;
 8054439:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 805443c:	eb 0c                	jmp    805444a <context_sendto.constprop.0+0x3a0>
		return -EBADF;
 805443e:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
 8054443:	eb 05                	jmp    805444a <context_sendto.constprop.0+0x3a0>
		return -ENOBUFS;
 8054445:	b8 97 ff ff ff       	mov    $0xffffff97,%eax
}
 805444a:	8d 65 f4             	lea    -0xc(%ebp),%esp
 805444d:	5b                   	pop    %ebx
 805444e:	5e                   	pop    %esi
 805444f:	5f                   	pop    %edi
 8054450:	5d                   	pop    %ebp
 8054451:	c3                   	ret    

08054452 <net_context_connect>:
{
 8054452:	55                   	push   %ebp
	k_mutex_lock(&context->lock, K_FOREVER);
 8054453:	83 ca ff             	or     $0xffffffff,%edx
 8054456:	89 d1                	mov    %edx,%ecx
{
 8054458:	89 e5                	mov    %esp,%ebp
 805445a:	57                   	push   %edi
 805445b:	56                   	push   %esi
		ret = -EALREADY;
 805445c:	be 8e ff ff ff       	mov    $0xffffff8e,%esi
{
 8054461:	53                   	push   %ebx
 8054462:	83 ec 1c             	sub    $0x1c,%esp
 8054465:	8b 5d 08             	mov    0x8(%ebp),%ebx
	k_mutex_lock(&context->lock, K_FOREVER);
 8054468:	8d 43 0c             	lea    0xc(%ebx),%eax
 805446b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 805446e:	e8 09 f4 ff ff       	call   805387c <k_mutex_lock.constprop.0.isra.0>
		((context->flags >> NET_CONTEXT_STATE_SHIFT) &
 8054473:	8b 93 98 00 00 00    	mov    0x98(%ebx),%edx
 8054479:	89 d1                	mov    %edx,%ecx
 805447b:	66 d1 e9             	shr    %cx
 805447e:	83 e1 03             	and    $0x3,%ecx
	if (net_context_get_state(context) == NET_CONTEXT_CONNECTING) {
 8054481:	66 83 f9 01          	cmp    $0x1,%cx
 8054485:	0f 84 41 01 00 00    	je     80545cc <net_context_connect+0x17a>
		ret = -EBADF;
 805448b:	be f7 ff ff ff       	mov    $0xfffffff7,%esi
	if (!net_context_is_used(context)) {
 8054490:	f6 c2 01             	test   $0x1,%dl
 8054493:	0f 84 33 01 00 00    	je     80545cc <net_context_connect+0x17a>
	return ((context->flags & NET_CONTEXT_FAMILY) >> 3);
 8054499:	89 d0                	mov    %edx,%eax
	if (addr->sa_family != net_context_get_family(context)) {
 805449b:	8b 7d 0c             	mov    0xc(%ebp),%edi
		ret = -EINVAL;
 805449e:	be ea ff ff ff       	mov    $0xffffffea,%esi
 80544a3:	66 c1 e8 03          	shr    $0x3,%ax
 80544a7:	83 e0 07             	and    $0x7,%eax
	if (addr->sa_family != net_context_get_family(context)) {
 80544aa:	66 39 07             	cmp    %ax,(%edi)
 80544ad:	0f 85 19 01 00 00    	jne    80545cc <net_context_connect+0x17a>
	if (net_context_get_state(context) == NET_CONTEXT_LISTENING) {
 80544b3:	66 83 f9 03          	cmp    $0x3,%cx
 80544b7:	75 0a                	jne    80544c3 <net_context_connect+0x71>
		ret = -EOPNOTSUPP;
 80544b9:	be a1 ff ff ff       	mov    $0xffffffa1,%esi
 80544be:	e9 09 01 00 00       	jmp    80545cc <net_context_connect+0x17a>
	if (IS_ENABLED(CONFIG_NET_IPV6) &&
 80544c3:	66 83 f8 02          	cmp    $0x2,%ax
 80544c7:	0f 85 84 00 00 00    	jne    8054551 <net_context_connect+0xff>
		if (addrlen < sizeof(struct sockaddr_in6)) {
 80544cd:	83 7d 10 17          	cmpl   $0x17,0x10(%ebp)
		ret = -EINVAL;
 80544d1:	be ea ff ff ff       	mov    $0xffffffea,%esi
		if (addrlen < sizeof(struct sockaddr_in6)) {
 80544d6:	0f 86 f0 00 00 00    	jbe    80545cc <net_context_connect+0x17a>
		if (net_context_get_proto(context) == IPPROTO_TCP &&
 80544dc:	66 83 bb 96 00 00 00 	cmpw   $0x6,0x96(%ebx)
 80544e3:	06 
 80544e4:	75 0f                	jne    80544f5 <net_context_connect+0xa3>
 80544e6:	80 7b 30 ff          	cmpb   $0xff,0x30(%ebx)
			ret = -EADDRNOTAVAIL;
 80544ea:	be 9d ff ff ff       	mov    $0xffffff9d,%esi
		if (net_context_get_proto(context) == IPPROTO_TCP &&
 80544ef:	0f 84 d7 00 00 00    	je     80545cc <net_context_connect+0x17a>
 80544f5:	8b 7d 0c             	mov    0xc(%ebp),%edi
		memcpy(&addr6->sin6_addr, &net_sin6(addr)->sin6_addr,
 80544f8:	8d 43 30             	lea    0x30(%ebx),%eax
 80544fb:	b9 04 00 00 00       	mov    $0x4,%ecx
 8054500:	89 55 e0             	mov    %edx,-0x20(%ebp)
 8054503:	8d 77 04             	lea    0x4(%edi),%esi
 8054506:	89 c7                	mov    %eax,%edi
 8054508:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
		addr6->sin6_port = net_sin6(addr)->sin6_port;
 805450a:	8b 7d 0c             	mov    0xc(%ebp),%edi
 805450d:	66 8b 4f 02          	mov    0x2(%edi),%cx
		addr6->sin6_family = AF_INET6;
 8054511:	66 c7 43 2c 02 00    	movw   $0x2,0x2c(%ebx)
		addr6->sin6_port = net_sin6(addr)->sin6_port;
 8054517:	66 89 4b 2e          	mov    %cx,0x2e(%ebx)
		if (!net_ipv6_is_addr_unspecified(&addr6->sin6_addr)) {
 805451b:	e8 70 f2 ff ff       	call   8053790 <net_ipv6_is_addr_unspecified>
			context->flags &= ~NET_CONTEXT_REMOTE_ADDR_SET;
 8054520:	8b 55 e0             	mov    -0x20(%ebp),%edx
 8054523:	89 d1                	mov    %edx,%ecx
 8054525:	80 e5 fe             	and    $0xfe,%ch
		if (!net_ipv6_is_addr_unspecified(&addr6->sin6_addr)) {
 8054528:	84 c0                	test   %al,%al
 805452a:	75 05                	jne    8054531 <net_context_connect+0xdf>
			context->flags |= NET_CONTEXT_REMOTE_ADDR_SET;
 805452c:	80 ce 01             	or     $0x1,%dh
 805452f:	89 d1                	mov    %edx,%ecx
 8054531:	66 89 8b 98 00 00 00 	mov    %cx,0x98(%ebx)
		ret = bind_default(context);
 8054538:	89 d8                	mov    %ebx,%eax
 805453a:	e8 5a f9 ff ff       	call   8053e99 <bind_default>
 805453f:	89 c6                	mov    %eax,%esi
		if (ret) {
 8054541:	85 c0                	test   %eax,%eax
 8054543:	0f 85 83 00 00 00    	jne    80545cc <net_context_connect+0x17a>
		net_sin6_ptr(&context->local)->sin6_family = AF_INET6;
 8054549:	66 c7 43 20 02 00    	movw   $0x2,0x20(%ebx)
		if (net_sin6_ptr(&context->local)->sin6_addr) {
 805454f:	eb 49                	jmp    805459a <net_context_connect+0x148>
		if (addrlen < sizeof(struct sockaddr_in)) {
 8054551:	83 7d 10 07          	cmpl   $0x7,0x10(%ebp)
 8054555:	76 70                	jbe    80545c7 <net_context_connect+0x175>
 8054557:	66 48                	dec    %ax
 8054559:	75 6c                	jne    80545c7 <net_context_connect+0x175>
 805455b:	8b 45 0c             	mov    0xc(%ebp),%eax
 805455e:	8b 48 04             	mov    0x4(%eax),%ecx
 8054561:	89 4b 30             	mov    %ecx,0x30(%ebx)
		addr4->sin_port = net_sin(addr)->sin_port;
 8054564:	66 8b 40 02          	mov    0x2(%eax),%ax
		addr4->sin_family = AF_INET;
 8054568:	66 c7 43 2c 01 00    	movw   $0x1,0x2c(%ebx)
		addr4->sin_port = net_sin(addr)->sin_port;
 805456e:	66 89 43 2e          	mov    %ax,0x2e(%ebx)
			context->flags &= ~NET_CONTEXT_REMOTE_ADDR_SET;
 8054572:	89 d0                	mov    %edx,%eax
 8054574:	80 e4 fe             	and    $0xfe,%ah
		if (addr4->sin_addr.s_addr) {
 8054577:	85 c9                	test   %ecx,%ecx
 8054579:	74 05                	je     8054580 <net_context_connect+0x12e>
			context->flags |= NET_CONTEXT_REMOTE_ADDR_SET;
 805457b:	89 d0                	mov    %edx,%eax
 805457d:	80 cc 01             	or     $0x1,%ah
 8054580:	66 89 83 98 00 00 00 	mov    %ax,0x98(%ebx)
		ret = bind_default(context);
 8054587:	89 d8                	mov    %ebx,%eax
 8054589:	e8 0b f9 ff ff       	call   8053e99 <bind_default>
 805458e:	89 c6                	mov    %eax,%esi
		if (ret) {
 8054590:	85 c0                	test   %eax,%eax
 8054592:	75 38                	jne    80545cc <net_context_connect+0x17a>
		net_sin_ptr(&context->local)->sin_family = AF_INET;
 8054594:	66 c7 43 20 01 00    	movw   $0x1,0x20(%ebx)
	return (enum net_sock_type)((context->flags & NET_CONTEXT_TYPE) >> 6);
 805459a:	0f b7 83 98 00 00 00 	movzwl 0x98(%ebx),%eax
 80545a1:	c1 e8 06             	shr    $0x6,%eax
 80545a4:	83 e0 03             	and    $0x3,%eax
	if (IS_ENABLED(CONFIG_NET_UDP) &&
 80545a7:	83 f8 02             	cmp    $0x2,%eax
 80545aa:	0f 85 09 ff ff ff    	jne    80544b9 <net_context_connect+0x67>
		ret = 0;
 80545b0:	31 f6                	xor    %esi,%esi
		if (cb) {
 80545b2:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
 80545b6:	74 14                	je     80545cc <net_context_connect+0x17a>
			cb(context, 0, user_data);
 80545b8:	50                   	push   %eax
 80545b9:	ff 75 20             	push   0x20(%ebp)
 80545bc:	6a 00                	push   $0x0
 80545be:	53                   	push   %ebx
 80545bf:	ff 55 14             	call   *0x14(%ebp)
 80545c2:	83 c4 10             	add    $0x10,%esp
 80545c5:	eb 05                	jmp    80545cc <net_context_connect+0x17a>
		ret = -EINVAL;
 80545c7:	be ea ff ff ff       	mov    $0xffffffea,%esi
	k_mutex_unlock(&context->lock);
 80545cc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 80545cf:	e8 bf f2 ff ff       	call   8053893 <k_mutex_unlock.isra.0>
}
 80545d4:	8d 65 f4             	lea    -0xc(%ebp),%esp
 80545d7:	89 f0                	mov    %esi,%eax
 80545d9:	5b                   	pop    %ebx
 80545da:	5e                   	pop    %esi
 80545db:	5f                   	pop    %edi
 80545dc:	5d                   	pop    %ebp
 80545dd:	c3                   	ret    

080545de <net_context_accept>:
{
 80545de:	55                   	push   %ebp
 80545df:	89 e5                	mov    %esp,%ebp
 80545e1:	57                   	push   %edi
 80545e2:	bf f7 ff ff ff       	mov    $0xfffffff7,%edi
 80545e7:	56                   	push   %esi
 80545e8:	53                   	push   %ebx
 80545e9:	83 ec 0c             	sub    $0xc,%esp
 80545ec:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (!net_context_is_used(context)) {
 80545ef:	f6 83 98 00 00 00 01 	testb  $0x1,0x98(%ebx)
 80545f6:	74 46                	je     805463e <net_context_accept+0x60>
	k_mutex_lock(&context->lock, K_FOREVER);
 80545f8:	83 ca ff             	or     $0xffffffff,%edx
 80545fb:	8d 73 0c             	lea    0xc(%ebx),%esi
 80545fe:	89 d1                	mov    %edx,%ecx
 8054600:	89 f0                	mov    %esi,%eax
 8054602:	e8 75 f2 ff ff       	call   805387c <k_mutex_lock.constprop.0.isra.0>
		((context->flags >> NET_CONTEXT_STATE_SHIFT) &
 8054607:	8b 83 98 00 00 00    	mov    0x98(%ebx),%eax
	if ((net_context_get_state(context) != NET_CONTEXT_LISTENING) &&
 805460d:	89 c2                	mov    %eax,%edx
 805460f:	83 f2 06             	xor    $0x6,%edx
 8054612:	80 e2 06             	and    $0x6,%dl
 8054615:	74 0e                	je     8054625 <net_context_accept+0x47>
	return (enum net_sock_type)((context->flags & NET_CONTEXT_TYPE) >> 6);
 8054617:	c1 e8 06             	shr    $0x6,%eax
		ret = -EINVAL;
 805461a:	bf ea ff ff ff       	mov    $0xffffffea,%edi
 805461f:	83 e0 03             	and    $0x3,%eax
	if ((net_context_get_state(context) != NET_CONTEXT_LISTENING) &&
 8054622:	48                   	dec    %eax
 8054623:	75 12                	jne    8054637 <net_context_accept+0x59>
		ret = net_tcp_accept(context, cb, user_data);
 8054625:	31 ff                	xor    %edi,%edi
 8054627:	b8 a3 ff ff ff       	mov    $0xffffffa3,%eax
 805462c:	66 83 bb 96 00 00 00 	cmpw   $0x6,0x96(%ebx)
 8054633:	06 
 8054634:	0f 44 f8             	cmove  %eax,%edi
	k_mutex_unlock(&context->lock);
 8054637:	89 f0                	mov    %esi,%eax
 8054639:	e8 55 f2 ff ff       	call   8053893 <k_mutex_unlock.isra.0>
}
 805463e:	83 c4 0c             	add    $0xc,%esp
 8054641:	89 f8                	mov    %edi,%eax
 8054643:	5b                   	pop    %ebx
 8054644:	5e                   	pop    %esi
 8054645:	5f                   	pop    %edi
 8054646:	5d                   	pop    %ebp
 8054647:	c3                   	ret    

08054648 <net_context_send>:
{
 8054648:	55                   	push   %ebp
	k_mutex_lock(&context->lock, K_FOREVER);
 8054649:	83 ca ff             	or     $0xffffffff,%edx
 805464c:	89 d1                	mov    %edx,%ecx
{
 805464e:	89 e5                	mov    %esp,%ebp
 8054650:	57                   	push   %edi
		ret = -EDESTADDRREQ;
 8054651:	bf a7 ff ff ff       	mov    $0xffffffa7,%edi
{
 8054656:	56                   	push   %esi
 8054657:	53                   	push   %ebx
 8054658:	83 ec 0c             	sub    $0xc,%esp
 805465b:	8b 5d 08             	mov    0x8(%ebp),%ebx
	k_mutex_lock(&context->lock, K_FOREVER);
 805465e:	8d 73 0c             	lea    0xc(%ebx),%esi
 8054661:	89 f0                	mov    %esi,%eax
 8054663:	e8 14 f2 ff ff       	call   805387c <k_mutex_lock.constprop.0.isra.0>
	if (!(context->flags & NET_CONTEXT_REMOTE_ADDR_SET) ||
 8054668:	0f b7 83 98 00 00 00 	movzwl 0x98(%ebx),%eax
 805466f:	f6 c4 01             	test   $0x1,%ah
 8054672:	74 44                	je     80546b8 <net_context_send+0x70>
 8054674:	66 83 7b 2e 00       	cmpw   $0x0,0x2e(%ebx)
 8054679:	74 3d                	je     80546b8 <net_context_send+0x70>
	return ((context->flags & NET_CONTEXT_FAMILY) >> 3);
 805467b:	c1 e8 03             	shr    $0x3,%eax
		addrlen = sizeof(struct sockaddr_in6);
 805467e:	ba 18 00 00 00       	mov    $0x18,%edx
 8054683:	83 e0 07             	and    $0x7,%eax
	if (IS_ENABLED(CONFIG_NET_IPV6) &&
 8054686:	66 83 f8 02          	cmp    $0x2,%ax
 805468a:	74 0a                	je     8054696 <net_context_send+0x4e>
	} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
 805468c:	31 d2                	xor    %edx,%edx
 805468e:	66 48                	dec    %ax
 8054690:	0f 94 c2             	sete   %dl
 8054693:	c1 e2 03             	shl    $0x3,%edx
	ret = context_sendto(context, buf, len, &context->remote,
 8054696:	83 ec 0c             	sub    $0xc,%esp
 8054699:	8d 43 2c             	lea    0x2c(%ebx),%eax
 805469c:	8b 4d 10             	mov    0x10(%ebp),%ecx
 805469f:	6a 00                	push   $0x0
 80546a1:	ff 75 20             	push   0x20(%ebp)
 80546a4:	ff 75 14             	push   0x14(%ebp)
 80546a7:	52                   	push   %edx
 80546a8:	50                   	push   %eax
 80546a9:	8b 55 0c             	mov    0xc(%ebp),%edx
 80546ac:	89 d8                	mov    %ebx,%eax
 80546ae:	e8 f7 f9 ff ff       	call   80540aa <context_sendto.constprop.0>
 80546b3:	83 c4 20             	add    $0x20,%esp
 80546b6:	89 c7                	mov    %eax,%edi
	k_mutex_unlock(&context->lock);
 80546b8:	89 f0                	mov    %esi,%eax
 80546ba:	e8 d4 f1 ff ff       	call   8053893 <k_mutex_unlock.isra.0>
}
 80546bf:	8d 65 f4             	lea    -0xc(%ebp),%esp
 80546c2:	89 f8                	mov    %edi,%eax
 80546c4:	5b                   	pop    %ebx
 80546c5:	5e                   	pop    %esi
 80546c6:	5f                   	pop    %edi
 80546c7:	5d                   	pop    %ebp
 80546c8:	c3                   	ret    

080546c9 <net_context_sendmsg>:
{
 80546c9:	55                   	push   %ebp
	k_mutex_lock(&context->lock, K_FOREVER);
 80546ca:	83 ca ff             	or     $0xffffffff,%edx
 80546cd:	89 d1                	mov    %edx,%ecx
{
 80546cf:	89 e5                	mov    %esp,%ebp
 80546d1:	56                   	push   %esi
 80546d2:	53                   	push   %ebx
 80546d3:	8b 5d 08             	mov    0x8(%ebp),%ebx
	k_mutex_lock(&context->lock, K_FOREVER);
 80546d6:	8d 73 0c             	lea    0xc(%ebx),%esi
 80546d9:	89 f0                	mov    %esi,%eax
 80546db:	e8 9c f1 ff ff       	call   805387c <k_mutex_lock.constprop.0.isra.0>
	ret = context_sendto(context, msghdr, 0, NULL, 0,
 80546e0:	83 ec 0c             	sub    $0xc,%esp
 80546e3:	8b 55 0c             	mov    0xc(%ebp),%edx
 80546e6:	31 c9                	xor    %ecx,%ecx
 80546e8:	6a 01                	push   $0x1
 80546ea:	89 d8                	mov    %ebx,%eax
 80546ec:	ff 75 20             	push   0x20(%ebp)
 80546ef:	ff 75 14             	push   0x14(%ebp)
 80546f2:	6a 00                	push   $0x0
 80546f4:	6a 00                	push   $0x0
 80546f6:	e8 af f9 ff ff       	call   80540aa <context_sendto.constprop.0>
 80546fb:	83 c4 20             	add    $0x20,%esp
 80546fe:	89 c3                	mov    %eax,%ebx
	k_mutex_unlock(&context->lock);
 8054700:	89 f0                	mov    %esi,%eax
 8054702:	e8 8c f1 ff ff       	call   8053893 <k_mutex_unlock.isra.0>
}
 8054707:	8d 65 f8             	lea    -0x8(%ebp),%esp
 805470a:	89 d8                	mov    %ebx,%eax
 805470c:	5b                   	pop    %ebx
 805470d:	5e                   	pop    %esi
 805470e:	5d                   	pop    %ebp
 805470f:	c3                   	ret    

08054710 <net_context_sendto>:
{
 8054710:	55                   	push   %ebp
	k_mutex_lock(&context->lock, K_FOREVER);
 8054711:	83 ca ff             	or     $0xffffffff,%edx
 8054714:	89 d1                	mov    %edx,%ecx
{
 8054716:	89 e5                	mov    %esp,%ebp
 8054718:	56                   	push   %esi
 8054719:	53                   	push   %ebx
 805471a:	8b 5d 08             	mov    0x8(%ebp),%ebx
	k_mutex_lock(&context->lock, K_FOREVER);
 805471d:	8d 73 0c             	lea    0xc(%ebx),%esi
 8054720:	89 f0                	mov    %esi,%eax
 8054722:	e8 55 f1 ff ff       	call   805387c <k_mutex_lock.constprop.0.isra.0>
	ret = context_sendto(context, buf, len, dst_addr, addrlen,
 8054727:	83 ec 0c             	sub    $0xc,%esp
 805472a:	8b 4d 10             	mov    0x10(%ebp),%ecx
 805472d:	8b 55 0c             	mov    0xc(%ebp),%edx
 8054730:	6a 01                	push   $0x1
 8054732:	89 d8                	mov    %ebx,%eax
 8054734:	ff 75 28             	push   0x28(%ebp)
 8054737:	ff 75 1c             	push   0x1c(%ebp)
 805473a:	ff 75 18             	push   0x18(%ebp)
 805473d:	ff 75 14             	push   0x14(%ebp)
 8054740:	e8 65 f9 ff ff       	call   80540aa <context_sendto.constprop.0>
 8054745:	83 c4 20             	add    $0x20,%esp
 8054748:	89 c3                	mov    %eax,%ebx
	k_mutex_unlock(&context->lock);
 805474a:	89 f0                	mov    %esi,%eax
 805474c:	e8 42 f1 ff ff       	call   8053893 <k_mutex_unlock.isra.0>
}
 8054751:	8d 65 f8             	lea    -0x8(%ebp),%esp
 8054754:	89 d8                	mov    %ebx,%eax
 8054756:	5b                   	pop    %ebx
 8054757:	5e                   	pop    %esi
 8054758:	5d                   	pop    %ebp
 8054759:	c3                   	ret    

0805475a <net_context_recv>:

int net_context_recv(struct net_context *context,
		     net_context_recv_cb_t cb,
		     k_timeout_t timeout,
		     void *user_data)
{
 805475a:	55                   	push   %ebp
 805475b:	89 e5                	mov    %esp,%ebp
 805475d:	57                   	push   %edi
 805475e:	56                   	push   %esi
 805475f:	be f7 ff ff ff       	mov    $0xfffffff7,%esi
 8054764:	53                   	push   %ebx
 8054765:	83 ec 5c             	sub    $0x5c,%esp
 8054768:	8b 45 0c             	mov    0xc(%ebp),%eax
 805476b:	8b 5d 08             	mov    0x8(%ebp),%ebx
 805476e:	89 45 a4             	mov    %eax,-0x5c(%ebp)
 8054771:	8b 45 10             	mov    0x10(%ebp),%eax
 8054774:	89 45 ac             	mov    %eax,-0x54(%ebp)
 8054777:	8b 45 14             	mov    0x14(%ebp),%eax
 805477a:	89 45 a8             	mov    %eax,-0x58(%ebp)
 805477d:	8b 45 18             	mov    0x18(%ebp),%eax
 8054780:	89 45 a0             	mov    %eax,-0x60(%ebp)
 8054783:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 8054789:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 805478c:	31 c0                	xor    %eax,%eax
	int ret;
	NET_ASSERT(context);

	if (!net_context_is_used(context)) {
 805478e:	f6 83 98 00 00 00 01 	testb  $0x1,0x98(%ebx)
 8054795:	0f 84 67 01 00 00    	je     8054902 <net_context_recv+0x1a8>
		return -EBADF;
	}

	k_mutex_lock(&context->lock, K_FOREVER);
 805479b:	83 ca ff             	or     $0xffffffff,%edx
 805479e:	8d 43 0c             	lea    0xc(%ebx),%eax
				 * correct net_context listener.
				 */
				ret = 0;
			}
		} else {
			ret = -EPROTOTYPE;
 80547a1:	be a5 ff ff ff       	mov    $0xffffffa5,%esi
	k_mutex_lock(&context->lock, K_FOREVER);
 80547a6:	89 d1                	mov    %edx,%ecx
 80547a8:	89 45 b4             	mov    %eax,-0x4c(%ebp)
 80547ab:	e8 cc f0 ff ff       	call   805387c <k_mutex_lock.constprop.0.isra.0>
	if (IS_ENABLED(CONFIG_NET_UDP) &&
 80547b0:	66 83 bb 96 00 00 00 	cmpw   $0x11,0x96(%ebx)
 80547b7:	11 
 80547b8:	0f 85 3c 01 00 00    	jne    80548fa <net_context_recv+0x1a0>
	struct sockaddr local_addr = {
 80547be:	31 c0                	xor    %eax,%eax
 80547c0:	8d 7d cc             	lea    -0x34(%ebp),%edi
 80547c3:	b9 06 00 00 00       	mov    $0x6,%ecx
 80547c8:	f3 ab                	rep stos %eax,%es:(%edi)
 80547ca:	0f b7 83 98 00 00 00 	movzwl 0x98(%ebx),%eax
 80547d1:	c1 e8 03             	shr    $0x3,%eax
 80547d4:	83 e0 07             	and    $0x7,%eax
 80547d7:	66 89 45 cc          	mov    %ax,-0x34(%ebp)
	if (context->conn_handler) {
 80547db:	8b 43 44             	mov    0x44(%ebx),%eax
 80547de:	85 c0                	test   %eax,%eax
 80547e0:	74 13                	je     80547f5 <net_context_recv+0x9b>
		net_conn_unregister(context->conn_handler);
 80547e2:	83 ec 0c             	sub    $0xc,%esp
 80547e5:	50                   	push   %eax
 80547e6:	e8 5c 16 00 00       	call   8055e47 <net_conn_unregister>
		context->conn_handler = NULL;
 80547eb:	c7 43 44 00 00 00 00 	movl   $0x0,0x44(%ebx)
		net_conn_unregister(context->conn_handler);
 80547f2:	83 c4 10             	add    $0x10,%esp
	ret = bind_default(context);
 80547f5:	89 d8                	mov    %ebx,%eax
 80547f7:	e8 9d f6 ff ff       	call   8053e99 <bind_default>
 80547fc:	89 c6                	mov    %eax,%esi
	if (ret) {
 80547fe:	85 c0                	test   %eax,%eax
 8054800:	0f 85 b2 00 00 00    	jne    80548b8 <net_context_recv+0x15e>
 8054806:	8b 83 98 00 00 00    	mov    0x98(%ebx),%eax
 805480c:	66 89 45 b0          	mov    %ax,-0x50(%ebp)
 8054810:	66 c1 e8 03          	shr    $0x3,%ax
 8054814:	83 e0 07             	and    $0x7,%eax
 8054817:	66 89 45 b2          	mov    %ax,-0x4e(%ebp)
	if (IS_ENABLED(CONFIG_NET_IPV6) &&
 805481b:	66 83 f8 02          	cmp    $0x2,%ax
 805481f:	75 2b                	jne    805484c <net_context_recv+0xf2>
		if (net_sin6_ptr(&context->local)->sin6_addr) {
 8054821:	8b 73 24             	mov    0x24(%ebx),%esi
 8054824:	85 f6                	test   %esi,%esi
 8054826:	74 1a                	je     8054842 <net_context_recv+0xe8>
			net_ipaddr_copy(&net_sin6(&local_addr)->sin6_addr,
 8054828:	8d 7d bc             	lea    -0x44(%ebp),%edi
 805482b:	b9 04 00 00 00       	mov    $0x4,%ecx
 8054830:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
 8054832:	8d 7d d0             	lea    -0x30(%ebp),%edi
 8054835:	8d 75 bc             	lea    -0x44(%ebp),%esi
 8054838:	b9 04 00 00 00       	mov    $0x4,%ecx
 805483d:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
			laddr = &local_addr;
 805483f:	8d 75 cc             	lea    -0x34(%ebp),%esi
			net_sin6((struct sockaddr *)&context->local)->sin6_port;
 8054842:	66 8b 43 22          	mov    0x22(%ebx),%ax
		net_sin6(&local_addr)->sin6_port =
 8054846:	66 89 45 ce          	mov    %ax,-0x32(%ebp)
		lport = net_sin6((struct sockaddr *)&context->local)->sin6_port;
 805484a:	eb 20                	jmp    805486c <net_context_recv+0x112>
	} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
 805484c:	66 83 7d b2 01       	cmpw   $0x1,-0x4e(%ebp)
 8054851:	75 15                	jne    8054868 <net_context_recv+0x10e>
		if (net_sin_ptr(&context->local)->sin_addr) {
 8054853:	8b 73 24             	mov    0x24(%ebx),%esi
 8054856:	85 f6                	test   %esi,%esi
 8054858:	74 08                	je     8054862 <net_context_recv+0x108>
			net_ipaddr_copy(&net_sin(&local_addr)->sin_addr,
 805485a:	8b 06                	mov    (%esi),%eax
			laddr = &local_addr;
 805485c:	8d 75 cc             	lea    -0x34(%ebp),%esi
			net_ipaddr_copy(&net_sin(&local_addr)->sin_addr,
 805485f:	89 45 d0             	mov    %eax,-0x30(%ebp)
		lport = net_sin((struct sockaddr *)&context->local)->sin_port;
 8054862:	66 8b 43 22          	mov    0x22(%ebx),%ax
 8054866:	eb 04                	jmp    805486c <net_context_recv+0x112>
	uint16_t lport = 0U;
 8054868:	31 c0                	xor    %eax,%eax
	struct sockaddr *laddr = NULL;
 805486a:	31 f6                	xor    %esi,%esi
	ret = net_conn_register(net_context_get_proto(context),
 805486c:	86 e0                	xchg   %ah,%al
 805486e:	66 8b 53 2e          	mov    0x2e(%ebx),%dx
	context->recv_cb = cb;
 8054872:	8b 7d a4             	mov    -0x5c(%ebp),%edi
	ret = net_conn_register(net_context_get_proto(context),
 8054875:	31 c9                	xor    %ecx,%ecx
 8054877:	86 f2                	xchg   %dh,%dl
	context->recv_cb = cb;
 8054879:	89 7b 48             	mov    %edi,0x48(%ebx)
	ret = net_conn_register(net_context_get_proto(context),
 805487c:	8d 7b 44             	lea    0x44(%ebx),%edi
 805487f:	0f b7 c0             	movzwl %ax,%eax
 8054882:	0f b7 d2             	movzwl %dx,%edx
 8054885:	66 f7 45 b0 00 01    	testw  $0x100,-0x50(%ebp)
 805488b:	74 03                	je     8054890 <net_context_recv+0x136>
 805488d:	8d 4b 2c             	lea    0x2c(%ebx),%ecx
 8054890:	83 ec 08             	sub    $0x8,%esp
 8054893:	57                   	push   %edi
 8054894:	ff 75 a0             	push   -0x60(%ebp)
 8054897:	68 a4 38 05 08       	push   $0x80538a4
 805489c:	53                   	push   %ebx
 805489d:	50                   	push   %eax
 805489e:	0f b7 45 b2          	movzwl -0x4e(%ebp),%eax
 80548a2:	52                   	push   %edx
 80548a3:	56                   	push   %esi
 80548a4:	51                   	push   %ecx
 80548a5:	50                   	push   %eax
 80548a6:	0f b7 83 96 00 00 00 	movzwl 0x96(%ebx),%eax
 80548ad:	50                   	push   %eax
 80548ae:	e8 77 12 00 00       	call   8055b2a <net_conn_register>
 80548b3:	83 c4 30             	add    $0x30,%esp
 80548b6:	89 c6                	mov    %eax,%esi
		}
	}

	if (ret < 0) {
 80548b8:	85 f6                	test   %esi,%esi
 80548ba:	78 3e                	js     80548fa <net_context_recv+0x1a0>
		goto unlock;
	}

#if defined(CONFIG_NET_CONTEXT_SYNC_RECV)
	if (!K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
 80548bc:	8b 45 a8             	mov    -0x58(%ebp),%eax
 80548bf:	0b 45 ac             	or     -0x54(%ebp),%eax
 80548c2:	74 36                	je     80548fa <net_context_recv+0x1a0>

		/* Make sure we have the lock, then the
		 * net_context_packet_received() callback will release the
		 * semaphore when data has been received.
		 */
		k_sem_reset(&context->recv_data_wait);
 80548c4:	83 c3 54             	add    $0x54,%ebx
	z_impl_k_sem_reset(sem);
 80548c7:	83 ec 0c             	sub    $0xc,%esp
 80548ca:	53                   	push   %ebx
 80548cb:	e8 49 ae 00 00       	call   805f719 <z_impl_k_sem_reset>

		k_mutex_unlock(&context->lock);
 80548d0:	8b 45 b4             	mov    -0x4c(%ebp),%eax
 80548d3:	83 c4 10             	add    $0x10,%esp
 80548d6:	e8 b8 ef ff ff       	call   8053893 <k_mutex_unlock.isra.0>

		ret = k_sem_take(&context->recv_data_wait, timeout);
 80548db:	8b 45 ac             	mov    -0x54(%ebp),%eax
 80548de:	8b 55 a8             	mov    -0x58(%ebp),%edx
	return z_impl_k_sem_take(sem, timeout);
 80548e1:	51                   	push   %ecx
 80548e2:	52                   	push   %edx
 80548e3:	50                   	push   %eax
 80548e4:	53                   	push   %ebx
 80548e5:	e8 c8 ad 00 00       	call   805f6b2 <z_impl_k_sem_take>

		k_mutex_lock(&context->lock, K_FOREVER);
 80548ea:	83 ca ff             	or     $0xffffffff,%edx
 80548ed:	8b 45 b4             	mov    -0x4c(%ebp),%eax
 80548f0:	83 c4 10             	add    $0x10,%esp
 80548f3:	89 d1                	mov    %edx,%ecx
 80548f5:	e8 82 ef ff ff       	call   805387c <k_mutex_lock.constprop.0.isra.0>
		}
	}
#endif /* CONFIG_NET_CONTEXT_SYNC_RECV */

unlock:
	k_mutex_unlock(&context->lock);
 80548fa:	8b 45 b4             	mov    -0x4c(%ebp),%eax
 80548fd:	e8 91 ef ff ff       	call   8053893 <k_mutex_unlock.isra.0>

	return ret;
}
 8054902:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8054905:	65 2b 05 14 00 00 00 	sub    %gs:0x14,%eax
 805490c:	74 05                	je     8054913 <net_context_recv+0x1b9>
 805490e:	e8 ed 49 ff ff       	call   8049300 <__stack_chk_fail@plt>
 8054913:	8d 65 f4             	lea    -0xc(%ebp),%esp
 8054916:	89 f0                	mov    %esi,%eax
 8054918:	5b                   	pop    %ebx
 8054919:	5e                   	pop    %esi
 805491a:	5f                   	pop    %edi
 805491b:	5d                   	pop    %ebp
 805491c:	c3                   	ret    

0805491d <net_context_update_recv_wnd>:

int net_context_update_recv_wnd(struct net_context *context,
				int32_t delta)
{
 805491d:	55                   	push   %ebp
	if (IS_ENABLED(CONFIG_NET_OFFLOAD) &&
		net_if_is_ip_offloaded(net_context_get_iface(context))) {
		return 0;
	}

	k_mutex_lock(&context->lock, K_FOREVER);
 805491e:	83 ca ff             	or     $0xffffffff,%edx
 8054921:	89 d1                	mov    %edx,%ecx
{
 8054923:	89 e5                	mov    %esp,%ebp
 8054925:	83 ec 18             	sub    $0x18,%esp
	k_mutex_lock(&context->lock, K_FOREVER);
 8054928:	8b 45 08             	mov    0x8(%ebp),%eax
 805492b:	83 c0 0c             	add    $0xc,%eax
 805492e:	89 45 f4             	mov    %eax,-0xc(%ebp)
 8054931:	e8 46 ef ff ff       	call   805387c <k_mutex_lock.constprop.0.isra.0>

	ret = net_tcp_update_recv_wnd(context, delta);

	k_mutex_unlock(&context->lock);
 8054936:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8054939:	e8 55 ef ff ff       	call   8053893 <k_mutex_unlock.isra.0>

	return ret;
}
 805493e:	b8 a3 ff ff ff       	mov    $0xffffffa3,%eax
 8054943:	c9                   	leave  
 8054944:	c3                   	ret    

08054945 <net_context_set_option>:
}

int net_context_set_option(struct net_context *context,
			   enum net_context_option option,
			   const void *value, size_t len)
{
 8054945:	55                   	push   %ebp
 8054946:	89 e5                	mov    %esp,%ebp
 8054948:	57                   	push   %edi
 8054949:	56                   	push   %esi
 805494a:	53                   	push   %ebx
	int ret = 0;

	NET_ASSERT(context);

	if (!PART_OF_ARRAY(contexts, context)) {
		return -EINVAL;
 805494b:	bb ea ff ff ff       	mov    $0xffffffea,%ebx
{
 8054950:	83 ec 1c             	sub    $0x1c,%esp
 8054953:	8b 75 08             	mov    0x8(%ebp),%esi
 8054956:	8b 7d 0c             	mov    0xc(%ebp),%edi
	if (!PART_OF_ARRAY(contexts, context)) {
 8054959:	85 f6                	test   %esi,%esi
 805495b:	74 5d                	je     80549ba <net_context_set_option+0x75>
 805495d:	81 fe a0 7e 06 08    	cmp    $0x8067ea0,%esi
 8054963:	72 55                	jb     80549ba <net_context_set_option+0x75>
 8054965:	81 fe 48 82 06 08    	cmp    $0x8068248,%esi
 805496b:	73 4d                	jae    80549ba <net_context_set_option+0x75>
	}

	k_mutex_lock(&context->lock, K_FOREVER);
 805496d:	83 ca ff             	or     $0xffffffff,%edx
 8054970:	8d 46 0c             	lea    0xc(%esi),%eax
 8054973:	89 d1                	mov    %edx,%ecx
 8054975:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 8054978:	e8 ff ee ff ff       	call   805387c <k_mutex_lock.constprop.0.isra.0>

	switch (option) {
 805497d:	83 ff 07             	cmp    $0x7,%edi
 8054980:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8054983:	77 09                	ja     805498e <net_context_set_option+0x49>
 8054985:	f7 df                	neg    %edi
 8054987:	19 db                	sbb    %ebx,%ebx
 8054989:	83 e3 a1             	and    $0xffffffa1,%ebx
 805498c:	eb 27                	jmp    80549b5 <net_context_set_option+0x70>
	int ret = 0;
 805498e:	31 db                	xor    %ebx,%ebx
	switch (option) {
 8054990:	83 ff 08             	cmp    $0x8,%edi
 8054993:	75 20                	jne    80549b5 <net_context_set_option+0x70>
	int dscp_ecn = *((int *)value);
 8054995:	8b 55 10             	mov    0x10(%ebp),%edx
	if (len != sizeof(int)) {
 8054998:	83 7d 14 04          	cmpl   $0x4,0x14(%ebp)
		return -EINVAL;
 805499c:	bb ea ff ff ff       	mov    $0xffffffea,%ebx
	int dscp_ecn = *((int *)value);
 80549a1:	8b 12                	mov    (%edx),%edx
	if (len != sizeof(int)) {
 80549a3:	75 10                	jne    80549b5 <net_context_set_option+0x70>
	if ((dscp_ecn < 0) || (dscp_ecn > UINT8_MAX)) {
 80549a5:	81 fa ff 00 00 00    	cmp    $0xff,%edx
 80549ab:	77 08                	ja     80549b5 <net_context_set_option+0x70>
	context->options.dscp_ecn = (uint8_t)dscp_ecn;
 80549ad:	88 96 94 00 00 00    	mov    %dl,0x94(%esi)
	return 0;
 80549b3:	31 db                	xor    %ebx,%ebx
	case NET_OPT_DSCP_ECN:
		ret = set_context_dscp_ecn(context, value, len);
		break;
	}

	k_mutex_unlock(&context->lock);
 80549b5:	e8 d9 ee ff ff       	call   8053893 <k_mutex_unlock.isra.0>

	return ret;
}
 80549ba:	83 c4 1c             	add    $0x1c,%esp
 80549bd:	89 d8                	mov    %ebx,%eax
 80549bf:	5b                   	pop    %ebx
 80549c0:	5e                   	pop    %esi
 80549c1:	5f                   	pop    %edi
 80549c2:	5d                   	pop    %ebp
 80549c3:	c3                   	ret    

080549c4 <net_context_get_option>:

int net_context_get_option(struct net_context *context,
			    enum net_context_option option,
			    void *value, size_t *len)
{
 80549c4:	55                   	push   %ebp
 80549c5:	89 e5                	mov    %esp,%ebp
 80549c7:	57                   	push   %edi
	int ret = 0;

	NET_ASSERT(context);

	if (!PART_OF_ARRAY(contexts, context)) {
		return -EINVAL;
 80549c8:	bf ea ff ff ff       	mov    $0xffffffea,%edi
{
 80549cd:	56                   	push   %esi
 80549ce:	53                   	push   %ebx
 80549cf:	83 ec 1c             	sub    $0x1c,%esp
 80549d2:	8b 5d 08             	mov    0x8(%ebp),%ebx
 80549d5:	8b 75 0c             	mov    0xc(%ebp),%esi
	if (!PART_OF_ARRAY(contexts, context)) {
 80549d8:	85 db                	test   %ebx,%ebx
 80549da:	74 58                	je     8054a34 <net_context_get_option+0x70>
 80549dc:	81 fb a0 7e 06 08    	cmp    $0x8067ea0,%ebx
 80549e2:	72 50                	jb     8054a34 <net_context_get_option+0x70>
 80549e4:	81 fb 48 82 06 08    	cmp    $0x8068248,%ebx
 80549ea:	73 48                	jae    8054a34 <net_context_get_option+0x70>
	}

	k_mutex_lock(&context->lock, K_FOREVER);
 80549ec:	83 ca ff             	or     $0xffffffff,%edx
 80549ef:	8d 43 0c             	lea    0xc(%ebx),%eax
 80549f2:	89 d1                	mov    %edx,%ecx
 80549f4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 80549f7:	e8 80 ee ff ff       	call   805387c <k_mutex_lock.constprop.0.isra.0>

	switch (option) {
 80549fc:	83 fe 07             	cmp    $0x7,%esi
 80549ff:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8054a02:	77 09                	ja     8054a0d <net_context_get_option+0x49>
 8054a04:	f7 de                	neg    %esi
 8054a06:	19 ff                	sbb    %edi,%edi
 8054a08:	83 e7 a1             	and    $0xffffffa1,%edi
 8054a0b:	eb 22                	jmp    8054a2f <net_context_get_option+0x6b>
	int ret = 0;
 8054a0d:	31 ff                	xor    %edi,%edi
	switch (option) {
 8054a0f:	83 fe 08             	cmp    $0x8,%esi
 8054a12:	75 1b                	jne    8054a2f <net_context_get_option+0x6b>
	*((int *)value) = context->options.dscp_ecn;
 8054a14:	0f b6 8b 94 00 00 00 	movzbl 0x94(%ebx),%ecx
 8054a1b:	8b 55 10             	mov    0x10(%ebp),%edx
	if (len) {
 8054a1e:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
	*((int *)value) = context->options.dscp_ecn;
 8054a22:	89 0a                	mov    %ecx,(%edx)
	if (len) {
 8054a24:	74 09                	je     8054a2f <net_context_get_option+0x6b>
		*len = sizeof(int);
 8054a26:	8b 4d 14             	mov    0x14(%ebp),%ecx
 8054a29:	c7 01 04 00 00 00    	movl   $0x4,(%ecx)
	case NET_OPT_DSCP_ECN:
		ret = get_context_dscp_ecn(context, value, len);
		break;
	}

	k_mutex_unlock(&context->lock);
 8054a2f:	e8 5f ee ff ff       	call   8053893 <k_mutex_unlock.isra.0>

	return ret;
}
 8054a34:	83 c4 1c             	add    $0x1c,%esp
 8054a37:	89 f8                	mov    %edi,%eax
 8054a39:	5b                   	pop    %ebx
 8054a3a:	5e                   	pop    %esi
 8054a3b:	5f                   	pop    %edi
 8054a3c:	5d                   	pop    %ebp
 8054a3d:	c3                   	ret    

08054a3e <net_context_init>:

	return NULL;
}

void net_context_init(void)
{
 8054a3e:	55                   	push   %ebp
 8054a3f:	89 e5                	mov    %esp,%ebp
 8054a41:	83 ec 0c             	sub    $0xc,%esp
	return z_impl_k_sem_init(sem, initial_count, limit);
 8054a44:	6a ff                	push   $0xffffffff
 8054a46:	6a 01                	push   $0x1
 8054a48:	68 ec 89 06 08       	push   $0x80689ec
 8054a4d:	e8 c5 ab 00 00       	call   805f617 <z_impl_k_sem_init>
 8054a52:	83 c4 10             	add    $0x10,%esp
	k_sem_init(&contexts_lock, 1, K_SEM_MAX_LIMIT);
}
 8054a55:	c9                   	leave  
 8054a56:	c3                   	ret    

08054a57 <pkt_cursor_jump>:
		pkt->cursor.pos = NULL;
	}
}

static void pkt_cursor_jump(struct net_pkt *pkt, bool write)
{
 8054a57:	55                   	push   %ebp
 8054a58:	89 e5                	mov    %esp,%ebp
 8054a5a:	56                   	push   %esi
 8054a5b:	89 d6                	mov    %edx,%esi
 8054a5d:	53                   	push   %ebx
 8054a5e:	89 c3                	mov    %eax,%ebx
	struct net_pkt_cursor *cursor = &pkt->cursor;

	cursor->buf = cursor->buf->frags;
 8054a60:	8b 40 0c             	mov    0xc(%eax),%eax
 8054a63:	8b 40 04             	mov    0x4(%eax),%eax
 8054a66:	89 43 0c             	mov    %eax,0xc(%ebx)
	while (cursor->buf) {
 8054a69:	85 c0                	test   %eax,%eax
 8054a6b:	74 25                	je     8054a92 <pkt_cursor_jump+0x3b>
		const size_t len =
			write ? net_buf_max_len(cursor->buf) : cursor->buf->len;
 8054a6d:	89 f1                	mov    %esi,%ecx
 8054a6f:	84 c9                	test   %cl,%cl
 8054a71:	74 14                	je     8054a87 <pkt_cursor_jump+0x30>
	return net_buf_simple_max_len(&buf->b);
 8054a73:	83 ec 0c             	sub    $0xc,%esp
 8054a76:	83 c0 0c             	add    $0xc,%eax
 8054a79:	50                   	push   %eax
 8054a7a:	e8 1e a8 ff ff       	call   804f29d <net_buf_simple_max_len>
 8054a7f:	83 c4 10             	add    $0x10,%esp
 8054a82:	0f b7 c0             	movzwl %ax,%eax
 8054a85:	eb 04                	jmp    8054a8b <pkt_cursor_jump+0x34>
 8054a87:	0f b7 40 10          	movzwl 0x10(%eax),%eax

		if (!len) {
			cursor->buf = cursor->buf->frags;
 8054a8b:	8b 53 0c             	mov    0xc(%ebx),%edx
		if (!len) {
 8054a8e:	85 c0                	test   %eax,%eax
 8054a90:	74 0c                	je     8054a9e <pkt_cursor_jump+0x47>
		} else {
			break;
		}
	}

	if (cursor->buf) {
 8054a92:	8b 43 0c             	mov    0xc(%ebx),%eax
 8054a95:	85 c0                	test   %eax,%eax
 8054a97:	74 0a                	je     8054aa3 <pkt_cursor_jump+0x4c>
		cursor->pos = cursor->buf->data;
 8054a99:	8b 40 0c             	mov    0xc(%eax),%eax
 8054a9c:	eb 05                	jmp    8054aa3 <pkt_cursor_jump+0x4c>
			cursor->buf = cursor->buf->frags;
 8054a9e:	8b 42 04             	mov    0x4(%edx),%eax
 8054aa1:	eb c3                	jmp    8054a66 <pkt_cursor_jump+0xf>
 8054aa3:	89 43 10             	mov    %eax,0x10(%ebx)
	} else {
		cursor->pos = NULL;
	}
}
 8054aa6:	8d 65 f8             	lea    -0x8(%ebp),%esp
 8054aa9:	5b                   	pop    %ebx
 8054aaa:	5e                   	pop    %esi
 8054aab:	5d                   	pop    %ebp
 8054aac:	c3                   	ret    

08054aad <pkt_cursor_advance>:

static void pkt_cursor_advance(struct net_pkt *pkt, bool write)
{
 8054aad:	55                   	push   %ebp
 8054aae:	89 e5                	mov    %esp,%ebp
 8054ab0:	56                   	push   %esi
 8054ab1:	53                   	push   %ebx
 8054ab2:	89 c3                	mov    %eax,%ebx
 8054ab4:	83 ec 10             	sub    $0x10,%esp
	struct net_pkt_cursor *cursor = &pkt->cursor;
	size_t len;

	if (!cursor->buf) {
 8054ab7:	8b 40 0c             	mov    0xc(%eax),%eax
 8054aba:	85 c0                	test   %eax,%eax
 8054abc:	74 3f                	je     8054afd <pkt_cursor_advance+0x50>
		return;
	}

	len = write ? net_buf_max_len(cursor->buf) : cursor->buf->len;
 8054abe:	84 d2                	test   %dl,%dl
 8054ac0:	74 1a                	je     8054adc <pkt_cursor_advance+0x2f>
 8054ac2:	83 ec 0c             	sub    $0xc,%esp
 8054ac5:	83 c0 0c             	add    $0xc,%eax
 8054ac8:	89 55 f4             	mov    %edx,-0xc(%ebp)
 8054acb:	50                   	push   %eax
 8054acc:	e8 cc a7 ff ff       	call   804f29d <net_buf_simple_max_len>
 8054ad1:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8054ad4:	83 c4 10             	add    $0x10,%esp
 8054ad7:	0f b7 c0             	movzwl %ax,%eax
 8054ada:	eb 04                	jmp    8054ae0 <pkt_cursor_advance+0x33>
 8054adc:	0f b7 40 10          	movzwl 0x10(%eax),%eax
	if ((cursor->pos - cursor->buf->data) == len) {
 8054ae0:	8b 73 0c             	mov    0xc(%ebx),%esi
 8054ae3:	8b 4b 10             	mov    0x10(%ebx),%ecx
 8054ae6:	2b 4e 0c             	sub    0xc(%esi),%ecx
 8054ae9:	39 c1                	cmp    %eax,%ecx
 8054aeb:	75 10                	jne    8054afd <pkt_cursor_advance+0x50>
		pkt_cursor_jump(pkt, write);
	}
}
 8054aed:	8d 65 f8             	lea    -0x8(%ebp),%esp
		pkt_cursor_jump(pkt, write);
 8054af0:	89 d8                	mov    %ebx,%eax
 8054af2:	0f b6 d2             	movzbl %dl,%edx
}
 8054af5:	5b                   	pop    %ebx
 8054af6:	5e                   	pop    %esi
 8054af7:	5d                   	pop    %ebp
		pkt_cursor_jump(pkt, write);
 8054af8:	e9 5a ff ff ff       	jmp    8054a57 <pkt_cursor_jump>
}
 8054afd:	8d 65 f8             	lea    -0x8(%ebp),%esp
 8054b00:	5b                   	pop    %ebx
 8054b01:	5e                   	pop    %esi
 8054b02:	5d                   	pop    %ebp
 8054b03:	c3                   	ret    

08054b04 <pkt_cursor_update>:

static void pkt_cursor_update(struct net_pkt *pkt,
			      size_t length, bool write)
{
 8054b04:	55                   	push   %ebp
 8054b05:	89 e5                	mov    %esp,%ebp
 8054b07:	57                   	push   %edi
 8054b08:	89 d7                	mov    %edx,%edi
 8054b0a:	56                   	push   %esi
 8054b0b:	89 c6                	mov    %eax,%esi
 8054b0d:	53                   	push   %ebx
 8054b0e:	83 ec 1c             	sub    $0x1c,%esp
	return pkt->overwrite;
 8054b11:	8a 58 33             	mov    0x33(%eax),%bl

	if (net_pkt_is_being_overwritten(pkt)) {
		write = false;
	}

	len = write ? net_buf_max_len(cursor->buf) : cursor->buf->len;
 8054b14:	8b 40 0c             	mov    0xc(%eax),%eax
 8054b17:	83 e3 01             	and    $0x1,%ebx
	if (net_pkt_is_being_overwritten(pkt)) {
 8054b1a:	83 f3 01             	xor    $0x1,%ebx
	len = write ? net_buf_max_len(cursor->buf) : cursor->buf->len;
 8054b1d:	20 cb                	and    %cl,%bl
 8054b1f:	74 14                	je     8054b35 <pkt_cursor_update+0x31>
 8054b21:	83 ec 0c             	sub    $0xc,%esp
 8054b24:	83 c0 0c             	add    $0xc,%eax
 8054b27:	50                   	push   %eax
 8054b28:	e8 70 a7 ff ff       	call   804f29d <net_buf_simple_max_len>
 8054b2d:	83 c4 10             	add    $0x10,%esp
 8054b30:	0f b7 d0             	movzwl %ax,%edx
 8054b33:	eb 04                	jmp    8054b39 <pkt_cursor_update+0x35>
 8054b35:	0f b7 50 10          	movzwl 0x10(%eax),%edx
	if (length + (cursor->pos - cursor->buf->data) == len &&
 8054b39:	8b 4e 0c             	mov    0xc(%esi),%ecx
 8054b3c:	8b 46 10             	mov    0x10(%esi),%eax
 8054b3f:	2b 41 0c             	sub    0xc(%ecx),%eax
 8054b42:	01 f8                	add    %edi,%eax
 8054b44:	39 d0                	cmp    %edx,%eax
 8054b46:	75 33                	jne    8054b7b <pkt_cursor_update+0x77>
 8054b48:	f6 46 33 01          	testb  $0x1,0x33(%esi)
 8054b4c:	75 11                	jne    8054b5f <pkt_cursor_update+0x5b>
	      len < net_buf_max_len(cursor->buf))) {
		pkt_cursor_jump(pkt, write);
	} else {
		cursor->pos += length;
	}
}
 8054b4e:	8d 65 f4             	lea    -0xc(%ebp),%esp
		pkt_cursor_jump(pkt, write);
 8054b51:	0f b6 d3             	movzbl %bl,%edx
 8054b54:	89 f0                	mov    %esi,%eax
}
 8054b56:	5b                   	pop    %ebx
 8054b57:	5e                   	pop    %esi
 8054b58:	5f                   	pop    %edi
 8054b59:	5d                   	pop    %ebp
		pkt_cursor_jump(pkt, write);
 8054b5a:	e9 f8 fe ff ff       	jmp    8054a57 <pkt_cursor_jump>
 8054b5f:	83 ec 0c             	sub    $0xc,%esp
 8054b62:	83 c1 0c             	add    $0xc,%ecx
 8054b65:	89 55 e4             	mov    %edx,-0x1c(%ebp)
 8054b68:	51                   	push   %ecx
 8054b69:	e8 2f a7 ff ff       	call   804f29d <net_buf_simple_max_len>
	    !(net_pkt_is_being_overwritten(pkt) &&
 8054b6e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 8054b71:	83 c4 10             	add    $0x10,%esp
	      len < net_buf_max_len(cursor->buf))) {
 8054b74:	0f b7 c0             	movzwl %ax,%eax
	    !(net_pkt_is_being_overwritten(pkt) &&
 8054b77:	39 d0                	cmp    %edx,%eax
 8054b79:	76 d3                	jbe    8054b4e <pkt_cursor_update+0x4a>
		cursor->pos += length;
 8054b7b:	01 7e 10             	add    %edi,0x10(%esi)
}
 8054b7e:	8d 65 f4             	lea    -0xc(%ebp),%esp
 8054b81:	5b                   	pop    %ebx
 8054b82:	5e                   	pop    %esi
 8054b83:	5f                   	pop    %edi
 8054b84:	5d                   	pop    %ebp
 8054b85:	c3                   	ret    

08054b86 <pkt_estimate_headers_length.part.0>:
static size_t pkt_estimate_headers_length(struct net_pkt *pkt,
 8054b86:	89 c1                	mov    %eax,%ecx
		hdr_len += NET_IPV6H_LEN;
 8054b88:	b8 28 00 00 00       	mov    $0x28,%eax
	if (IS_ENABLED(CONFIG_NET_IPV6) && family == AF_INET6) {
 8054b8d:	66 83 f9 02          	cmp    $0x2,%cx
 8054b91:	74 0c                	je     8054b9f <pkt_estimate_headers_length.part.0+0x19>
		hdr_len += NET_IPV4H_LEN;
 8054b93:	31 c0                	xor    %eax,%eax
 8054b95:	66 49                	dec    %cx
 8054b97:	b9 14 00 00 00       	mov    $0x14,%ecx
 8054b9c:	0f 44 c1             	cmove  %ecx,%eax
	} else if (IS_ENABLED(CONFIG_NET_UDP) && proto == IPPROTO_UDP) {
 8054b9f:	83 fa 11             	cmp    $0x11,%edx
 8054ba2:	75 04                	jne    8054ba8 <pkt_estimate_headers_length.part.0+0x22>
		hdr_len += NET_UDPH_LEN;
 8054ba4:	83 c0 08             	add    $0x8,%eax
 8054ba7:	c3                   	ret    
	} else if (proto == IPPROTO_ICMP || proto == IPPROTO_ICMPV6) {
 8054ba8:	83 fa 01             	cmp    $0x1,%edx
 8054bab:	74 05                	je     8054bb2 <pkt_estimate_headers_length.part.0+0x2c>
 8054bad:	83 fa 3a             	cmp    $0x3a,%edx
 8054bb0:	75 03                	jne    8054bb5 <pkt_estimate_headers_length.part.0+0x2f>
		hdr_len += NET_ICMPH_LEN;
 8054bb2:	83 c0 04             	add    $0x4,%eax
}
 8054bb5:	c3                   	ret    

08054bb6 <net_pkt_get_len.isra.0>:
	size_t bytes = 0;
 8054bb6:	31 d2                	xor    %edx,%edx
	while (buf) {
 8054bb8:	85 c0                	test   %eax,%eax
 8054bba:	74 0b                	je     8054bc7 <net_pkt_get_len.isra.0+0x11>
		bytes += buf->len;
 8054bbc:	0f b7 48 10          	movzwl 0x10(%eax),%ecx
		buf = buf->frags;
 8054bc0:	8b 40 04             	mov    0x4(%eax),%eax
		bytes += buf->len;
 8054bc3:	01 ca                	add    %ecx,%edx
		buf = buf->frags;
 8054bc5:	eb f1                	jmp    8054bb8 <net_pkt_get_len.isra.0+0x2>
}
 8054bc7:	89 d0                	mov    %edx,%eax
 8054bc9:	c3                   	ret    

08054bca <net_pkt_cursor_operate>:

/* Internal function that does all operation (skip/read/write/memset) */
static int net_pkt_cursor_operate(struct net_pkt *pkt,
				  void *data, size_t length,
				  bool copy, bool write)
{
 8054bca:	55                   	push   %ebp
 8054bcb:	89 e5                	mov    %esp,%ebp
 8054bcd:	57                   	push   %edi
 8054bce:	56                   	push   %esi
 8054bcf:	53                   	push   %ebx
 8054bd0:	89 c3                	mov    %eax,%ebx
 8054bd2:	83 ec 2c             	sub    $0x2c,%esp
 8054bd5:	8a 45 08             	mov    0x8(%ebp),%al
 8054bd8:	89 55 e4             	mov    %edx,-0x1c(%ebp)
 8054bdb:	89 4d e0             	mov    %ecx,-0x20(%ebp)
 8054bde:	88 45 de             	mov    %al,-0x22(%ebp)
 8054be1:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
 8054be5:	88 45 df             	mov    %al,-0x21(%ebp)

		if (write && !net_pkt_is_being_overwritten(pkt)) {
			net_buf_add(c_op->buf, len);
		}

		pkt_cursor_update(pkt, len, write);
 8054be8:	89 45 d8             	mov    %eax,-0x28(%ebp)
	while (c_op->buf && length) {
 8054beb:	83 7b 0c 00          	cmpl   $0x0,0xc(%ebx)
 8054bef:	0f 84 ef 00 00 00    	je     8054ce4 <net_pkt_cursor_operate+0x11a>
 8054bf5:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
 8054bf9:	0f 84 ef 00 00 00    	je     8054cee <net_pkt_cursor_operate+0x124>
	return pkt->overwrite;
 8054bff:	8a 53 33             	mov    0x33(%ebx),%dl
		pkt_cursor_advance(pkt, net_pkt_is_being_overwritten(pkt) ?
 8054c02:	89 d8                	mov    %ebx,%eax
 8054c04:	83 e2 01             	and    $0x1,%edx
				   false : write);
 8054c07:	83 f2 01             	xor    $0x1,%edx
 8054c0a:	22 55 df             	and    -0x21(%ebp),%dl
		pkt_cursor_advance(pkt, net_pkt_is_being_overwritten(pkt) ?
 8054c0d:	0f b6 d2             	movzbl %dl,%edx
 8054c10:	e8 98 fe ff ff       	call   8054aad <pkt_cursor_advance>
		if (c_op->buf == NULL) {
 8054c15:	8b 43 0c             	mov    0xc(%ebx),%eax
 8054c18:	85 c0                	test   %eax,%eax
 8054c1a:	75 0a                	jne    8054c26 <net_pkt_cursor_operate+0x5c>
		length -= len;
	}

	if (length) {
		NET_DBG("Still some length to go %zu", length);
		return -ENOBUFS;
 8054c1c:	b8 97 ff ff ff       	mov    $0xffffff97,%eax
 8054c21:	e9 ca 00 00 00       	jmp    8054cf0 <net_pkt_cursor_operate+0x126>
		if (write && !net_pkt_is_being_overwritten(pkt)) {
 8054c26:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
 8054c2a:	74 23                	je     8054c4f <net_pkt_cursor_operate+0x85>
 8054c2c:	f6 43 33 01          	testb  $0x1,0x33(%ebx)
 8054c30:	75 1d                	jne    8054c4f <net_pkt_cursor_operate+0x85>
	return net_buf_simple_max_len(&buf->b);
 8054c32:	83 ec 0c             	sub    $0xc,%esp
 8054c35:	83 c0 0c             	add    $0xc,%eax
 8054c38:	50                   	push   %eax
 8054c39:	e8 5f a6 ff ff       	call   804f29d <net_buf_simple_max_len>
				(c_op->pos - c_op->buf->data);
 8054c3e:	8b 4b 0c             	mov    0xc(%ebx),%ecx
 8054c41:	83 c4 10             	add    $0x10,%esp
			d_len = net_buf_max_len(c_op->buf) -
 8054c44:	0f b7 d0             	movzwl %ax,%edx
				(c_op->pos - c_op->buf->data);
 8054c47:	8b 43 10             	mov    0x10(%ebx),%eax
 8054c4a:	2b 41 0c             	sub    0xc(%ecx),%eax
 8054c4d:	eb 0c                	jmp    8054c5b <net_pkt_cursor_operate+0x91>
			d_len = c_op->buf->len - (c_op->pos - c_op->buf->data);
 8054c4f:	8b 4b 10             	mov    0x10(%ebx),%ecx
 8054c52:	2b 48 0c             	sub    0xc(%eax),%ecx
 8054c55:	0f b7 50 10          	movzwl 0x10(%eax),%edx
 8054c59:	89 c8                	mov    %ecx,%eax
 8054c5b:	29 c2                	sub    %eax,%edx
		if (!d_len) {
 8054c5d:	85 d2                	test   %edx,%edx
 8054c5f:	74 bb                	je     8054c1c <net_pkt_cursor_operate+0x52>
		if (length < d_len) {
 8054c61:	3b 55 e0             	cmp    -0x20(%ebp),%edx
 8054c64:	0f 47 55 e0          	cmova  -0x20(%ebp),%edx
		if (copy) {
 8054c68:	80 7d de 00          	cmpb   $0x0,-0x22(%ebp)
 8054c6c:	74 19                	je     8054c87 <net_pkt_cursor_operate+0xbd>
			memcpy(write ? c_op->pos : data,
 8054c6e:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
 8054c72:	8b 73 10             	mov    0x10(%ebx),%esi
 8054c75:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8054c78:	74 05                	je     8054c7f <net_pkt_cursor_operate+0xb5>
 8054c7a:	89 f0                	mov    %esi,%eax
 8054c7c:	8b 75 e4             	mov    -0x1c(%ebp),%esi
 8054c7f:	89 c7                	mov    %eax,%edi
 8054c81:	89 d1                	mov    %edx,%ecx
 8054c83:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
 8054c85:	eb 12                	jmp    8054c99 <net_pkt_cursor_operate+0xcf>
		} else if (data) {
 8054c87:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
 8054c8b:	74 0c                	je     8054c99 <net_pkt_cursor_operate+0xcf>
  return __builtin___memset_chk (__dest, __ch, __len,
 8054c8d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8054c90:	8b 7b 10             	mov    0x10(%ebx),%edi
 8054c93:	89 d1                	mov    %edx,%ecx
 8054c95:	8a 00                	mov    (%eax),%al
 8054c97:	f3 aa                	rep stos %al,%es:(%edi)
		if (write && !net_pkt_is_being_overwritten(pkt)) {
 8054c99:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
 8054c9d:	74 1e                	je     8054cbd <net_pkt_cursor_operate+0xf3>
 8054c9f:	f6 43 33 01          	testb  $0x1,0x33(%ebx)
 8054ca3:	75 18                	jne    8054cbd <net_pkt_cursor_operate+0xf3>
	return net_buf_simple_add(&buf->b, len);
 8054ca5:	50                   	push   %eax
 8054ca6:	50                   	push   %eax
 8054ca7:	8b 43 0c             	mov    0xc(%ebx),%eax
 8054caa:	52                   	push   %edx
 8054cab:	83 c0 0c             	add    $0xc,%eax
 8054cae:	89 55 d4             	mov    %edx,-0x2c(%ebp)
 8054cb1:	50                   	push   %eax
 8054cb2:	e8 86 a5 ff ff       	call   804f23d <net_buf_simple_add>
 8054cb7:	8b 55 d4             	mov    -0x2c(%ebp),%edx
 8054cba:	83 c4 10             	add    $0x10,%esp
		pkt_cursor_update(pkt, len, write);
 8054cbd:	8b 4d d8             	mov    -0x28(%ebp),%ecx
 8054cc0:	89 d8                	mov    %ebx,%eax
 8054cc2:	89 55 d4             	mov    %edx,-0x2c(%ebp)
 8054cc5:	e8 3a fe ff ff       	call   8054b04 <pkt_cursor_update>
		if (copy && data) {
 8054cca:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
 8054cce:	8b 55 d4             	mov    -0x2c(%ebp),%edx
 8054cd1:	74 09                	je     8054cdc <net_pkt_cursor_operate+0x112>
 8054cd3:	80 7d de 00          	cmpb   $0x0,-0x22(%ebp)
 8054cd7:	74 03                	je     8054cdc <net_pkt_cursor_operate+0x112>
			data = (uint8_t *) data + len;
 8054cd9:	01 55 e4             	add    %edx,-0x1c(%ebp)
		length -= len;
 8054cdc:	29 55 e0             	sub    %edx,-0x20(%ebp)
 8054cdf:	e9 07 ff ff ff       	jmp    8054beb <net_pkt_cursor_operate+0x21>
	if (length) {
 8054ce4:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
 8054ce8:	0f 85 2e ff ff ff    	jne    8054c1c <net_pkt_cursor_operate+0x52>
	}

	return 0;
 8054cee:	31 c0                	xor    %eax,%eax
}
 8054cf0:	8d 65 f4             	lea    -0xc(%ebp),%esp
 8054cf3:	5b                   	pop    %ebx
 8054cf4:	5e                   	pop    %esi
 8054cf5:	5f                   	pop    %edi
 8054cf6:	5d                   	pop    %ebp
 8054cf7:	c3                   	ret    

08054cf8 <net_pkt_get_reserve_data>:
{
 8054cf8:	55                   	push   %ebp
 8054cf9:	89 e5                	mov    %esp,%ebp
 8054cfb:	57                   	push   %edi
 8054cfc:	56                   	push   %esi
 8054cfd:	53                   	push   %ebx
 8054cfe:	83 ec 1c             	sub    $0x1c,%esp
 8054d01:	8b 45 0c             	mov    0xc(%ebp),%eax
 8054d04:	8b 5d 08             	mov    0x8(%ebp),%ebx
 8054d07:	8b 75 10             	mov    0x10(%ebp),%esi
 8054d0a:	8b 7d 14             	mov    0x14(%ebp),%edi
 8054d0d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (k_is_in_isr()) {
 8054d10:	e8 7d a2 00 00       	call   805ef92 <k_is_in_isr>
 8054d15:	84 c0                	test   %al,%al
 8054d17:	74 04                	je     8054d1d <net_pkt_get_reserve_data+0x25>
		timeout = K_NO_WAIT;
 8054d19:	31 f6                	xor    %esi,%esi
 8054d1b:	31 ff                	xor    %edi,%edi
	if (min_len > CONFIG_NET_BUF_DATA_SIZE) {
 8054d1d:	81 7d e4 80 00 00 00 	cmpl   $0x80,-0x1c(%ebp)
 8054d24:	77 15                	ja     8054d3b <net_pkt_get_reserve_data+0x43>
	return net_buf_alloc_fixed(pool, timeout);
 8054d26:	89 75 0c             	mov    %esi,0xc(%ebp)
 8054d29:	89 7d 10             	mov    %edi,0x10(%ebp)
 8054d2c:	89 5d 08             	mov    %ebx,0x8(%ebp)
}
 8054d2f:	83 c4 1c             	add    $0x1c,%esp
 8054d32:	5b                   	pop    %ebx
 8054d33:	5e                   	pop    %esi
 8054d34:	5f                   	pop    %edi
 8054d35:	5d                   	pop    %ebp
 8054d36:	e9 25 a4 ff ff       	jmp    804f160 <net_buf_alloc_fixed>
 8054d3b:	83 c4 1c             	add    $0x1c,%esp
 8054d3e:	31 c0                	xor    %eax,%eax
 8054d40:	5b                   	pop    %ebx
 8054d41:	5e                   	pop    %esi
 8054d42:	5f                   	pop    %edi
 8054d43:	5d                   	pop    %ebp
 8054d44:	c3                   	ret    

08054d45 <net_pkt_get_reserve_rx_data>:
{
 8054d45:	55                   	push   %ebp
 8054d46:	89 e5                	mov    %esp,%ebp
 8054d48:	83 ec 08             	sub    $0x8,%esp
	return net_pkt_get_reserve_data(&rx_bufs, min_len, timeout);
 8054d4b:	ff 75 10             	push   0x10(%ebp)
 8054d4e:	ff 75 0c             	push   0xc(%ebp)
 8054d51:	ff 75 08             	push   0x8(%ebp)
 8054d54:	68 58 76 06 08       	push   $0x8067658
 8054d59:	e8 9a ff ff ff       	call   8054cf8 <net_pkt_get_reserve_data>
 8054d5e:	83 c4 10             	add    $0x10,%esp
}
 8054d61:	c9                   	leave  
 8054d62:	c3                   	ret    

08054d63 <net_pkt_get_reserve_tx_data>:
{
 8054d63:	55                   	push   %ebp
 8054d64:	89 e5                	mov    %esp,%ebp
 8054d66:	83 ec 08             	sub    $0x8,%esp
	return net_pkt_get_reserve_data(&tx_bufs, min_len, timeout);
 8054d69:	ff 75 10             	push   0x10(%ebp)
 8054d6c:	ff 75 0c             	push   0xc(%ebp)
 8054d6f:	ff 75 08             	push   0x8(%ebp)
 8054d72:	68 84 76 06 08       	push   $0x8067684
 8054d77:	e8 7c ff ff ff       	call   8054cf8 <net_pkt_get_reserve_data>
 8054d7c:	83 c4 10             	add    $0x10,%esp
}
 8054d7f:	c9                   	leave  
 8054d80:	c3                   	ret    

08054d81 <net_pkt_get_frag>:
{
 8054d81:	55                   	push   %ebp
 8054d82:	89 e5                	mov    %esp,%ebp
 8054d84:	53                   	push   %ebx
	if (pkt->slab == &rx_pkts) {
 8054d85:	8b 55 08             	mov    0x8(%ebp),%edx
{
 8054d88:	8b 45 0c             	mov    0xc(%ebp),%eax
 8054d8b:	8b 4d 10             	mov    0x10(%ebp),%ecx
 8054d8e:	8b 5d 14             	mov    0x14(%ebp),%ebx
	if (pkt->slab == &rx_pkts) {
 8054d91:	81 7a 04 4c 75 06 08 	cmpl   $0x806754c,0x4(%edx)
		return net_pkt_get_reserve_rx_data(min_len, timeout);
 8054d98:	89 45 08             	mov    %eax,0x8(%ebp)
 8054d9b:	89 4d 0c             	mov    %ecx,0xc(%ebp)
 8054d9e:	89 5d 10             	mov    %ebx,0x10(%ebp)
	if (pkt->slab == &rx_pkts) {
 8054da1:	75 07                	jne    8054daa <net_pkt_get_frag+0x29>
}
 8054da3:	5b                   	pop    %ebx
 8054da4:	5d                   	pop    %ebp
		return net_pkt_get_reserve_rx_data(min_len, timeout);
 8054da5:	e9 9b ff ff ff       	jmp    8054d45 <net_pkt_get_reserve_rx_data>
}
 8054daa:	5b                   	pop    %ebx
 8054dab:	5d                   	pop    %ebp
	return net_pkt_get_reserve_tx_data(min_len, timeout);
 8054dac:	e9 b2 ff ff ff       	jmp    8054d63 <net_pkt_get_reserve_tx_data>

08054db1 <net_pkt_ref>:
{
 8054db1:	55                   	push   %ebp
 8054db2:	89 e5                	mov    %esp,%ebp
 8054db4:	53                   	push   %ebx
 8054db5:	8b 55 08             	mov    0x8(%ebp),%edx
		ref = pkt ? atomic_get(&pkt->atomic_ref) : 0;
 8054db8:	8d 4a 1c             	lea    0x1c(%edx),%ecx
 8054dbb:	85 d2                	test   %edx,%edx
 8054dbd:	74 11                	je     8054dd0 <net_pkt_ref+0x1f>
 8054dbf:	8b 01                	mov    (%ecx),%eax
		if (!ref) {
 8054dc1:	85 c0                	test   %eax,%eax
 8054dc3:	74 0b                	je     8054dd0 <net_pkt_ref+0x1f>
	} while (!atomic_cas(&pkt->atomic_ref, ref, ref + 1));
 8054dc5:	8d 58 01             	lea    0x1(%eax),%ebx
	return __atomic_compare_exchange_n(target, &old_value, new_value,
 8054dc8:	f0 0f b1 19          	lock cmpxchg %ebx,(%ecx)
 8054dcc:	74 04                	je     8054dd2 <net_pkt_ref+0x21>
 8054dce:	eb eb                	jmp    8054dbb <net_pkt_ref+0xa>
			return NULL;
 8054dd0:	31 d2                	xor    %edx,%edx
}
 8054dd2:	89 d0                	mov    %edx,%eax
 8054dd4:	5b                   	pop    %ebx
 8054dd5:	5d                   	pop    %ebp
 8054dd6:	c3                   	ret    

08054dd7 <net_pkt_frag_unref>:
{
 8054dd7:	55                   	push   %ebp
 8054dd8:	89 e5                	mov    %esp,%ebp
	if (!frag) {
 8054dda:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 8054dde:	74 06                	je     8054de6 <net_pkt_frag_unref+0xf>
}
 8054de0:	5d                   	pop    %ebp
	net_buf_unref(frag);
 8054de1:	e9 9c a3 ff ff       	jmp    804f182 <net_buf_unref>
}
 8054de6:	5d                   	pop    %ebp
 8054de7:	c3                   	ret    

08054de8 <net_pkt_unref>:
{
 8054de8:	55                   	push   %ebp
 8054de9:	89 e5                	mov    %esp,%ebp
 8054deb:	53                   	push   %ebx
 8054dec:	52                   	push   %edx
	if (!pkt) {
 8054ded:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 8054df1:	74 46                	je     8054e39 <net_pkt_unref+0x51>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
 8054df3:	8b 45 08             	mov    0x8(%ebp),%eax
 8054df6:	8b 50 1c             	mov    0x1c(%eax),%edx
		if (!ref) {
 8054df9:	85 d2                	test   %edx,%edx
 8054dfb:	74 3c                	je     8054e39 <net_pkt_unref+0x51>
	return __atomic_compare_exchange_n(target, &old_value, new_value,
 8054dfd:	8b 4d 08             	mov    0x8(%ebp),%ecx
	} while (!atomic_cas(&pkt->atomic_ref, ref, ref - 1));
 8054e00:	8d 5a ff             	lea    -0x1(%edx),%ebx
 8054e03:	89 d0                	mov    %edx,%eax
 8054e05:	f0 0f b1 59 1c       	lock cmpxchg %ebx,0x1c(%ecx)
 8054e0a:	75 e7                	jne    8054df3 <net_pkt_unref+0xb>
	if (ref > 1) {
 8054e0c:	4a                   	dec    %edx
 8054e0d:	7f 2a                	jg     8054e39 <net_pkt_unref+0x51>
	if (pkt->frags) {
 8054e0f:	8b 45 08             	mov    0x8(%ebp),%eax
 8054e12:	8b 40 08             	mov    0x8(%eax),%eax
 8054e15:	85 c0                	test   %eax,%eax
 8054e17:	74 0c                	je     8054e25 <net_pkt_unref+0x3d>
		net_pkt_frag_unref(pkt->frags);
 8054e19:	83 ec 0c             	sub    $0xc,%esp
 8054e1c:	50                   	push   %eax
 8054e1d:	e8 b5 ff ff ff       	call   8054dd7 <net_pkt_frag_unref>
 8054e22:	83 c4 10             	add    $0x10,%esp
	k_mem_slab_free(pkt->slab, (void **)&pkt);
 8054e25:	50                   	push   %eax
 8054e26:	50                   	push   %eax
 8054e27:	8d 45 08             	lea    0x8(%ebp),%eax
 8054e2a:	50                   	push   %eax
 8054e2b:	8b 45 08             	mov    0x8(%ebp),%eax
 8054e2e:	ff 70 04             	push   0x4(%eax)
 8054e31:	e8 e5 a0 00 00       	call   805ef1b <k_mem_slab_free>
 8054e36:	83 c4 10             	add    $0x10,%esp
}
 8054e39:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 8054e3c:	c9                   	leave  
 8054e3d:	c3                   	ret    

08054e3e <net_pkt_frag_insert>:
{
 8054e3e:	55                   	push   %ebp
 8054e3f:	89 e5                	mov    %esp,%ebp
 8054e41:	56                   	push   %esi
 8054e42:	53                   	push   %ebx
 8054e43:	8b 75 0c             	mov    0xc(%ebp),%esi
 8054e46:	8b 5d 08             	mov    0x8(%ebp),%ebx
	net_buf_frag_last(frag)->frags = pkt->frags;
 8054e49:	83 ec 0c             	sub    $0xc,%esp
 8054e4c:	56                   	push   %esi
 8054e4d:	e8 b1 a3 ff ff       	call   804f203 <net_buf_frag_last>
 8054e52:	8b 53 08             	mov    0x8(%ebx),%edx
 8054e55:	83 c4 10             	add    $0x10,%esp
 8054e58:	89 50 04             	mov    %edx,0x4(%eax)
	pkt->frags = frag;
 8054e5b:	89 73 08             	mov    %esi,0x8(%ebx)
}
 8054e5e:	8d 65 f8             	lea    -0x8(%ebp),%esp
 8054e61:	5b                   	pop    %ebx
 8054e62:	5e                   	pop    %esi
 8054e63:	5d                   	pop    %ebp
 8054e64:	c3                   	ret    

08054e65 <net_pkt_available_buffer>:
{
 8054e65:	55                   	push   %ebp
 8054e66:	31 c0                	xor    %eax,%eax
 8054e68:	89 e5                	mov    %esp,%ebp
 8054e6a:	57                   	push   %edi
 8054e6b:	56                   	push   %esi
 8054e6c:	53                   	push   %ebx
 8054e6d:	83 ec 0c             	sub    $0xc,%esp
 8054e70:	8b 7d 08             	mov    0x8(%ebp),%edi
	if (!pkt) {
 8054e73:	85 ff                	test   %edi,%edi
 8054e75:	74 30                	je     8054ea7 <net_pkt_available_buffer+0x42>
	return pkt_get_max_len(pkt) - net_pkt_get_len(pkt);
 8054e77:	8b 77 08             	mov    0x8(%edi),%esi
	size_t size = 0;
 8054e7a:	31 db                	xor    %ebx,%ebx
	while (buf) {
 8054e7c:	85 f6                	test   %esi,%esi
 8054e7e:	74 19                	je     8054e99 <net_pkt_available_buffer+0x34>
	return net_buf_simple_max_len(&buf->b);
 8054e80:	83 ec 0c             	sub    $0xc,%esp
 8054e83:	8d 46 0c             	lea    0xc(%esi),%eax
 8054e86:	50                   	push   %eax
 8054e87:	e8 11 a4 ff ff       	call   804f29d <net_buf_simple_max_len>
		buf = buf->frags;
 8054e8c:	8b 76 04             	mov    0x4(%esi),%esi
 8054e8f:	83 c4 10             	add    $0x10,%esp
		size += net_buf_max_len(buf);
 8054e92:	0f b7 c0             	movzwl %ax,%eax
 8054e95:	01 c3                	add    %eax,%ebx
		buf = buf->frags;
 8054e97:	eb e3                	jmp    8054e7c <net_pkt_available_buffer+0x17>
	return pkt_get_max_len(pkt) - net_pkt_get_len(pkt);
 8054e99:	8b 47 08             	mov    0x8(%edi),%eax
 8054e9c:	e8 15 fd ff ff       	call   8054bb6 <net_pkt_get_len.isra.0>
 8054ea1:	89 c2                	mov    %eax,%edx
 8054ea3:	89 d8                	mov    %ebx,%eax
 8054ea5:	29 d0                	sub    %edx,%eax
}
 8054ea7:	8d 65 f4             	lea    -0xc(%ebp),%esp
 8054eaa:	5b                   	pop    %ebx
 8054eab:	5e                   	pop    %esi
 8054eac:	5f                   	pop    %edi
 8054ead:	5d                   	pop    %ebp
 8054eae:	c3                   	ret    

08054eaf <net_pkt_available_payload_buffer>:
{
 8054eaf:	55                   	push   %ebp
 8054eb0:	31 c0                	xor    %eax,%eax
 8054eb2:	89 e5                	mov    %esp,%ebp
 8054eb4:	57                   	push   %edi
 8054eb5:	56                   	push   %esi
 8054eb6:	53                   	push   %ebx
 8054eb7:	83 ec 0c             	sub    $0xc,%esp
 8054eba:	8b 75 08             	mov    0x8(%ebp),%esi
	if (!pkt) {
 8054ebd:	85 f6                	test   %esi,%esi
 8054ebf:	74 37                	je     8054ef8 <net_pkt_available_payload_buffer+0x49>
	if (family == AF_UNSPEC) {
 8054ec1:	8a 46 33             	mov    0x33(%esi),%al
		return  0;
 8054ec4:	31 db                	xor    %ebx,%ebx
	if (family == AF_UNSPEC) {
 8054ec6:	c0 e8 05             	shr    $0x5,%al
 8054ec9:	74 0d                	je     8054ed8 <net_pkt_available_payload_buffer+0x29>
 8054ecb:	8b 55 0c             	mov    0xc(%ebp),%edx
	hdr_len = pkt_estimate_headers_length(pkt, net_pkt_family(pkt), proto);
 8054ece:	0f b6 c0             	movzbl %al,%eax
 8054ed1:	e8 b0 fc ff ff       	call   8054b86 <pkt_estimate_headers_length.part.0>
 8054ed6:	89 c3                	mov    %eax,%ebx
	len = net_pkt_get_len(pkt);
 8054ed8:	8b 46 08             	mov    0x8(%esi),%eax
	hdr_len = hdr_len <= len ? 0 : hdr_len - len;
 8054edb:	31 ff                	xor    %edi,%edi
	len = net_pkt_get_len(pkt);
 8054edd:	e8 d4 fc ff ff       	call   8054bb6 <net_pkt_get_len.isra.0>
	hdr_len = hdr_len <= len ? 0 : hdr_len - len;
 8054ee2:	39 d8                	cmp    %ebx,%eax
 8054ee4:	73 04                	jae    8054eea <net_pkt_available_payload_buffer+0x3b>
 8054ee6:	89 df                	mov    %ebx,%edi
 8054ee8:	29 c7                	sub    %eax,%edi
	len = net_pkt_available_buffer(pkt) - hdr_len;
 8054eea:	83 ec 0c             	sub    $0xc,%esp
 8054eed:	56                   	push   %esi
 8054eee:	e8 72 ff ff ff       	call   8054e65 <net_pkt_available_buffer>
 8054ef3:	83 c4 10             	add    $0x10,%esp
 8054ef6:	29 f8                	sub    %edi,%eax
}
 8054ef8:	8d 65 f4             	lea    -0xc(%ebp),%esp
 8054efb:	5b                   	pop    %ebx
 8054efc:	5e                   	pop    %esi
 8054efd:	5f                   	pop    %edi
 8054efe:	5d                   	pop    %ebp
 8054eff:	c3                   	ret    

08054f00 <net_pkt_trim_buffer>:
{
 8054f00:	55                   	push   %ebp
 8054f01:	89 e5                	mov    %esp,%ebp
 8054f03:	57                   	push   %edi
 8054f04:	56                   	push   %esi
 8054f05:	53                   	push   %ebx
 8054f06:	83 ec 0c             	sub    $0xc,%esp
 8054f09:	8b 75 08             	mov    0x8(%ebp),%esi
	buf = pkt->buffer;
 8054f0c:	8b 46 08             	mov    0x8(%esi),%eax
	prev = buf;
 8054f0f:	89 c3                	mov    %eax,%ebx
	while (buf) {
 8054f11:	85 c0                	test   %eax,%eax
 8054f13:	74 37                	je     8054f4c <net_pkt_trim_buffer+0x4c>
		if (!buf->len) {
 8054f15:	66 83 78 10 00       	cmpw   $0x0,0x10(%eax)
		struct net_buf *next = buf->frags;
 8054f1a:	8b 78 04             	mov    0x4(%eax),%edi
		if (!buf->len) {
 8054f1d:	75 27                	jne    8054f46 <net_pkt_trim_buffer+0x46>
			if (buf == pkt->buffer) {
 8054f1f:	39 46 08             	cmp    %eax,0x8(%esi)
 8054f22:	75 05                	jne    8054f29 <net_pkt_trim_buffer+0x29>
				pkt->buffer = next;
 8054f24:	89 7e 08             	mov    %edi,0x8(%esi)
 8054f27:	eb 08                	jmp    8054f31 <net_pkt_trim_buffer+0x31>
			} else if (buf == prev->frags) {
 8054f29:	39 43 04             	cmp    %eax,0x4(%ebx)
 8054f2c:	75 03                	jne    8054f31 <net_pkt_trim_buffer+0x31>
				prev->frags = next;
 8054f2e:	89 7b 04             	mov    %edi,0x4(%ebx)
			net_buf_unref(buf);
 8054f31:	83 ec 0c             	sub    $0xc,%esp
			buf->frags = NULL;
 8054f34:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
			net_buf_unref(buf);
 8054f3b:	50                   	push   %eax
 8054f3c:	e8 41 a2 ff ff       	call   804f182 <net_buf_unref>
 8054f41:	83 c4 10             	add    $0x10,%esp
 8054f44:	89 d8                	mov    %ebx,%eax
 8054f46:	89 c3                	mov    %eax,%ebx
 8054f48:	89 f8                	mov    %edi,%eax
 8054f4a:	eb c5                	jmp    8054f11 <net_pkt_trim_buffer+0x11>
}
 8054f4c:	8d 65 f4             	lea    -0xc(%ebp),%esp
 8054f4f:	5b                   	pop    %ebx
 8054f50:	5e                   	pop    %esi
 8054f51:	5f                   	pop    %edi
 8054f52:	5d                   	pop    %ebp
 8054f53:	c3                   	ret    

08054f54 <net_pkt_cursor_init>:
{
 8054f54:	55                   	push   %ebp
 8054f55:	89 e5                	mov    %esp,%ebp
 8054f57:	8b 55 08             	mov    0x8(%ebp),%edx
	pkt->cursor.buf = pkt->buffer;
 8054f5a:	8b 42 08             	mov    0x8(%edx),%eax
 8054f5d:	89 42 0c             	mov    %eax,0xc(%edx)
	if (pkt->cursor.buf) {
 8054f60:	85 c0                	test   %eax,%eax
 8054f62:	74 03                	je     8054f67 <net_pkt_cursor_init+0x13>
		pkt->cursor.pos = pkt->cursor.buf->data;
 8054f64:	8b 40 0c             	mov    0xc(%eax),%eax
 8054f67:	89 42 10             	mov    %eax,0x10(%edx)
}
 8054f6a:	5d                   	pop    %ebp
 8054f6b:	c3                   	ret    

08054f6c <pkt_alloc>:
{
 8054f6c:	55                   	push   %ebp
 8054f6d:	89 e5                	mov    %esp,%ebp
 8054f6f:	57                   	push   %edi
 8054f70:	89 cf                	mov    %ecx,%edi
 8054f72:	56                   	push   %esi
 8054f73:	89 d6                	mov    %edx,%esi
 8054f75:	53                   	push   %ebx
 8054f76:	89 c3                	mov    %eax,%ebx
 8054f78:	83 ec 1c             	sub    $0x1c,%esp
 8054f7b:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 8054f81:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 8054f84:	31 c0                	xor    %eax,%eax
	if (k_is_in_isr()) {
 8054f86:	e8 07 a0 00 00       	call   805ef92 <k_is_in_isr>
 8054f8b:	84 c0                	test   %al,%al
 8054f8d:	74 04                	je     8054f93 <pkt_alloc+0x27>
		timeout = K_NO_WAIT;
 8054f8f:	31 f6                	xor    %esi,%esi
 8054f91:	31 ff                	xor    %edi,%edi
	ret = k_mem_slab_alloc(slab, (void **)&pkt, timeout);
 8054f93:	8d 45 e0             	lea    -0x20(%ebp),%eax
 8054f96:	57                   	push   %edi
 8054f97:	56                   	push   %esi
 8054f98:	50                   	push   %eax
 8054f99:	53                   	push   %ebx
 8054f9a:	e8 fc 9e 00 00       	call   805ee9b <k_mem_slab_alloc>
 8054f9f:	83 c4 10             	add    $0x10,%esp
		return NULL;
 8054fa2:	31 c9                	xor    %ecx,%ecx
	if (ret) {
 8054fa4:	85 c0                	test   %eax,%eax
 8054fa6:	75 41                	jne    8054fe9 <pkt_alloc+0x7d>
 8054fa8:	8b 7d e0             	mov    -0x20(%ebp),%edi
 8054fab:	b9 10 00 00 00       	mov    $0x10,%ecx
 8054fb0:	f3 ab                	rep stos %eax,%es:(%edi)
	pkt->atomic_ref = ATOMIC_INIT(1);
 8054fb2:	8b 4d e0             	mov    -0x20(%ebp),%ecx
 8054fb5:	c7 41 1c 01 00 00 00 	movl   $0x1,0x1c(%ecx)
	pkt->slab = slab;
 8054fbc:	89 59 04             	mov    %ebx,0x4(%ecx)
	pkt->ipv6_next_hdr = next_hdr;
 8054fbf:	c6 41 3b ff          	movb   $0xff,0x3b(%ecx)
	if (&tx_pkts == slab) {
 8054fc3:	81 fb 68 75 06 08    	cmp    $0x8067568,%ebx
 8054fc9:	75 06                	jne    8054fd1 <pkt_alloc+0x65>
	pkt->priority = priority;
 8054fcb:	c6 41 3d 01          	movb   $0x1,0x3d(%ecx)
}
 8054fcf:	eb 0c                	jmp    8054fdd <pkt_alloc+0x71>
	} else if (&rx_pkts == slab) {
 8054fd1:	81 fb 4c 75 06 08    	cmp    $0x806754c,%ebx
 8054fd7:	75 04                	jne    8054fdd <pkt_alloc+0x71>
	pkt->priority = priority;
 8054fd9:	c6 41 3d 00          	movb   $0x0,0x3d(%ecx)
	net_pkt_cursor_init(pkt);
 8054fdd:	83 ec 0c             	sub    $0xc,%esp
 8054fe0:	51                   	push   %ecx
 8054fe1:	e8 6e ff ff ff       	call   8054f54 <net_pkt_cursor_init>
 8054fe6:	83 c4 10             	add    $0x10,%esp
}
 8054fe9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8054fec:	65 2b 05 14 00 00 00 	sub    %gs:0x14,%eax
 8054ff3:	74 05                	je     8054ffa <pkt_alloc+0x8e>
 8054ff5:	e8 06 43 ff ff       	call   8049300 <__stack_chk_fail@plt>
 8054ffa:	8d 65 f4             	lea    -0xc(%ebp),%esp
 8054ffd:	89 c8                	mov    %ecx,%eax
 8054fff:	5b                   	pop    %ebx
 8055000:	5e                   	pop    %esi
 8055001:	5f                   	pop    %edi
 8055002:	5d                   	pop    %ebp
 8055003:	c3                   	ret    

08055004 <pkt_alloc_on_iface>:
{
 8055004:	55                   	push   %ebp
 8055005:	89 e5                	mov    %esp,%ebp
 8055007:	53                   	push   %ebx
 8055008:	89 d3                	mov    %edx,%ebx
 805500a:	51                   	push   %ecx
	pkt = pkt_alloc(slab, timeout);
 805500b:	8b 55 08             	mov    0x8(%ebp),%edx
 805500e:	8b 4d 0c             	mov    0xc(%ebp),%ecx
 8055011:	e8 56 ff ff ff       	call   8054f6c <pkt_alloc>
	if (pkt) {
 8055016:	85 c0                	test   %eax,%eax
 8055018:	74 17                	je     8055031 <pkt_alloc_on_iface+0x2d>
	pkt->iface = iface;
 805501a:	89 58 18             	mov    %ebx,0x18(%eax)
	if (iface) {
 805501d:	85 db                	test   %ebx,%ebx
 805501f:	74 10                	je     8055031 <pkt_alloc_on_iface+0x2d>
		pkt->lladdr_src.type = net_if_get_link_addr(iface)->type;
 8055021:	8b 13                	mov    (%ebx),%edx
 8055023:	8a 52 15             	mov    0x15(%edx),%dl
 8055026:	88 50 25             	mov    %dl,0x25(%eax)
		pkt->lladdr_dst.type = net_if_get_link_addr(iface)->type;
 8055029:	8b 13                	mov    (%ebx),%edx
 805502b:	8a 52 15             	mov    0x15(%edx),%dl
 805502e:	88 50 2d             	mov    %dl,0x2d(%eax)
}
 8055031:	5a                   	pop    %edx
 8055032:	5b                   	pop    %ebx
 8055033:	5d                   	pop    %ebp
 8055034:	c3                   	ret    

08055035 <net_pkt_append_buffer>:
{
 8055035:	55                   	push   %ebp
 8055036:	89 e5                	mov    %esp,%ebp
 8055038:	53                   	push   %ebx
 8055039:	50                   	push   %eax
 805503a:	8b 55 08             	mov    0x8(%ebp),%edx
 805503d:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	if (!pkt->buffer) {
 8055040:	8b 42 08             	mov    0x8(%edx),%eax
 8055043:	85 c0                	test   %eax,%eax
 8055045:	75 0c                	jne    8055053 <net_pkt_append_buffer+0x1e>
		pkt->buffer = buffer;
 8055047:	89 5a 08             	mov    %ebx,0x8(%edx)
}
 805504a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 805504d:	c9                   	leave  
		net_pkt_cursor_init(pkt);
 805504e:	e9 01 ff ff ff       	jmp    8054f54 <net_pkt_cursor_init>
		net_buf_frag_insert(net_buf_frag_last(pkt->buffer), buffer);
 8055053:	83 ec 0c             	sub    $0xc,%esp
 8055056:	50                   	push   %eax
 8055057:	e8 a7 a1 ff ff       	call   804f203 <net_buf_frag_last>
 805505c:	89 5d 0c             	mov    %ebx,0xc(%ebp)
 805505f:	83 c4 10             	add    $0x10,%esp
}
 8055062:	8b 5d fc             	mov    -0x4(%ebp),%ebx
		net_buf_frag_insert(net_buf_frag_last(pkt->buffer), buffer);
 8055065:	89 45 08             	mov    %eax,0x8(%ebp)
}
 8055068:	c9                   	leave  
		net_buf_frag_insert(net_buf_frag_last(pkt->buffer), buffer);
 8055069:	e9 a8 a1 ff ff       	jmp    804f216 <net_buf_frag_insert>

0805506e <net_pkt_alloc_buffer>:
{
 805506e:	55                   	push   %ebp
 805506f:	89 e5                	mov    %esp,%ebp
 8055071:	57                   	push   %edi
 8055072:	56                   	push   %esi
 8055073:	53                   	push   %ebx
 8055074:	83 ec 34             	sub    $0x34,%esp
 8055077:	8b 75 14             	mov    0x14(%ebp),%esi
 805507a:	8b 7d 18             	mov    0x18(%ebp),%edi
	uint64_t end = sys_clock_timeout_end_calc(timeout);
 805507d:	57                   	push   %edi
 805507e:	56                   	push   %esi
 805507f:	e8 95 bb 00 00       	call   8060c19 <sys_clock_timeout_end_calc>
 8055084:	83 c4 10             	add    $0x10,%esp
 8055087:	89 45 d8             	mov    %eax,-0x28(%ebp)
	if (!size && proto == 0 && net_pkt_family(pkt) == AF_UNSPEC) {
 805508a:	8b 45 10             	mov    0x10(%ebp),%eax
 805508d:	0b 45 0c             	or     0xc(%ebp),%eax
	uint64_t end = sys_clock_timeout_end_calc(timeout);
 8055090:	89 55 dc             	mov    %edx,-0x24(%ebp)
	if (!size && proto == 0 && net_pkt_family(pkt) == AF_UNSPEC) {
 8055093:	75 11                	jne    80550a6 <net_pkt_alloc_buffer+0x38>
	return pkt->family;
 8055095:	8b 45 08             	mov    0x8(%ebp),%eax
 8055098:	8a 50 33             	mov    0x33(%eax),%dl
		return 0;
 805509b:	31 c0                	xor    %eax,%eax
	if (!size && proto == 0 && net_pkt_family(pkt) == AF_UNSPEC) {
 805509d:	c0 ea 05             	shr    $0x5,%dl
 80550a0:	0f 84 a8 01 00 00    	je     805524e <net_pkt_alloc_buffer+0x1e0>
	if (k_is_in_isr()) {
 80550a6:	e8 e7 9e 00 00       	call   805ef92 <k_is_in_isr>
 80550ab:	84 c0                	test   %al,%al
 80550ad:	74 04                	je     80550b3 <net_pkt_alloc_buffer+0x45>
		timeout = K_NO_WAIT;
 80550af:	31 f6                	xor    %esi,%esi
 80550b1:	31 ff                	xor    %edi,%edi
	alloc_len = net_pkt_available_buffer(pkt);
 80550b3:	83 ec 0c             	sub    $0xc,%esp
 80550b6:	ff 75 08             	push   0x8(%ebp)
 80550b9:	e8 a7 fd ff ff       	call   8054e65 <net_pkt_available_buffer>
 80550be:	8b 4d 08             	mov    0x8(%ebp),%ecx
 80550c1:	83 c4 10             	add    $0x10,%esp
 80550c4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	size_t hdr_len = 0;
 80550c7:	31 c0                	xor    %eax,%eax
	if (!alloc_len) {
 80550c9:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
 80550cd:	8a 59 33             	mov    0x33(%ecx),%bl
 80550d0:	75 12                	jne    80550e4 <net_pkt_alloc_buffer+0x76>
	if (family == AF_UNSPEC) {
 80550d2:	89 da                	mov    %ebx,%edx
 80550d4:	c0 ea 05             	shr    $0x5,%dl
 80550d7:	74 0b                	je     80550e4 <net_pkt_alloc_buffer+0x76>
		hdr_len = pkt_estimate_headers_length(pkt,
 80550d9:	0f b6 c2             	movzbl %dl,%eax
 80550dc:	8b 55 10             	mov    0x10(%ebp),%edx
 80550df:	e8 a2 fa ff ff       	call   8054b86 <pkt_estimate_headers_length.part.0>
 80550e4:	c0 eb 05             	shr    $0x5,%bl
	alloc_len = pkt_buffer_length(pkt, size + hdr_len, proto, alloc_len);
 80550e7:	03 45 0c             	add    0xc(%ebp),%eax
		max_len = 0;
 80550ea:	31 c9                	xor    %ecx,%ecx
	sa_family_t family = net_pkt_family(pkt);
 80550ec:	0f b6 d3             	movzbl %bl,%edx
	return pkt->iface;
 80550ef:	8b 5d 08             	mov    0x8(%ebp),%ebx
 80550f2:	8b 5b 18             	mov    0x18(%ebx),%ebx
	if (net_pkt_iface(pkt)) {
 80550f5:	85 db                	test   %ebx,%ebx
 80550f7:	74 06                	je     80550ff <net_pkt_alloc_buffer+0x91>
	return iface->if_dev->mtu;
 80550f9:	8b 0b                	mov    (%ebx),%ecx
		max_len = net_if_get_mtu(net_pkt_iface(pkt));
 80550fb:	0f b7 49 18          	movzwl 0x18(%ecx),%ecx
	if (IS_ENABLED(CONFIG_NET_IPV6) && family == AF_INET6) {
 80550ff:	66 83 fa 02          	cmp    $0x2,%dx
 8055103:	75 07                	jne    805510c <net_pkt_alloc_buffer+0x9e>
		max_len = MAX(max_len, NET_IPV6_MTU);
 8055105:	ba 00 05 00 00       	mov    $0x500,%edx
 805510a:	eb 09                	jmp    8055115 <net_pkt_alloc_buffer+0xa7>
	} else if (IS_ENABLED(CONFIG_NET_IPV4) && family == AF_INET) {
 805510c:	66 4a                	dec    %dx
 805510e:	75 0c                	jne    805511c <net_pkt_alloc_buffer+0xae>
		max_len = MAX(max_len, NET_IPV4_MTU);
 8055110:	ba 40 02 00 00       	mov    $0x240,%edx
 8055115:	39 d1                	cmp    %edx,%ecx
 8055117:	0f 43 d1             	cmovae %ecx,%edx
 805511a:	eb 18                	jmp    8055134 <net_pkt_alloc_buffer+0xc6>
			max_len = size;
 805511c:	89 c2                	mov    %eax,%edx
	if (!iface || !iface->if_dev) {
 805511e:	85 db                	test   %ebx,%ebx
 8055120:	74 12                	je     8055134 <net_pkt_alloc_buffer+0xc6>
 8055122:	8b 1b                	mov    (%ebx),%ebx
 8055124:	85 db                	test   %ebx,%ebx
 8055126:	74 0c                	je     8055134 <net_pkt_alloc_buffer+0xc6>
		if (net_if_l2(net_pkt_iface(pkt)) ==
 8055128:	81 7b 04 d8 76 06 08 	cmpl   $0x80676d8,0x4(%ebx)
 805512f:	75 03                	jne    8055134 <net_pkt_alloc_buffer+0xc6>
			max_len += NET_ETH_MAX_HDR_SIZE;
 8055131:	8d 51 0e             	lea    0xe(%ecx),%edx
	max_len -= existing;
 8055134:	2b 55 e4             	sub    -0x1c(%ebp),%edx
	return MIN(size, max_len);
 8055137:	39 c2                	cmp    %eax,%edx
 8055139:	0f 46 c2             	cmovbe %edx,%eax
		pool = pkt->slab == &tx_pkts ? &tx_bufs : &rx_bufs;
 805513c:	ba 84 76 06 08       	mov    $0x8067684,%edx
	return MIN(size, max_len);
 8055141:	89 c3                	mov    %eax,%ebx
		pool = pkt->slab == &tx_pkts ? &tx_bufs : &rx_bufs;
 8055143:	8b 45 08             	mov    0x8(%ebp),%eax
 8055146:	81 78 04 68 75 06 08 	cmpl   $0x8067568,0x4(%eax)
 805514d:	b8 58 76 06 08       	mov    $0x8067658,%eax
 8055152:	0f 44 c2             	cmove  %edx,%eax
 8055155:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (!K_TIMEOUT_EQ(timeout, K_NO_WAIT) &&
 8055158:	89 f8                	mov    %edi,%eax
 805515a:	09 f0                	or     %esi,%eax
 805515c:	74 29                	je     8055187 <net_pkt_alloc_buffer+0x119>
 805515e:	83 ff ff             	cmp    $0xffffffff,%edi
 8055161:	75 05                	jne    8055168 <net_pkt_alloc_buffer+0xfa>
 8055163:	83 fe ff             	cmp    $0xffffffff,%esi
 8055166:	74 1f                	je     8055187 <net_pkt_alloc_buffer+0x119>
		int64_t remaining = end - sys_clock_tick_get();
 8055168:	e8 5d ba 00 00       	call   8060bca <sys_clock_tick_get>
 805516d:	8b 75 d8             	mov    -0x28(%ebp),%esi
 8055170:	8b 7d dc             	mov    -0x24(%ebp),%edi
 8055173:	29 c6                	sub    %eax,%esi
 8055175:	19 d7                	sbb    %edx,%edi
 8055177:	31 d2                	xor    %edx,%edx
 8055179:	31 c0                	xor    %eax,%eax
 805517b:	89 f9                	mov    %edi,%ecx
 805517d:	39 d6                	cmp    %edx,%esi
 805517f:	19 c1                	sbb    %eax,%ecx
 8055181:	0f 4c f2             	cmovl  %edx,%esi
 8055184:	0f 4c f8             	cmovl  %eax,%edi
	uint64_t end = sys_clock_timeout_end_calc(timeout);
 8055187:	51                   	push   %ecx
 8055188:	51                   	push   %ecx
 8055189:	57                   	push   %edi
 805518a:	56                   	push   %esi
 805518b:	e8 89 ba 00 00       	call   8060c19 <sys_clock_timeout_end_calc>
	struct net_buf *first = NULL;
 8055190:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	uint64_t end = sys_clock_timeout_end_calc(timeout);
 8055197:	83 c4 10             	add    $0x10,%esp
	struct net_buf *current = NULL;
 805519a:	31 c9                	xor    %ecx,%ecx
	uint64_t end = sys_clock_timeout_end_calc(timeout);
 805519c:	89 45 d8             	mov    %eax,-0x28(%ebp)
 805519f:	89 55 dc             	mov    %edx,-0x24(%ebp)
		new = net_buf_alloc_fixed(pool, timeout);
 80551a2:	52                   	push   %edx
 80551a3:	57                   	push   %edi
 80551a4:	56                   	push   %esi
 80551a5:	ff 75 e0             	push   -0x20(%ebp)
 80551a8:	89 4d d4             	mov    %ecx,-0x2c(%ebp)
 80551ab:	e8 b0 9f ff ff       	call   804f160 <net_buf_alloc_fixed>
 80551b0:	83 c4 10             	add    $0x10,%esp
		if (!new) {
 80551b3:	8b 55 d4             	mov    -0x2c(%ebp),%edx
 80551b6:	85 c0                	test   %eax,%eax
		new = net_buf_alloc_fixed(pool, timeout);
 80551b8:	89 c1                	mov    %eax,%ecx
		if (!new) {
 80551ba:	75 16                	jne    80551d2 <net_pkt_alloc_buffer+0x164>
	if (first) {
 80551bc:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
 80551c0:	74 68                	je     805522a <net_pkt_alloc_buffer+0x1bc>
		net_buf_unref(first);
 80551c2:	83 ec 0c             	sub    $0xc,%esp
 80551c5:	ff 75 e4             	push   -0x1c(%ebp)
 80551c8:	e8 b5 9f ff ff       	call   804f182 <net_buf_unref>
 80551cd:	83 c4 10             	add    $0x10,%esp
 80551d0:	eb 58                	jmp    805522a <net_pkt_alloc_buffer+0x1bc>
		if (!first && !current) {
 80551d2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 80551d5:	09 d0                	or     %edx,%eax
 80551d7:	74 05                	je     80551de <net_pkt_alloc_buffer+0x170>
			current->frags = new;
 80551d9:	89 4a 04             	mov    %ecx,0x4(%edx)
 80551dc:	eb 03                	jmp    80551e1 <net_pkt_alloc_buffer+0x173>
 80551de:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
		if (current->size > size) {
 80551e1:	0f b7 41 12          	movzwl 0x12(%ecx),%eax
 80551e5:	39 d8                	cmp    %ebx,%eax
 80551e7:	76 04                	jbe    80551ed <net_pkt_alloc_buffer+0x17f>
			current->size = size;
 80551e9:	66 89 59 12          	mov    %bx,0x12(%ecx)
		size -= current->size;
 80551ed:	0f b7 41 12          	movzwl 0x12(%ecx),%eax
 80551f1:	29 c3                	sub    %eax,%ebx
		if (!K_TIMEOUT_EQ(timeout, K_NO_WAIT) &&
 80551f3:	89 f8                	mov    %edi,%eax
 80551f5:	09 f0                	or     %esi,%eax
 80551f7:	74 27                	je     8055220 <net_pkt_alloc_buffer+0x1b2>
 80551f9:	83 ff ff             	cmp    $0xffffffff,%edi
 80551fc:	75 05                	jne    8055203 <net_pkt_alloc_buffer+0x195>
 80551fe:	83 fe ff             	cmp    $0xffffffff,%esi
 8055201:	74 1d                	je     8055220 <net_pkt_alloc_buffer+0x1b2>
 8055203:	89 4d d4             	mov    %ecx,-0x2c(%ebp)
			int64_t remaining = end - sys_clock_tick_get();
 8055206:	e8 bf b9 00 00       	call   8060bca <sys_clock_tick_get>
 805520b:	8b 75 d8             	mov    -0x28(%ebp),%esi
 805520e:	8b 7d dc             	mov    -0x24(%ebp),%edi
			if (remaining <= 0) {
 8055211:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
			int64_t remaining = end - sys_clock_tick_get();
 8055214:	29 c6                	sub    %eax,%esi
 8055216:	19 d7                	sbb    %edx,%edi
			if (remaining <= 0) {
 8055218:	31 c0                	xor    %eax,%eax
 805521a:	39 f0                	cmp    %esi,%eax
 805521c:	19 f8                	sbb    %edi,%eax
 805521e:	7d 11                	jge    8055231 <net_pkt_alloc_buffer+0x1c3>
	} while (size);
 8055220:	85 db                	test   %ebx,%ebx
 8055222:	0f 85 7a ff ff ff    	jne    80551a2 <net_pkt_alloc_buffer+0x134>
 8055228:	eb 07                	jmp    8055231 <net_pkt_alloc_buffer+0x1c3>
		return -ENOMEM;
 805522a:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
 805522f:	eb 1d                	jmp    805524e <net_pkt_alloc_buffer+0x1e0>
	if (!buf) {
 8055231:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
		return -ENOMEM;
 8055235:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
	if (!buf) {
 805523a:	74 12                	je     805524e <net_pkt_alloc_buffer+0x1e0>
	net_pkt_append_buffer(pkt, buf);
 805523c:	50                   	push   %eax
 805523d:	50                   	push   %eax
 805523e:	ff 75 e4             	push   -0x1c(%ebp)
 8055241:	ff 75 08             	push   0x8(%ebp)
 8055244:	e8 ec fd ff ff       	call   8055035 <net_pkt_append_buffer>
 8055249:	83 c4 10             	add    $0x10,%esp
	return 0;
 805524c:	31 c0                	xor    %eax,%eax
}
 805524e:	8d 65 f4             	lea    -0xc(%ebp),%esp
 8055251:	5b                   	pop    %ebx
 8055252:	5e                   	pop    %esi
 8055253:	5f                   	pop    %edi
 8055254:	5d                   	pop    %ebp
 8055255:	c3                   	ret    

08055256 <pkt_alloc_with_buffer>:
{
 8055256:	55                   	push   %ebp
 8055257:	89 e5                	mov    %esp,%ebp
 8055259:	57                   	push   %edi
 805525a:	56                   	push   %esi
 805525b:	53                   	push   %ebx
 805525c:	89 d3                	mov    %edx,%ebx
 805525e:	83 ec 34             	sub    $0x34,%esp
 8055261:	8b 75 10             	mov    0x10(%ebp),%esi
 8055264:	8b 7d 14             	mov    0x14(%ebp),%edi
 8055267:	89 45 dc             	mov    %eax,-0x24(%ebp)
 805526a:	8b 45 08             	mov    0x8(%ebp),%eax
 805526d:	89 4d d8             	mov    %ecx,-0x28(%ebp)
	uint64_t end = sys_clock_timeout_end_calc(timeout);
 8055270:	57                   	push   %edi
 8055271:	56                   	push   %esi
{
 8055272:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	uint64_t end = sys_clock_timeout_end_calc(timeout);
 8055275:	e8 9f b9 00 00       	call   8060c19 <sys_clock_timeout_end_calc>
 805527a:	59                   	pop    %ecx
 805527b:	59                   	pop    %ecx
	pkt = pkt_alloc_on_iface(slab, iface, timeout);
 805527c:	57                   	push   %edi
 805527d:	56                   	push   %esi
	uint64_t end = sys_clock_timeout_end_calc(timeout);
 805527e:	89 45 e0             	mov    %eax,-0x20(%ebp)
	pkt = pkt_alloc_on_iface(slab, iface, timeout);
 8055281:	8b 45 dc             	mov    -0x24(%ebp),%eax
	uint64_t end = sys_clock_timeout_end_calc(timeout);
 8055284:	89 55 e4             	mov    %edx,-0x1c(%ebp)
	pkt = pkt_alloc_on_iface(slab, iface, timeout);
 8055287:	89 da                	mov    %ebx,%edx
 8055289:	e8 76 fd ff ff       	call   8055004 <pkt_alloc_on_iface>
 805528e:	83 c4 10             	add    $0x10,%esp
 8055291:	89 c3                	mov    %eax,%ebx
	if (!pkt) {
 8055293:	85 c0                	test   %eax,%eax
 8055295:	74 66                	je     80552fd <pkt_alloc_with_buffer+0xa7>
	pkt->family = family;
 8055297:	8a 40 33             	mov    0x33(%eax),%al
 805529a:	8a 55 d4             	mov    -0x2c(%ebp),%dl
 805529d:	83 e0 1f             	and    $0x1f,%eax
 80552a0:	c1 e2 05             	shl    $0x5,%edx
 80552a3:	09 d0                	or     %edx,%eax
 80552a5:	88 43 33             	mov    %al,0x33(%ebx)
	if (!K_TIMEOUT_EQ(timeout, K_NO_WAIT) &&
 80552a8:	89 f8                	mov    %edi,%eax
 80552aa:	09 f0                	or     %esi,%eax
 80552ac:	74 29                	je     80552d7 <pkt_alloc_with_buffer+0x81>
 80552ae:	83 ff ff             	cmp    $0xffffffff,%edi
 80552b1:	75 05                	jne    80552b8 <pkt_alloc_with_buffer+0x62>
 80552b3:	83 fe ff             	cmp    $0xffffffff,%esi
 80552b6:	74 1f                	je     80552d7 <pkt_alloc_with_buffer+0x81>
		int64_t remaining = end - sys_clock_tick_get();
 80552b8:	e8 0d b9 00 00       	call   8060bca <sys_clock_tick_get>
 80552bd:	8b 75 e0             	mov    -0x20(%ebp),%esi
 80552c0:	8b 7d e4             	mov    -0x1c(%ebp),%edi
 80552c3:	29 c6                	sub    %eax,%esi
 80552c5:	19 d7                	sbb    %edx,%edi
 80552c7:	31 d2                	xor    %edx,%edx
 80552c9:	31 c0                	xor    %eax,%eax
 80552cb:	89 f9                	mov    %edi,%ecx
 80552cd:	39 d6                	cmp    %edx,%esi
 80552cf:	19 c1                	sbb    %eax,%ecx
 80552d1:	0f 4c f2             	cmovl  %edx,%esi
 80552d4:	0f 4c f8             	cmovl  %eax,%edi
	ret = net_pkt_alloc_buffer(pkt, size, proto, timeout);
 80552d7:	83 ec 0c             	sub    $0xc,%esp
 80552da:	57                   	push   %edi
 80552db:	56                   	push   %esi
 80552dc:	ff 75 0c             	push   0xc(%ebp)
 80552df:	ff 75 d8             	push   -0x28(%ebp)
 80552e2:	53                   	push   %ebx
 80552e3:	e8 86 fd ff ff       	call   805506e <net_pkt_alloc_buffer>
 80552e8:	83 c4 20             	add    $0x20,%esp
	if (ret) {
 80552eb:	85 c0                	test   %eax,%eax
 80552ed:	74 0e                	je     80552fd <pkt_alloc_with_buffer+0xa7>
		net_pkt_unref(pkt);
 80552ef:	83 ec 0c             	sub    $0xc,%esp
 80552f2:	53                   	push   %ebx
		return NULL;
 80552f3:	31 db                	xor    %ebx,%ebx
		net_pkt_unref(pkt);
 80552f5:	e8 ee fa ff ff       	call   8054de8 <net_pkt_unref>
 80552fa:	83 c4 10             	add    $0x10,%esp
}
 80552fd:	8d 65 f4             	lea    -0xc(%ebp),%esp
 8055300:	89 d8                	mov    %ebx,%eax
 8055302:	5b                   	pop    %ebx
 8055303:	5e                   	pop    %esi
 8055304:	5f                   	pop    %edi
 8055305:	5d                   	pop    %ebp
 8055306:	c3                   	ret    

08055307 <net_pkt_alloc_with_buffer>:
{
 8055307:	55                   	push   %ebp
 8055308:	89 e5                	mov    %esp,%ebp
 805530a:	57                   	push   %edi
 805530b:	8b 45 10             	mov    0x10(%ebp),%eax
	return pkt_alloc_with_buffer(&tx_pkts, iface, size, family,
 805530e:	8b 7d 1c             	mov    0x1c(%ebp),%edi
{
 8055311:	56                   	push   %esi
	return pkt_alloc_with_buffer(&tx_pkts, iface, size, family,
 8055312:	8b 75 18             	mov    0x18(%ebp),%esi
{
 8055315:	8b 55 08             	mov    0x8(%ebp),%edx
 8055318:	53                   	push   %ebx
 8055319:	8b 5d 14             	mov    0x14(%ebp),%ebx
 805531c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	return pkt_alloc_with_buffer(&tx_pkts, iface, size, family,
 805531f:	0f b7 c0             	movzwl %ax,%eax
 8055322:	89 7d 14             	mov    %edi,0x14(%ebp)
 8055325:	89 75 10             	mov    %esi,0x10(%ebp)
 8055328:	89 5d 0c             	mov    %ebx,0xc(%ebp)
}
 805532b:	5b                   	pop    %ebx
	return pkt_alloc_with_buffer(&tx_pkts, iface, size, family,
 805532c:	89 45 08             	mov    %eax,0x8(%ebp)
}
 805532f:	5e                   	pop    %esi
	return pkt_alloc_with_buffer(&tx_pkts, iface, size, family,
 8055330:	b8 68 75 06 08       	mov    $0x8067568,%eax
}
 8055335:	5f                   	pop    %edi
 8055336:	5d                   	pop    %ebp
	return pkt_alloc_with_buffer(&tx_pkts, iface, size, family,
 8055337:	e9 1a ff ff ff       	jmp    8055256 <pkt_alloc_with_buffer>

0805533c <net_pkt_rx_alloc_with_buffer>:
{
 805533c:	55                   	push   %ebp
 805533d:	89 e5                	mov    %esp,%ebp
 805533f:	57                   	push   %edi
 8055340:	8b 45 10             	mov    0x10(%ebp),%eax
	return pkt_alloc_with_buffer(&rx_pkts, iface, size, family,
 8055343:	8b 7d 1c             	mov    0x1c(%ebp),%edi
{
 8055346:	56                   	push   %esi
	return pkt_alloc_with_buffer(&rx_pkts, iface, size, family,
 8055347:	8b 75 18             	mov    0x18(%ebp),%esi
{
 805534a:	8b 55 08             	mov    0x8(%ebp),%edx
 805534d:	53                   	push   %ebx
 805534e:	8b 5d 14             	mov    0x14(%ebp),%ebx
 8055351:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	return pkt_alloc_with_buffer(&rx_pkts, iface, size, family,
 8055354:	0f b7 c0             	movzwl %ax,%eax
 8055357:	89 7d 14             	mov    %edi,0x14(%ebp)
 805535a:	89 75 10             	mov    %esi,0x10(%ebp)
 805535d:	89 5d 0c             	mov    %ebx,0xc(%ebp)
}
 8055360:	5b                   	pop    %ebx
	return pkt_alloc_with_buffer(&rx_pkts, iface, size, family,
 8055361:	89 45 08             	mov    %eax,0x8(%ebp)
}
 8055364:	5e                   	pop    %esi
	return pkt_alloc_with_buffer(&rx_pkts, iface, size, family,
 8055365:	b8 4c 75 06 08       	mov    $0x806754c,%eax
}
 805536a:	5f                   	pop    %edi
 805536b:	5d                   	pop    %ebp
	return pkt_alloc_with_buffer(&rx_pkts, iface, size, family,
 805536c:	e9 e5 fe ff ff       	jmp    8055256 <pkt_alloc_with_buffer>

08055371 <net_pkt_skip>:

int net_pkt_skip(struct net_pkt *pkt, size_t skip)
{
 8055371:	55                   	push   %ebp
	NET_DBG("pkt %p skip %zu", pkt, skip);

	return net_pkt_cursor_operate(pkt, NULL, skip, false, true);
 8055372:	31 d2                	xor    %edx,%edx
{
 8055374:	89 e5                	mov    %esp,%ebp
 8055376:	8b 45 08             	mov    0x8(%ebp),%eax
 8055379:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	return net_pkt_cursor_operate(pkt, NULL, skip, false, true);
 805537c:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
 8055383:	c7 45 0c 01 00 00 00 	movl   $0x1,0xc(%ebp)
}
 805538a:	5d                   	pop    %ebp
	return net_pkt_cursor_operate(pkt, NULL, skip, false, true);
 805538b:	e9 3a f8 ff ff       	jmp    8054bca <net_pkt_cursor_operate>

08055390 <clone_pkt_lladdr>:
	return ret;
}

static void clone_pkt_lladdr(struct net_pkt *pkt, struct net_pkt *clone_pkt,
			     struct net_linkaddr *lladdr)
{
 8055390:	55                   	push   %ebp
 8055391:	89 e5                	mov    %esp,%ebp
 8055393:	57                   	push   %edi
 8055394:	89 c7                	mov    %eax,%edi
 8055396:	56                   	push   %esi
 8055397:	53                   	push   %ebx
 8055398:	83 ec 1c             	sub    $0x1c,%esp
	int32_t ll_addr_offset;

	if (!lladdr->addr)
 805539b:	8b 01                	mov    (%ecx),%eax
 805539d:	85 c0                	test   %eax,%eax
 805539f:	74 60                	je     8055401 <clone_pkt_lladdr+0x71>
	if (!ptr || !pkt || !pkt->buffer) {
 80553a1:	85 ff                	test   %edi,%edi
 80553a3:	74 5c                	je     8055401 <clone_pkt_lladdr+0x71>
 80553a5:	89 d3                	mov    %edx,%ebx
 80553a7:	8b 57 08             	mov    0x8(%edi),%edx
 80553aa:	85 d2                	test   %edx,%edx
 80553ac:	74 53                	je     8055401 <clone_pkt_lladdr+0x71>
	offset = 0U;
 80553ae:	66 c7 45 e6 00 00    	movw   $0x0,-0x1a(%ebp)
 80553b4:	89 ce                	mov    %ecx,%esi
		if (buf->data <= ptr && ptr <= (buf->data + buf->len)) {
 80553b6:	0f b7 7a 10          	movzwl 0x10(%edx),%edi
 80553ba:	8b 4a 0c             	mov    0xc(%edx),%ecx
 80553bd:	66 89 7d e4          	mov    %di,-0x1c(%ebp)
 80553c1:	39 c8                	cmp    %ecx,%eax
 80553c3:	72 2e                	jb     80553f3 <clone_pkt_lladdr+0x63>
 80553c5:	01 cf                	add    %ecx,%edi
 80553c7:	39 f8                	cmp    %edi,%eax
 80553c9:	77 28                	ja     80553f3 <clone_pkt_lladdr+0x63>
			ret = offset + (ptr - buf->data);
 80553cb:	0f b7 55 e6          	movzwl -0x1a(%ebp),%edx
 80553cf:	29 c8                	sub    %ecx,%eax
		return;

	ll_addr_offset = net_pkt_find_offset(pkt, lladdr->addr);

	if (ll_addr_offset >= 0) {
 80553d1:	01 d0                	add    %edx,%eax
 80553d3:	89 c1                	mov    %eax,%ecx
 80553d5:	78 2a                	js     8055401 <clone_pkt_lladdr+0x71>
		net_pkt_cursor_init(clone_pkt);
 80553d7:	83 ec 0c             	sub    $0xc,%esp
 80553da:	53                   	push   %ebx
 80553db:	e8 74 fb ff ff       	call   8054f54 <net_pkt_cursor_init>
 80553e0:	58                   	pop    %eax
 80553e1:	5a                   	pop    %edx
		net_pkt_skip(clone_pkt, ll_addr_offset);
 80553e2:	51                   	push   %ecx
 80553e3:	53                   	push   %ebx
 80553e4:	e8 88 ff ff ff       	call   8055371 <net_pkt_skip>
	return pkt->cursor.pos;
 80553e9:	8b 43 10             	mov    0x10(%ebx),%eax
 80553ec:	83 c4 10             	add    $0x10,%esp
		lladdr->addr = net_pkt_cursor_get_pos(clone_pkt);
 80553ef:	89 06                	mov    %eax,(%esi)
 80553f1:	eb 0e                	jmp    8055401 <clone_pkt_lladdr+0x71>
		buf = buf->frags;
 80553f3:	8b 52 04             	mov    0x4(%edx),%edx
		offset += buf->len;
 80553f6:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
 80553f9:	66 01 4d e6          	add    %cx,-0x1a(%ebp)
	while (buf) {
 80553fd:	85 d2                	test   %edx,%edx
 80553ff:	75 b5                	jne    80553b6 <clone_pkt_lladdr+0x26>
	}
}
 8055401:	8d 65 f4             	lea    -0xc(%ebp),%esp
 8055404:	5b                   	pop    %ebx
 8055405:	5e                   	pop    %esi
 8055406:	5f                   	pop    %edi
 8055407:	5d                   	pop    %ebp
 8055408:	c3                   	ret    

08055409 <clone_pkt_attributes>:
	ARG_UNUSED(clone_pkt);
}
#endif

static void clone_pkt_attributes(struct net_pkt *pkt, struct net_pkt *clone_pkt)
{
 8055409:	55                   	push   %ebp
 805540a:	89 e5                	mov    %esp,%ebp
 805540c:	56                   	push   %esi
 805540d:	89 c6                	mov    %eax,%esi
 805540f:	53                   	push   %ebx
 8055410:	89 d3                	mov    %edx,%ebx
	pkt->family = family;
 8055412:	8a 50 33             	mov    0x33(%eax),%dl
 8055415:	8a 43 33             	mov    0x33(%ebx),%al
 8055418:	83 e2 e0             	and    $0xffffffe0,%edx
 805541b:	83 e0 1f             	and    $0x1f,%eax
 805541e:	09 d0                	or     %edx,%eax
 8055420:	88 43 33             	mov    %al,0x33(%ebx)
	return pkt->context;
 8055423:	8b 46 14             	mov    0x14(%esi),%eax
	pkt->context = ctx;
 8055426:	89 43 14             	mov    %eax,0x14(%ebx)
	return pkt->ip_hdr_len;
 8055429:	8a 46 32             	mov    0x32(%esi),%al
	pkt->ip_hdr_len = len;
 805542c:	88 43 32             	mov    %al,0x32(%ebx)
	pkt->ip_dscp = dscp;
 805542f:	8a 43 3c             	mov    0x3c(%ebx),%al
	return pkt->ip_dscp;
 8055432:	8a 56 3c             	mov    0x3c(%esi),%dl
	pkt->ip_dscp = dscp;
 8055435:	83 e0 c0             	and    $0xffffffc0,%eax
	return pkt->ip_dscp;
 8055438:	83 e2 3f             	and    $0x3f,%edx
	pkt->ip_dscp = dscp;
 805543b:	09 d0                	or     %edx,%eax
 805543d:	88 43 3c             	mov    %al,0x3c(%ebx)
	pkt->ip_ecn = ecn;
 8055440:	8a 56 3c             	mov    0x3c(%esi),%dl
 8055443:	83 e0 3f             	and    $0x3f,%eax
 8055446:	83 e2 c0             	and    $0xffffffc0,%edx
 8055449:	09 d0                	or     %edx,%eax
 805544b:	88 43 3c             	mov    %al,0x3c(%ebx)
	return pkt->priority;
 805544e:	8a 46 3d             	mov    0x3d(%esi),%al
	pkt->priority = priority;
 8055451:	88 43 3d             	mov    %al,0x3d(%ebx)
	pkt->captured = is_captured;
 8055454:	8a 43 34             	mov    0x34(%ebx),%al
 8055457:	8a 56 34             	mov    0x34(%esi),%dl
 805545a:	83 e0 fd             	and    $0xfffffffd,%eax
 805545d:	83 e2 02             	and    $0x2,%edx
 8055460:	09 d0                	or     %edx,%eax
 8055462:	88 43 34             	mov    %al,0x34(%ebx)
	pkt->l2_processed = is_l2_processed;
 8055465:	8a 56 34             	mov    0x34(%esi),%dl
 8055468:	83 e0 f7             	and    $0xfffffff7,%eax
 805546b:	83 e2 08             	and    $0x8,%edx
 805546e:	09 d0                	or     %edx,%eax
 8055470:	88 43 34             	mov    %al,0x34(%ebx)
	return pkt->ll_proto_type;
 8055473:	8b 46 30             	mov    0x30(%esi),%eax
	pkt->ll_proto_type = type;
 8055476:	66 89 43 30          	mov    %ax,0x30(%ebx)

	net_pkt_set_l2_bridged(clone_pkt, net_pkt_is_l2_bridged(pkt));
	net_pkt_set_l2_processed(clone_pkt, net_pkt_is_l2_processed(pkt));
	net_pkt_set_ll_proto_type(clone_pkt, net_pkt_ll_proto_type(pkt));

	if (pkt->buffer && clone_pkt->buffer) {
 805547a:	83 7e 08 00          	cmpl   $0x0,0x8(%esi)
 805547e:	74 3c                	je     80554bc <clone_pkt_attributes+0xb3>
 8055480:	8b 4b 08             	mov    0x8(%ebx),%ecx
 8055483:	85 c9                	test   %ecx,%ecx
 8055485:	74 35                	je     80554bc <clone_pkt_attributes+0xb3>
  return __builtin___memcpy_chk (__dest, __src, __len,
 8055487:	8b 46 20             	mov    0x20(%esi),%eax
 805548a:	8b 56 24             	mov    0x24(%esi),%edx
 805548d:	89 43 20             	mov    %eax,0x20(%ebx)
 8055490:	89 53 24             	mov    %edx,0x24(%ebx)
 8055493:	8b 46 28             	mov    0x28(%esi),%eax
 8055496:	8b 56 2c             	mov    0x2c(%esi),%edx
 8055499:	89 43 28             	mov    %eax,0x28(%ebx)
 805549c:	89 53 2c             	mov    %edx,0x2c(%ebx)
		 * into the fragment memory of the buffer,
		 * otherwise we have to set the ll address pointer
		 * relative to the new buffer to avoid dangling
		 * pointers into the source packet.
		 */
		if (pkt->buffer != clone_pkt->buffer) {
 805549f:	3b 4e 08             	cmp    0x8(%esi),%ecx
 80554a2:	74 18                	je     80554bc <clone_pkt_attributes+0xb3>
	return &pkt->lladdr_src;
 80554a4:	8d 4b 20             	lea    0x20(%ebx),%ecx
			clone_pkt_lladdr(pkt, clone_pkt, net_pkt_lladdr_src(clone_pkt));
 80554a7:	89 da                	mov    %ebx,%edx
 80554a9:	89 f0                	mov    %esi,%eax
 80554ab:	e8 e0 fe ff ff       	call   8055390 <clone_pkt_lladdr>
	return &pkt->lladdr_dst;
 80554b0:	8d 4b 28             	lea    0x28(%ebx),%ecx
			clone_pkt_lladdr(pkt, clone_pkt, net_pkt_lladdr_dst(clone_pkt));
 80554b3:	89 da                	mov    %ebx,%edx
 80554b5:	89 f0                	mov    %esi,%eax
 80554b7:	e8 d4 fe ff ff       	call   8055390 <clone_pkt_lladdr>
	return pkt->family;
 80554bc:	8a 46 33             	mov    0x33(%esi),%al
 80554bf:	c0 e8 05             	shr    $0x5,%al
		}
	}

	if (IS_ENABLED(CONFIG_NET_IPV4) && net_pkt_family(pkt) == AF_INET) {
 80554c2:	3c 01                	cmp    $0x1,%al
 80554c4:	75 0e                	jne    80554d4 <clone_pkt_attributes+0xcb>
	return pkt->ipv4_ttl;
 80554c6:	8a 46 35             	mov    0x35(%esi),%al
	pkt->ipv4_ttl = ttl;
 80554c9:	88 43 35             	mov    %al,0x35(%ebx)
	return pkt->ipv4_opts_len;
 80554cc:	8a 46 36             	mov    0x36(%esi),%al
	pkt->ipv4_opts_len = opts_len;
 80554cf:	88 43 36             	mov    %al,0x36(%ebx)
}
 80554d2:	eb 25                	jmp    80554f9 <clone_pkt_attributes+0xf0>
		net_pkt_set_ipv4_ttl(clone_pkt, net_pkt_ipv4_ttl(pkt));
		net_pkt_set_ipv4_opts_len(clone_pkt,
					  net_pkt_ipv4_opts_len(pkt));
	} else if (IS_ENABLED(CONFIG_NET_IPV6) &&
 80554d4:	3c 02                	cmp    $0x2,%al
 80554d6:	75 21                	jne    80554f9 <clone_pkt_attributes+0xf0>
	return pkt->ipv6_hop_limit;
 80554d8:	8a 46 35             	mov    0x35(%esi),%al
	pkt->ipv6_hop_limit = hop_limit;
 80554db:	88 43 35             	mov    %al,0x35(%ebx)
	return pkt->ipv6_ext_len;
 80554de:	66 8b 46 36          	mov    0x36(%esi),%ax
	pkt->ipv6_ext_len = len;
 80554e2:	66 89 43 36          	mov    %ax,0x36(%ebx)
	return pkt->ipv6_ext_opt_len;
 80554e6:	8a 46 3a             	mov    0x3a(%esi),%al
	pkt->ipv6_ext_opt_len = len;
 80554e9:	88 43 3a             	mov    %al,0x3a(%ebx)
	return pkt->ipv6_prev_hdr_start;
 80554ec:	8b 46 38             	mov    0x38(%esi),%eax
	pkt->ipv6_prev_hdr_start = offset;
 80554ef:	66 89 43 38          	mov    %ax,0x38(%ebx)
	return pkt->ipv6_next_hdr;
 80554f3:	8a 46 3b             	mov    0x3b(%esi),%al
	pkt->ipv6_next_hdr = next_hdr;
 80554f6:	88 43 3b             	mov    %al,0x3b(%ebx)
		net_pkt_set_ipv6_next_hdr(clone_pkt,
					  net_pkt_ipv6_next_hdr(pkt));
	}

	clone_pkt_cb(pkt, clone_pkt);
}
 80554f9:	5b                   	pop    %ebx
 80554fa:	5e                   	pop    %esi
 80554fb:	5d                   	pop    %ebp
 80554fc:	c3                   	ret    

080554fd <net_pkt_memset>:
{
 80554fd:	55                   	push   %ebp
 80554fe:	89 e5                	mov    %esp,%ebp
 8055500:	83 ec 10             	sub    $0x10,%esp
	return net_pkt_cursor_operate(pkt, &byte, amount, false, true);
 8055503:	8b 4d 10             	mov    0x10(%ebp),%ecx
 8055506:	8b 45 08             	mov    0x8(%ebp),%eax
 8055509:	6a 01                	push   $0x1
 805550b:	8d 55 0c             	lea    0xc(%ebp),%edx
 805550e:	6a 00                	push   $0x0
 8055510:	e8 b5 f6 ff ff       	call   8054bca <net_pkt_cursor_operate>
 8055515:	83 c4 10             	add    $0x10,%esp
}
 8055518:	c9                   	leave  
 8055519:	c3                   	ret    

0805551a <net_pkt_read>:
{
 805551a:	55                   	push   %ebp
 805551b:	89 e5                	mov    %esp,%ebp
 805551d:	8b 45 08             	mov    0x8(%ebp),%eax
 8055520:	8b 55 0c             	mov    0xc(%ebp),%edx
	return net_pkt_cursor_operate(pkt, data, length, true, false);
 8055523:	c7 45 08 01 00 00 00 	movl   $0x1,0x8(%ebp)
 805552a:	8b 4d 10             	mov    0x10(%ebp),%ecx
 805552d:	c7 45 0c 00 00 00 00 	movl   $0x0,0xc(%ebp)
}
 8055534:	5d                   	pop    %ebp
	return net_pkt_cursor_operate(pkt, data, length, true, false);
 8055535:	e9 90 f6 ff ff       	jmp    8054bca <net_pkt_cursor_operate>

0805553a <net_pkt_read_be32>:
{
 805553a:	55                   	push   %ebp
 805553b:	89 e5                	mov    %esp,%ebp
 805553d:	53                   	push   %ebx
 805553e:	83 ec 18             	sub    $0x18,%esp
 8055541:	8b 5d 0c             	mov    0xc(%ebp),%ebx
 8055544:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 805554a:	89 45 f4             	mov    %eax,-0xc(%ebp)
 805554d:	31 c0                	xor    %eax,%eax
	ret = net_pkt_read(pkt, d32, sizeof(uint32_t));
 805554f:	8d 45 f0             	lea    -0x10(%ebp),%eax
 8055552:	6a 04                	push   $0x4
 8055554:	50                   	push   %eax
 8055555:	ff 75 08             	push   0x8(%ebp)
 8055558:	e8 bd ff ff ff       	call   805551a <net_pkt_read>
 805555d:	8b 55 f0             	mov    -0x10(%ebp),%edx
 8055560:	83 c4 10             	add    $0x10,%esp
	*data = d32[0] << 24 | d32[1] << 16 | d32[2] << 8 | d32[3];
 8055563:	0f ca                	bswap  %edx
 8055565:	89 13                	mov    %edx,(%ebx)
}
 8055567:	8b 55 f4             	mov    -0xc(%ebp),%edx
 805556a:	65 2b 15 14 00 00 00 	sub    %gs:0x14,%edx
 8055571:	74 05                	je     8055578 <net_pkt_read_be32+0x3e>
 8055573:	e8 88 3d ff ff       	call   8049300 <__stack_chk_fail@plt>
 8055578:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 805557b:	c9                   	leave  
 805557c:	c3                   	ret    

0805557d <net_pkt_copy>:
{
 805557d:	55                   	push   %ebp
 805557e:	89 e5                	mov    %esp,%ebp
 8055580:	57                   	push   %edi
 8055581:	56                   	push   %esi
 8055582:	53                   	push   %ebx
 8055583:	83 ec 1c             	sub    $0x1c,%esp
	while (c_dst->buf && c_src->buf && length) {
 8055586:	8b 45 08             	mov    0x8(%ebp),%eax
 8055589:	83 78 0c 00          	cmpl   $0x0,0xc(%eax)
 805558d:	0f 84 dc 00 00 00    	je     805566f <net_pkt_copy+0xf2>
 8055593:	8b 45 0c             	mov    0xc(%ebp),%eax
 8055596:	83 78 0c 00          	cmpl   $0x0,0xc(%eax)
 805559a:	0f 84 cf 00 00 00    	je     805566f <net_pkt_copy+0xf2>
 80555a0:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
 80555a4:	0f 84 c1 00 00 00    	je     805566b <net_pkt_copy+0xee>
		pkt_cursor_advance(pkt_dst, true);
 80555aa:	8b 45 08             	mov    0x8(%ebp),%eax
 80555ad:	ba 01 00 00 00       	mov    $0x1,%edx
 80555b2:	e8 f6 f4 ff ff       	call   8054aad <pkt_cursor_advance>
		pkt_cursor_advance(pkt_src, false);
 80555b7:	8b 45 0c             	mov    0xc(%ebp),%eax
 80555ba:	31 d2                	xor    %edx,%edx
 80555bc:	e8 ec f4 ff ff       	call   8054aad <pkt_cursor_advance>
		if (!c_dst->buf || !c_src->buf) {
 80555c1:	8b 45 08             	mov    0x8(%ebp),%eax
 80555c4:	8b 40 0c             	mov    0xc(%eax),%eax
 80555c7:	85 c0                	test   %eax,%eax
 80555c9:	0f 84 a8 00 00 00    	je     8055677 <net_pkt_copy+0xfa>
 80555cf:	8b 7d 0c             	mov    0xc(%ebp),%edi
 80555d2:	8b 4f 0c             	mov    0xc(%edi),%ecx
 80555d5:	85 c9                	test   %ecx,%ecx
 80555d7:	0f 84 9a 00 00 00    	je     8055677 <net_pkt_copy+0xfa>
 80555dd:	83 ec 0c             	sub    $0xc,%esp
 80555e0:	83 c0 0c             	add    $0xc,%eax
		s_len = c_src->buf->len - (c_src->pos - c_src->buf->data);
 80555e3:	0f b7 71 10          	movzwl 0x10(%ecx),%esi
 80555e7:	8b 57 10             	mov    0x10(%edi),%edx
 80555ea:	2b 51 0c             	sub    0xc(%ecx),%edx
 80555ed:	50                   	push   %eax
 80555ee:	29 d6                	sub    %edx,%esi
 80555f0:	e8 a8 9c ff ff       	call   804f29d <net_buf_simple_max_len>
		d_len = net_buf_max_len(c_dst->buf) - (c_dst->pos - c_dst->buf->data);
 80555f5:	8b 4d 08             	mov    0x8(%ebp),%ecx
 80555f8:	83 c4 10             	add    $0x10,%esp
 80555fb:	0f b7 d8             	movzwl %ax,%ebx
 80555fe:	8b 51 10             	mov    0x10(%ecx),%edx
 8055601:	8b 41 0c             	mov    0xc(%ecx),%eax
 8055604:	89 d7                	mov    %edx,%edi
 8055606:	2b 78 0c             	sub    0xc(%eax),%edi
 8055609:	29 fb                	sub    %edi,%ebx
 805560b:	39 f3                	cmp    %esi,%ebx
 805560d:	0f 47 de             	cmova  %esi,%ebx
		if (length < s_len && length < d_len) {
 8055610:	3b 5d 10             	cmp    0x10(%ebp),%ebx
 8055613:	77 06                	ja     805561b <net_pkt_copy+0x9e>
		if (!len) {
 8055615:	85 db                	test   %ebx,%ebx
 8055617:	75 05                	jne    805561e <net_pkt_copy+0xa1>
 8055619:	eb 5c                	jmp    8055677 <net_pkt_copy+0xfa>
 805561b:	8b 5d 10             	mov    0x10(%ebp),%ebx
 805561e:	8b 45 0c             	mov    0xc(%ebp),%eax
 8055621:	89 d7                	mov    %edx,%edi
 8055623:	89 d9                	mov    %ebx,%ecx
 8055625:	8b 70 10             	mov    0x10(%eax),%esi
		if (!net_pkt_is_being_overwritten(pkt_dst)) {
 8055628:	8b 45 08             	mov    0x8(%ebp),%eax
 805562b:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
 805562d:	f6 40 33 01          	testb  $0x1,0x33(%eax)
 8055631:	75 15                	jne    8055648 <net_pkt_copy+0xcb>
	return net_buf_simple_add(&buf->b, len);
 8055633:	52                   	push   %edx
 8055634:	52                   	push   %edx
 8055635:	53                   	push   %ebx
 8055636:	8b 40 0c             	mov    0xc(%eax),%eax
 8055639:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 805563c:	83 c0 0c             	add    $0xc,%eax
 805563f:	50                   	push   %eax
 8055640:	e8 f8 9b ff ff       	call   804f23d <net_buf_simple_add>
 8055645:	83 c4 10             	add    $0x10,%esp
		pkt_cursor_update(pkt_dst, len, true);
 8055648:	8b 45 08             	mov    0x8(%ebp),%eax
 805564b:	b9 01 00 00 00       	mov    $0x1,%ecx
 8055650:	89 da                	mov    %ebx,%edx
 8055652:	e8 ad f4 ff ff       	call   8054b04 <pkt_cursor_update>
		pkt_cursor_update(pkt_src, len, false);
 8055657:	8b 45 0c             	mov    0xc(%ebp),%eax
 805565a:	31 c9                	xor    %ecx,%ecx
 805565c:	89 da                	mov    %ebx,%edx
 805565e:	e8 a1 f4 ff ff       	call   8054b04 <pkt_cursor_update>
		length -= len;
 8055663:	29 5d 10             	sub    %ebx,0x10(%ebp)
 8055666:	e9 1b ff ff ff       	jmp    8055586 <net_pkt_copy+0x9>
	return 0;
 805566b:	31 c0                	xor    %eax,%eax
 805566d:	eb 0d                	jmp    805567c <net_pkt_copy+0xff>
 805566f:	31 c0                	xor    %eax,%eax
	if (length) {
 8055671:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
 8055675:	74 05                	je     805567c <net_pkt_copy+0xff>
		return -ENOBUFS;
 8055677:	b8 97 ff ff ff       	mov    $0xffffff97,%eax
}
 805567c:	8d 65 f4             	lea    -0xc(%ebp),%esp
 805567f:	5b                   	pop    %ebx
 8055680:	5e                   	pop    %esi
 8055681:	5f                   	pop    %edi
 8055682:	5d                   	pop    %ebp
 8055683:	c3                   	ret    

08055684 <net_pkt_remaining_data>:

	return clone_pkt;
}

size_t net_pkt_remaining_data(struct net_pkt *pkt)
{
 8055684:	55                   	push   %ebp
	struct net_buf *buf;
	size_t data_length;

	if (!pkt || !pkt->cursor.buf || !pkt->cursor.pos) {
		return 0;
 8055685:	31 c0                	xor    %eax,%eax
{
 8055687:	89 e5                	mov    %esp,%ebp
 8055689:	8b 4d 08             	mov    0x8(%ebp),%ecx
	if (!pkt || !pkt->cursor.buf || !pkt->cursor.pos) {
 805568c:	85 c9                	test   %ecx,%ecx
 805568e:	74 26                	je     80556b6 <net_pkt_remaining_data+0x32>
 8055690:	8b 51 0c             	mov    0xc(%ecx),%edx
 8055693:	85 d2                	test   %edx,%edx
 8055695:	74 1f                	je     80556b6 <net_pkt_remaining_data+0x32>
 8055697:	8b 49 10             	mov    0x10(%ecx),%ecx
 805569a:	85 c9                	test   %ecx,%ecx
 805569c:	74 18                	je     80556b6 <net_pkt_remaining_data+0x32>
	}

	buf = pkt->cursor.buf;
	data_length = buf->len - (pkt->cursor.pos - buf->data);
 805569e:	0f b7 42 10          	movzwl 0x10(%edx),%eax
 80556a2:	2b 4a 0c             	sub    0xc(%edx),%ecx
 80556a5:	29 c8                	sub    %ecx,%eax

	buf = buf->frags;
	while (buf) {
		data_length += buf->len;
		buf = buf->frags;
 80556a7:	8b 52 04             	mov    0x4(%edx),%edx
	while (buf) {
 80556aa:	85 d2                	test   %edx,%edx
 80556ac:	74 08                	je     80556b6 <net_pkt_remaining_data+0x32>
		data_length += buf->len;
 80556ae:	0f b7 4a 10          	movzwl 0x10(%edx),%ecx
 80556b2:	01 c8                	add    %ecx,%eax
 80556b4:	eb f1                	jmp    80556a7 <net_pkt_remaining_data+0x23>
	}

	return data_length;
}
 80556b6:	5d                   	pop    %ebp
 80556b7:	c3                   	ret    

080556b8 <net_pkt_update_length>:

int net_pkt_update_length(struct net_pkt *pkt, size_t length)
{
 80556b8:	55                   	push   %ebp
 80556b9:	89 e5                	mov    %esp,%ebp
	struct net_buf *buf;

	for (buf = pkt->buffer; buf; buf = buf->frags) {
 80556bb:	8b 55 08             	mov    0x8(%ebp),%edx
{
 80556be:	8b 45 0c             	mov    0xc(%ebp),%eax
	for (buf = pkt->buffer; buf; buf = buf->frags) {
 80556c1:	8b 52 08             	mov    0x8(%edx),%edx
 80556c4:	85 d2                	test   %edx,%edx
 80556c6:	74 17                	je     80556df <net_pkt_update_length+0x27>
		if (buf->len < length) {
 80556c8:	0f b7 4a 10          	movzwl 0x10(%edx),%ecx
 80556cc:	39 c1                	cmp    %eax,%ecx
 80556ce:	73 04                	jae    80556d4 <net_pkt_update_length+0x1c>
			length -= buf->len;
 80556d0:	29 c8                	sub    %ecx,%eax
 80556d2:	eb 06                	jmp    80556da <net_pkt_update_length+0x22>
		} else {
			buf->len = length;
 80556d4:	66 89 42 10          	mov    %ax,0x10(%edx)
			length = 0;
 80556d8:	31 c0                	xor    %eax,%eax
	for (buf = pkt->buffer; buf; buf = buf->frags) {
 80556da:	8b 52 04             	mov    0x4(%edx),%edx
 80556dd:	eb e5                	jmp    80556c4 <net_pkt_update_length+0xc>
		}
	}

	return !length ? 0 : -EINVAL;
 80556df:	f7 d8                	neg    %eax
}
 80556e1:	5d                   	pop    %ebp
	return !length ? 0 : -EINVAL;
 80556e2:	19 c0                	sbb    %eax,%eax
 80556e4:	83 e0 ea             	and    $0xffffffea,%eax
}
 80556e7:	c3                   	ret    

080556e8 <net_pkt_get_current_offset>:

	return 0;
}

uint16_t net_pkt_get_current_offset(struct net_pkt *pkt)
{
 80556e8:	55                   	push   %ebp
	struct net_buf *buf = pkt->buffer;
	uint16_t offset;

	if (!pkt->cursor.buf || !pkt->cursor.pos) {
		return 0;
 80556e9:	31 c0                	xor    %eax,%eax
{
 80556eb:	89 e5                	mov    %esp,%ebp
 80556ed:	53                   	push   %ebx
 80556ee:	8b 4d 08             	mov    0x8(%ebp),%ecx
	if (!pkt->cursor.buf || !pkt->cursor.pos) {
 80556f1:	8b 59 0c             	mov    0xc(%ecx),%ebx
 80556f4:	85 db                	test   %ebx,%ebx
 80556f6:	74 1b                	je     8055713 <net_pkt_get_current_offset+0x2b>
 80556f8:	8b 51 10             	mov    0x10(%ecx),%edx
 80556fb:	85 d2                	test   %edx,%edx
 80556fd:	74 14                	je     8055713 <net_pkt_get_current_offset+0x2b>
	struct net_buf *buf = pkt->buffer;
 80556ff:	8b 49 08             	mov    0x8(%ecx),%ecx
	}

	offset = 0U;

	while (buf != pkt->cursor.buf) {
 8055702:	39 cb                	cmp    %ecx,%ebx
 8055704:	74 08                	je     805570e <net_pkt_get_current_offset+0x26>
		offset += buf->len;
 8055706:	03 41 10             	add    0x10(%ecx),%eax
		buf = buf->frags;
 8055709:	8b 49 04             	mov    0x4(%ecx),%ecx
 805570c:	eb f4                	jmp    8055702 <net_pkt_get_current_offset+0x1a>
	}

	offset += pkt->cursor.pos - buf->data;
 805570e:	2b 53 0c             	sub    0xc(%ebx),%edx
 8055711:	01 d0                	add    %edx,%eax

	return offset;
}
 8055713:	5b                   	pop    %ebx
 8055714:	5d                   	pop    %ebp
 8055715:	c3                   	ret    

08055716 <net_pkt_clone_internal>:
{
 8055716:	55                   	push   %ebp
 8055717:	89 e5                	mov    %esp,%ebp
 8055719:	57                   	push   %edi
 805571a:	56                   	push   %esi
 805571b:	89 d6                	mov    %edx,%esi
 805571d:	53                   	push   %ebx
 805571e:	89 c3                	mov    %eax,%ebx
 8055720:	83 ec 28             	sub    $0x28,%esp
	size_t cursor_offset = net_pkt_get_current_offset(pkt);
 8055723:	50                   	push   %eax
 8055724:	e8 bf ff ff ff       	call   80556e8 <net_pkt_get_current_offset>
 8055729:	83 c4 10             	add    $0x10,%esp
 805572c:	66 89 45 dc          	mov    %ax,-0x24(%ebp)
	return pkt->overwrite;
 8055730:	8a 43 33             	mov    0x33(%ebx),%al
 8055733:	83 e0 01             	and    $0x1,%eax
 8055736:	88 45 e7             	mov    %al,-0x19(%ebp)
	clone_pkt = pkt_alloc_with_buffer(slab, net_pkt_iface(pkt),
 8055739:	8b 43 08             	mov    0x8(%ebx),%eax
 805573c:	e8 75 f4 ff ff       	call   8054bb6 <net_pkt_get_len.isra.0>
 8055741:	ff 75 0c             	push   0xc(%ebp)
 8055744:	8b 53 18             	mov    0x18(%ebx),%edx
 8055747:	ff 75 08             	push   0x8(%ebp)
 805574a:	89 c1                	mov    %eax,%ecx
 805574c:	89 f0                	mov    %esi,%eax
 805574e:	6a 00                	push   $0x0
 8055750:	6a 00                	push   $0x0
 8055752:	e8 ff fa ff ff       	call   8055256 <pkt_alloc_with_buffer>
 8055757:	83 c4 10             	add    $0x10,%esp
 805575a:	89 c6                	mov    %eax,%esi
	if (!clone_pkt) {
 805575c:	85 c0                	test   %eax,%eax
 805575e:	0f 84 aa 00 00 00    	je     805580e <net_pkt_clone_internal+0xf8>
	net_pkt_cursor_init(pkt);
 8055764:	83 ec 0c             	sub    $0xc,%esp
	pkt->overwrite = overwrite;
 8055767:	80 4b 33 01          	orb    $0x1,0x33(%ebx)
	backup->pos = pkt->cursor.pos;
 805576b:	8b 43 10             	mov    0x10(%ebx),%eax
 805576e:	53                   	push   %ebx
	backup->buf = pkt->cursor.buf;
 805576f:	8b 7b 0c             	mov    0xc(%ebx),%edi
	backup->pos = pkt->cursor.pos;
 8055772:	89 45 e0             	mov    %eax,-0x20(%ebp)
 8055775:	e8 da f7 ff ff       	call   8054f54 <net_pkt_cursor_init>
	if (net_pkt_copy(clone_pkt, pkt, net_pkt_get_len(pkt))) {
 805577a:	8b 43 08             	mov    0x8(%ebx),%eax
	net_pkt_cursor_init(pkt);
 805577d:	83 c4 10             	add    $0x10,%esp
	if (net_pkt_copy(clone_pkt, pkt, net_pkt_get_len(pkt))) {
 8055780:	e8 31 f4 ff ff       	call   8054bb6 <net_pkt_get_len.isra.0>
 8055785:	52                   	push   %edx
 8055786:	50                   	push   %eax
 8055787:	53                   	push   %ebx
 8055788:	56                   	push   %esi
 8055789:	e8 ef fd ff ff       	call   805557d <net_pkt_copy>
 805578e:	83 c4 10             	add    $0x10,%esp
 8055791:	85 c0                	test   %eax,%eax
 8055793:	74 25                	je     80557ba <net_pkt_clone_internal+0xa4>
		net_pkt_unref(clone_pkt);
 8055795:	83 ec 0c             	sub    $0xc,%esp
 8055798:	56                   	push   %esi
		return NULL;
 8055799:	31 f6                	xor    %esi,%esi
		net_pkt_unref(clone_pkt);
 805579b:	e8 48 f6 ff ff       	call   8054de8 <net_pkt_unref>
	pkt->cursor.pos = backup->pos;
 80557a0:	8b 45 e0             	mov    -0x20(%ebp),%eax
	pkt->cursor.buf = backup->buf;
 80557a3:	89 7b 0c             	mov    %edi,0xc(%ebx)
 80557a6:	83 c4 10             	add    $0x10,%esp
	pkt->cursor.pos = backup->pos;
 80557a9:	89 43 10             	mov    %eax,0x10(%ebx)
	pkt->overwrite = overwrite;
 80557ac:	8a 43 33             	mov    0x33(%ebx),%al
 80557af:	83 e0 fe             	and    $0xfffffffe,%eax
 80557b2:	0a 45 e7             	or     -0x19(%ebp),%al
 80557b5:	88 43 33             	mov    %al,0x33(%ebx)
		return NULL;
 80557b8:	eb 54                	jmp    805580e <net_pkt_clone_internal+0xf8>
 80557ba:	80 4e 33 01          	orb    $0x1,0x33(%esi)
	size_t cursor_offset = net_pkt_get_current_offset(pkt);
 80557be:	0f b7 4d dc          	movzwl -0x24(%ebp),%ecx
	clone_pkt_attributes(pkt, clone_pkt);
 80557c2:	89 f2                	mov    %esi,%edx
 80557c4:	89 d8                	mov    %ebx,%eax
	size_t cursor_offset = net_pkt_get_current_offset(pkt);
 80557c6:	89 4d dc             	mov    %ecx,-0x24(%ebp)
	clone_pkt_attributes(pkt, clone_pkt);
 80557c9:	e8 3b fc ff ff       	call   8055409 <clone_pkt_attributes>
	net_pkt_cursor_init(clone_pkt);
 80557ce:	83 ec 0c             	sub    $0xc,%esp
 80557d1:	56                   	push   %esi
 80557d2:	e8 7d f7 ff ff       	call   8054f54 <net_pkt_cursor_init>
	if (cursor_offset) {
 80557d7:	8b 4d dc             	mov    -0x24(%ebp),%ecx
	net_pkt_cursor_init(clone_pkt);
 80557da:	83 c4 10             	add    $0x10,%esp
	if (cursor_offset) {
 80557dd:	85 c9                	test   %ecx,%ecx
 80557df:	74 0c                	je     80557ed <net_pkt_clone_internal+0xd7>
		net_pkt_skip(clone_pkt, cursor_offset);
 80557e1:	50                   	push   %eax
 80557e2:	50                   	push   %eax
 80557e3:	51                   	push   %ecx
 80557e4:	56                   	push   %esi
 80557e5:	e8 87 fb ff ff       	call   8055371 <net_pkt_skip>
 80557ea:	83 c4 10             	add    $0x10,%esp
 80557ed:	8a 46 33             	mov    0x33(%esi),%al
 80557f0:	83 e0 fe             	and    $0xfffffffe,%eax
 80557f3:	0a 45 e7             	or     -0x19(%ebp),%al
 80557f6:	88 46 33             	mov    %al,0x33(%esi)
	pkt->cursor.pos = backup->pos;
 80557f9:	8b 45 e0             	mov    -0x20(%ebp),%eax
	pkt->cursor.buf = backup->buf;
 80557fc:	89 7b 0c             	mov    %edi,0xc(%ebx)
	pkt->cursor.pos = backup->pos;
 80557ff:	89 43 10             	mov    %eax,0x10(%ebx)
	pkt->overwrite = overwrite;
 8055802:	8a 43 33             	mov    0x33(%ebx),%al
 8055805:	83 e0 fe             	and    $0xfffffffe,%eax
 8055808:	0a 45 e7             	or     -0x19(%ebp),%al
 805580b:	88 43 33             	mov    %al,0x33(%ebx)
}
 805580e:	8d 65 f4             	lea    -0xc(%ebp),%esp
 8055811:	89 f0                	mov    %esi,%eax
 8055813:	5b                   	pop    %ebx
 8055814:	5e                   	pop    %esi
 8055815:	5f                   	pop    %edi
 8055816:	5d                   	pop    %ebp
 8055817:	c3                   	ret    

08055818 <net_pkt_clone>:
{
 8055818:	55                   	push   %ebp
 8055819:	89 e5                	mov    %esp,%ebp
 805581b:	53                   	push   %ebx
 805581c:	8b 45 08             	mov    0x8(%ebp),%eax
	return net_pkt_clone_internal(pkt, pkt->slab, timeout);
 805581f:	8b 4d 0c             	mov    0xc(%ebp),%ecx
 8055822:	8b 5d 10             	mov    0x10(%ebp),%ebx
 8055825:	8b 50 04             	mov    0x4(%eax),%edx
 8055828:	89 4d 08             	mov    %ecx,0x8(%ebp)
 805582b:	89 5d 0c             	mov    %ebx,0xc(%ebp)
}
 805582e:	5b                   	pop    %ebx
 805582f:	5d                   	pop    %ebp
	return net_pkt_clone_internal(pkt, pkt->slab, timeout);
 8055830:	e9 e1 fe ff ff       	jmp    8055716 <net_pkt_clone_internal>

08055835 <net_pkt_get_contiguous_len>:

	return len >= size;
}

size_t net_pkt_get_contiguous_len(struct net_pkt *pkt)
{
 8055835:	55                   	push   %ebp
 8055836:	89 e5                	mov    %esp,%ebp
 8055838:	53                   	push   %ebx
 8055839:	51                   	push   %ecx
 805583a:	8b 5d 08             	mov    0x8(%ebp),%ebx
	return pkt->overwrite;
 805583d:	8a 53 33             	mov    0x33(%ebx),%dl
	pkt_cursor_advance(pkt, !net_pkt_is_being_overwritten(pkt));
 8055840:	89 d8                	mov    %ebx,%eax
 8055842:	83 e2 01             	and    $0x1,%edx
 8055845:	83 f2 01             	xor    $0x1,%edx
 8055848:	0f b6 d2             	movzbl %dl,%edx
 805584b:	e8 5d f2 ff ff       	call   8054aad <pkt_cursor_advance>

	if (pkt->cursor.buf && pkt->cursor.pos) {
 8055850:	8b 4b 0c             	mov    0xc(%ebx),%ecx
			pkt->cursor.buf->len : pkt->cursor.buf->size;
		len -= pkt->cursor.pos - pkt->cursor.buf->data;
		return len;
	}

	return 0;
 8055853:	31 c0                	xor    %eax,%eax
	if (pkt->cursor.buf && pkt->cursor.pos) {
 8055855:	85 c9                	test   %ecx,%ecx
 8055857:	74 1c                	je     8055875 <net_pkt_get_contiguous_len+0x40>
 8055859:	8b 53 10             	mov    0x10(%ebx),%edx
 805585c:	85 d2                	test   %edx,%edx
 805585e:	74 15                	je     8055875 <net_pkt_get_contiguous_len+0x40>
			pkt->cursor.buf->len : pkt->cursor.buf->size;
 8055860:	f6 43 33 01          	testb  $0x1,0x33(%ebx)
 8055864:	74 06                	je     805586c <net_pkt_get_contiguous_len+0x37>
 8055866:	0f b7 41 10          	movzwl 0x10(%ecx),%eax
 805586a:	eb 04                	jmp    8055870 <net_pkt_get_contiguous_len+0x3b>
 805586c:	0f b7 41 12          	movzwl 0x12(%ecx),%eax
		len -= pkt->cursor.pos - pkt->cursor.buf->data;
 8055870:	2b 51 0c             	sub    0xc(%ecx),%edx
 8055873:	29 d0                	sub    %edx,%eax
}
 8055875:	5a                   	pop    %edx
 8055876:	5b                   	pop    %ebx
 8055877:	5d                   	pop    %ebp
 8055878:	c3                   	ret    

08055879 <net_pkt_write>:
{
 8055879:	55                   	push   %ebp
 805587a:	89 e5                	mov    %esp,%ebp
 805587c:	53                   	push   %ebx
 805587d:	83 ec 14             	sub    $0x14,%esp
 8055880:	8b 5d 08             	mov    0x8(%ebp),%ebx
 8055883:	8b 55 0c             	mov    0xc(%ebp),%edx
 8055886:	8b 4d 10             	mov    0x10(%ebp),%ecx
	if (data == pkt->cursor.pos && net_pkt_is_contiguous(pkt, length)) {
 8055889:	3b 53 10             	cmp    0x10(%ebx),%edx
 805588c:	75 2b                	jne    80558b9 <net_pkt_write+0x40>
	size_t len = net_pkt_get_contiguous_len(pkt);
 805588e:	83 ec 0c             	sub    $0xc,%esp
 8055891:	89 4d f0             	mov    %ecx,-0x10(%ebp)
 8055894:	53                   	push   %ebx
 8055895:	89 55 f4             	mov    %edx,-0xc(%ebp)
 8055898:	e8 98 ff ff ff       	call   8055835 <net_pkt_get_contiguous_len>
	if (data == pkt->cursor.pos && net_pkt_is_contiguous(pkt, length)) {
 805589d:	8b 4d f0             	mov    -0x10(%ebp),%ecx
	size_t len = net_pkt_get_contiguous_len(pkt);
 80558a0:	83 c4 10             	add    $0x10,%esp
	if (data == pkt->cursor.pos && net_pkt_is_contiguous(pkt, length)) {
 80558a3:	8b 55 f4             	mov    -0xc(%ebp),%edx
 80558a6:	39 c1                	cmp    %eax,%ecx
 80558a8:	77 0f                	ja     80558b9 <net_pkt_write+0x40>
		return net_pkt_skip(pkt, length);
 80558aa:	89 5d 08             	mov    %ebx,0x8(%ebp)
}
 80558ad:	8b 5d fc             	mov    -0x4(%ebp),%ebx
		return net_pkt_skip(pkt, length);
 80558b0:	89 4d 0c             	mov    %ecx,0xc(%ebp)
}
 80558b3:	c9                   	leave  
		return net_pkt_skip(pkt, length);
 80558b4:	e9 b8 fa ff ff       	jmp    8055371 <net_pkt_skip>
	return net_pkt_cursor_operate(pkt, (void *)data, length, true, true);
 80558b9:	c7 45 0c 01 00 00 00 	movl   $0x1,0xc(%ebp)
 80558c0:	89 d8                	mov    %ebx,%eax
}
 80558c2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
	return net_pkt_cursor_operate(pkt, (void *)data, length, true, true);
 80558c5:	c7 45 08 01 00 00 00 	movl   $0x1,0x8(%ebp)
}
 80558cc:	c9                   	leave  
	return net_pkt_cursor_operate(pkt, (void *)data, length, true, true);
 80558cd:	e9 f8 f2 ff ff       	jmp    8054bca <net_pkt_cursor_operate>

080558d2 <net_pkt_get_data>:

void *net_pkt_get_data(struct net_pkt *pkt,
		       struct net_pkt_data_access *access)
{
 80558d2:	55                   	push   %ebp
 80558d3:	89 e5                	mov    %esp,%ebp
 80558d5:	57                   	push   %edi
 80558d6:	56                   	push   %esi
 80558d7:	53                   	push   %ebx
 80558d8:	83 ec 28             	sub    $0x28,%esp
 80558db:	8b 5d 08             	mov    0x8(%ebp),%ebx
 80558de:	8b 75 0c             	mov    0xc(%ebp),%esi
			return NULL;
		}

		return pkt->cursor.pos;
	} else {
		if (net_pkt_is_contiguous(pkt, access->size)) {
 80558e1:	8b 7e 04             	mov    0x4(%esi),%edi
	size_t len = net_pkt_get_contiguous_len(pkt);
 80558e4:	53                   	push   %ebx
 80558e5:	e8 4b ff ff ff       	call   8055835 <net_pkt_get_contiguous_len>
 80558ea:	83 c4 10             	add    $0x10,%esp
		if (net_pkt_is_contiguous(pkt, access->size)) {
 80558ed:	39 c7                	cmp    %eax,%edi
 80558ef:	77 07                	ja     80558f8 <net_pkt_get_data+0x26>
			access->data = pkt->cursor.pos;
 80558f1:	8b 43 10             	mov    0x10(%ebx),%eax
 80558f4:	89 06                	mov    %eax,(%esi)
 80558f6:	eb 34                	jmp    805592c <net_pkt_get_data+0x5a>
		} else if (net_pkt_is_being_overwritten(pkt)) {
			struct net_pkt_cursor backup;

			if (!access->data) {
 80558f8:	8b 06                	mov    (%esi),%eax
		} else if (net_pkt_is_being_overwritten(pkt)) {
 80558fa:	f6 43 33 01          	testb  $0x1,0x33(%ebx)
 80558fe:	74 2c                	je     805592c <net_pkt_get_data+0x5a>
			if (!access->data) {
 8055900:	85 c0                	test   %eax,%eax
 8055902:	74 2a                	je     805592e <net_pkt_get_data+0x5c>
	backup->buf = pkt->cursor.buf;
 8055904:	8b 53 0c             	mov    0xc(%ebx),%edx
	backup->pos = pkt->cursor.pos;
 8055907:	8b 7b 10             	mov    0x10(%ebx),%edi
	backup->buf = pkt->cursor.buf;
 805590a:	89 55 e4             	mov    %edx,-0x1c(%ebp)
				return NULL;
			}

			net_pkt_cursor_backup(pkt, &backup);

			if (net_pkt_read(pkt, access->data, access->size)) {
 805590d:	52                   	push   %edx
 805590e:	ff 76 04             	push   0x4(%esi)
 8055911:	50                   	push   %eax
 8055912:	53                   	push   %ebx
 8055913:	e8 02 fc ff ff       	call   805551a <net_pkt_read>
 8055918:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 805591b:	83 c4 10             	add    $0x10,%esp
	pkt->cursor.pos = backup->pos;
 805591e:	89 7b 10             	mov    %edi,0x10(%ebx)
 8055921:	85 c0                	test   %eax,%eax
	pkt->cursor.buf = backup->buf;
 8055923:	89 53 0c             	mov    %edx,0xc(%ebx)
 8055926:	74 04                	je     805592c <net_pkt_get_data+0x5a>
				net_pkt_cursor_restore(pkt, &backup);
				return NULL;
 8055928:	31 c0                	xor    %eax,%eax
 805592a:	eb 02                	jmp    805592e <net_pkt_get_data+0x5c>
			}

			net_pkt_cursor_restore(pkt, &backup);
		}

		return access->data;
 805592c:	8b 06                	mov    (%esi),%eax
	}

	return NULL;
}
 805592e:	8d 65 f4             	lea    -0xc(%ebp),%esp
 8055931:	5b                   	pop    %ebx
 8055932:	5e                   	pop    %esi
 8055933:	5f                   	pop    %edi
 8055934:	5d                   	pop    %ebp
 8055935:	c3                   	ret    

08055936 <net_pkt_set_data>:

int net_pkt_set_data(struct net_pkt *pkt,
		     struct net_pkt_data_access *access)
{
 8055936:	55                   	push   %ebp
 8055937:	89 e5                	mov    %esp,%ebp
 8055939:	83 ec 0c             	sub    $0xc,%esp
 805593c:	8b 45 0c             	mov    0xc(%ebp),%eax
	if (IS_ENABLED(CONFIG_NET_HEADERS_ALWAYS_CONTIGUOUS)) {
		return net_pkt_skip(pkt, access->size);
	}

	return net_pkt_write(pkt, access->data, access->size);
 805593f:	ff 70 04             	push   0x4(%eax)
 8055942:	ff 30                	push   (%eax)
 8055944:	ff 75 08             	push   0x8(%ebp)
 8055947:	e8 2d ff ff ff       	call   8055879 <net_pkt_write>
 805594c:	83 c4 10             	add    $0x10,%esp
}
 805594f:	c9                   	leave  
 8055950:	c3                   	ret    

08055951 <net_pkt_init>:
		(size_t)(k_mem_slab_num_free_get(&tx_pkts) *
			 sizeof(struct net_pkt)),
		get_frees(&rx_bufs), get_size(&rx_bufs),
		get_frees(&tx_bufs), get_size(&tx_bufs));
#endif
}
 8055951:	c3                   	ret    

08055952 <tc_rx_handler>:
#endif
#endif

#if NET_TC_RX_COUNT > 0
static void tc_rx_handler(struct k_fifo *fifo)
{
 8055952:	55                   	push   %ebp
 8055953:	89 e5                	mov    %esp,%ebp
 8055955:	83 ec 08             	sub    $0x8,%esp
	return z_impl_k_queue_get(queue, timeout);
 8055958:	50                   	push   %eax
 8055959:	6a ff                	push   $0xffffffff
 805595b:	6a ff                	push   $0xffffffff
 805595d:	ff 75 08             	push   0x8(%ebp)
 8055960:	e8 d6 9b 00 00       	call   805f53b <z_impl_k_queue_get>
 8055965:	83 c4 10             	add    $0x10,%esp
	struct net_pkt *pkt;

	while (1) {
		pkt = k_fifo_get(fifo, K_FOREVER);
		if (pkt == NULL) {
 8055968:	85 c0                	test   %eax,%eax
 805596a:	74 ec                	je     8055958 <tc_rx_handler+0x6>
			continue;
		}

		net_process_rx_packet(pkt);
 805596c:	83 ec 0c             	sub    $0xc,%esp
 805596f:	50                   	push   %eax
 8055970:	e8 af ac ff ff       	call   8050624 <net_process_rx_packet>
 8055975:	83 c4 10             	add    $0x10,%esp
 8055978:	eb de                	jmp    8055958 <tc_rx_handler+0x6>

0805597a <net_tc_submit_to_rx_queue>:
{
 805597a:	55                   	push   %ebp
 805597b:	89 e5                	mov    %esp,%ebp
	k_fifo_put(queue, pkt);
 805597d:	0f b6 45 08          	movzbl 0x8(%ebp),%eax
 8055981:	6b c0 70             	imul   $0x70,%eax,%eax
 8055984:	05 60 82 06 08       	add    $0x8068260,%eax
 8055989:	89 45 08             	mov    %eax,0x8(%ebp)
}
 805598c:	5d                   	pop    %ebp
	k_fifo_put(queue, pkt);
 805598d:	e9 6b 9b 00 00       	jmp    805f4fd <k_queue_append>

08055992 <net_tx_priority2tc>:
}
 8055992:	31 c0                	xor    %eax,%eax
 8055994:	c3                   	ret    

08055995 <net_rx_priority2tc>:
{
 8055995:	55                   	push   %ebp
 8055996:	89 e5                	mov    %esp,%ebp
 8055998:	8b 55 08             	mov    0x8(%ebp),%edx
}
 805599b:	5d                   	pop    %ebp
{
 805599c:	0f b6 c2             	movzbl %dl,%eax
		prio = NET_PRIORITY_BE;
 805599f:	80 fa 08             	cmp    $0x8,%dl
 80559a2:	ba 00 00 00 00       	mov    $0x0,%edx
 80559a7:	0f 43 c2             	cmovae %edx,%eax
	return rx_prio2tc_map[prio];
 80559aa:	0f b6 80 88 24 06 08 	movzbl 0x8062488(%eax),%eax
}
 80559b1:	c3                   	ret    

080559b2 <net_tc_tx_init>:
		}

		k_thread_start(tid);
	}
#endif
}
 80559b2:	c3                   	ret    

080559b3 <net_tc_rx_init>:

void net_tc_rx_init(void)
{
 80559b3:	55                   	push   %ebp
 80559b4:	89 e5                	mov    %esp,%ebp
 80559b6:	83 ec 14             	sub    $0x14,%esp
	z_impl_k_queue_init(queue);
 80559b9:	68 60 82 06 08       	push   $0x8068260
 80559be:	e8 b2 9a 00 00       	call   805f475 <z_impl_k_queue_init>
 80559c3:	83 c4 0c             	add    $0xc,%esp
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
 80559c6:	6a ff                	push   $0xffffffff
 80559c8:	6a ff                	push   $0xffffffff
 80559ca:	6a 00                	push   $0x0
 80559cc:	6a ff                	push   $0xffffffff
 80559ce:	6a 00                	push   $0x0
 80559d0:	6a 00                	push   $0x0
 80559d2:	68 60 82 06 08       	push   $0x8068260
 80559d7:	68 52 59 05 08       	push   $0x8055952
 80559dc:	68 dc 05 00 00       	push   $0x5dc
 80559e1:	68 b0 be 06 08       	push   $0x806beb0
 80559e6:	68 78 82 06 08       	push   $0x8068278
 80559eb:	e8 3b 96 00 00       	call   805f02b <z_impl_k_thread_create>
 80559f0:	83 c4 30             	add    $0x30,%esp
		tid = k_thread_create(&rx_classes[i].handler, rx_stack[i],
				      K_KERNEL_STACK_SIZEOF(rx_stack[i]),
				      (k_thread_entry_t)tc_rx_handler,
				      &rx_classes[i].fifo, NULL, NULL,
				      priority, 0, K_FOREVER);
		if (!tid) {
 80559f3:	85 c0                	test   %eax,%eax
 80559f5:	74 0c                	je     8055a03 <net_tc_rx_init+0x50>
	z_impl_k_thread_start(thread);
 80559f7:	83 ec 0c             	sub    $0xc,%esp
 80559fa:	50                   	push   %eax
 80559fb:	e8 a3 95 00 00       	call   805efa3 <z_impl_k_thread_start>
 8055a00:	83 c4 10             	add    $0x10,%esp
		}

		k_thread_start(tid);
	}
#endif
}
 8055a03:	c9                   	leave  
 8055a04:	c3                   	ret    

08055a05 <net_ipv6_is_addr_unspecified>:
{
 8055a05:	89 c2                	mov    %eax,%edx
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
 8055a07:	31 c0                	xor    %eax,%eax
 8055a09:	83 3a 00             	cmpl   $0x0,(%edx)
 8055a0c:	75 15                	jne    8055a23 <net_ipv6_is_addr_unspecified+0x1e>
	return UNALIGNED_GET(&addr->s6_addr32[0]) == 0 &&
 8055a0e:	83 7a 04 00          	cmpl   $0x0,0x4(%edx)
 8055a12:	75 0f                	jne    8055a23 <net_ipv6_is_addr_unspecified+0x1e>
		UNALIGNED_GET(&addr->s6_addr32[1]) == 0 &&
 8055a14:	83 7a 08 00          	cmpl   $0x0,0x8(%edx)
 8055a18:	75 09                	jne    8055a23 <net_ipv6_is_addr_unspecified+0x1e>
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
 8055a1a:	31 c0                	xor    %eax,%eax
 8055a1c:	83 7a 0c 00          	cmpl   $0x0,0xc(%edx)
 8055a20:	0f 94 c0             	sete   %al
 8055a23:	83 e0 01             	and    $0x1,%eax
}
 8055a26:	c3                   	ret    

08055a27 <conn_addr_cmp>:

static bool conn_addr_cmp(struct net_pkt *pkt,
			  union net_ip_header *ip_hdr,
			  struct sockaddr *addr,
			  bool is_remote)
{
 8055a27:	55                   	push   %ebp
 8055a28:	89 e5                	mov    %esp,%ebp
 8055a2a:	57                   	push   %edi
 8055a2b:	56                   	push   %esi
 8055a2c:	89 c6                	mov    %eax,%esi
 8055a2e:	89 c8                	mov    %ecx,%eax
 8055a30:	53                   	push   %ebx
 8055a31:	83 ec 0c             	sub    $0xc,%esp
	if (addr->sa_family != net_pkt_family(pkt)) {
 8055a34:	66 8b 19             	mov    (%ecx),%bx
	return pkt->family;
 8055a37:	8a 4e 33             	mov    0x33(%esi),%cl
{
 8055a3a:	8b 7d 08             	mov    0x8(%ebp),%edi
 8055a3d:	c0 e9 05             	shr    $0x5,%cl
	if (addr->sa_family != net_pkt_family(pkt)) {
 8055a40:	0f b6 f1             	movzbl %cl,%esi
 8055a43:	66 39 f3             	cmp    %si,%bx
 8055a46:	75 66                	jne    8055aae <conn_addr_cmp+0x87>
		return false;
	}

	if (IS_ENABLED(CONFIG_NET_IPV6) &&
 8055a48:	80 f9 02             	cmp    $0x2,%cl
 8055a4b:	75 37                	jne    8055a84 <conn_addr_cmp+0x5d>
						   addr6)) {
				return false;
			}
		}

		return true;
 8055a4d:	b1 01                	mov    $0x1,%cl
	    net_pkt_family(pkt) == AF_INET6 &&
 8055a4f:	66 83 fb 02          	cmp    $0x2,%bx
 8055a53:	75 5f                	jne    8055ab4 <conn_addr_cmp+0x8d>
			addr6 = ip_hdr->ipv6->src;
 8055a55:	8b 12                	mov    (%edx),%edx
		if (is_remote) {
 8055a57:	89 fb                	mov    %edi,%ebx
			addr6 = ip_hdr->ipv6->dst;
 8055a59:	8d 72 18             	lea    0x18(%edx),%esi
		if (is_remote) {
 8055a5c:	84 db                	test   %bl,%bl
 8055a5e:	74 03                	je     8055a63 <conn_addr_cmp+0x3c>
			addr6 = ip_hdr->ipv6->src;
 8055a60:	8d 72 08             	lea    0x8(%edx),%esi
			    &net_sin6(addr)->sin6_addr)) {
 8055a63:	8d 58 04             	lea    0x4(%eax),%ebx
		if (!net_ipv6_is_addr_unspecified(
 8055a66:	89 d8                	mov    %ebx,%eax
 8055a68:	e8 98 ff ff ff       	call   8055a05 <net_ipv6_is_addr_unspecified>
 8055a6d:	89 c1                	mov    %eax,%ecx
 8055a6f:	84 c0                	test   %al,%al
 8055a71:	75 41                	jne    8055ab4 <conn_addr_cmp+0x8d>
	return !memcmp(addr1, addr2, sizeof(struct in6_addr));
 8055a73:	50                   	push   %eax
 8055a74:	6a 10                	push   $0x10
 8055a76:	56                   	push   %esi
 8055a77:	53                   	push   %ebx
 8055a78:	e8 f3 35 ff ff       	call   8049070 <memcmp@plt>
 8055a7d:	83 c4 10             	add    $0x10,%esp
			if (!net_ipv6_addr_cmp_raw((uint8_t *)&net_sin6(addr)->sin6_addr,
 8055a80:	85 c0                	test   %eax,%eax
 8055a82:	eb 25                	jmp    8055aa9 <conn_addr_cmp+0x82>
	} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
		   net_pkt_family(pkt) == AF_INET &&
 8055a84:	66 4b                	dec    %bx
 8055a86:	0f 94 c3             	sete   %bl
	} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
 8055a89:	fe c9                	dec    %cl
 8055a8b:	0f 94 c1             	sete   %cl
		   net_pkt_family(pkt) == AF_INET &&
 8055a8e:	20 d9                	and    %bl,%cl
 8055a90:	74 20                	je     8055ab2 <conn_addr_cmp+0x8b>
			addr6 = ip_hdr->ipv6->src;
 8055a92:	8b 1a                	mov    (%edx),%ebx
		   addr->sa_family == AF_INET) {
		uint8_t *addr4;

		if (is_remote) {
 8055a94:	89 fa                	mov    %edi,%edx
			addr4 = ip_hdr->ipv4->src;
		} else {
			addr4 = ip_hdr->ipv4->dst;
 8055a96:	8d 73 10             	lea    0x10(%ebx),%esi
		if (is_remote) {
 8055a99:	84 d2                	test   %dl,%dl
 8055a9b:	74 03                	je     8055aa0 <conn_addr_cmp+0x79>
			addr4 = ip_hdr->ipv4->src;
 8055a9d:	8d 73 0c             	lea    0xc(%ebx),%esi
		}

		if (net_sin(addr)->sin_addr.s_addr) {
 8055aa0:	8b 40 04             	mov    0x4(%eax),%eax
 8055aa3:	85 c0                	test   %eax,%eax
 8055aa5:	74 0d                	je     8055ab4 <conn_addr_cmp+0x8d>
			if (!net_ipv4_addr_cmp_raw((uint8_t *)&net_sin(addr)->sin_addr,
 8055aa7:	39 06                	cmp    %eax,(%esi)
 8055aa9:	0f 94 c1             	sete   %cl
 8055aac:	eb 06                	jmp    8055ab4 <conn_addr_cmp+0x8d>
		return false;
 8055aae:	31 c9                	xor    %ecx,%ecx
 8055ab0:	eb 02                	jmp    8055ab4 <conn_addr_cmp+0x8d>
		return true;
 8055ab2:	b1 01                	mov    $0x1,%cl
			}
		}
	}

	return true;
}
 8055ab4:	8d 65 f4             	lea    -0xc(%ebp),%esp
 8055ab7:	89 c8                	mov    %ecx,%eax
 8055ab9:	5b                   	pop    %ebx
 8055aba:	5e                   	pop    %esi
 8055abb:	5f                   	pop    %edi
 8055abc:	5d                   	pop    %ebp
 8055abd:	c3                   	ret    

08055abe <k_mutex_lock.constprop.0.isra.0>:
static inline int k_mutex_lock(struct k_mutex * mutex, k_timeout_t timeout)
 8055abe:	55                   	push   %ebp
 8055abf:	89 e5                	mov    %esp,%ebp
 8055ac1:	83 ec 0c             	sub    $0xc,%esp
	return z_impl_k_mutex_lock(mutex, timeout);
 8055ac4:	52                   	push   %edx
 8055ac5:	50                   	push   %eax
 8055ac6:	68 98 75 06 08       	push   $0x8067598
 8055acb:	e8 c8 96 00 00       	call   805f198 <z_impl_k_mutex_lock>
 8055ad0:	83 c4 10             	add    $0x10,%esp
}
 8055ad3:	c9                   	leave  
 8055ad4:	c3                   	ret    

08055ad5 <k_mutex_unlock.constprop.0.isra.0>:
static inline int k_mutex_unlock(struct k_mutex * mutex)
 8055ad5:	55                   	push   %ebp
 8055ad6:	89 e5                	mov    %esp,%ebp
 8055ad8:	83 ec 14             	sub    $0x14,%esp
	return z_impl_k_mutex_unlock(mutex);
 8055adb:	68 98 75 06 08       	push   $0x8067598
 8055ae0:	e8 c1 97 00 00       	call   805f2a6 <z_impl_k_mutex_unlock>
 8055ae5:	83 c4 10             	add    $0x10,%esp
}
 8055ae8:	c9                   	leave  
 8055ae9:	c3                   	ret    

08055aea <conn_set_unused>:
{
 8055aea:	55                   	push   %ebp
  return __builtin___memset_chk (__dest, __ch, __len,
 8055aeb:	b9 11 00 00 00       	mov    $0x11,%ecx
 8055af0:	89 e5                	mov    %esp,%ebp
 8055af2:	57                   	push   %edi
 8055af3:	53                   	push   %ebx
 8055af4:	89 c3                	mov    %eax,%ebx
 8055af6:	31 c0                	xor    %eax,%eax
 8055af8:	89 df                	mov    %ebx,%edi
 8055afa:	f3 ab                	rep stos %eax,%es:(%edi)
	k_mutex_lock(&conn_lock, K_FOREVER);
 8055afc:	83 c8 ff             	or     $0xffffffff,%eax
 8055aff:	89 c2                	mov    %eax,%edx
 8055b01:	e8 b8 ff ff ff       	call   8055abe <k_mutex_lock.constprop.0.isra.0>
	return list->head;
 8055b06:	a1 0c 8a 06 08       	mov    0x8068a0c,%eax
	parent->next = child;
 8055b0b:	89 03                	mov    %eax,(%ebx)
Z_GENLIST_PREPEND(slist, snode)
 8055b0d:	83 3d 10 8a 06 08 00 	cmpl   $0x0,0x8068a10
	list->head = node;
 8055b14:	89 1d 0c 8a 06 08    	mov    %ebx,0x8068a0c
Z_GENLIST_PREPEND(slist, snode)
 8055b1a:	75 06                	jne    8055b22 <conn_set_unused+0x38>
	list->tail = node;
 8055b1c:	89 1d 10 8a 06 08    	mov    %ebx,0x8068a10
}
 8055b22:	5b                   	pop    %ebx
 8055b23:	5f                   	pop    %edi
 8055b24:	5d                   	pop    %ebp
	k_mutex_unlock(&conn_lock);
 8055b25:	e9 ab ff ff ff       	jmp    8055ad5 <k_mutex_unlock.constprop.0.isra.0>

08055b2a <net_conn_register>:
{
 8055b2a:	55                   	push   %ebp
 8055b2b:	89 e5                	mov    %esp,%ebp
 8055b2d:	57                   	push   %edi
 8055b2e:	56                   	push   %esi
 8055b2f:	53                   	push   %ebx
 8055b30:	83 ec 2c             	sub    $0x2c,%esp
 8055b33:	8b 45 08             	mov    0x8(%ebp),%eax
 8055b36:	89 45 dc             	mov    %eax,-0x24(%ebp)
 8055b39:	8b 45 0c             	mov    0xc(%ebp),%eax
 8055b3c:	89 45 d8             	mov    %eax,-0x28(%ebp)
 8055b3f:	8b 45 18             	mov    0x18(%ebp),%eax
 8055b42:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 8055b45:	8b 45 1c             	mov    0x1c(%ebp),%eax
 8055b48:	89 45 e0             	mov    %eax,-0x20(%ebp)
 8055b4b:	8b 45 dc             	mov    -0x24(%ebp),%eax
 8055b4e:	66 89 45 d2          	mov    %ax,-0x2e(%ebp)
 8055b52:	8a 45 d8             	mov    -0x28(%ebp),%al
 8055b55:	88 45 d1             	mov    %al,-0x2f(%ebp)
	k_mutex_lock(&conn_lock, K_FOREVER);
 8055b58:	83 c8 ff             	or     $0xffffffff,%eax
 8055b5b:	89 c2                	mov    %eax,%edx
 8055b5d:	e8 5c ff ff ff       	call   8055abe <k_mutex_lock.constprop.0.isra.0>
	return list->head;
 8055b62:	8b 1d 04 8a 06 08    	mov    0x8068a04,%ebx
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&conn_used, conn, tmp, node) {
 8055b68:	85 db                	test   %ebx,%ebx
 8055b6a:	0f 84 27 01 00 00    	je     8055c97 <net_conn_register+0x16d>
	return node->next;
 8055b70:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8055b73:	8b 3b                	mov    (%ebx),%edi
 8055b75:	86 e0                	xchg   %ah,%al
 8055b77:	66 89 45 d6          	mov    %ax,-0x2a(%ebp)
 8055b7b:	8b 45 e0             	mov    -0x20(%ebp),%eax
 8055b7e:	86 e0                	xchg   %ah,%al
 8055b80:	66 89 45 d4          	mov    %ax,-0x2c(%ebp)
 8055b84:	8b 45 14             	mov    0x14(%ebp),%eax
 8055b87:	83 c0 04             	add    $0x4,%eax
 8055b8a:	89 45 cc             	mov    %eax,-0x34(%ebp)
 8055b8d:	8b 45 10             	mov    0x10(%ebp),%eax
 8055b90:	8d 70 04             	lea    0x4(%eax),%esi
		if (conn->proto != proto) {
 8055b93:	66 8b 45 d2          	mov    -0x2e(%ebp),%ax
 8055b97:	66 3b 43 40          	cmp    0x40(%ebx),%ax
 8055b9b:	0f 85 e9 00 00 00    	jne    8055c8a <net_conn_register+0x160>
		if (conn->family != family) {
 8055ba1:	8a 45 d1             	mov    -0x2f(%ebp),%al
 8055ba4:	3a 43 42             	cmp    0x42(%ebx),%al
 8055ba7:	0f 85 dd 00 00 00    	jne    8055c8a <net_conn_register+0x160>
			if (!(conn->flags & NET_CONN_REMOTE_ADDR_SET)) {
 8055bad:	8a 53 43             	mov    0x43(%ebx),%dl
 8055bb0:	89 d0                	mov    %edx,%eax
 8055bb2:	83 e0 02             	and    $0x2,%eax
		if (remote_addr) {
 8055bb5:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
 8055bb9:	74 57                	je     8055c12 <net_conn_register+0xe8>
			if (!(conn->flags & NET_CONN_REMOTE_ADDR_SET)) {
 8055bbb:	84 c0                	test   %al,%al
 8055bbd:	0f 84 c7 00 00 00    	je     8055c8a <net_conn_register+0x160>
			    remote_addr->sa_family == AF_INET6 &&
 8055bc3:	8b 45 10             	mov    0x10(%ebp),%eax
 8055bc6:	66 8b 00             	mov    (%eax),%ax
			if (IS_ENABLED(CONFIG_NET_IPV6) &&
 8055bc9:	66 83 f8 02          	cmp    $0x2,%ax
 8055bcd:	75 25                	jne    8055bf4 <net_conn_register+0xca>
			    remote_addr->sa_family == AF_INET6 &&
 8055bcf:	66 83 7b 04 02       	cmpw   $0x2,0x4(%ebx)
 8055bd4:	0f 85 b0 00 00 00    	jne    8055c8a <net_conn_register+0x160>
 8055bda:	8d 43 08             	lea    0x8(%ebx),%eax
 8055bdd:	88 55 d0             	mov    %dl,-0x30(%ebp)
 8055be0:	52                   	push   %edx
 8055be1:	6a 10                	push   $0x10
 8055be3:	50                   	push   %eax
 8055be4:	56                   	push   %esi
 8055be5:	e8 86 34 ff ff       	call   8049070 <memcmp@plt>
 8055bea:	83 c4 10             	add    $0x10,%esp
				if (!net_ipv6_addr_cmp(
 8055bed:	8a 55 d0             	mov    -0x30(%ebp),%dl
 8055bf0:	85 c0                	test   %eax,%eax
 8055bf2:	eb 20                	jmp    8055c14 <net_conn_register+0xea>
			} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
 8055bf4:	66 48                	dec    %ax
 8055bf6:	0f 85 8e 00 00 00    	jne    8055c8a <net_conn_register+0x160>
				   remote_addr->sa_family == AF_INET &&
 8055bfc:	66 83 7b 04 01       	cmpw   $0x1,0x4(%ebx)
 8055c01:	0f 85 83 00 00 00    	jne    8055c8a <net_conn_register+0x160>
				if (!net_ipv4_addr_cmp(
 8055c07:	8b 45 10             	mov    0x10(%ebp),%eax
 8055c0a:	8b 4b 08             	mov    0x8(%ebx),%ecx
 8055c0d:	39 48 04             	cmp    %ecx,0x4(%eax)
 8055c10:	eb 02                	jmp    8055c14 <net_conn_register+0xea>
		} else if (conn->flags & NET_CONN_REMOTE_ADDR_SET) {
 8055c12:	84 c0                	test   %al,%al
 8055c14:	75 74                	jne    8055c8a <net_conn_register+0x160>
		if (local_addr) {
 8055c16:	89 d0                	mov    %edx,%eax
 8055c18:	83 e0 04             	and    $0x4,%eax
 8055c1b:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
 8055c1f:	74 43                	je     8055c64 <net_conn_register+0x13a>
			if (!(conn->flags & NET_CONN_LOCAL_ADDR_SET)) {
 8055c21:	84 c0                	test   %al,%al
 8055c23:	74 65                	je     8055c8a <net_conn_register+0x160>
			    local_addr->sa_family == AF_INET6 &&
 8055c25:	8b 45 14             	mov    0x14(%ebp),%eax
 8055c28:	66 8b 00             	mov    (%eax),%ax
			if (IS_ENABLED(CONFIG_NET_IPV6) &&
 8055c2b:	66 83 f8 02          	cmp    $0x2,%ax
 8055c2f:	75 1d                	jne    8055c4e <net_conn_register+0x124>
			    local_addr->sa_family == AF_INET6 &&
 8055c31:	66 83 7b 1c 02       	cmpw   $0x2,0x1c(%ebx)
 8055c36:	75 52                	jne    8055c8a <net_conn_register+0x160>
 8055c38:	50                   	push   %eax
 8055c39:	8d 43 20             	lea    0x20(%ebx),%eax
 8055c3c:	6a 10                	push   $0x10
 8055c3e:	50                   	push   %eax
 8055c3f:	ff 75 cc             	push   -0x34(%ebp)
 8055c42:	e8 29 34 ff ff       	call   8049070 <memcmp@plt>
 8055c47:	83 c4 10             	add    $0x10,%esp
				if (!net_ipv6_addr_cmp(
 8055c4a:	85 c0                	test   %eax,%eax
 8055c4c:	eb 18                	jmp    8055c66 <net_conn_register+0x13c>
			} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
 8055c4e:	66 48                	dec    %ax
 8055c50:	75 38                	jne    8055c8a <net_conn_register+0x160>
				   local_addr->sa_family == AF_INET &&
 8055c52:	66 83 7b 1c 01       	cmpw   $0x1,0x1c(%ebx)
 8055c57:	75 31                	jne    8055c8a <net_conn_register+0x160>
				if (!net_ipv4_addr_cmp(
 8055c59:	8b 45 14             	mov    0x14(%ebp),%eax
 8055c5c:	8b 4b 20             	mov    0x20(%ebx),%ecx
 8055c5f:	39 48 04             	cmp    %ecx,0x4(%eax)
 8055c62:	eb 02                	jmp    8055c66 <net_conn_register+0x13c>
		} else if (conn->flags & NET_CONN_LOCAL_ADDR_SET) {
 8055c64:	84 c0                	test   %al,%al
 8055c66:	75 22                	jne    8055c8a <net_conn_register+0x160>
		if (net_sin(&conn->remote_addr)->sin_port !=
 8055c68:	66 8b 45 d6          	mov    -0x2a(%ebp),%ax
 8055c6c:	66 39 43 06          	cmp    %ax,0x6(%ebx)
 8055c70:	75 18                	jne    8055c8a <net_conn_register+0x160>
		if (net_sin(&conn->local_addr)->sin_port !=
 8055c72:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 8055c75:	66 39 43 1e          	cmp    %ax,0x1e(%ebx)
 8055c79:	75 0f                	jne    8055c8a <net_conn_register+0x160>
		k_mutex_unlock(&conn_lock);
 8055c7b:	e8 55 fe ff ff       	call   8055ad5 <k_mutex_unlock.constprop.0.isra.0>
		return -EALREADY;
 8055c80:	b8 8e ff ff ff       	mov    $0xffffff8e,%eax
 8055c85:	e9 b5 01 00 00       	jmp    8055e3f <net_conn_register+0x315>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&conn_used, conn, tmp, node) {
 8055c8a:	85 ff                	test   %edi,%edi
 8055c8c:	74 09                	je     8055c97 <net_conn_register+0x16d>
 8055c8e:	89 fb                	mov    %edi,%ebx
 8055c90:	8b 3f                	mov    (%edi),%edi
 8055c92:	e9 fc fe ff ff       	jmp    8055b93 <net_conn_register+0x69>
	k_mutex_unlock(&conn_lock);
 8055c97:	e8 39 fe ff ff       	call   8055ad5 <k_mutex_unlock.constprop.0.isra.0>
	k_mutex_lock(&conn_lock, K_FOREVER);
 8055c9c:	83 c8 ff             	or     $0xffffffff,%eax
 8055c9f:	89 c2                	mov    %eax,%edx
 8055ca1:	e8 18 fe ff ff       	call   8055abe <k_mutex_lock.constprop.0.isra.0>
	return list->head;
 8055ca6:	8b 1d 0c 8a 06 08    	mov    0x8068a0c,%ebx
	if (!node) {
 8055cac:	85 db                	test   %ebx,%ebx
 8055cae:	75 0f                	jne    8055cbf <net_conn_register+0x195>
		k_mutex_unlock(&conn_lock);
 8055cb0:	e8 20 fe ff ff       	call   8055ad5 <k_mutex_unlock.constprop.0.isra.0>
		return -ENOENT;
 8055cb5:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
 8055cba:	e9 80 01 00 00       	jmp    8055e3f <net_conn_register+0x315>
	return node->next;
 8055cbf:	8b 03                	mov    (%ebx),%eax
	list->head = node;
 8055cc1:	a3 0c 8a 06 08       	mov    %eax,0x8068a0c
Z_GENLIST_REMOVE(slist, snode)
 8055cc6:	3b 1d 10 8a 06 08    	cmp    0x8068a10,%ebx
 8055ccc:	75 05                	jne    8055cd3 <net_conn_register+0x1a9>
	list->tail = node;
 8055cce:	a3 10 8a 06 08       	mov    %eax,0x8068a10
	parent->next = child;
 8055cd3:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
	k_mutex_unlock(&conn_lock);
 8055cd9:	e8 f7 fd ff ff       	call   8055ad5 <k_mutex_unlock.constprop.0.isra.0>
	if (remote_addr) {
 8055cde:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
 8055ce2:	74 55                	je     8055d39 <net_conn_register+0x20f>
		    remote_addr->sa_family == AF_INET6) {
 8055ce4:	8b 45 10             	mov    0x10(%ebp),%eax
 8055ce7:	66 8b 00             	mov    (%eax),%ax
		if (IS_ENABLED(CONFIG_NET_IPV6) &&
 8055cea:	66 83 f8 02          	cmp    $0x2,%ax
 8055cee:	75 1f                	jne    8055d0f <net_conn_register+0x1e5>
  return __builtin___memcpy_chk (__dest, __src, __len,
 8055cf0:	8d 43 04             	lea    0x4(%ebx),%eax
 8055cf3:	8b 75 10             	mov    0x10(%ebp),%esi
 8055cf6:	b9 06 00 00 00       	mov    $0x6,%ecx
 8055cfb:	89 c7                	mov    %eax,%edi
				    &net_sin6(remote_addr)->
 8055cfd:	8b 45 10             	mov    0x10(%ebp),%eax
 8055d00:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
 8055d02:	83 c0 04             	add    $0x4,%eax
			if (!net_ipv6_is_addr_unspecified(
 8055d05:	e8 fb fc ff ff       	call   8055a05 <net_ipv6_is_addr_unspecified>
 8055d0a:	83 f0 01             	xor    $0x1,%eax
 8055d0d:	eb 20                	jmp    8055d2f <net_conn_register+0x205>
		} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
 8055d0f:	66 48                	dec    %ax
 8055d11:	0f 85 1c 01 00 00    	jne    8055e33 <net_conn_register+0x309>
 8055d17:	8b 45 10             	mov    0x10(%ebp),%eax
 8055d1a:	8b 50 04             	mov    0x4(%eax),%edx
 8055d1d:	8b 00                	mov    (%eax),%eax
 8055d1f:	89 43 04             	mov    %eax,0x4(%ebx)
			if (net_sin(remote_addr)->sin_addr.s_addr) {
 8055d22:	8b 45 10             	mov    0x10(%ebp),%eax
 8055d25:	89 53 08             	mov    %edx,0x8(%ebx)
 8055d28:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
 8055d2c:	0f 95 c0             	setne  %al
 8055d2f:	c1 e0 05             	shl    $0x5,%eax
		flags |= NET_CONN_REMOTE_ADDR_SET;
 8055d32:	83 c8 02             	or     $0x2,%eax
 8055d35:	89 c2                	mov    %eax,%edx
 8055d37:	eb 02                	jmp    8055d3b <net_conn_register+0x211>
	uint8_t flags = 0U;
 8055d39:	31 d2                	xor    %edx,%edx
	if (local_addr) {
 8055d3b:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
 8055d3f:	74 6c                	je     8055dad <net_conn_register+0x283>
		    local_addr->sa_family == AF_INET6) {
 8055d41:	8b 45 14             	mov    0x14(%ebp),%eax
 8055d44:	66 8b 00             	mov    (%eax),%ax
		if (IS_ENABLED(CONFIG_NET_IPV6) &&
 8055d47:	66 83 f8 02          	cmp    $0x2,%ax
 8055d4b:	75 26                	jne    8055d73 <net_conn_register+0x249>
 8055d4d:	8d 43 1c             	lea    0x1c(%ebx),%eax
 8055d50:	8b 75 14             	mov    0x14(%ebp),%esi
 8055d53:	b9 06 00 00 00       	mov    $0x6,%ecx
 8055d58:	88 55 d6             	mov    %dl,-0x2a(%ebp)
 8055d5b:	89 c7                	mov    %eax,%edi
				    &net_sin6(local_addr)->
 8055d5d:	8b 45 14             	mov    0x14(%ebp),%eax
 8055d60:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
 8055d62:	83 c0 04             	add    $0x4,%eax
			if (!net_ipv6_is_addr_unspecified(
 8055d65:	e8 9b fc ff ff       	call   8055a05 <net_ipv6_is_addr_unspecified>
 8055d6a:	8a 55 d6             	mov    -0x2a(%ebp),%dl
 8055d6d:	84 c0                	test   %al,%al
 8055d6f:	75 21                	jne    8055d92 <net_conn_register+0x268>
 8055d71:	eb 1c                	jmp    8055d8f <net_conn_register+0x265>
		} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
 8055d73:	66 48                	dec    %ax
 8055d75:	0f 85 b8 00 00 00    	jne    8055e33 <net_conn_register+0x309>
 8055d7b:	8b 45 14             	mov    0x14(%ebp),%eax
 8055d7e:	8b 30                	mov    (%eax),%esi
 8055d80:	8b 78 04             	mov    0x4(%eax),%edi
 8055d83:	89 73 1c             	mov    %esi,0x1c(%ebx)
 8055d86:	89 7b 20             	mov    %edi,0x20(%ebx)
			if (net_sin(local_addr)->sin_addr.s_addr) {
 8055d89:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
 8055d8d:	74 03                	je     8055d92 <net_conn_register+0x268>
				flags |= NET_CONN_LOCAL_ADDR_SPEC;
 8055d8f:	83 ca 40             	or     $0x40,%edx
		flags |= NET_CONN_LOCAL_ADDR_SET;
 8055d92:	83 ca 04             	or     $0x4,%edx
	if (remote_addr && local_addr) {
 8055d95:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
 8055d99:	74 12                	je     8055dad <net_conn_register+0x283>
		if (remote_addr->sa_family != local_addr->sa_family) {
 8055d9b:	8b 4d 14             	mov    0x14(%ebp),%ecx
 8055d9e:	8b 45 10             	mov    0x10(%ebp),%eax
 8055da1:	66 8b 31             	mov    (%ecx),%si
 8055da4:	66 39 30             	cmp    %si,(%eax)
 8055da7:	0f 85 86 00 00 00    	jne    8055e33 <net_conn_register+0x309>
	if (remote_port) {
 8055dad:	66 83 7d e4 00       	cmpw   $0x0,-0x1c(%ebp)
 8055db2:	74 0c                	je     8055dc0 <net_conn_register+0x296>
		net_sin(&conn->remote_addr)->sin_port = htons(remote_port);
 8055db4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
		flags |= NET_CONN_REMOTE_PORT_SPEC;
 8055db7:	83 ca 08             	or     $0x8,%edx
		net_sin(&conn->remote_addr)->sin_port = htons(remote_port);
 8055dba:	86 e0                	xchg   %ah,%al
 8055dbc:	66 89 43 06          	mov    %ax,0x6(%ebx)
	if (local_port) {
 8055dc0:	66 83 7d e0 00       	cmpw   $0x0,-0x20(%ebp)
 8055dc5:	74 0c                	je     8055dd3 <net_conn_register+0x2a9>
		net_sin(&conn->local_addr)->sin_port = htons(local_port);
 8055dc7:	8b 45 e0             	mov    -0x20(%ebp),%eax
		flags |= NET_CONN_LOCAL_PORT_SPEC;
 8055dca:	83 ca 10             	or     $0x10,%edx
		net_sin(&conn->local_addr)->sin_port = htons(local_port);
 8055dcd:	86 e0                	xchg   %ah,%al
 8055dcf:	66 89 43 1e          	mov    %ax,0x1e(%ebx)
	conn->cb = cb;
 8055dd3:	8b 45 24             	mov    0x24(%ebp),%eax
	if (handle) {
 8055dd6:	83 7d 2c 00          	cmpl   $0x0,0x2c(%ebp)
	conn->flags = flags;
 8055dda:	88 53 43             	mov    %dl,0x43(%ebx)
	conn->cb = cb;
 8055ddd:	89 43 34             	mov    %eax,0x34(%ebx)
	conn->user_data = user_data;
 8055de0:	8b 45 28             	mov    0x28(%ebp),%eax
 8055de3:	89 43 3c             	mov    %eax,0x3c(%ebx)
	conn->proto = proto;
 8055de6:	8b 45 dc             	mov    -0x24(%ebp),%eax
 8055de9:	66 89 43 40          	mov    %ax,0x40(%ebx)
	conn->family = family;
 8055ded:	8a 45 d8             	mov    -0x28(%ebp),%al
 8055df0:	88 43 42             	mov    %al,0x42(%ebx)
	conn->context = context;
 8055df3:	8b 45 20             	mov    0x20(%ebp),%eax
 8055df6:	89 43 38             	mov    %eax,0x38(%ebx)
	if (handle) {
 8055df9:	74 05                	je     8055e00 <net_conn_register+0x2d6>
		*handle = (struct net_conn_handle *)conn;
 8055dfb:	8b 45 2c             	mov    0x2c(%ebp),%eax
 8055dfe:	89 18                	mov    %ebx,(%eax)
	conn->flags |= NET_CONN_IN_USE;
 8055e00:	80 4b 43 01          	orb    $0x1,0x43(%ebx)
	k_mutex_lock(&conn_lock, K_FOREVER);
 8055e04:	83 c8 ff             	or     $0xffffffff,%eax
 8055e07:	89 c2                	mov    %eax,%edx
 8055e09:	e8 b0 fc ff ff       	call   8055abe <k_mutex_lock.constprop.0.isra.0>
	return list->head;
 8055e0e:	a1 04 8a 06 08       	mov    0x8068a04,%eax
	parent->next = child;
 8055e13:	89 03                	mov    %eax,(%ebx)
Z_GENLIST_PREPEND(slist, snode)
 8055e15:	83 3d 08 8a 06 08 00 	cmpl   $0x0,0x8068a08
	list->head = node;
 8055e1c:	89 1d 04 8a 06 08    	mov    %ebx,0x8068a04
Z_GENLIST_PREPEND(slist, snode)
 8055e22:	75 06                	jne    8055e2a <net_conn_register+0x300>
	list->tail = node;
 8055e24:	89 1d 08 8a 06 08    	mov    %ebx,0x8068a08
	k_mutex_unlock(&conn_lock);
 8055e2a:	e8 a6 fc ff ff       	call   8055ad5 <k_mutex_unlock.constprop.0.isra.0>
	return 0;
 8055e2f:	31 c0                	xor    %eax,%eax
}
 8055e31:	eb 0c                	jmp    8055e3f <net_conn_register+0x315>
	conn_set_unused(conn);
 8055e33:	89 d8                	mov    %ebx,%eax
 8055e35:	e8 b0 fc ff ff       	call   8055aea <conn_set_unused>
	return -EINVAL;
 8055e3a:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
}
 8055e3f:	8d 65 f4             	lea    -0xc(%ebp),%esp
 8055e42:	5b                   	pop    %ebx
 8055e43:	5e                   	pop    %esi
 8055e44:	5f                   	pop    %edi
 8055e45:	5d                   	pop    %ebp
 8055e46:	c3                   	ret    

08055e47 <net_conn_unregister>:
{
 8055e47:	55                   	push   %ebp
 8055e48:	89 e5                	mov    %esp,%ebp
 8055e4a:	53                   	push   %ebx
 8055e4b:	51                   	push   %ecx
 8055e4c:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (conn < &conns[0] || conn > &conns[CONFIG_NET_MAX_CONN]) {
 8055e4f:	81 fb 00 85 06 08    	cmp    $0x8068500,%ebx
 8055e55:	77 74                	ja     8055ecb <net_conn_unregister+0x84>
 8055e57:	81 fb e0 82 06 08    	cmp    $0x80682e0,%ebx
 8055e5d:	72 6c                	jb     8055ecb <net_conn_unregister+0x84>
		return -ENOENT;
 8055e5f:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
	if (!(conn->flags & NET_CONN_IN_USE)) {
 8055e64:	f6 43 43 01          	testb  $0x1,0x43(%ebx)
 8055e68:	74 66                	je     8055ed0 <net_conn_unregister+0x89>
	k_mutex_lock(&conn_lock, K_FOREVER);
 8055e6a:	83 c8 ff             	or     $0xffffffff,%eax
 8055e6d:	89 c2                	mov    %eax,%edx
 8055e6f:	e8 4a fc ff ff       	call   8055abe <k_mutex_lock.constprop.0.isra.0>
	return list->head;
 8055e74:	a1 04 8a 06 08       	mov    0x8068a04,%eax
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
 8055e79:	31 d2                	xor    %edx,%edx
 8055e7b:	85 c0                	test   %eax,%eax
 8055e7d:	74 3c                	je     8055ebb <net_conn_unregister+0x74>
 8055e7f:	39 c3                	cmp    %eax,%ebx
 8055e81:	75 32                	jne    8055eb5 <net_conn_unregister+0x6e>
	return node->next;
 8055e83:	8b 03                	mov    (%ebx),%eax
Z_GENLIST_REMOVE(slist, snode)
 8055e85:	85 d2                	test   %edx,%edx
 8055e87:	75 14                	jne    8055e9d <net_conn_unregister+0x56>
	list->head = node;
 8055e89:	a3 04 8a 06 08       	mov    %eax,0x8068a04
Z_GENLIST_REMOVE(slist, snode)
 8055e8e:	3b 1d 08 8a 06 08    	cmp    0x8068a08,%ebx
 8055e94:	75 17                	jne    8055ead <net_conn_unregister+0x66>
	list->tail = node;
 8055e96:	a3 08 8a 06 08       	mov    %eax,0x8068a08
}
 8055e9b:	eb 10                	jmp    8055ead <net_conn_unregister+0x66>
	parent->next = child;
 8055e9d:	89 02                	mov    %eax,(%edx)
Z_GENLIST_REMOVE(slist, snode)
 8055e9f:	3b 1d 08 8a 06 08    	cmp    0x8068a08,%ebx
 8055ea5:	75 06                	jne    8055ead <net_conn_unregister+0x66>
	list->tail = node;
 8055ea7:	89 15 08 8a 06 08    	mov    %edx,0x8068a08
	parent->next = child;
 8055ead:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
Z_GENLIST_REMOVE(slist, snode)
 8055eb3:	eb 06                	jmp    8055ebb <net_conn_unregister+0x74>
	return node->next;
 8055eb5:	89 c2                	mov    %eax,%edx
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
 8055eb7:	8b 00                	mov    (%eax),%eax
 8055eb9:	eb c0                	jmp    8055e7b <net_conn_unregister+0x34>
	k_mutex_unlock(&conn_lock);
 8055ebb:	e8 15 fc ff ff       	call   8055ad5 <k_mutex_unlock.constprop.0.isra.0>
	conn_set_unused(conn);
 8055ec0:	89 d8                	mov    %ebx,%eax
 8055ec2:	e8 23 fc ff ff       	call   8055aea <conn_set_unused>
	return 0;
 8055ec7:	31 c0                	xor    %eax,%eax
 8055ec9:	eb 05                	jmp    8055ed0 <net_conn_unregister+0x89>
		return -EINVAL;
 8055ecb:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
}
 8055ed0:	5a                   	pop    %edx
 8055ed1:	5b                   	pop    %ebx
 8055ed2:	5d                   	pop    %ebp
 8055ed3:	c3                   	ret    

08055ed4 <net_conn_input>:

enum net_verdict net_conn_input(struct net_pkt *pkt,
				union net_ip_header *ip_hdr,
				uint8_t proto,
				union net_proto_header *proto_hdr)
{
 8055ed4:	55                   	push   %ebp
 8055ed5:	89 e5                	mov    %esp,%ebp
 8055ed7:	57                   	push   %edi
 8055ed8:	56                   	push   %esi
 8055ed9:	53                   	push   %ebx
 8055eda:	83 ec 1c             	sub    $0x1c,%esp
 8055edd:	8b 75 08             	mov    0x8(%ebp),%esi
 8055ee0:	8b 45 10             	mov    0x10(%ebp),%eax
	return pkt->iface;
 8055ee3:	8b 4e 18             	mov    0x18(%esi),%ecx
 8055ee6:	88 45 d8             	mov    %al,-0x28(%ebp)
 8055ee9:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
	return pkt->family;
 8055eec:	8a 4e 33             	mov    0x33(%esi),%cl
 8055eef:	c0 e9 05             	shr    $0x5,%cl
	struct net_if *pkt_iface = net_pkt_iface(pkt);
	uint8_t pkt_family = net_pkt_family(pkt);
	uint16_t src_port = 0U, dst_port = 0U;

	if (IS_ENABLED(CONFIG_NET_IP) && (pkt_family == AF_INET || pkt_family == AF_INET6)) {
 8055ef2:	89 cf                	mov    %ecx,%edi
 8055ef4:	88 4d e2             	mov    %cl,-0x1e(%ebp)
 8055ef7:	8d 57 ff             	lea    -0x1(%edi),%edx
 8055efa:	80 fa 01             	cmp    $0x1,%dl
 8055efd:	0f 87 e3 02 00 00    	ja     80561e6 <net_conn_input+0x312>
		if (IS_ENABLED(CONFIG_NET_UDP) && proto == IPPROTO_UDP) {
 8055f03:	3c 11                	cmp    $0x11,%al
 8055f05:	75 16                	jne    8055f1d <net_conn_input+0x49>
			src_port = proto_hdr->udp->src_port;
 8055f07:	8b 45 14             	mov    0x14(%ebp),%eax
 8055f0a:	8b 00                	mov    (%eax),%eax
 8055f0c:	66 8b 08             	mov    (%eax),%cx
			dst_port = proto_hdr->udp->dst_port;
 8055f0f:	66 8b 40 02          	mov    0x2(%eax),%ax
			src_port = proto_hdr->udp->src_port;
 8055f13:	66 89 4d dc          	mov    %cx,-0x24(%ebp)
			dst_port = proto_hdr->udp->dst_port;
 8055f17:	66 89 45 de          	mov    %ax,-0x22(%ebp)
 8055f1b:	eb 0c                	jmp    8055f29 <net_conn_input+0x55>
	uint16_t src_port = 0U, dst_port = 0U;
 8055f1d:	66 c7 45 de 00 00    	movw   $0x0,-0x22(%ebp)
 8055f23:	66 c7 45 dc 00 00    	movw   $0x0,-0x24(%ebp)
			(struct in_addr *)ip_hdr->ipv4->src);
 8055f29:	8b 45 0c             	mov    0xc(%ebp),%eax
	if (IS_ENABLED(CONFIG_NET_IPV4) && family == AF_INET) {
 8055f2c:	80 7d e2 01          	cmpb   $0x1,-0x1e(%ebp)
			(struct in_addr *)ip_hdr->ipv4->src);
 8055f30:	8b 18                	mov    (%eax),%ebx
	if (IS_ENABLED(CONFIG_NET_IPV4) && family == AF_INET) {
 8055f32:	75 44                	jne    8055f78 <net_conn_input+0xa4>
			(struct in_addr *)ip_hdr->ipv4->src);
 8055f34:	8d 7b 0c             	lea    0xc(%ebx),%edi
	ret = net_if_ipv4_addr_lookup(addr, NULL) != NULL;
 8055f37:	50                   	push   %eax
 8055f38:	50                   	push   %eax
 8055f39:	6a 00                	push   $0x0
 8055f3b:	57                   	push   %edi
 8055f3c:	e8 04 c8 ff ff       	call   8052745 <net_if_ipv4_addr_lookup>
 8055f41:	83 c4 10             	add    $0x10,%esp
 8055f44:	85 c0                	test   %eax,%eax
 8055f46:	0f 95 c2             	setne  %dl
	if (!ret) {
 8055f49:	75 1d                	jne    8055f68 <net_conn_input+0x94>
	if (net_ipv4_addr_cmp(addr, net_ipv4_broadcast_address())) {
 8055f4b:	e8 24 d8 ff ff       	call   8053774 <net_ipv4_broadcast_address>
		return true;
 8055f50:	b2 01                	mov    $0x1,%dl
	if (net_ipv4_addr_cmp(addr, net_ipv4_broadcast_address())) {
 8055f52:	8b 00                	mov    (%eax),%eax
 8055f54:	39 43 0c             	cmp    %eax,0xc(%ebx)
 8055f57:	74 0f                	je     8055f68 <net_conn_input+0x94>
	return net_if_ipv4_is_addr_bcast(iface, addr);
 8055f59:	50                   	push   %eax
 8055f5a:	50                   	push   %eax
 8055f5b:	57                   	push   %edi
 8055f5c:	6a 00                	push   $0x0
 8055f5e:	e8 36 c6 ff ff       	call   8052599 <net_if_ipv4_is_addr_bcast>
 8055f63:	83 c4 10             	add    $0x10,%esp
 8055f66:	89 c2                	mov    %eax,%edx
			ip_hdr->ipv4->src, ip_hdr->ipv4->dst);
 8055f68:	8b 45 0c             	mov    0xc(%ebp),%eax
 8055f6b:	8b 00                	mov    (%eax),%eax
	return UNALIGNED_GET(&addr1->s_addr) == UNALIGNED_GET(&addr2->s_addr);
 8055f6d:	8b 78 10             	mov    0x10(%eax),%edi
 8055f70:	39 78 0c             	cmp    %edi,0xc(%eax)
 8055f73:	0f 94 c0             	sete   %al
 8055f76:	eb 37                	jmp    8055faf <net_conn_input+0xdb>
			(struct in6_addr *)ip_hdr->ipv6->src);
 8055f78:	83 c3 08             	add    $0x8,%ebx
	return net_if_ipv6_addr_lookup(addr, NULL) != NULL;
 8055f7b:	57                   	push   %edi
 8055f7c:	57                   	push   %edi
 8055f7d:	6a 00                	push   $0x0
 8055f7f:	53                   	push   %ebx
 8055f80:	e8 9a b3 ff ff       	call   805131f <net_if_ipv6_addr_lookup>
 8055f85:	83 c4 0c             	add    $0xc,%esp
 8055f88:	85 c0                	test   %eax,%eax
			ip_hdr->ipv6->src, ip_hdr->ipv6->dst);
 8055f8a:	8b 45 0c             	mov    0xc(%ebp),%eax
 8055f8d:	0f 95 c2             	setne  %dl
 8055f90:	8b 00                	mov    (%eax),%eax
	return !memcmp(addr1, addr2, sizeof(struct in6_addr));
 8055f92:	6a 10                	push   $0x10
	return net_if_ipv6_addr_lookup(addr, NULL) != NULL;
 8055f94:	88 55 e3             	mov    %dl,-0x1d(%ebp)
	return !memcmp(addr1, addr2, sizeof(struct in6_addr));
 8055f97:	8d 48 18             	lea    0x18(%eax),%ecx
 8055f9a:	83 c0 08             	add    $0x8,%eax
 8055f9d:	51                   	push   %ecx
 8055f9e:	50                   	push   %eax
 8055f9f:	e8 cc 30 ff ff       	call   8049070 <memcmp@plt>
 8055fa4:	83 c4 10             	add    $0x10,%esp
 8055fa7:	8a 55 e3             	mov    -0x1d(%ebp),%dl
 8055faa:	85 c0                	test   %eax,%eax
 8055fac:	0f 94 c0             	sete   %al
		(is_same_src_and_dst_addr || is_my_src_addr) && is_same_src_and_dst_port;
 8055faf:	09 c2                	or     %eax,%edx
 8055fb1:	8b 4d dc             	mov    -0x24(%ebp),%ecx
 8055fb4:	66 39 4d de          	cmp    %cx,-0x22(%ebp)
 8055fb8:	0f 94 c0             	sete   %al
				return NET_DROP;
			}
			src_port = proto_hdr->tcp->src_port;
			dst_port = proto_hdr->tcp->dst_port;
		}
		if (!conn_are_endpoints_valid(pkt, pkt_family, ip_hdr, src_port, dst_port)) {
 8055fbb:	20 c2                	and    %al,%dl
 8055fbd:	88 55 e0             	mov    %dl,-0x20(%ebp)
 8055fc0:	0f 85 20 02 00 00    	jne    80561e6 <net_conn_input+0x312>
	if (IS_ENABLED(CONFIG_NET_IP)) {
		/* If we receive a packet with multicast destination address, we might
		 * need to deliver the packet to multiple recipients.
		 */
		if (IS_ENABLED(CONFIG_NET_IPV4) && pkt_family == AF_INET) {
			if (net_ipv4_is_addr_mcast((struct in_addr *)ip_hdr->ipv4->dst)) {
 8055fc6:	8b 45 0c             	mov    0xc(%ebp),%eax
		if (IS_ENABLED(CONFIG_NET_IPV4) && pkt_family == AF_INET) {
 8055fc9:	80 7d e2 01          	cmpb   $0x1,-0x1e(%ebp)
			if (net_ipv4_is_addr_mcast((struct in_addr *)ip_hdr->ipv4->dst)) {
 8055fcd:	8b 00                	mov    (%eax),%eax
		if (IS_ENABLED(CONFIG_NET_IPV4) && pkt_family == AF_INET) {
 8055fcf:	75 2b                	jne    8055ffc <net_conn_input+0x128>
	return (ntohl(UNALIGNED_GET(&addr->s_addr)) & 0xF0000000) == 0xE0000000;
 8055fd1:	8b 50 10             	mov    0x10(%eax),%edx
 8055fd4:	81 e2 f0 00 00 00    	and    $0xf0,%edx
			if (net_ipv4_is_addr_mcast((struct in_addr *)ip_hdr->ipv4->dst)) {
 8055fda:	81 fa e0 00 00 00    	cmp    $0xe0,%edx
 8055fe0:	74 28                	je     805600a <net_conn_input+0x136>
 8055fe2:	83 c0 10             	add    $0x10,%eax
				is_mcast_pkt = true;
			} else if (net_if_ipv4_is_addr_bcast(pkt_iface,
 8055fe5:	51                   	push   %ecx
 8055fe6:	51                   	push   %ecx
 8055fe7:	50                   	push   %eax
 8055fe8:	ff 75 e4             	push   -0x1c(%ebp)
 8055feb:	e8 a9 c5 ff ff       	call   8052599 <net_if_ipv4_is_addr_bcast>
	bool is_mcast_pkt = false;
 8055ff0:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			} else if (net_if_ipv4_is_addr_bcast(pkt_iface,
 8055ff4:	83 c4 10             	add    $0x10,%esp
 8055ff7:	88 45 e1             	mov    %al,-0x1f(%ebp)
 8055ffa:	eb 16                	jmp    8056012 <net_conn_input+0x13e>
	return addr->s6_addr[0] == 0xFF;
 8055ffc:	80 78 18 ff          	cmpb   $0xff,0x18(%eax)
	bool is_bcast_pkt = false;
 8056000:	c6 45 e1 00          	movb   $0x0,-0x1f(%ebp)
 8056004:	0f 94 45 e3          	sete   -0x1d(%ebp)
 8056008:	eb 08                	jmp    8056012 <net_conn_input+0x13e>
 805600a:	c6 45 e1 00          	movb   $0x0,-0x1f(%ebp)
				is_mcast_pkt = true;
 805600e:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
			}
			continue; /* wrong protocol family */
		}

		/* Is the candidate connection matching the packet's protocol wihin the family? */
		if (conn->proto != proto) {
 8056012:	0f b6 45 d8          	movzbl -0x28(%ebp),%eax
 8056016:	66 c7 45 da ff ff    	movw   $0xffff,-0x26(%ebp)
 805601c:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	return list->head;
 8056023:	8b 1d 04 8a 06 08    	mov    0x8068a04,%ebx
 8056029:	66 89 45 d8          	mov    %ax,-0x28(%ebp)
	SYS_SLIST_FOR_EACH_CONTAINER(&conn_used, conn, node) {
 805602d:	85 db                	test   %ebx,%ebx
 805602f:	0f 84 39 01 00 00    	je     805616e <net_conn_input+0x29a>
		if (conn->context != NULL &&
 8056035:	8b 43 38             	mov    0x38(%ebx),%eax
 8056038:	85 c0                	test   %eax,%eax
 805603a:	75 11                	jne    805604d <net_conn_input+0x179>
		if (conn->family != AF_UNSPEC &&
 805603c:	8a 43 42             	mov    0x42(%ebx),%al
 805603f:	84 c0                	test   %al,%al
 8056041:	74 33                	je     8056076 <net_conn_input+0x1a2>
 8056043:	3a 45 e2             	cmp    -0x1e(%ebp),%al
 8056046:	74 2e                	je     8056076 <net_conn_input+0x1a2>
 8056048:	e9 1a 01 00 00       	jmp    8056167 <net_conn_input+0x293>
		if (conn->context != NULL &&
 805604d:	f6 80 99 00 00 00 08 	testb  $0x8,0x99(%eax)
 8056054:	74 e6                	je     805603c <net_conn_input+0x168>
	return pkt->iface;
 8056056:	8b 7e 18             	mov    0x18(%esi),%edi
	return net_if_get_by_index(context->iface);
 8056059:	0f be 80 9a 00 00 00 	movsbl 0x9a(%eax),%eax
 8056060:	83 ec 0c             	sub    $0xc,%esp
 8056063:	50                   	push   %eax
 8056064:	e8 91 af ff ff       	call   8050ffa <z_impl_net_if_get_by_index>
 8056069:	83 c4 10             	add    $0x10,%esp
		    net_context_is_bound_to_iface(conn->context) &&
 805606c:	39 c7                	cmp    %eax,%edi
 805606e:	0f 85 f3 00 00 00    	jne    8056167 <net_conn_input+0x293>
 8056074:	eb c6                	jmp    805603c <net_conn_input+0x168>
		if (conn->proto != proto) {
 8056076:	8b 45 d8             	mov    -0x28(%ebp),%eax
 8056079:	66 39 43 40          	cmp    %ax,0x40(%ebx)
 805607d:	0f 85 e4 00 00 00    	jne    8056167 <net_conn_input+0x293>
			   (conn_family == AF_INET || conn_family == AF_INET6 ||
			    conn_family == AF_UNSPEC)) {
			/* Is the candidate connection matching the packet's TCP/UDP
			 * address and port?
			 */
			if (net_sin(&conn->remote_addr)->sin_port &&
 8056083:	66 8b 43 06          	mov    0x6(%ebx),%ax
 8056087:	66 3b 45 dc          	cmp    -0x24(%ebp),%ax
 805608b:	74 09                	je     8056096 <net_conn_input+0x1c2>
 805608d:	66 85 c0             	test   %ax,%ax
 8056090:	0f 85 d1 00 00 00    	jne    8056167 <net_conn_input+0x293>
			    net_sin(&conn->remote_addr)->sin_port != src_port) {
				continue; /* wrong remote port */
			}

			if (net_sin(&conn->local_addr)->sin_port &&
 8056096:	66 8b 43 1e          	mov    0x1e(%ebx),%ax
 805609a:	66 3b 45 de          	cmp    -0x22(%ebp),%ax
 805609e:	74 09                	je     80560a9 <net_conn_input+0x1d5>
 80560a0:	66 85 c0             	test   %ax,%ax
 80560a3:	0f 85 be 00 00 00    	jne    8056167 <net_conn_input+0x293>
			    net_sin(&conn->local_addr)->sin_port != dst_port) {
				continue; /* wrong local port */
			}

			if ((conn->flags & NET_CONN_REMOTE_ADDR_SET) &&
 80560a9:	0f b6 7b 43          	movzbl 0x43(%ebx),%edi
 80560ad:	f7 c7 02 00 00 00    	test   $0x2,%edi
 80560b3:	74 1d                	je     80560d2 <net_conn_input+0x1fe>
			    !conn_addr_cmp(pkt, ip_hdr, &conn->remote_addr, true)) {
 80560b5:	83 ec 0c             	sub    $0xc,%esp
 80560b8:	8b 55 0c             	mov    0xc(%ebp),%edx
 80560bb:	8d 4b 04             	lea    0x4(%ebx),%ecx
 80560be:	89 f0                	mov    %esi,%eax
 80560c0:	6a 01                	push   $0x1
 80560c2:	e8 60 f9 ff ff       	call   8055a27 <conn_addr_cmp>
 80560c7:	83 c4 10             	add    $0x10,%esp
			if ((conn->flags & NET_CONN_REMOTE_ADDR_SET) &&
 80560ca:	84 c0                	test   %al,%al
 80560cc:	0f 84 95 00 00 00    	je     8056167 <net_conn_input+0x293>
				continue; /* wrong remote address */
			}

			if ((conn->flags & NET_CONN_LOCAL_ADDR_SET) &&
 80560d2:	f7 c7 04 00 00 00    	test   $0x4,%edi
 80560d8:	74 19                	je     80560f3 <net_conn_input+0x21f>
			    !conn_addr_cmp(pkt, ip_hdr, &conn->local_addr, false)) {
 80560da:	83 ec 0c             	sub    $0xc,%esp
 80560dd:	8b 55 0c             	mov    0xc(%ebp),%edx
 80560e0:	8d 4b 1c             	lea    0x1c(%ebx),%ecx
 80560e3:	89 f0                	mov    %esi,%eax
 80560e5:	6a 00                	push   $0x0
 80560e7:	e8 3b f9 ff ff       	call   8055a27 <conn_addr_cmp>
 80560ec:	83 c4 10             	add    $0x10,%esp
			if ((conn->flags & NET_CONN_LOCAL_ADDR_SET) &&
 80560ef:	84 c0                	test   %al,%al
 80560f1:	74 74                	je     8056167 <net_conn_input+0x293>

			/* If we have an existing best_match, and that one
			 * specifies a remote port, then we've matched to a
			 * LISTENING connection that we should not override.
			 */
			if (best_match != NULL && best_match->flags & NET_CONN_REMOTE_PORT_SPEC) {
 80560f3:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
 80560f7:	74 09                	je     8056102 <net_conn_input+0x22e>
 80560f9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 80560fc:	f6 40 43 08          	testb  $0x8,0x43(%eax)
 8056100:	75 65                	jne    8056167 <net_conn_input+0x293>
				continue; /* do not override listening connection */
			}

			if (best_rank < NET_CONN_RANK(conn->flags)) {
 8056102:	0f bf 45 da          	movswl -0x26(%ebp),%eax
 8056106:	89 fa                	mov    %edi,%edx
 8056108:	83 e7 78             	and    $0x78,%edi
 805610b:	83 e2 78             	and    $0x78,%edx
 805610e:	39 f8                	cmp    %edi,%eax
 8056110:	7d 55                	jge    8056167 <net_conn_input+0x293>
				struct net_pkt *mcast_pkt;

				if (!is_mcast_pkt) {
 8056112:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
 8056116:	75 0c                	jne    8056124 <net_conn_input+0x250>
					best_rank = NET_CONN_RANK(conn->flags);
 8056118:	0f b6 c2             	movzbl %dl,%eax
					best_match = conn;

					continue; /* found a match - but maybe not yet the best */
 805611b:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
					best_rank = NET_CONN_RANK(conn->flags);
 805611e:	66 89 45 da          	mov    %ax,-0x26(%ebp)
					continue; /* found a match - but maybe not yet the best */
 8056122:	eb 43                	jmp    8056167 <net_conn_input+0x293>
				 */

				NET_DBG("[%p] mcast match found cb %p ud %p", conn, conn->cb,
					conn->user_data);

				mcast_pkt = net_pkt_clone(pkt, CLONE_TIMEOUT);
 8056124:	52                   	push   %edx
 8056125:	6a 00                	push   $0x0
 8056127:	6a 0a                	push   $0xa
 8056129:	56                   	push   %esi
 805612a:	e8 e9 f6 ff ff       	call   8055818 <net_pkt_clone>
 805612f:	83 c4 10             	add    $0x10,%esp
 8056132:	89 c7                	mov    %eax,%edi
				if (!mcast_pkt) {
 8056134:	85 c0                	test   %eax,%eax
 8056136:	0f 84 aa 00 00 00    	je     80561e6 <net_conn_input+0x312>
					goto drop;
				}

				if (conn->cb(conn, mcast_pkt, ip_hdr, proto_hdr, conn->user_data) ==
 805613c:	83 ec 0c             	sub    $0xc,%esp
 805613f:	ff 73 3c             	push   0x3c(%ebx)
 8056142:	ff 75 14             	push   0x14(%ebp)
 8056145:	ff 75 0c             	push   0xc(%ebp)
 8056148:	50                   	push   %eax
 8056149:	53                   	push   %ebx
 805614a:	ff 53 34             	call   *0x34(%ebx)
 805614d:	83 c4 20             	add    $0x20,%esp
 8056150:	83 f8 02             	cmp    $0x2,%eax
 8056153:	75 0c                	jne    8056161 <net_conn_input+0x28d>
				    NET_DROP) {
					net_stats_update_per_proto_drop(pkt_iface, proto);
					net_pkt_unref(mcast_pkt);
 8056155:	83 ec 0c             	sub    $0xc,%esp
 8056158:	57                   	push   %edi
 8056159:	e8 8a ec ff ff       	call   8054de8 <net_pkt_unref>
 805615e:	83 c4 10             	add    $0x10,%esp
				} else {
					net_stats_update_per_proto_recv(pkt_iface, proto);
				}

				mcast_pkt_delivered = true;
 8056161:	8a 45 e3             	mov    -0x1d(%ebp),%al
 8056164:	88 45 e0             	mov    %al,-0x20(%ebp)
	return node->next;
 8056167:	8b 1b                	mov    (%ebx),%ebx
 8056169:	e9 bf fe ff ff       	jmp    805602d <net_conn_input+0x159>
			net_pkt_unref(pkt);
			return NET_OK;
		}
	}

	if (IS_ENABLED(CONFIG_NET_IP) && is_mcast_pkt && mcast_pkt_delivered) {
 805616e:	80 7d e0 00          	cmpb   $0x0,-0x20(%ebp)
 8056172:	74 16                	je     805618a <net_conn_input+0x2b6>
 8056174:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
 8056178:	74 10                	je     805618a <net_conn_input+0x2b6>
		/* As one or more multicast packets
		 * have already been delivered in the loop above,
		 * we shall not call the callback again here.
		 */
		net_pkt_unref(pkt);
 805617a:	83 ec 0c             	sub    $0xc,%esp
 805617d:	56                   	push   %esi
 805617e:	e8 65 ec ff ff       	call   8054de8 <net_pkt_unref>
 8056183:	83 c4 10             	add    $0x10,%esp
		return NET_OK;
 8056186:	31 c0                	xor    %eax,%eax
 8056188:	eb 61                	jmp    80561eb <net_conn_input+0x317>
	}

	if (best_match) {
 805618a:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
 805618e:	74 24                	je     80561b4 <net_conn_input+0x2e0>
		NET_DBG("[%p] match found cb %p ud %p rank 0x%02x", best_match, best_match->cb,
			best_match->user_data, best_match->flags);

		if (best_match->cb(best_match, pkt, ip_hdr, proto_hdr, best_match->user_data)
 8056190:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8056193:	83 ec 0c             	sub    $0xc,%esp
 8056196:	ff 70 3c             	push   0x3c(%eax)
 8056199:	ff 75 14             	push   0x14(%ebp)
 805619c:	ff 75 0c             	push   0xc(%ebp)
 805619f:	56                   	push   %esi
 80561a0:	50                   	push   %eax
 80561a1:	ff 50 34             	call   *0x34(%eax)
 80561a4:	83 c4 20             	add    $0x20,%esp
 80561a7:	83 f8 02             	cmp    $0x2,%eax
 80561aa:	0f 94 c0             	sete   %al
 80561ad:	0f b6 c0             	movzbl %al,%eax
 80561b0:	01 c0                	add    %eax,%eax
 80561b2:	eb 37                	jmp    80561eb <net_conn_input+0x317>
		return NET_OK;
	}

	NET_DBG("No match found.");

	if (IS_ENABLED(CONFIG_NET_IP) && (pkt_family == AF_INET || pkt_family == AF_INET6) &&
 80561b4:	80 7d e1 00          	cmpb   $0x0,-0x1f(%ebp)
 80561b8:	75 2c                	jne    80561e6 <net_conn_input+0x312>
 80561ba:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
 80561be:	75 26                	jne    80561e6 <net_conn_input+0x312>
	return pkt->family;
 80561c0:	8a 46 33             	mov    0x33(%esi),%al
 80561c3:	c0 e8 05             	shr    $0x5,%al
	if (IS_ENABLED(CONFIG_NET_IPV6) && net_pkt_family(pkt) == AF_INET6) {
 80561c6:	3c 02                	cmp    $0x2,%al
 80561c8:	75 0e                	jne    80561d8 <net_conn_input+0x304>
		net_icmpv6_send_error(pkt, NET_ICMPV6_DST_UNREACH,
 80561ca:	6a 00                	push   $0x0
 80561cc:	6a 04                	push   $0x4
 80561ce:	6a 01                	push   $0x1
 80561d0:	56                   	push   %esi
 80561d1:	e8 20 0c 00 00       	call   8056df6 <net_icmpv6_send_error>
 80561d6:	eb 0b                	jmp    80561e3 <net_conn_input+0x30f>
		net_icmpv4_send_error(pkt, NET_ICMPV4_DST_UNREACH,
 80561d8:	50                   	push   %eax
 80561d9:	6a 03                	push   $0x3
 80561db:	6a 03                	push   $0x3
 80561dd:	56                   	push   %esi
 80561de:	e8 e5 02 00 00       	call   80564c8 <net_icmpv4_send_error>
 80561e3:	83 c4 10             	add    $0x10,%esp
	}

drop:
	net_stats_update_per_proto_drop(pkt_iface, proto);

	return NET_DROP;
 80561e6:	b8 02 00 00 00       	mov    $0x2,%eax
}
 80561eb:	8d 65 f4             	lea    -0xc(%ebp),%esp
 80561ee:	5b                   	pop    %ebx
 80561ef:	5e                   	pop    %esi
 80561f0:	5f                   	pop    %edi
 80561f1:	5d                   	pop    %ebp
 80561f2:	c3                   	ret    

080561f3 <net_conn_init>:

	k_mutex_unlock(&conn_lock);
}

void net_conn_init(void)
{
 80561f3:	55                   	push   %ebp
 80561f4:	b8 e0 82 06 08       	mov    $0x80682e0,%eax
	list->tail = NULL;
 80561f9:	31 c9                	xor    %ecx,%ecx
 80561fb:	31 d2                	xor    %edx,%edx
 80561fd:	c7 05 10 8a 06 08 00 	movl   $0x0,0x8068a10
 8056204:	00 00 00 
	list->head = NULL;
 8056207:	c7 05 04 8a 06 08 00 	movl   $0x0,0x8068a04
 805620e:	00 00 00 
	list->tail = NULL;
 8056211:	c7 05 08 8a 06 08 00 	movl   $0x0,0x8068a08
 8056218:	00 00 00 
 805621b:	89 e5                	mov    %esp,%ebp
 805621d:	56                   	push   %esi
 805621e:	53                   	push   %ebx
 805621f:	31 db                	xor    %ebx,%ebx

	sys_slist_init(&conn_unused);
	sys_slist_init(&conn_used);

	for (i = 0; i < CONFIG_NET_MAX_CONN; i++) {
		sys_slist_prepend(&conn_unused, &conns[i].node);
 8056221:	89 de                	mov    %ebx,%esi
 8056223:	89 c3                	mov    %eax,%ebx
Z_GENLIST_PREPEND(slist, snode)
 8056225:	85 d2                	test   %edx,%edx
 8056227:	75 04                	jne    805622d <net_conn_init+0x3a>
 8056229:	89 c2                	mov    %eax,%edx
 805622b:	b1 01                	mov    $0x1,%cl
	parent->next = child;
 805622d:	89 30                	mov    %esi,(%eax)
	for (i = 0; i < CONFIG_NET_MAX_CONN; i++) {
 805622f:	83 c0 44             	add    $0x44,%eax
 8056232:	3d 00 85 06 08       	cmp    $0x8068500,%eax
 8056237:	75 e8                	jne    8056221 <net_conn_init+0x2e>
 8056239:	c7 05 0c 8a 06 08 bc 	movl   $0x80684bc,0x8068a0c
 8056240:	84 06 08 
 8056243:	84 c9                	test   %cl,%cl
 8056245:	74 06                	je     805624d <net_conn_init+0x5a>
 8056247:	89 15 10 8a 06 08    	mov    %edx,0x8068a10
	}
}
 805624d:	5b                   	pop    %ebx
 805624e:	5e                   	pop    %esi
 805624f:	5d                   	pop    %ebp
 8056250:	c3                   	ret    

08056251 <icmpv4_create>:
	struct net_pkt *reply;
	const struct in_addr *src;
};

static int icmpv4_create(struct net_pkt *pkt, uint8_t icmp_type, uint8_t icmp_code)
{
 8056251:	55                   	push   %ebp
 8056252:	89 e5                	mov    %esp,%ebp
 8056254:	57                   	push   %edi
 8056255:	89 d7                	mov    %edx,%edi
 8056257:	56                   	push   %esi
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmpv4_access,
					      struct net_icmp_hdr);
	struct net_icmp_hdr *icmp_hdr;

	icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(pkt, &icmpv4_access);
 8056258:	8d 75 dc             	lea    -0x24(%ebp),%esi
{
 805625b:	53                   	push   %ebx
 805625c:	89 c3                	mov    %eax,%ebx
 805625e:	83 ec 34             	sub    $0x34,%esp
 8056261:	89 4d d4             	mov    %ecx,-0x2c(%ebp)
 8056264:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 805626a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 805626d:	31 c0                	xor    %eax,%eax
	icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(pkt, &icmpv4_access);
 805626f:	56                   	push   %esi
 8056270:	53                   	push   %ebx
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmpv4_access,
 8056271:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
 8056278:	c7 45 e0 04 00 00 00 	movl   $0x4,-0x20(%ebp)
	icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(pkt, &icmpv4_access);
 805627f:	e8 4e f6 ff ff       	call   80558d2 <net_pkt_get_data>
 8056284:	83 c4 10             	add    $0x10,%esp
	if (!icmp_hdr) {
 8056287:	b9 97 ff ff ff       	mov    $0xffffff97,%ecx
 805628c:	85 c0                	test   %eax,%eax
 805628e:	74 1e                	je     80562ae <icmpv4_create+0x5d>
		return -ENOBUFS;
	}

	icmp_hdr->type   = icmp_type;
	icmp_hdr->code   = icmp_code;
 8056290:	8b 55 d4             	mov    -0x2c(%ebp),%edx
	icmp_hdr->type   = icmp_type;
 8056293:	89 f9                	mov    %edi,%ecx
	icmp_hdr->chksum = 0U;
 8056295:	66 c7 40 02 00 00    	movw   $0x0,0x2(%eax)
	icmp_hdr->type   = icmp_type;
 805629b:	88 08                	mov    %cl,(%eax)
	icmp_hdr->code   = icmp_code;
 805629d:	88 50 01             	mov    %dl,0x1(%eax)

	return net_pkt_set_data(pkt, &icmpv4_access);
 80562a0:	50                   	push   %eax
 80562a1:	50                   	push   %eax
 80562a2:	56                   	push   %esi
 80562a3:	53                   	push   %ebx
 80562a4:	e8 8d f6 ff ff       	call   8055936 <net_pkt_set_data>
 80562a9:	83 c4 10             	add    $0x10,%esp
 80562ac:	89 c1                	mov    %eax,%ecx
}
 80562ae:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 80562b1:	65 2b 05 14 00 00 00 	sub    %gs:0x14,%eax
 80562b8:	74 05                	je     80562bf <icmpv4_create+0x6e>
 80562ba:	e8 41 30 ff ff       	call   8049300 <__stack_chk_fail@plt>
 80562bf:	8d 65 f4             	lea    -0xc(%ebp),%esp
 80562c2:	89 c8                	mov    %ecx,%eax
 80562c4:	5b                   	pop    %ebx
 80562c5:	5e                   	pop    %esi
 80562c6:	5f                   	pop    %edi
 80562c7:	5d                   	pop    %ebp
 80562c8:	c3                   	ret    

080562c9 <net_ipv4_is_addr_bcast>:
{
 80562c9:	55                   	push   %ebp
 80562ca:	89 e5                	mov    %esp,%ebp
 80562cc:	56                   	push   %esi
 80562cd:	89 c6                	mov    %eax,%esi
 80562cf:	53                   	push   %ebx
 80562d0:	89 d3                	mov    %edx,%ebx
	if (net_ipv4_addr_cmp(addr, net_ipv4_broadcast_address())) {
 80562d2:	e8 9d d4 ff ff       	call   8053774 <net_ipv4_broadcast_address>
 80562d7:	8b 00                	mov    (%eax),%eax
 80562d9:	39 03                	cmp    %eax,(%ebx)
 80562db:	74 0e                	je     80562eb <net_ipv4_is_addr_bcast+0x22>
	return net_if_ipv4_is_addr_bcast(iface, addr);
 80562dd:	50                   	push   %eax
 80562de:	50                   	push   %eax
 80562df:	53                   	push   %ebx
 80562e0:	56                   	push   %esi
 80562e1:	e8 b3 c2 ff ff       	call   8052599 <net_if_ipv4_is_addr_bcast>
 80562e6:	83 c4 10             	add    $0x10,%esp
 80562e9:	eb 02                	jmp    80562ed <net_ipv4_is_addr_bcast+0x24>
		return true;
 80562eb:	b0 01                	mov    $0x1,%al
}
 80562ed:	8d 65 f8             	lea    -0x8(%ebp),%esp
 80562f0:	5b                   	pop    %ebx
 80562f1:	5e                   	pop    %esi
 80562f2:	5d                   	pop    %ebp
 80562f3:	c3                   	ret    

080562f4 <icmpv4_handle_echo_request>:
#endif

static enum net_verdict icmpv4_handle_echo_request(struct net_pkt *pkt,
					   struct net_ipv4_hdr *ip_hdr,
					   struct net_icmp_hdr *icmp_hdr)
{
 80562f4:	55                   	push   %ebp
		net_pkt_unref(reply);
	}

	net_stats_update_icmp_drop(net_pkt_iface(pkt));

	return NET_DROP;
 80562f5:	b8 02 00 00 00       	mov    $0x2,%eax
{
 80562fa:	89 e5                	mov    %esp,%ebp
 80562fc:	57                   	push   %edi
 80562fd:	56                   	push   %esi
 80562fe:	53                   	push   %ebx
 80562ff:	83 ec 1c             	sub    $0x1c,%esp
 8056302:	8b 7d 0c             	mov    0xc(%ebp),%edi
 8056305:	8b 75 08             	mov    0x8(%ebp),%esi
	if (net_ipv4_is_addr_unspecified((struct in_addr *)ip_hdr->src)) {
 8056308:	83 7f 0c 00          	cmpl   $0x0,0xc(%edi)
 805630c:	0f 84 23 01 00 00    	je     8056435 <icmpv4_handle_echo_request+0x141>
	payload_len = net_pkt_get_len(pkt) -
 8056312:	8b 56 08             	mov    0x8(%esi),%edx
	size_t bytes = 0;
 8056315:	31 c0                	xor    %eax,%eax
	while (buf) {
 8056317:	85 d2                	test   %edx,%edx
 8056319:	74 0b                	je     8056326 <icmpv4_handle_echo_request+0x32>
		bytes += buf->len;
 805631b:	0f b7 4a 10          	movzwl 0x10(%edx),%ecx
		buf = buf->frags;
 805631f:	8b 52 04             	mov    0x4(%edx),%edx
		bytes += buf->len;
 8056322:	01 c8                	add    %ecx,%eax
		buf = buf->frags;
 8056324:	eb f1                	jmp    8056317 <icmpv4_handle_echo_request+0x23>
	return pkt->ipv4_opts_len;
 8056326:	0f b6 5e 36          	movzbl 0x36(%esi),%ebx
		      net_pkt_ip_hdr_len(pkt) -
 805632a:	0f b6 4e 32          	movzbl 0x32(%esi),%ecx
		      net_pkt_ipv4_opts_len(pkt) - NET_ICMPH_LEN;
 805632e:	01 d9                	add    %ebx,%ecx
 8056330:	89 da                	mov    %ebx,%edx
 8056332:	29 c8                	sub    %ecx,%eax
 8056334:	83 e8 04             	sub    $0x4,%eax
	if (payload_len < NET_ICMPV4_UNUSED_LEN) {
 8056337:	66 83 f8 03          	cmp    $0x3,%ax
 805633b:	0f 8e ef 00 00 00    	jle    8056430 <icmpv4_handle_echo_request+0x13c>
					  net_pkt_ipv4_opts_len(pkt) +
 8056341:	98                   	cwtl   
	reply = net_pkt_alloc_with_buffer(net_pkt_iface(pkt),
 8056342:	51                   	push   %ecx
					  net_pkt_ipv4_opts_len(pkt) +
 8056343:	01 c2                	add    %eax,%edx
	reply = net_pkt_alloc_with_buffer(net_pkt_iface(pkt),
 8056345:	51                   	push   %ecx
 8056346:	6a 00                	push   $0x0
 8056348:	6a 64                	push   $0x64
 805634a:	6a 01                	push   $0x1
 805634c:	6a 01                	push   $0x1
 805634e:	52                   	push   %edx
 805634f:	ff 76 18             	push   0x18(%esi)
					  net_pkt_ipv4_opts_len(pkt) +
 8056352:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	reply = net_pkt_alloc_with_buffer(net_pkt_iface(pkt),
 8056355:	e8 ad ef ff ff       	call   8055307 <net_pkt_alloc_with_buffer>
 805635a:	83 c4 20             	add    $0x20,%esp
 805635d:	89 c3                	mov    %eax,%ebx
	if (!reply) {
 805635f:	85 c0                	test   %eax,%eax
 8056361:	0f 84 c9 00 00 00    	je     8056430 <icmpv4_handle_echo_request+0x13c>
	return (ntohl(UNALIGNED_GET(&addr->s_addr)) & 0xF0000000) == 0xE0000000;
 8056367:	8b 4f 10             	mov    0x10(%edi),%ecx
	return pkt->iface;
 805636a:	8b 46 18             	mov    0x18(%esi),%eax
	if (net_ipv4_is_addr_mcast((struct in_addr *)ip_hdr->dst) ||
 805636d:	8d 57 10             	lea    0x10(%edi),%edx
 8056370:	81 e1 f0 00 00 00    	and    $0xf0,%ecx
 8056376:	81 f9 e0 00 00 00    	cmp    $0xe0,%ecx
 805637c:	75 12                	jne    8056390 <icmpv4_handle_echo_request+0x9c>
		src = net_if_ipv4_select_src_addr(net_pkt_iface(pkt),
 805637e:	50                   	push   %eax
 805637f:	50                   	push   %eax
 8056380:	52                   	push   %edx
 8056381:	ff 76 18             	push   0x18(%esi)
 8056384:	e8 d2 c2 ff ff       	call   805265b <net_if_ipv4_select_src_addr>
 8056389:	83 c4 10             	add    $0x10,%esp
 805638c:	89 c2                	mov    %eax,%edx
 805638e:	eb 0f                	jmp    805639f <icmpv4_handle_echo_request+0xab>
	    net_ipv4_is_addr_bcast(net_pkt_iface(pkt),
 8056390:	89 55 e0             	mov    %edx,-0x20(%ebp)
 8056393:	e8 31 ff ff ff       	call   80562c9 <net_ipv4_is_addr_bcast>
	if (net_ipv4_is_addr_mcast((struct in_addr *)ip_hdr->dst) ||
 8056398:	8b 55 e0             	mov    -0x20(%ebp),%edx
 805639b:	84 c0                	test   %al,%al
 805639d:	75 df                	jne    805637e <icmpv4_handle_echo_request+0x8a>
	return pkt->ip_dscp;
 805639f:	8a 4e 3c             	mov    0x3c(%esi),%cl
	pkt->ip_dscp = dscp;
 80563a2:	8a 43 3c             	mov    0x3c(%ebx),%al
	if (net_ipv4_create(reply, src, (struct in_addr *)ip_hdr->src)) {
 80563a5:	83 c7 0c             	add    $0xc,%edi
	return pkt->ip_dscp;
 80563a8:	83 e1 3f             	and    $0x3f,%ecx
	pkt->ip_dscp = dscp;
 80563ab:	83 e0 c0             	and    $0xffffffc0,%eax
 80563ae:	09 c8                	or     %ecx,%eax
 80563b0:	88 43 3c             	mov    %al,0x3c(%ebx)
	pkt->ip_ecn = ecn;
 80563b3:	8a 4e 3c             	mov    0x3c(%esi),%cl
 80563b6:	83 e0 3f             	and    $0x3f,%eax
 80563b9:	83 e1 c0             	and    $0xffffffc0,%ecx
 80563bc:	09 c8                	or     %ecx,%eax
 80563be:	88 43 3c             	mov    %al,0x3c(%ebx)
 80563c1:	50                   	push   %eax
 80563c2:	57                   	push   %edi
 80563c3:	52                   	push   %edx
 80563c4:	53                   	push   %ebx
 80563c5:	e8 c8 04 00 00       	call   8056892 <net_ipv4_create>
 80563ca:	83 c4 10             	add    $0x10,%esp
 80563cd:	85 c0                	test   %eax,%eax
 80563cf:	75 53                	jne    8056424 <icmpv4_handle_echo_request+0x130>
	if (icmpv4_create(reply, NET_ICMPV4_ECHO_REPLY, 0) ||
 80563d1:	31 c9                	xor    %ecx,%ecx
 80563d3:	31 d2                	xor    %edx,%edx
 80563d5:	89 d8                	mov    %ebx,%eax
 80563d7:	e8 75 fe ff ff       	call   8056251 <icmpv4_create>
 80563dc:	85 c0                	test   %eax,%eax
 80563de:	75 44                	jne    8056424 <icmpv4_handle_echo_request+0x130>
	    net_pkt_copy(reply, pkt, payload_len)) {
 80563e0:	51                   	push   %ecx
 80563e1:	ff 75 e4             	push   -0x1c(%ebp)
 80563e4:	56                   	push   %esi
 80563e5:	53                   	push   %ebx
 80563e6:	e8 92 f1 ff ff       	call   805557d <net_pkt_copy>
 80563eb:	83 c4 10             	add    $0x10,%esp
	if (icmpv4_create(reply, NET_ICMPV4_ECHO_REPLY, 0) ||
 80563ee:	85 c0                	test   %eax,%eax
 80563f0:	75 32                	jne    8056424 <icmpv4_handle_echo_request+0x130>
	net_pkt_cursor_init(reply);
 80563f2:	83 ec 0c             	sub    $0xc,%esp
 80563f5:	53                   	push   %ebx
 80563f6:	e8 59 eb ff ff       	call   8054f54 <net_pkt_cursor_init>
 80563fb:	58                   	pop    %eax
 80563fc:	5a                   	pop    %edx
	net_ipv4_finalize(reply, IPPROTO_ICMP);
 80563fd:	6a 01                	push   $0x1
 80563ff:	53                   	push   %ebx
 8056400:	e8 bc 04 00 00       	call   80568c1 <net_ipv4_finalize>
	if (net_send_data(reply) < 0) {
 8056405:	89 1c 24             	mov    %ebx,(%esp)
 8056408:	e8 23 a0 ff ff       	call   8050430 <net_send_data>
 805640d:	83 c4 10             	add    $0x10,%esp
 8056410:	85 c0                	test   %eax,%eax
 8056412:	78 10                	js     8056424 <icmpv4_handle_echo_request+0x130>
	net_pkt_unref(pkt);
 8056414:	83 ec 0c             	sub    $0xc,%esp
 8056417:	56                   	push   %esi
 8056418:	e8 cb e9 ff ff       	call   8054de8 <net_pkt_unref>
 805641d:	83 c4 10             	add    $0x10,%esp
	return NET_OK;
 8056420:	31 c0                	xor    %eax,%eax
 8056422:	eb 11                	jmp    8056435 <icmpv4_handle_echo_request+0x141>
		net_pkt_unref(reply);
 8056424:	83 ec 0c             	sub    $0xc,%esp
 8056427:	53                   	push   %ebx
 8056428:	e8 bb e9 ff ff       	call   8054de8 <net_pkt_unref>
 805642d:	83 c4 10             	add    $0x10,%esp
	return NET_DROP;
 8056430:	b8 02 00 00 00       	mov    $0x2,%eax
}
 8056435:	8d 65 f4             	lea    -0xc(%ebp),%esp
 8056438:	5b                   	pop    %ebx
 8056439:	5e                   	pop    %esi
 805643a:	5f                   	pop    %edi
 805643b:	5d                   	pop    %ebp
 805643c:	c3                   	ret    

0805643d <net_icmpv4_finalize>:
{
 805643d:	55                   	push   %ebp
 805643e:	89 e5                	mov    %esp,%ebp
 8056440:	57                   	push   %edi
 8056441:	56                   	push   %esi
	icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(pkt, &icmpv4_access);
 8056442:	8d 7d dc             	lea    -0x24(%ebp),%edi
{
 8056445:	53                   	push   %ebx
 8056446:	83 ec 24             	sub    $0x24,%esp
 8056449:	8b 75 08             	mov    0x8(%ebp),%esi
 805644c:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 8056452:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 8056455:	31 c0                	xor    %eax,%eax
	icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(pkt, &icmpv4_access);
 8056457:	57                   	push   %edi
 8056458:	56                   	push   %esi
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmpv4_access,
 8056459:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
 8056460:	c7 45 e0 04 00 00 00 	movl   $0x4,-0x20(%ebp)
	icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(pkt, &icmpv4_access);
 8056467:	e8 66 f4 ff ff       	call   80558d2 <net_pkt_get_data>
 805646c:	83 c4 10             	add    $0x10,%esp
 805646f:	89 c3                	mov    %eax,%ebx
	if (!icmp_hdr) {
 8056471:	b8 97 ff ff ff       	mov    $0xffffff97,%eax
 8056476:	85 db                	test   %ebx,%ebx
 8056478:	74 35                	je     80564af <net_icmpv4_finalize+0x72>
	if (net_if_need_calc_tx_checksum(net_pkt_iface(pkt))) {
 805647a:	83 ec 0c             	sub    $0xc,%esp
	icmp_hdr->chksum = 0U;
 805647d:	66 c7 43 02 00 00    	movw   $0x0,0x2(%ebx)
	if (net_if_need_calc_tx_checksum(net_pkt_iface(pkt))) {
 8056483:	ff 76 18             	push   0x18(%esi)
 8056486:	e8 d5 c5 ff ff       	call   8052a60 <net_if_need_calc_tx_checksum>
 805648b:	83 c4 10             	add    $0x10,%esp
 805648e:	84 c0                	test   %al,%al
 8056490:	74 11                	je     80564a3 <net_icmpv4_finalize+0x66>
	return net_calc_chksum(pkt, IPPROTO_ICMPV6);
}

static inline uint16_t net_calc_chksum_icmpv4(struct net_pkt *pkt)
{
	return net_calc_chksum(pkt, IPPROTO_ICMP);
 8056492:	52                   	push   %edx
 8056493:	52                   	push   %edx
 8056494:	6a 01                	push   $0x1
 8056496:	56                   	push   %esi
 8056497:	e8 77 d0 ff ff       	call   8053513 <net_calc_chksum>
 805649c:	83 c4 10             	add    $0x10,%esp
		icmp_hdr->chksum = net_calc_chksum_icmpv4(pkt);
 805649f:	66 89 43 02          	mov    %ax,0x2(%ebx)
	return net_pkt_set_data(pkt, &icmpv4_access);
 80564a3:	50                   	push   %eax
 80564a4:	50                   	push   %eax
 80564a5:	57                   	push   %edi
 80564a6:	56                   	push   %esi
 80564a7:	e8 8a f4 ff ff       	call   8055936 <net_pkt_set_data>
 80564ac:	83 c4 10             	add    $0x10,%esp
}
 80564af:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 80564b2:	65 2b 15 14 00 00 00 	sub    %gs:0x14,%edx
 80564b9:	74 05                	je     80564c0 <net_icmpv4_finalize+0x83>
 80564bb:	e8 40 2e ff ff       	call   8049300 <__stack_chk_fail@plt>
 80564c0:	8d 65 f4             	lea    -0xc(%ebp),%esp
 80564c3:	5b                   	pop    %ebx
 80564c4:	5e                   	pop    %esi
 80564c5:	5f                   	pop    %edi
 80564c6:	5d                   	pop    %ebp
 80564c7:	c3                   	ret    

080564c8 <net_icmpv4_send_error>:

	return ret;
}

int net_icmpv4_send_error(struct net_pkt *orig, uint8_t type, uint8_t code)
{
 80564c8:	55                   	push   %ebp
 80564c9:	89 e5                	mov    %esp,%ebp
 80564cb:	57                   	push   %edi
 80564cc:	56                   	push   %esi
 80564cd:	53                   	push   %ebx
 80564ce:	83 ec 48             	sub    $0x48,%esp
 80564d1:	8b 45 0c             	mov    0xc(%ebp),%eax
 80564d4:	8b 7d 08             	mov    0x8(%ebp),%edi
 80564d7:	89 45 bc             	mov    %eax,-0x44(%ebp)
 80564da:	8b 45 10             	mov    0x10(%ebp),%eax
 80564dd:	89 45 b8             	mov    %eax,-0x48(%ebp)
 80564e0:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 80564e6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 80564e9:	31 c0                	xor    %eax,%eax
	int err = -EIO;
	struct net_ipv4_hdr *ip_hdr;
	struct net_pkt *pkt;
	size_t copy_len;

	net_pkt_cursor_init(orig);
 80564eb:	57                   	push   %edi
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv4_access, struct net_ipv4_hdr);
 80564ec:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
 80564f3:	c7 45 d8 14 00 00 00 	movl   $0x14,-0x28(%ebp)
	net_pkt_cursor_init(orig);
 80564fa:	e8 55 ea ff ff       	call   8054f54 <net_pkt_cursor_init>
 80564ff:	58                   	pop    %eax

	ip_hdr = (struct net_ipv4_hdr *)net_pkt_get_data(orig, &ipv4_access);
 8056500:	8d 45 d4             	lea    -0x2c(%ebp),%eax
	net_pkt_cursor_init(orig);
 8056503:	5a                   	pop    %edx
	ip_hdr = (struct net_ipv4_hdr *)net_pkt_get_data(orig, &ipv4_access);
 8056504:	50                   	push   %eax
 8056505:	57                   	push   %edi
 8056506:	e8 c7 f3 ff ff       	call   80558d2 <net_pkt_get_data>
 805650b:	83 c4 10             	add    $0x10,%esp
	if (!ip_hdr) {
 805650e:	85 c0                	test   %eax,%eax
 8056510:	0f 84 ba 00 00 00    	je     80565d0 <net_icmpv4_send_error+0x108>
		goto drop_no_pkt;
	}

	if (ip_hdr->proto == IPPROTO_ICMP) {
 8056516:	80 78 09 01          	cmpb   $0x1,0x9(%eax)
 805651a:	89 c6                	mov    %eax,%esi
 805651c:	75 31                	jne    805654f <net_icmpv4_send_error+0x87>
		NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmpv4_access,
						      struct net_icmp_hdr);
		struct net_icmp_hdr *icmp_hdr;

		icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(
 805651e:	50                   	push   %eax
 805651f:	50                   	push   %eax
 8056520:	8d 45 dc             	lea    -0x24(%ebp),%eax
 8056523:	50                   	push   %eax
 8056524:	57                   	push   %edi
		NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmpv4_access,
 8056525:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
 805652c:	c7 45 e0 04 00 00 00 	movl   $0x4,-0x20(%ebp)
		icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(
 8056533:	e8 9a f3 ff ff       	call   80558d2 <net_pkt_get_data>
 8056538:	83 c4 10             	add    $0x10,%esp
							orig, &icmpv4_access);
		if (!icmp_hdr || icmp_hdr->code < 8) {
 805653b:	85 c0                	test   %eax,%eax
 805653d:	74 06                	je     8056545 <net_icmpv4_send_error+0x7d>
 805653f:	80 78 01 07          	cmpb   $0x7,0x1(%eax)
 8056543:	77 0a                	ja     805654f <net_icmpv4_send_error+0x87>
			/* We must not send ICMP errors back */
			err = -EINVAL;
 8056545:	ba ea ff ff ff       	mov    $0xffffffea,%edx
 805654a:	e9 f3 00 00 00       	jmp    8056642 <net_icmpv4_send_error+0x17a>
			goto drop_no_pkt;
		}
	}

	if (net_ipv4_is_addr_bcast(net_pkt_iface(orig),
				   (struct in_addr *)ip_hdr->dst)) {
 805654f:	8d 46 10             	lea    0x10(%esi),%eax
	if (net_ipv4_is_addr_bcast(net_pkt_iface(orig),
 8056552:	8d 56 10             	lea    0x10(%esi),%edx
				   (struct in_addr *)ip_hdr->dst)) {
 8056555:	89 45 c0             	mov    %eax,-0x40(%ebp)
	if (net_ipv4_is_addr_bcast(net_pkt_iface(orig),
 8056558:	8b 47 18             	mov    0x18(%edi),%eax
 805655b:	e8 69 fd ff ff       	call   80562c9 <net_ipv4_is_addr_bcast>
 8056560:	84 c0                	test   %al,%al
 8056562:	75 6c                	jne    80565d0 <net_icmpv4_send_error+0x108>
			net_sprint_ipv4_addr(&ip_hdr->src),
			net_proto2str(AF_INET, ip_hdr->proto));
		goto drop_no_pkt;
	}

	if (ip_hdr->proto == IPPROTO_UDP) {
 8056564:	8a 46 09             	mov    0x9(%esi),%al
		copy_len = sizeof(struct net_ipv4_hdr) +
 8056567:	c7 45 c4 1c 00 00 00 	movl   $0x1c,-0x3c(%ebp)
	if (ip_hdr->proto == IPPROTO_UDP) {
 805656e:	3c 11                	cmp    $0x11,%al
 8056570:	74 12                	je     8056584 <net_icmpv4_send_error+0xbc>
			sizeof(struct net_udp_hdr);
	} else if (ip_hdr->proto == IPPROTO_TCP) {
		copy_len = sizeof(struct net_ipv4_hdr) +
			sizeof(struct net_tcp_hdr);
	} else {
		copy_len = 0;
 8056572:	3c 06                	cmp    $0x6,%al
 8056574:	ba 28 00 00 00       	mov    $0x28,%edx
 8056579:	b8 00 00 00 00       	mov    $0x0,%eax
 805657e:	0f 44 c2             	cmove  %edx,%eax
 8056581:	89 45 c4             	mov    %eax,-0x3c(%ebp)
	}

	pkt = net_pkt_alloc_with_buffer(net_pkt_iface(orig),
 8056584:	50                   	push   %eax
 8056585:	50                   	push   %eax
 8056586:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 8056589:	6a 00                	push   $0x0
 805658b:	83 c0 04             	add    $0x4,%eax
 805658e:	6a 64                	push   $0x64
 8056590:	6a 01                	push   $0x1
 8056592:	6a 01                	push   $0x1
 8056594:	50                   	push   %eax
 8056595:	ff 77 18             	push   0x18(%edi)
 8056598:	e8 6a ed ff ff       	call   8055307 <net_pkt_alloc_with_buffer>
 805659d:	83 c4 20             	add    $0x20,%esp
					copy_len + NET_ICMPV4_UNUSED_LEN,
					AF_INET, IPPROTO_ICMP,
					PKT_WAIT_TIME);
	if (!pkt) {
		err =  -ENOMEM;
 80565a0:	ba f4 ff ff ff       	mov    $0xfffffff4,%edx
	pkt = net_pkt_alloc_with_buffer(net_pkt_iface(orig),
 80565a5:	89 c3                	mov    %eax,%ebx
	if (!pkt) {
 80565a7:	85 c0                	test   %eax,%eax
 80565a9:	0f 84 93 00 00 00    	je     8056642 <net_icmpv4_send_error+0x17a>
		goto drop_no_pkt;
	}

	if (net_ipv4_create(pkt, (struct in_addr *)ip_hdr->dst,
			    (struct in_addr *)ip_hdr->src) ||
 80565af:	83 c6 0c             	add    $0xc,%esi
	if (net_ipv4_create(pkt, (struct in_addr *)ip_hdr->dst,
 80565b2:	50                   	push   %eax
 80565b3:	56                   	push   %esi
 80565b4:	ff 75 c0             	push   -0x40(%ebp)
 80565b7:	53                   	push   %ebx
 80565b8:	e8 d5 02 00 00       	call   8056892 <net_ipv4_create>
 80565bd:	83 c4 10             	add    $0x10,%esp
 80565c0:	85 c0                	test   %eax,%eax
 80565c2:	74 13                	je     80565d7 <net_icmpv4_send_error+0x10f>
		net_stats_update_icmp_sent(net_pkt_iface(orig));
		return 0;
	}

drop:
	net_pkt_unref(pkt);
 80565c4:	83 ec 0c             	sub    $0xc,%esp
 80565c7:	53                   	push   %ebx
 80565c8:	e8 1b e8 ff ff       	call   8054de8 <net_pkt_unref>
 80565cd:	83 c4 10             	add    $0x10,%esp
	int err = -EIO;
 80565d0:	ba fb ff ff ff       	mov    $0xfffffffb,%edx
 80565d5:	eb 6b                	jmp    8056642 <net_icmpv4_send_error+0x17a>
	    icmpv4_create(pkt, type, code) ||
 80565d7:	0f b6 4d b8          	movzbl -0x48(%ebp),%ecx
 80565db:	0f b6 55 bc          	movzbl -0x44(%ebp),%edx
 80565df:	89 d8                	mov    %ebx,%eax
 80565e1:	e8 6b fc ff ff       	call   8056251 <icmpv4_create>
			    (struct in_addr *)ip_hdr->src) ||
 80565e6:	85 c0                	test   %eax,%eax
 80565e8:	75 da                	jne    80565c4 <net_icmpv4_send_error+0xfc>
	    net_pkt_memset(pkt, 0, NET_ICMPV4_UNUSED_LEN) ||
 80565ea:	56                   	push   %esi
 80565eb:	6a 04                	push   $0x4
 80565ed:	6a 00                	push   $0x0
 80565ef:	53                   	push   %ebx
 80565f0:	e8 08 ef ff ff       	call   80554fd <net_pkt_memset>
 80565f5:	83 c4 10             	add    $0x10,%esp
	    icmpv4_create(pkt, type, code) ||
 80565f8:	85 c0                	test   %eax,%eax
 80565fa:	75 c8                	jne    80565c4 <net_icmpv4_send_error+0xfc>
	    net_pkt_copy(pkt, orig, copy_len)) {
 80565fc:	51                   	push   %ecx
 80565fd:	ff 75 c4             	push   -0x3c(%ebp)
 8056600:	57                   	push   %edi
 8056601:	53                   	push   %ebx
 8056602:	e8 76 ef ff ff       	call   805557d <net_pkt_copy>
 8056607:	83 c4 10             	add    $0x10,%esp
	    net_pkt_memset(pkt, 0, NET_ICMPV4_UNUSED_LEN) ||
 805660a:	85 c0                	test   %eax,%eax
 805660c:	89 45 c4             	mov    %eax,-0x3c(%ebp)
 805660f:	75 b3                	jne    80565c4 <net_icmpv4_send_error+0xfc>
	net_pkt_cursor_init(pkt);
 8056611:	83 ec 0c             	sub    $0xc,%esp
 8056614:	53                   	push   %ebx
 8056615:	e8 3a e9 ff ff       	call   8054f54 <net_pkt_cursor_init>
 805661a:	58                   	pop    %eax
 805661b:	5a                   	pop    %edx
	net_ipv4_finalize(pkt, IPPROTO_ICMP);
 805661c:	6a 01                	push   $0x1
 805661e:	53                   	push   %ebx
 805661f:	e8 9d 02 00 00       	call   80568c1 <net_ipv4_finalize>
	net_pkt_lladdr_dst(pkt)->addr = net_pkt_lladdr_src(orig)->addr;
 8056624:	8b 47 20             	mov    0x20(%edi),%eax
 8056627:	89 43 28             	mov    %eax,0x28(%ebx)
	net_pkt_lladdr_dst(pkt)->len = net_pkt_lladdr_src(orig)->len;
 805662a:	8a 47 24             	mov    0x24(%edi),%al
 805662d:	88 43 2c             	mov    %al,0x2c(%ebx)
	if (net_send_data(pkt) >= 0) {
 8056630:	89 1c 24             	mov    %ebx,(%esp)
 8056633:	e8 f8 9d ff ff       	call   8050430 <net_send_data>
 8056638:	83 c4 10             	add    $0x10,%esp
 805663b:	8b 55 c4             	mov    -0x3c(%ebp),%edx
 805663e:	85 c0                	test   %eax,%eax
 8056640:	78 82                	js     80565c4 <net_icmpv4_send_error+0xfc>
drop_no_pkt:
	net_stats_update_icmp_drop(net_pkt_iface(orig));

	return err;

}
 8056642:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8056645:	65 2b 05 14 00 00 00 	sub    %gs:0x14,%eax
 805664c:	74 05                	je     8056653 <net_icmpv4_send_error+0x18b>
 805664e:	e8 ad 2c ff ff       	call   8049300 <__stack_chk_fail@plt>
 8056653:	8d 65 f4             	lea    -0xc(%ebp),%esp
 8056656:	89 d0                	mov    %edx,%eax
 8056658:	5b                   	pop    %ebx
 8056659:	5e                   	pop    %esi
 805665a:	5f                   	pop    %edi
 805665b:	5d                   	pop    %ebp
 805665c:	c3                   	ret    

0805665d <net_icmpv4_register_handler>:

void net_icmpv4_register_handler(struct net_icmpv4_handler *handler)
{
 805665d:	55                   	push   %ebp
	return list->head;
 805665e:	8b 15 14 8a 06 08    	mov    0x8068a14,%edx
 8056664:	89 e5                	mov    %esp,%ebp
 8056666:	8b 45 08             	mov    0x8(%ebp),%eax
	parent->next = child;
 8056669:	89 10                	mov    %edx,(%eax)
Z_GENLIST_PREPEND(slist, snode)
 805666b:	83 3d 18 8a 06 08 00 	cmpl   $0x0,0x8068a18
	list->head = node;
 8056672:	a3 14 8a 06 08       	mov    %eax,0x8068a14
Z_GENLIST_PREPEND(slist, snode)
 8056677:	75 05                	jne    805667e <net_icmpv4_register_handler+0x21>
	list->tail = node;
 8056679:	a3 18 8a 06 08       	mov    %eax,0x8068a18
	sys_slist_prepend(&handlers, &handler->node);
}
 805667e:	5d                   	pop    %ebp
 805667f:	c3                   	ret    

08056680 <net_icmpv4_input>:
	sys_slist_find_and_remove(&handlers, &handler->node);
}

enum net_verdict net_icmpv4_input(struct net_pkt *pkt,
				  struct net_ipv4_hdr *ip_hdr)
{
 8056680:	55                   	push   %ebp
 8056681:	89 e5                	mov    %esp,%ebp
 8056683:	57                   	push   %edi
 8056684:	56                   	push   %esi
 8056685:	53                   	push   %ebx
 8056686:	83 ec 24             	sub    $0x24,%esp
 8056689:	8b 75 08             	mov    0x8(%ebp),%esi
 805668c:	8b 7d 0c             	mov    0xc(%ebp),%edi
 805668f:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 8056695:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 8056698:	31 c0                	xor    %eax,%eax
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmp_access,
					      struct net_icmp_hdr);
	struct net_icmp_hdr *icmp_hdr;
	struct net_icmpv4_handler *cb;

	icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(pkt, &icmp_access);
 805669a:	8d 45 dc             	lea    -0x24(%ebp),%eax
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmp_access,
 805669d:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(pkt, &icmp_access);
 80566a4:	50                   	push   %eax
 80566a5:	56                   	push   %esi
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmp_access,
 80566a6:	c7 45 e0 04 00 00 00 	movl   $0x4,-0x20(%ebp)
	icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(pkt, &icmp_access);
 80566ad:	e8 20 f2 ff ff       	call   80558d2 <net_pkt_get_data>
 80566b2:	83 c4 10             	add    $0x10,%esp
	if (!icmp_hdr) {
 80566b5:	85 c0                	test   %eax,%eax
 80566b7:	75 07                	jne    80566c0 <net_icmpv4_input+0x40>
		NET_DBG("DROP: NULL ICMPv4 header");
		return NET_DROP;
 80566b9:	b8 02 00 00 00       	mov    $0x2,%eax
 80566be:	eb 77                	jmp    8056737 <net_icmpv4_input+0xb7>
	}

	if (net_if_need_calc_rx_checksum(net_pkt_iface(pkt))) {
 80566c0:	83 ec 0c             	sub    $0xc,%esp
 80566c3:	ff 76 18             	push   0x18(%esi)
 80566c6:	89 c3                	mov    %eax,%ebx
 80566c8:	e8 a4 c3 ff ff       	call   8052a71 <net_if_need_calc_rx_checksum>
 80566cd:	83 c4 10             	add    $0x10,%esp
 80566d0:	84 c0                	test   %al,%al
 80566d2:	75 11                	jne    80566e5 <net_icmpv4_input+0x65>
			NET_DBG("DROP: Invalid checksum");
			goto drop;
		}
	}

	if (net_ipv4_is_addr_bcast(net_pkt_iface(pkt),
 80566d4:	8b 46 18             	mov    0x18(%esi),%eax
				   (struct in_addr *)ip_hdr->dst) &&
 80566d7:	8d 57 10             	lea    0x10(%edi),%edx
	if (net_ipv4_is_addr_bcast(net_pkt_iface(pkt),
 80566da:	e8 ea fb ff ff       	call   80562c9 <net_ipv4_is_addr_bcast>
 80566df:	84 c0                	test   %al,%al
 80566e1:	74 16                	je     80566f9 <net_icmpv4_input+0x79>
 80566e3:	eb d4                	jmp    80566b9 <net_icmpv4_input+0x39>
 80566e5:	50                   	push   %eax
 80566e6:	50                   	push   %eax
 80566e7:	6a 01                	push   $0x1
 80566e9:	56                   	push   %esi
 80566ea:	e8 24 ce ff ff       	call   8053513 <net_calc_chksum>
 80566ef:	83 c4 10             	add    $0x10,%esp
		if (net_calc_chksum_icmpv4(pkt) != 0U) {
 80566f2:	66 85 c0             	test   %ax,%ax
 80566f5:	74 dd                	je     80566d4 <net_icmpv4_input+0x54>
 80566f7:	eb c0                	jmp    80566b9 <net_icmpv4_input+0x39>
	return net_pkt_skip(pkt, access->size);
 80566f9:	51                   	push   %ecx
 80566fa:	51                   	push   %ecx
 80566fb:	ff 75 e0             	push   -0x20(%ebp)
 80566fe:	56                   	push   %esi
 80566ff:	e8 6d ec ff ff       	call   8055371 <net_pkt_skip>
	return list->head;
 8056704:	a1 14 8a 06 08       	mov    0x8068a14,%eax
 8056709:	83 c4 10             	add    $0x10,%esp
	NET_DBG("ICMPv4 packet received type %d code %d",
		icmp_hdr->type, icmp_hdr->code);

	net_stats_update_icmp_recv(net_pkt_iface(pkt));

	SYS_SLIST_FOR_EACH_CONTAINER(&handlers, cb, node) {
 805670c:	85 c0                	test   %eax,%eax
 805670e:	74 a9                	je     80566b9 <net_icmpv4_input+0x39>
		if (cb->type == icmp_hdr->type &&
 8056710:	8a 0b                	mov    (%ebx),%cl
 8056712:	38 48 08             	cmp    %cl,0x8(%eax)
 8056715:	75 18                	jne    805672f <net_icmpv4_input+0xaf>
		    (cb->code == icmp_hdr->code || cb->code == 0U)) {
 8056717:	8a 50 09             	mov    0x9(%eax),%dl
 805671a:	38 53 01             	cmp    %dl,0x1(%ebx)
 805671d:	74 04                	je     8056723 <net_icmpv4_input+0xa3>
 805671f:	84 d2                	test   %dl,%dl
 8056721:	75 0c                	jne    805672f <net_icmpv4_input+0xaf>
			return cb->handler(pkt, ip_hdr, icmp_hdr);
 8056723:	52                   	push   %edx
 8056724:	53                   	push   %ebx
 8056725:	57                   	push   %edi
 8056726:	56                   	push   %esi
 8056727:	ff 50 04             	call   *0x4(%eax)
 805672a:	83 c4 10             	add    $0x10,%esp
 805672d:	eb 08                	jmp    8056737 <net_icmpv4_input+0xb7>
	return node->next;
 805672f:	8b 00                	mov    (%eax),%eax
	SYS_SLIST_FOR_EACH_CONTAINER(&handlers, cb, node) {
 8056731:	85 c0                	test   %eax,%eax
 8056733:	75 dd                	jne    8056712 <net_icmpv4_input+0x92>
 8056735:	eb 82                	jmp    80566b9 <net_icmpv4_input+0x39>

drop:
	net_stats_update_icmp_drop(net_pkt_iface(pkt));

	return NET_DROP;
}
 8056737:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 805673a:	65 2b 15 14 00 00 00 	sub    %gs:0x14,%edx
 8056741:	74 05                	je     8056748 <net_icmpv4_input+0xc8>
 8056743:	e8 b8 2b ff ff       	call   8049300 <__stack_chk_fail@plt>
 8056748:	8d 65 f4             	lea    -0xc(%ebp),%esp
 805674b:	5b                   	pop    %ebx
 805674c:	5e                   	pop    %esi
 805674d:	5f                   	pop    %edi
 805674e:	5d                   	pop    %ebp
 805674f:	c3                   	ret    

08056750 <net_icmpv4_init>:
	.code = 0,
	.handler = icmpv4_handle_echo_request,
};

void net_icmpv4_init(void)
{
 8056750:	55                   	push   %ebp
 8056751:	89 e5                	mov    %esp,%ebp
 8056753:	83 ec 14             	sub    $0x14,%esp
	net_icmpv4_register_handler(&echo_request_handler);
 8056756:	68 74 73 06 08       	push   $0x8067374
 805675b:	e8 fd fe ff ff       	call   805665d <net_icmpv4_register_handler>
 8056760:	83 c4 10             	add    $0x10,%esp
}
 8056763:	c9                   	leave  
 8056764:	c3                   	ret    

08056765 <net_ipv4_is_addr_mcast>:
 8056765:	8b 00                	mov    (%eax),%eax
 8056767:	25 f0 00 00 00       	and    $0xf0,%eax
 805676c:	3d e0 00 00 00       	cmp    $0xe0,%eax
 8056771:	0f 94 c0             	sete   %al
}
 8056774:	c3                   	ret    

08056775 <net_ipv4_is_addr_bcast>:
{
 8056775:	55                   	push   %ebp
 8056776:	89 e5                	mov    %esp,%ebp
 8056778:	56                   	push   %esi
 8056779:	89 c6                	mov    %eax,%esi
 805677b:	53                   	push   %ebx
 805677c:	89 d3                	mov    %edx,%ebx
	if (net_ipv4_addr_cmp(addr, net_ipv4_broadcast_address())) {
 805677e:	e8 f1 cf ff ff       	call   8053774 <net_ipv4_broadcast_address>
 8056783:	8b 00                	mov    (%eax),%eax
 8056785:	39 03                	cmp    %eax,(%ebx)
 8056787:	74 0e                	je     8056797 <net_ipv4_is_addr_bcast+0x22>
	return net_if_ipv4_is_addr_bcast(iface, addr);
 8056789:	50                   	push   %eax
 805678a:	50                   	push   %eax
 805678b:	53                   	push   %ebx
 805678c:	56                   	push   %esi
 805678d:	e8 07 be ff ff       	call   8052599 <net_if_ipv4_is_addr_bcast>
 8056792:	83 c4 10             	add    $0x10,%esp
 8056795:	eb 02                	jmp    8056799 <net_ipv4_is_addr_bcast+0x24>
		return true;
 8056797:	b0 01                	mov    $0x1,%al
}
 8056799:	8d 65 f8             	lea    -0x8(%ebp),%esp
 805679c:	5b                   	pop    %ebx
 805679d:	5e                   	pop    %esi
 805679e:	5d                   	pop    %ebp
 805679f:	c3                   	ret    

080567a0 <net_ipv4_create_full>:
			 uint8_t tos,
			 uint16_t id,
			 uint8_t flags,
			 uint16_t offset,
			 uint8_t ttl)
{
 80567a0:	55                   	push   %ebp
 80567a1:	89 e5                	mov    %esp,%ebp
 80567a3:	57                   	push   %edi
 80567a4:	56                   	push   %esi
 80567a5:	53                   	push   %ebx
 80567a6:	83 ec 44             	sub    $0x44,%esp
 80567a9:	8b 45 0c             	mov    0xc(%ebp),%eax
 80567ac:	8b 4d 14             	mov    0x14(%ebp),%ecx
 80567af:	8b 55 24             	mov    0x24(%ebp),%edx
 80567b2:	8b 7d 08             	mov    0x8(%ebp),%edi
 80567b5:	89 45 d0             	mov    %eax,-0x30(%ebp)
 80567b8:	8b 45 18             	mov    0x18(%ebp),%eax
 80567bb:	89 4d c0             	mov    %ecx,-0x40(%ebp)
 80567be:	8b 75 10             	mov    0x10(%ebp),%esi
 80567c1:	89 45 cc             	mov    %eax,-0x34(%ebp)
 80567c4:	8b 45 1c             	mov    0x1c(%ebp),%eax
 80567c7:	89 55 c4             	mov    %edx,-0x3c(%ebp)
 80567ca:	89 45 c8             	mov    %eax,-0x38(%ebp)
 80567cd:	8b 45 20             	mov    0x20(%ebp),%eax
 80567d0:	89 45 d4             	mov    %eax,-0x2c(%ebp)
 80567d3:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 80567d9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 80567dc:	31 c0                	xor    %eax,%eax
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv4_access, struct net_ipv4_hdr);
	struct net_ipv4_hdr *ipv4_hdr;

	ipv4_hdr = (struct net_ipv4_hdr *)net_pkt_get_data(pkt, &ipv4_access);
 80567de:	8d 45 dc             	lea    -0x24(%ebp),%eax
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv4_access, struct net_ipv4_hdr);
 80567e1:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	ipv4_hdr = (struct net_ipv4_hdr *)net_pkt_get_data(pkt, &ipv4_access);
 80567e8:	50                   	push   %eax
 80567e9:	57                   	push   %edi
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv4_access, struct net_ipv4_hdr);
 80567ea:	c7 45 e0 14 00 00 00 	movl   $0x14,-0x20(%ebp)
	ipv4_hdr = (struct net_ipv4_hdr *)net_pkt_get_data(pkt, &ipv4_access);
 80567f1:	e8 dc f0 ff ff       	call   80558d2 <net_pkt_get_data>
 80567f6:	83 c4 10             	add    $0x10,%esp
 80567f9:	89 c3                	mov    %eax,%ebx
	if (!ipv4_hdr) {
 80567fb:	b8 97 ff ff ff       	mov    $0xffffff97,%eax
 8056800:	85 db                	test   %ebx,%ebx
 8056802:	74 75                	je     8056879 <net_ipv4_create_full+0xd9>
	}

	ipv4_hdr->vhl       = 0x45;
	ipv4_hdr->tos       = tos;
	ipv4_hdr->len       = 0U;
	ipv4_hdr->id[0]     = id >> 8;
 8056804:	8b 45 cc             	mov    -0x34(%ebp),%eax
	ipv4_hdr->tos       = tos;
 8056807:	8b 4d c0             	mov    -0x40(%ebp),%ecx
	ipv4_hdr->vhl       = 0x45;
 805680a:	c6 03 45             	movb   $0x45,(%ebx)
	ipv4_hdr->id[1]     = id;
	ipv4_hdr->offset[0] = (offset >> 8) | (flags << 5);
	ipv4_hdr->offset[1] = offset;
	ipv4_hdr->ttl       = ttl;
 805680d:	8b 55 c4             	mov    -0x3c(%ebp),%edx
	ipv4_hdr->len       = 0U;
 8056810:	66 c7 43 02 00 00    	movw   $0x0,0x2(%ebx)
	ipv4_hdr->id[0]     = id >> 8;
 8056816:	86 e0                	xchg   %ah,%al
	ipv4_hdr->tos       = tos;
 8056818:	88 4b 01             	mov    %cl,0x1(%ebx)
	ipv4_hdr->offset[0] = (offset >> 8) | (flags << 5);
 805681b:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
	ipv4_hdr->ttl       = ttl;
 805681e:	88 53 08             	mov    %dl,0x8(%ebx)
	ipv4_hdr->offset[0] = (offset >> 8) | (flags << 5);
 8056821:	66 c1 e9 08          	shr    $0x8,%cx
	ipv4_hdr->id[0]     = id >> 8;
 8056825:	66 89 43 04          	mov    %ax,0x4(%ebx)
	ipv4_hdr->offset[0] = (offset >> 8) | (flags << 5);
 8056829:	8a 45 c8             	mov    -0x38(%ebp),%al
 805682c:	c1 e0 05             	shl    $0x5,%eax
 805682f:	09 c8                	or     %ecx,%eax
 8056831:	88 43 06             	mov    %al,0x6(%ebx)
	ipv4_hdr->offset[1] = offset;
 8056834:	8a 45 d4             	mov    -0x2c(%ebp),%al
 8056837:	88 43 07             	mov    %al,0x7(%ebx)

	if (ttl == 0U) {
 805683a:	84 d2                	test   %dl,%dl
 805683c:	75 11                	jne    805684f <net_ipv4_create_full+0xaf>
		ipv4_hdr->ttl = net_if_ipv4_get_ttl(net_pkt_iface(pkt));
 805683e:	83 ec 0c             	sub    $0xc,%esp
 8056841:	ff 77 18             	push   0x18(%edi)
 8056844:	e8 a0 bc ff ff       	call   80524e9 <net_if_ipv4_get_ttl>
 8056849:	83 c4 10             	add    $0x10,%esp
 805684c:	88 43 08             	mov    %al,0x8(%ebx)
	}

	ipv4_hdr->proto     = 0U;
 805684f:	c6 43 09 00          	movb   $0x0,0x9(%ebx)
	ipv4_hdr->chksum    = 0U;
 8056853:	66 c7 43 0a 00 00    	movw   $0x0,0xa(%ebx)
	net_ipaddr_copy((struct in_addr *)dest, (const struct in_addr *)src);
 8056859:	8b 06                	mov    (%esi),%eax
 805685b:	89 43 10             	mov    %eax,0x10(%ebx)
 805685e:	8b 45 d0             	mov    -0x30(%ebp),%eax
 8056861:	8b 00                	mov    (%eax),%eax
 8056863:	89 43 0c             	mov    %eax,0xc(%ebx)
	pkt->ip_hdr_len = len;
 8056866:	c6 47 32 14          	movb   $0x14,0x32(%edi)
	net_ipv4_addr_copy_raw(ipv4_hdr->dst, (uint8_t *)dst);
	net_ipv4_addr_copy_raw(ipv4_hdr->src, (uint8_t *)src);

	net_pkt_set_ip_hdr_len(pkt, sizeof(struct net_ipv4_hdr));

	return net_pkt_set_data(pkt, &ipv4_access);
 805686a:	50                   	push   %eax
 805686b:	50                   	push   %eax
 805686c:	8d 45 dc             	lea    -0x24(%ebp),%eax
 805686f:	50                   	push   %eax
 8056870:	57                   	push   %edi
 8056871:	e8 c0 f0 ff ff       	call   8055936 <net_pkt_set_data>
 8056876:	83 c4 10             	add    $0x10,%esp
}
 8056879:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 805687c:	65 2b 15 14 00 00 00 	sub    %gs:0x14,%edx
 8056883:	74 05                	je     805688a <net_ipv4_create_full+0xea>
 8056885:	e8 76 2a ff ff       	call   8049300 <__stack_chk_fail@plt>
 805688a:	8d 65 f4             	lea    -0xc(%ebp),%esp
 805688d:	5b                   	pop    %ebx
 805688e:	5e                   	pop    %esi
 805688f:	5f                   	pop    %edi
 8056890:	5d                   	pop    %ebp
 8056891:	c3                   	ret    

08056892 <net_ipv4_create>:

int net_ipv4_create(struct net_pkt *pkt,
		    const struct in_addr *src,
		    const struct in_addr *dst)
{
 8056892:	55                   	push   %ebp
 8056893:	89 e5                	mov    %esp,%ebp
 8056895:	83 ec 08             	sub    $0x8,%esp
 8056898:	8b 55 08             	mov    0x8(%ebp),%edx
	if (IS_ENABLED(CONFIG_NET_IP_DSCP_ECN)) {
		net_ipv4_set_dscp(&tos, net_pkt_ip_dscp(pkt));
		net_ipv4_set_ecn(&tos, net_pkt_ip_ecn(pkt));
	}

	return net_ipv4_create_full(pkt, src, dst, tos, 0U, 0U, 0U,
 805689b:	0f b6 42 35          	movzbl 0x35(%edx),%eax
 805689f:	50                   	push   %eax
 80568a0:	6a 00                	push   $0x0
 80568a2:	6a 00                	push   $0x0
 80568a4:	6a 00                	push   $0x0
 * @param ecn ECN value to set.
 */
static inline void net_ipv4_set_ecn(uint8_t *tos, uint8_t ecn)
{
	*tos &= ~NET_IPV4_ECN_MASK;
	*tos |= ecn & NET_IPV4_ECN_MASK;
 80568a6:	8a 42 3c             	mov    0x3c(%edx),%al
 80568a9:	c0 c0 02             	rol    $0x2,%al
 80568ac:	0f b6 c0             	movzbl %al,%eax
 80568af:	50                   	push   %eax
 80568b0:	ff 75 10             	push   0x10(%ebp)
 80568b3:	ff 75 0c             	push   0xc(%ebp)
 80568b6:	52                   	push   %edx
 80568b7:	e8 e4 fe ff ff       	call   80567a0 <net_ipv4_create_full>
 80568bc:	83 c4 20             	add    $0x20,%esp
				    net_pkt_ipv4_ttl(pkt));
}
 80568bf:	c9                   	leave  
 80568c0:	c3                   	ret    

080568c1 <net_ipv4_finalize>:

int net_ipv4_finalize(struct net_pkt *pkt, uint8_t next_header_proto)
{
 80568c1:	55                   	push   %ebp
 80568c2:	89 e5                	mov    %esp,%ebp
 80568c4:	57                   	push   %edi
 80568c5:	56                   	push   %esi
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv4_access, struct net_ipv4_hdr);
	struct net_ipv4_hdr *ipv4_hdr;

	net_pkt_set_overwrite(pkt, true);

	ipv4_hdr = (struct net_ipv4_hdr *)net_pkt_get_data(pkt, &ipv4_access);
 80568c6:	8d 75 dc             	lea    -0x24(%ebp),%esi
{
 80568c9:	53                   	push   %ebx
 80568ca:	83 ec 34             	sub    $0x34,%esp
 80568cd:	8b 45 0c             	mov    0xc(%ebp),%eax
 80568d0:	8b 5d 08             	mov    0x8(%ebp),%ebx
 80568d3:	89 45 d4             	mov    %eax,-0x2c(%ebp)
 80568d6:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 80568dc:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 80568df:	31 c0                	xor    %eax,%eax
	pkt->overwrite = overwrite;
 80568e1:	80 4b 33 01          	orb    $0x1,0x33(%ebx)
	ipv4_hdr = (struct net_ipv4_hdr *)net_pkt_get_data(pkt, &ipv4_access);
 80568e5:	56                   	push   %esi
 80568e6:	53                   	push   %ebx
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv4_access, struct net_ipv4_hdr);
 80568e7:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
 80568ee:	c7 45 e0 14 00 00 00 	movl   $0x14,-0x20(%ebp)
	ipv4_hdr = (struct net_ipv4_hdr *)net_pkt_get_data(pkt, &ipv4_access);
 80568f5:	e8 d8 ef ff ff       	call   80558d2 <net_pkt_get_data>
 80568fa:	83 c4 10             	add    $0x10,%esp
 80568fd:	89 c7                	mov    %eax,%edi
	if (!ipv4_hdr) {
		return -ENOBUFS;
 80568ff:	b8 97 ff ff ff       	mov    $0xffffff97,%eax
	if (!ipv4_hdr) {
 8056904:	85 ff                	test   %edi,%edi
 8056906:	74 73                	je     805697b <net_ipv4_finalize+0xba>
					((net_pkt_ip_hdr_len(pkt) +
					  net_pkt_ipv4_opts_len(pkt)) / 4U));
		}
	}

	ipv4_hdr->len   = htons(net_pkt_get_len(pkt));
 8056908:	8b 43 08             	mov    0x8(%ebx),%eax
	size_t bytes = 0;
 805690b:	31 c9                	xor    %ecx,%ecx
	while (buf) {
 805690d:	85 c0                	test   %eax,%eax
 805690f:	74 0b                	je     805691c <net_ipv4_finalize+0x5b>
		bytes += buf->len;
 8056911:	0f b7 50 10          	movzwl 0x10(%eax),%edx
		buf = buf->frags;
 8056915:	8b 40 04             	mov    0x4(%eax),%eax
		bytes += buf->len;
 8056918:	01 d1                	add    %edx,%ecx
		buf = buf->frags;
 805691a:	eb f1                	jmp    805690d <net_ipv4_finalize+0x4c>
 805691c:	86 e9                	xchg   %ch,%cl
	ipv4_hdr->proto = next_header_proto;
 805691e:	8a 45 d4             	mov    -0x2c(%ebp),%al

	if (net_if_need_calc_tx_checksum(net_pkt_iface(pkt))) {
 8056921:	83 ec 0c             	sub    $0xc,%esp
	ipv4_hdr->proto = next_header_proto;
 8056924:	88 47 09             	mov    %al,0x9(%edi)
	ipv4_hdr->len   = htons(net_pkt_get_len(pkt));
 8056927:	66 89 4f 02          	mov    %cx,0x2(%edi)
	if (net_if_need_calc_tx_checksum(net_pkt_iface(pkt))) {
 805692b:	ff 73 18             	push   0x18(%ebx)
 805692e:	e8 2d c1 ff ff       	call   8052a60 <net_if_need_calc_tx_checksum>
 8056933:	83 c4 10             	add    $0x10,%esp
 8056936:	84 c0                	test   %al,%al
 8056938:	74 10                	je     805694a <net_ipv4_finalize+0x89>
		ipv4_hdr->chksum = net_calc_chksum_ipv4(pkt);
 805693a:	83 ec 0c             	sub    $0xc,%esp
 805693d:	53                   	push   %ebx
 805693e:	e8 51 cd ff ff       	call   8053694 <net_calc_chksum_ipv4>
 8056943:	83 c4 10             	add    $0x10,%esp
 8056946:	66 89 47 0a          	mov    %ax,0xa(%edi)
	}

	net_pkt_set_data(pkt, &ipv4_access);
 805694a:	50                   	push   %eax
 805694b:	50                   	push   %eax
 805694c:	56                   	push   %esi
 805694d:	53                   	push   %ebx
 805694e:	e8 e3 ef ff ff       	call   8055936 <net_pkt_set_data>
 8056953:	83 c4 10             	add    $0x10,%esp

	if (IS_ENABLED(CONFIG_NET_UDP) &&
 8056956:	80 7d d4 11          	cmpb   $0x11,-0x2c(%ebp)
 805695a:	75 0b                	jne    8056967 <net_ipv4_finalize+0xa6>
	    next_header_proto == IPPROTO_UDP) {
		return net_udp_finalize(pkt);
 805695c:	83 ec 0c             	sub    $0xc,%esp
 805695f:	53                   	push   %ebx
 8056960:	e8 80 3d 00 00       	call   805a6e5 <net_udp_finalize>
 8056965:	eb 11                	jmp    8056978 <net_ipv4_finalize+0xb7>
		return net_tcp_finalize(pkt);
	} else if (next_header_proto == IPPROTO_ICMP) {
		return net_icmpv4_finalize(pkt);
	}

	return 0;
 8056967:	31 c0                	xor    %eax,%eax
	} else if (next_header_proto == IPPROTO_ICMP) {
 8056969:	80 7d d4 01          	cmpb   $0x1,-0x2c(%ebp)
 805696d:	75 0c                	jne    805697b <net_ipv4_finalize+0xba>
		return net_icmpv4_finalize(pkt);
 805696f:	83 ec 0c             	sub    $0xc,%esp
 8056972:	53                   	push   %ebx
 8056973:	e8 c5 fa ff ff       	call   805643d <net_icmpv4_finalize>
 8056978:	83 c4 10             	add    $0x10,%esp
}
 805697b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 805697e:	65 2b 15 14 00 00 00 	sub    %gs:0x14,%edx
 8056985:	74 05                	je     805698c <net_ipv4_finalize+0xcb>
 8056987:	e8 74 29 ff ff       	call   8049300 <__stack_chk_fail@plt>
 805698c:	8d 65 f4             	lea    -0xc(%ebp),%esp
 805698f:	5b                   	pop    %ebx
 8056990:	5e                   	pop    %esi
 8056991:	5f                   	pop    %edi
 8056992:	5d                   	pop    %ebp
 8056993:	c3                   	ret    

08056994 <net_ipv4_input>:
	return 0;
}
#endif

enum net_verdict net_ipv4_input(struct net_pkt *pkt)
{
 8056994:	55                   	push   %ebp
 8056995:	89 e5                	mov    %esp,%ebp
 8056997:	57                   	push   %edi
	size_t bytes = 0;
 8056998:	31 ff                	xor    %edi,%edi
 805699a:	56                   	push   %esi
 805699b:	53                   	push   %ebx
 805699c:	83 ec 4c             	sub    $0x4c,%esp
 805699f:	8b 5d 08             	mov    0x8(%ebp),%ebx
 80569a2:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 80569a8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 80569ab:	31 c0                	xor    %eax,%eax
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv4_access, struct net_ipv4_hdr);
	NET_PKT_DATA_ACCESS_DEFINE(udp_access, struct net_udp_hdr);
 80569ad:	8d 45 dc             	lea    -0x24(%ebp),%eax
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv4_access, struct net_ipv4_hdr);
 80569b0:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
 80569b7:	c7 45 d0 14 00 00 00 	movl   $0x14,-0x30(%ebp)
	NET_PKT_DATA_ACCESS_DEFINE(udp_access, struct net_udp_hdr);
 80569be:	c7 45 d8 08 00 00 00 	movl   $0x8,-0x28(%ebp)
 80569c5:	89 45 d4             	mov    %eax,-0x2c(%ebp)
 80569c8:	8b 43 08             	mov    0x8(%ebx),%eax
	while (buf) {
 80569cb:	85 c0                	test   %eax,%eax
 80569cd:	74 0b                	je     80569da <net_ipv4_input+0x46>
		bytes += buf->len;
 80569cf:	0f b7 50 10          	movzwl 0x10(%eax),%edx
		buf = buf->frags;
 80569d3:	8b 40 04             	mov    0x4(%eax),%eax
		bytes += buf->len;
 80569d6:	01 d7                	add    %edx,%edi
		buf = buf->frags;
 80569d8:	eb f1                	jmp    80569cb <net_ipv4_input+0x37>
	net_pkt_cursor_backup(pkt, &hdr_start);
#endif

	net_stats_update_ipv4_recv(net_pkt_iface(pkt));

	hdr = (struct net_ipv4_hdr *)net_pkt_get_data(pkt, &ipv4_access);
 80569da:	8d 45 cc             	lea    -0x34(%ebp),%eax
 80569dd:	51                   	push   %ecx
 80569de:	51                   	push   %ecx
 80569df:	50                   	push   %eax
 80569e0:	53                   	push   %ebx
 80569e1:	e8 ec ee ff ff       	call   80558d2 <net_pkt_get_data>
 80569e6:	83 c4 10             	add    $0x10,%esp
 80569e9:	89 c6                	mov    %eax,%esi
	if (!hdr) {
 80569eb:	85 c0                	test   %eax,%eax
 80569ed:	0f 84 66 01 00 00    	je     8056b59 <net_ipv4_input+0x1c5>
		NET_DBG("DROP: no buffer");
		goto drop;
	}

	hdr_len = (hdr->vhl & NET_IPV4_IHL_MASK) * 4U;
 80569f3:	8a 10                	mov    (%eax),%dl
 80569f5:	83 e2 0f             	and    $0xf,%edx
 80569f8:	c1 e2 02             	shl    $0x2,%edx
	if (hdr_len < sizeof(struct net_ipv4_hdr)) {
 80569fb:	80 fa 13             	cmp    $0x13,%dl
 80569fe:	0f 86 55 01 00 00    	jbe    8056b59 <net_ipv4_input+0x1c5>
	pkt->ip_hdr_len = len;
 8056a04:	c6 43 32 14          	movb   $0x14,0x32(%ebx)
	pkt->ip_dscp = dscp;
 8056a08:	8a 48 01             	mov    0x1(%eax),%cl
 8056a0b:	8a 43 3c             	mov    0x3c(%ebx),%al
 8056a0e:	c0 e9 02             	shr    $0x2,%cl
 8056a11:	83 e0 c0             	and    $0xffffffc0,%eax
 8056a14:	09 c8                	or     %ecx,%eax
 8056a16:	88 43 3c             	mov    %al,0x3c(%ebx)
	pkt->ip_ecn = ecn;
 8056a19:	8a 4e 01             	mov    0x1(%esi),%cl
 8056a1c:	83 e0 3f             	and    $0x3f,%eax
 8056a1f:	c1 e1 06             	shl    $0x6,%ecx
 8056a22:	09 c8                	or     %ecx,%eax
 8056a24:	88 43 3c             	mov    %al,0x3c(%ebx)
	if (IS_ENABLED(CONFIG_NET_IP_DSCP_ECN)) {
		net_pkt_set_ip_dscp(pkt, net_ipv4_get_dscp(hdr->tos));
		net_pkt_set_ip_ecn(pkt, net_ipv4_get_ecn(hdr->tos));
	}

	opts_len = hdr_len - sizeof(struct net_ipv4_hdr);
 8056a27:	8d 42 ec             	lea    -0x14(%edx),%eax
	if (opts_len > NET_IPV4_HDR_OPTNS_MAX_LEN) {
		return -EINVAL;
	}

	if (hdr->ttl == 0) {
 8056a2a:	80 7e 08 00          	cmpb   $0x0,0x8(%esi)
	opts_len = hdr_len - sizeof(struct net_ipv4_hdr);
 8056a2e:	88 45 b7             	mov    %al,-0x49(%ebp)
	if (hdr->ttl == 0) {
 8056a31:	0f 84 22 01 00 00    	je     8056b59 <net_ipv4_input+0x1c5>
	pkt->ipv4_opts_len = opts_len;
 8056a37:	88 43 36             	mov    %al,0x36(%ebx)
		goto drop;
	}

	net_pkt_set_ipv4_opts_len(pkt, opts_len);

	pkt_len = ntohs(hdr->len);
 8056a3a:	66 8b 46 02          	mov    0x2(%esi),%ax
 8056a3e:	86 e0                	xchg   %ah,%al
 8056a40:	0f b7 c0             	movzwl %ax,%eax
	if (real_len < pkt_len) {
 8056a43:	39 f8                	cmp    %edi,%eax
 8056a45:	0f 8f 0e 01 00 00    	jg     8056b59 <net_ipv4_input+0x1c5>
		NET_DBG("DROP: pkt len per hdr %d != pkt real len %d",
			pkt_len, real_len);
		goto drop;
	} else if (real_len > pkt_len) {
 8056a4b:	7d 0c                	jge    8056a59 <net_ipv4_input+0xc5>
		net_pkt_update_length(pkt, pkt_len);
 8056a4d:	52                   	push   %edx
 8056a4e:	52                   	push   %edx
 8056a4f:	50                   	push   %eax
 8056a50:	53                   	push   %ebx
 8056a51:	e8 62 ec ff ff       	call   80556b8 <net_pkt_update_length>
 8056a56:	83 c4 10             	add    $0x10,%esp
	}

	if (net_ipv4_is_addr_mcast((struct in_addr *)hdr->src)) {
 8056a59:	8d 56 0c             	lea    0xc(%esi),%edx
 8056a5c:	89 d0                	mov    %edx,%eax
 8056a5e:	e8 02 fd ff ff       	call   8056765 <net_ipv4_is_addr_mcast>
 8056a63:	84 c0                	test   %al,%al
 8056a65:	0f 85 ee 00 00 00    	jne    8056b59 <net_ipv4_input+0x1c5>
		NET_DBG("DROP: src addr is %s", "mcast");
		goto drop;
	}

	if (net_ipv4_is_addr_bcast(net_pkt_iface(pkt), (struct in_addr *)hdr->src)) {
 8056a6b:	8b 43 18             	mov    0x18(%ebx),%eax
 8056a6e:	e8 02 fd ff ff       	call   8056775 <net_ipv4_is_addr_bcast>
 8056a73:	84 c0                	test   %al,%al
 8056a75:	0f 85 de 00 00 00    	jne    8056b59 <net_ipv4_input+0x1c5>
		NET_DBG("DROP: src addr is %s", "bcast");
		goto drop;
	}

	if (net_ipv4_is_addr_unspecified((struct in_addr *)hdr->src) &&
 8056a7b:	83 7e 0c 00          	cmpl   $0x0,0xc(%esi)
	return pkt->iface;
 8056a7f:	8b 43 18             	mov    0x18(%ebx),%eax
 8056a82:	74 14                	je     8056a98 <net_ipv4_input+0x104>
	    !net_ipv4_is_addr_bcast(net_pkt_iface(pkt), (struct in_addr *)hdr->dst)) {
		NET_DBG("DROP: src addr is %s", "unspecified");
		goto drop;
	}

	if (net_if_need_calc_rx_checksum(net_pkt_iface(pkt)) &&
 8056a84:	83 ec 0c             	sub    $0xc,%esp
 8056a87:	ff 73 18             	push   0x18(%ebx)
 8056a8a:	e8 e2 bf ff ff       	call   8052a71 <net_if_need_calc_rx_checksum>
 8056a8f:	83 c4 10             	add    $0x10,%esp
 8056a92:	84 c0                	test   %al,%al
 8056a94:	75 13                	jne    8056aa9 <net_ipv4_input+0x115>
 8056a96:	eb 26                	jmp    8056abe <net_ipv4_input+0x12a>
	    !net_ipv4_is_addr_bcast(net_pkt_iface(pkt), (struct in_addr *)hdr->dst)) {
 8056a98:	8d 56 10             	lea    0x10(%esi),%edx
 8056a9b:	e8 d5 fc ff ff       	call   8056775 <net_ipv4_is_addr_bcast>
	if (net_ipv4_is_addr_unspecified((struct in_addr *)hdr->src) &&
 8056aa0:	84 c0                	test   %al,%al
 8056aa2:	75 e0                	jne    8056a84 <net_ipv4_input+0xf0>
 8056aa4:	e9 b0 00 00 00       	jmp    8056b59 <net_ipv4_input+0x1c5>
	    net_calc_chksum_ipv4(pkt) != 0U) {
 8056aa9:	83 ec 0c             	sub    $0xc,%esp
 8056aac:	53                   	push   %ebx
 8056aad:	e8 e2 cb ff ff       	call   8053694 <net_calc_chksum_ipv4>
 8056ab2:	83 c4 10             	add    $0x10,%esp
	if (net_if_need_calc_rx_checksum(net_pkt_iface(pkt)) &&
 8056ab5:	66 85 c0             	test   %ax,%ax
 8056ab8:	0f 85 9b 00 00 00    	jne    8056b59 <net_ipv4_input+0x1c5>
		NET_DBG("DROP: invalid chksum");
		goto drop;
	}

	if ((!net_ipv4_is_my_addr((struct in_addr *)hdr->dst) &&
 8056abe:	8d 7e 10             	lea    0x10(%esi),%edi
	ret = net_if_ipv4_addr_lookup(addr, NULL) != NULL;
 8056ac1:	50                   	push   %eax
 8056ac2:	50                   	push   %eax
 8056ac3:	6a 00                	push   $0x0
 8056ac5:	57                   	push   %edi
 8056ac6:	e8 7a bc ff ff       	call   8052745 <net_if_ipv4_addr_lookup>
 8056acb:	83 c4 10             	add    $0x10,%esp
	if (!ret) {
 8056ace:	85 c0                	test   %eax,%eax
 8056ad0:	75 0d                	jne    8056adf <net_ipv4_input+0x14b>
		ret = net_ipv4_is_addr_bcast(NULL, addr);
 8056ad2:	31 c0                	xor    %eax,%eax
 8056ad4:	89 fa                	mov    %edi,%edx
 8056ad6:	e8 9a fc ff ff       	call   8056775 <net_ipv4_is_addr_bcast>
 8056adb:	84 c0                	test   %al,%al
 8056add:	74 08                	je     8056ae7 <net_ipv4_input+0x153>
	     !(hdr->proto == IPPROTO_UDP &&
	       (net_ipv4_addr_cmp((struct in_addr *)hdr->dst, net_ipv4_broadcast_address()) ||
		/* RFC 1122 ch. 3.3.6 The 0.0.0.0 is non-standard bcast addr */
		(IS_ENABLED(CONFIG_NET_IPV4_ACCEPT_ZERO_BROADCAST) &&
		 net_ipv4_addr_cmp((struct in_addr *)hdr->dst,
				   net_ipv4_unspecified_address()))))) ||
 8056adf:	80 7e 09 06          	cmpb   $0x6,0x9(%esi)
 8056ae3:	75 2f                	jne    8056b14 <net_ipv4_input+0x180>
 8056ae5:	eb 1f                	jmp    8056b06 <net_ipv4_input+0x172>
	     !net_ipv4_is_addr_mcast((struct in_addr *)hdr->dst) &&
 8056ae7:	89 f8                	mov    %edi,%eax
 8056ae9:	e8 77 fc ff ff       	call   8056765 <net_ipv4_is_addr_mcast>
	if ((!net_ipv4_is_my_addr((struct in_addr *)hdr->dst) &&
 8056aee:	84 c0                	test   %al,%al
 8056af0:	75 ed                	jne    8056adf <net_ipv4_input+0x14b>
	     !net_ipv4_is_addr_mcast((struct in_addr *)hdr->dst) &&
 8056af2:	80 7e 09 11          	cmpb   $0x11,0x9(%esi)
 8056af6:	75 61                	jne    8056b59 <net_ipv4_input+0x1c5>
	       (net_ipv4_addr_cmp((struct in_addr *)hdr->dst, net_ipv4_broadcast_address()) ||
 8056af8:	e8 77 cc ff ff       	call   8053774 <net_ipv4_broadcast_address>
	     !(hdr->proto == IPPROTO_UDP &&
 8056afd:	8b 00                	mov    (%eax),%eax
 8056aff:	39 46 10             	cmp    %eax,0x10(%esi)
 8056b02:	74 db                	je     8056adf <net_ipv4_input+0x14b>
 8056b04:	eb 53                	jmp    8056b59 <net_ipv4_input+0x1c5>
	    (hdr->proto == IPPROTO_TCP &&
	     net_ipv4_is_addr_bcast(net_pkt_iface(pkt), (struct in_addr *)hdr->dst))) {
 8056b06:	8b 43 18             	mov    0x18(%ebx),%eax
 8056b09:	89 fa                	mov    %edi,%edx
 8056b0b:	e8 65 fc ff ff       	call   8056775 <net_ipv4_is_addr_bcast>
	    (hdr->proto == IPPROTO_TCP &&
 8056b10:	84 c0                	test   %al,%al
 8056b12:	75 45                	jne    8056b59 <net_ipv4_input+0x1c5>
	return net_pkt_skip(pkt, access->size);
 8056b14:	57                   	push   %edi
 8056b15:	57                   	push   %edi
 8056b16:	ff 75 d0             	push   -0x30(%ebp)
 8056b19:	53                   	push   %ebx
 8056b1a:	e8 52 e8 ff ff       	call   8055371 <net_pkt_skip>
 8056b1f:	83 c4 10             	add    $0x10,%esp
		goto drop;
	}

	net_pkt_acknowledge_data(pkt, &ipv4_access);

	if (opts_len) {
 8056b22:	80 7d b7 00          	cmpb   $0x0,-0x49(%ebp)
 8056b26:	74 14                	je     8056b3c <net_ipv4_input+0x1a8>
		/* Only few options are handled in EchoRequest, rest skipped */
		if (net_pkt_skip(pkt, opts_len)) {
 8056b28:	0f b6 45 b7          	movzbl -0x49(%ebp),%eax
 8056b2c:	51                   	push   %ecx
 8056b2d:	51                   	push   %ecx
 8056b2e:	50                   	push   %eax
 8056b2f:	53                   	push   %ebx
 8056b30:	e8 3c e8 ff ff       	call   8055371 <net_pkt_skip>
 8056b35:	83 c4 10             	add    $0x10,%esp
 8056b38:	85 c0                	test   %eax,%eax
 8056b3a:	75 1d                	jne    8056b59 <net_ipv4_input+0x1c5>
			NET_DBG("Header too big? %u", hdr_len);
			goto drop;
		}
	}

	net_pkt_set_ipv4_ttl(pkt, hdr->ttl);
 8056b3c:	8a 46 08             	mov    0x8(%esi),%al
	pkt->ipv4_ttl = ttl;
 8056b3f:	88 43 35             	mov    %al,0x35(%ebx)
	pkt->family = family;
 8056b42:	8a 43 33             	mov    0x33(%ebx),%al
 8056b45:	83 e0 1f             	and    $0x1f,%eax
 8056b48:	83 c8 20             	or     $0x20,%eax
 8056b4b:	88 43 33             	mov    %al,0x33(%ebx)

	NET_DBG("IPv4 packet received from %s to %s",
		net_sprint_ipv4_addr(&hdr->src),
		net_sprint_ipv4_addr(&hdr->dst));

	switch (hdr->proto) {
 8056b4e:	8a 46 09             	mov    0x9(%esi),%al
 8056b51:	3c 01                	cmp    $0x1,%al
 8056b53:	74 0b                	je     8056b60 <net_ipv4_input+0x1cc>
 8056b55:	3c 11                	cmp    $0x11,%al
 8056b57:	74 12                	je     8056b6b <net_ipv4_input+0x1d7>
 8056b59:	b8 02 00 00 00       	mov    $0x2,%eax
 8056b5e:	eb 3a                	jmp    8056b9a <net_ipv4_input+0x206>
	case IPPROTO_ICMP:
		verdict = net_icmpv4_input(pkt, hdr);
 8056b60:	52                   	push   %edx
 8056b61:	52                   	push   %edx
 8056b62:	56                   	push   %esi
 8056b63:	53                   	push   %ebx
 8056b64:	e8 17 fb ff ff       	call   8056680 <net_icmpv4_input>
 8056b69:	eb 2c                	jmp    8056b97 <net_ipv4_input+0x203>
		if (proto_hdr.tcp) {
			verdict = NET_OK;
		}
		break;
	case IPPROTO_UDP:
		proto_hdr.udp = net_udp_input(pkt, &udp_access);
 8056b6b:	50                   	push   %eax
 8056b6c:	50                   	push   %eax
 8056b6d:	8d 45 d4             	lea    -0x2c(%ebp),%eax
 8056b70:	50                   	push   %eax
 8056b71:	53                   	push   %ebx
 8056b72:	e8 1e 3c 00 00       	call   805a795 <net_udp_input>
 8056b77:	83 c4 10             	add    $0x10,%esp
 8056b7a:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		if (proto_hdr.udp) {
 8056b7d:	85 c0                	test   %eax,%eax
 8056b7f:	74 d8                	je     8056b59 <net_ipv4_input+0x1c5>
		goto drop;
	}

	ip.ipv4 = hdr;

	verdict = net_conn_input(pkt, &ip, hdr->proto, &proto_hdr);
 8056b81:	8d 45 c4             	lea    -0x3c(%ebp),%eax
	ip.ipv4 = hdr;
 8056b84:	89 75 c8             	mov    %esi,-0x38(%ebp)
	verdict = net_conn_input(pkt, &ip, hdr->proto, &proto_hdr);
 8056b87:	50                   	push   %eax
 8056b88:	0f b6 46 09          	movzbl 0x9(%esi),%eax
 8056b8c:	50                   	push   %eax
 8056b8d:	8d 45 c8             	lea    -0x38(%ebp),%eax
 8056b90:	50                   	push   %eax
 8056b91:	53                   	push   %ebx
 8056b92:	e8 3d f3 ff ff       	call   8055ed4 <net_conn_input>
 8056b97:	83 c4 10             	add    $0x10,%esp
	}

drop:
	net_stats_update_ipv4_drop(net_pkt_iface(pkt));
	return NET_DROP;
}
 8056b9a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 8056b9d:	65 2b 15 14 00 00 00 	sub    %gs:0x14,%edx
 8056ba4:	74 05                	je     8056bab <net_ipv4_input+0x217>
 8056ba6:	e8 55 27 ff ff       	call   8049300 <__stack_chk_fail@plt>
 8056bab:	8d 65 f4             	lea    -0xc(%ebp),%esp
 8056bae:	5b                   	pop    %ebx
 8056baf:	5e                   	pop    %esi
 8056bb0:	5f                   	pop    %edi
 8056bb1:	5d                   	pop    %ebp
 8056bb2:	c3                   	ret    

08056bb3 <net_ipv4_init>:
void net_ipv4_init(void)
{
	if (IS_ENABLED(CONFIG_NET_IPV4_FRAGMENT)) {
		net_ipv4_setup_fragment_buffers();
	}
}
 8056bb3:	c3                   	ret    

08056bb4 <net_icmpv6_register_handler>:

	return "?";
}

void net_icmpv6_register_handler(struct net_icmpv6_handler *handler)
{
 8056bb4:	55                   	push   %ebp
	return list->head;
 8056bb5:	8b 15 1c 8a 06 08    	mov    0x8068a1c,%edx
 8056bbb:	89 e5                	mov    %esp,%ebp
 8056bbd:	8b 45 08             	mov    0x8(%ebp),%eax
	parent->next = child;
 8056bc0:	89 10                	mov    %edx,(%eax)
Z_GENLIST_PREPEND(slist, snode)
 8056bc2:	83 3d 20 8a 06 08 00 	cmpl   $0x0,0x8068a20
	list->head = node;
 8056bc9:	a3 1c 8a 06 08       	mov    %eax,0x8068a1c
Z_GENLIST_PREPEND(slist, snode)
 8056bce:	75 05                	jne    8056bd5 <net_icmpv6_register_handler+0x21>
	list->tail = node;
 8056bd0:	a3 20 8a 06 08       	mov    %eax,0x8068a20
	sys_slist_prepend(&handlers, &handler->node);
}
 8056bd5:	5d                   	pop    %ebp
 8056bd6:	c3                   	ret    

08056bd7 <net_icmpv6_finalize>:
{
	sys_slist_find_and_remove(&handlers, &handler->node);
}

int net_icmpv6_finalize(struct net_pkt *pkt)
{
 8056bd7:	55                   	push   %ebp
 8056bd8:	89 e5                	mov    %esp,%ebp
 8056bda:	57                   	push   %edi
 8056bdb:	56                   	push   %esi
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmp_access,
					      struct net_icmp_hdr);
	struct net_icmp_hdr *icmp_hdr;

	icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(pkt, &icmp_access);
 8056bdc:	8d 7d dc             	lea    -0x24(%ebp),%edi
{
 8056bdf:	53                   	push   %ebx
 8056be0:	83 ec 24             	sub    $0x24,%esp
 8056be3:	8b 75 08             	mov    0x8(%ebp),%esi
 8056be6:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 8056bec:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 8056bef:	31 c0                	xor    %eax,%eax
	icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(pkt, &icmp_access);
 8056bf1:	57                   	push   %edi
 8056bf2:	56                   	push   %esi
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmp_access,
 8056bf3:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
 8056bfa:	c7 45 e0 04 00 00 00 	movl   $0x4,-0x20(%ebp)
	icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(pkt, &icmp_access);
 8056c01:	e8 cc ec ff ff       	call   80558d2 <net_pkt_get_data>
 8056c06:	83 c4 10             	add    $0x10,%esp
 8056c09:	89 c3                	mov    %eax,%ebx
	if (!icmp_hdr) {
 8056c0b:	b8 97 ff ff ff       	mov    $0xffffff97,%eax
 8056c10:	85 db                	test   %ebx,%ebx
 8056c12:	74 35                	je     8056c49 <net_icmpv6_finalize+0x72>
		return -ENOBUFS;
	}

	icmp_hdr->chksum = 0U;
	if (net_if_need_calc_tx_checksum(net_pkt_iface(pkt))) {
 8056c14:	83 ec 0c             	sub    $0xc,%esp
	icmp_hdr->chksum = 0U;
 8056c17:	66 c7 43 02 00 00    	movw   $0x0,0x2(%ebx)
	if (net_if_need_calc_tx_checksum(net_pkt_iface(pkt))) {
 8056c1d:	ff 76 18             	push   0x18(%esi)
 8056c20:	e8 3b be ff ff       	call   8052a60 <net_if_need_calc_tx_checksum>
 8056c25:	83 c4 10             	add    $0x10,%esp
 8056c28:	84 c0                	test   %al,%al
 8056c2a:	74 11                	je     8056c3d <net_icmpv6_finalize+0x66>
	return net_calc_chksum(pkt, IPPROTO_ICMPV6);
 8056c2c:	52                   	push   %edx
 8056c2d:	52                   	push   %edx
 8056c2e:	6a 3a                	push   $0x3a
 8056c30:	56                   	push   %esi
 8056c31:	e8 dd c8 ff ff       	call   8053513 <net_calc_chksum>
 8056c36:	83 c4 10             	add    $0x10,%esp
		icmp_hdr->chksum = net_calc_chksum_icmpv6(pkt);
 8056c39:	66 89 43 02          	mov    %ax,0x2(%ebx)
	}

	return net_pkt_set_data(pkt, &icmp_access);
 8056c3d:	50                   	push   %eax
 8056c3e:	50                   	push   %eax
 8056c3f:	57                   	push   %edi
 8056c40:	56                   	push   %esi
 8056c41:	e8 f0 ec ff ff       	call   8055936 <net_pkt_set_data>
 8056c46:	83 c4 10             	add    $0x10,%esp
}
 8056c49:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 8056c4c:	65 2b 15 14 00 00 00 	sub    %gs:0x14,%edx
 8056c53:	74 05                	je     8056c5a <net_icmpv6_finalize+0x83>
 8056c55:	e8 a6 26 ff ff       	call   8049300 <__stack_chk_fail@plt>
 8056c5a:	8d 65 f4             	lea    -0xc(%ebp),%esp
 8056c5d:	5b                   	pop    %ebx
 8056c5e:	5e                   	pop    %esi
 8056c5f:	5f                   	pop    %edi
 8056c60:	5d                   	pop    %ebp
 8056c61:	c3                   	ret    

08056c62 <net_icmpv6_create>:

int net_icmpv6_create(struct net_pkt *pkt, uint8_t icmp_type, uint8_t icmp_code)
{
 8056c62:	55                   	push   %ebp
 8056c63:	89 e5                	mov    %esp,%ebp
 8056c65:	57                   	push   %edi
 8056c66:	56                   	push   %esi
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmp_access,
					      struct net_icmp_hdr);
	struct net_icmp_hdr *icmp_hdr;

	icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(pkt, &icmp_access);
 8056c67:	8d 75 dc             	lea    -0x24(%ebp),%esi
{
 8056c6a:	53                   	push   %ebx
 8056c6b:	83 ec 34             	sub    $0x34,%esp
 8056c6e:	8b 55 0c             	mov    0xc(%ebp),%edx
 8056c71:	8b 5d 08             	mov    0x8(%ebp),%ebx
 8056c74:	8b 7d 10             	mov    0x10(%ebp),%edi
 8056c77:	89 55 d4             	mov    %edx,-0x2c(%ebp)
 8056c7a:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 8056c80:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 8056c83:	31 c0                	xor    %eax,%eax
	icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(pkt, &icmp_access);
 8056c85:	56                   	push   %esi
 8056c86:	53                   	push   %ebx
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmp_access,
 8056c87:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
 8056c8e:	c7 45 e0 04 00 00 00 	movl   $0x4,-0x20(%ebp)
	icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(pkt, &icmp_access);
 8056c95:	e8 38 ec ff ff       	call   80558d2 <net_pkt_get_data>
 8056c9a:	83 c4 10             	add    $0x10,%esp
	if (!icmp_hdr) {
 8056c9d:	b9 97 ff ff ff       	mov    $0xffffff97,%ecx
 8056ca2:	85 c0                	test   %eax,%eax
 8056ca4:	74 1e                	je     8056cc4 <net_icmpv6_create+0x62>
		return -ENOBUFS;
	}

	icmp_hdr->type   = icmp_type;
 8056ca6:	8b 55 d4             	mov    -0x2c(%ebp),%edx
	icmp_hdr->code   = icmp_code;
 8056ca9:	89 f9                	mov    %edi,%ecx
	icmp_hdr->chksum = 0U;
 8056cab:	66 c7 40 02 00 00    	movw   $0x0,0x2(%eax)
	icmp_hdr->code   = icmp_code;
 8056cb1:	88 48 01             	mov    %cl,0x1(%eax)
	icmp_hdr->type   = icmp_type;
 8056cb4:	88 10                	mov    %dl,(%eax)

	return net_pkt_set_data(pkt, &icmp_access);
 8056cb6:	50                   	push   %eax
 8056cb7:	50                   	push   %eax
 8056cb8:	56                   	push   %esi
 8056cb9:	53                   	push   %ebx
 8056cba:	e8 77 ec ff ff       	call   8055936 <net_pkt_set_data>
 8056cbf:	83 c4 10             	add    $0x10,%esp
 8056cc2:	89 c1                	mov    %eax,%ecx
}
 8056cc4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8056cc7:	65 2b 05 14 00 00 00 	sub    %gs:0x14,%eax
 8056cce:	74 05                	je     8056cd5 <net_icmpv6_create+0x73>
 8056cd0:	e8 2b 26 ff ff       	call   8049300 <__stack_chk_fail@plt>
 8056cd5:	8d 65 f4             	lea    -0xc(%ebp),%esp
 8056cd8:	89 c8                	mov    %ecx,%eax
 8056cda:	5b                   	pop    %ebx
 8056cdb:	5e                   	pop    %esi
 8056cdc:	5f                   	pop    %edi
 8056cdd:	5d                   	pop    %ebp
 8056cde:	c3                   	ret    

08056cdf <icmpv6_handle_echo_request>:

static
enum net_verdict icmpv6_handle_echo_request(struct net_pkt *pkt,
					    struct net_ipv6_hdr *ip_hdr,
					    struct net_icmp_hdr *icmp_hdr)
{
 8056cdf:	55                   	push   %ebp
 8056ce0:	89 e5                	mov    %esp,%ebp
 8056ce2:	57                   	push   %edi
 8056ce3:	56                   	push   %esi
 8056ce4:	53                   	push   %ebx
 8056ce5:	83 ec 1c             	sub    $0x1c,%esp
 8056ce8:	8b 7d 0c             	mov    0xc(%ebp),%edi
 8056ceb:	8b 75 08             	mov    0x8(%ebp),%esi
	NET_DBG("Received Echo Request from %s to %s",
		net_sprint_ipv6_addr(&ip_hdr->src),
		net_sprint_ipv6_addr(&ip_hdr->dst));

	payload_len = ntohs(ip_hdr->len) -
		net_pkt_ipv6_ext_len(pkt) - NET_ICMPH_LEN;
 8056cee:	66 8b 5f 04          	mov    0x4(%edi),%bx
 8056cf2:	86 fb                	xchg   %bh,%bl
 8056cf4:	66 2b 5e 36          	sub    0x36(%esi),%bx
 8056cf8:	83 eb 04             	sub    $0x4,%ebx
	if (payload_len < NET_ICMPV6_UNUSED_LEN) {
 8056cfb:	66 83 fb 03          	cmp    $0x3,%bx
 8056cff:	0f 8e e4 00 00 00    	jle    8056de9 <icmpv6_handle_echo_request+0x10a>
		/* No identifier or sequence number present */
		goto drop;
	}

	reply = net_pkt_alloc_with_buffer(net_pkt_iface(pkt), payload_len,
 8056d05:	0f bf c3             	movswl %bx,%eax
 8056d08:	52                   	push   %edx
 8056d09:	52                   	push   %edx
 8056d0a:	6a 00                	push   $0x0
 8056d0c:	6a 64                	push   $0x64
 8056d0e:	6a 3a                	push   $0x3a
 8056d10:	6a 02                	push   $0x2
 8056d12:	50                   	push   %eax
 8056d13:	ff 76 18             	push   0x18(%esi)
 8056d16:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 8056d19:	e8 e9 e5 ff ff       	call   8055307 <net_pkt_alloc_with_buffer>
 8056d1e:	83 c4 20             	add    $0x20,%esp
 8056d21:	89 c3                	mov    %eax,%ebx
					  AF_INET6, IPPROTO_ICMPV6,
					  PKT_WAIT_TIME);
	if (!reply) {
 8056d23:	85 c0                	test   %eax,%eax
 8056d25:	0f 84 be 00 00 00    	je     8056de9 <icmpv6_handle_echo_request+0x10a>
		NET_DBG("DROP: No buffer");
		goto drop;
	}

	if (net_ipv6_is_addr_mcast((struct in6_addr *)ip_hdr->dst)) {
 8056d2b:	80 7f 18 ff          	cmpb   $0xff,0x18(%edi)
		src = net_if_ipv6_select_src_addr(net_pkt_iface(pkt),
						  (struct in6_addr *)ip_hdr->dst);
 8056d2f:	8d 4f 18             	lea    0x18(%edi),%ecx
	if (net_ipv6_is_addr_mcast((struct in6_addr *)ip_hdr->dst)) {
 8056d32:	75 10                	jne    8056d44 <icmpv6_handle_echo_request+0x65>
		src = net_if_ipv6_select_src_addr(net_pkt_iface(pkt),
 8056d34:	50                   	push   %eax
 8056d35:	50                   	push   %eax
 8056d36:	51                   	push   %ecx
 8056d37:	ff 76 18             	push   0x18(%esi)
 8056d3a:	e8 21 b6 ff ff       	call   8052360 <net_if_ipv6_select_src_addr>
 8056d3f:	83 c4 10             	add    $0x10,%esp
 8056d42:	89 c1                	mov    %eax,%ecx
	pkt->ip_dscp = dscp;
 8056d44:	8a 43 3c             	mov    0x3c(%ebx),%al

	/* We must not set the destination ll address here but trust
	 * that it is set properly using a value from neighbor cache.
	 * Same for source as it points to original pkt ll src address.
	 */
	net_pkt_lladdr_dst(reply)->addr = NULL;
 8056d47:	c7 43 28 00 00 00 00 	movl   $0x0,0x28(%ebx)
	net_pkt_lladdr_src(reply)->addr = NULL;

	net_pkt_set_ip_dscp(reply, net_pkt_ip_dscp(pkt));
	net_pkt_set_ip_ecn(reply, net_pkt_ip_ecn(pkt));

	if (net_ipv6_create(reply, src, (struct in6_addr *)ip_hdr->src)) {
 8056d4e:	83 c7 08             	add    $0x8,%edi
	net_pkt_lladdr_src(reply)->addr = NULL;
 8056d51:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
	return pkt->ip_dscp;
 8056d58:	8a 56 3c             	mov    0x3c(%esi),%dl
	pkt->ip_dscp = dscp;
 8056d5b:	83 e0 c0             	and    $0xffffffc0,%eax
	return pkt->ip_dscp;
 8056d5e:	83 e2 3f             	and    $0x3f,%edx
	pkt->ip_dscp = dscp;
 8056d61:	09 d0                	or     %edx,%eax
 8056d63:	88 43 3c             	mov    %al,0x3c(%ebx)
	pkt->ip_ecn = ecn;
 8056d66:	8a 56 3c             	mov    0x3c(%esi),%dl
 8056d69:	83 e0 3f             	and    $0x3f,%eax
 8056d6c:	83 e2 c0             	and    $0xffffffc0,%edx
 8056d6f:	09 d0                	or     %edx,%eax
 8056d71:	88 43 3c             	mov    %al,0x3c(%ebx)
	if (net_ipv6_create(reply, src, (struct in6_addr *)ip_hdr->src)) {
 8056d74:	50                   	push   %eax
 8056d75:	57                   	push   %edi
 8056d76:	51                   	push   %ecx
 8056d77:	53                   	push   %ebx
 8056d78:	e8 d5 05 00 00       	call   8057352 <net_ipv6_create>
 8056d7d:	83 c4 10             	add    $0x10,%esp
 8056d80:	85 c0                	test   %eax,%eax
 8056d82:	75 59                	jne    8056ddd <icmpv6_handle_echo_request+0xfe>
		NET_DBG("DROP: wrong buffer");
		goto drop;
	}

	if (net_icmpv6_create(reply, NET_ICMPV6_ECHO_REPLY, 0) ||
 8056d84:	57                   	push   %edi
 8056d85:	6a 00                	push   $0x0
 8056d87:	68 81 00 00 00       	push   $0x81
 8056d8c:	53                   	push   %ebx
 8056d8d:	e8 d0 fe ff ff       	call   8056c62 <net_icmpv6_create>
 8056d92:	83 c4 10             	add    $0x10,%esp
 8056d95:	85 c0                	test   %eax,%eax
 8056d97:	75 44                	jne    8056ddd <icmpv6_handle_echo_request+0xfe>
	    net_pkt_copy(reply, pkt, payload_len)) {
 8056d99:	51                   	push   %ecx
 8056d9a:	ff 75 e4             	push   -0x1c(%ebp)
 8056d9d:	56                   	push   %esi
 8056d9e:	53                   	push   %ebx
 8056d9f:	e8 d9 e7 ff ff       	call   805557d <net_pkt_copy>
 8056da4:	83 c4 10             	add    $0x10,%esp
	if (net_icmpv6_create(reply, NET_ICMPV6_ECHO_REPLY, 0) ||
 8056da7:	85 c0                	test   %eax,%eax
 8056da9:	75 32                	jne    8056ddd <icmpv6_handle_echo_request+0xfe>
		NET_DBG("DROP: wrong buffer");
		goto drop;
	}

	net_pkt_cursor_init(reply);
 8056dab:	83 ec 0c             	sub    $0xc,%esp
 8056dae:	53                   	push   %ebx
 8056daf:	e8 a0 e1 ff ff       	call   8054f54 <net_pkt_cursor_init>
 8056db4:	58                   	pop    %eax
 8056db5:	5a                   	pop    %edx
	net_ipv6_finalize(reply, IPPROTO_ICMPV6);
 8056db6:	6a 3a                	push   $0x3a
 8056db8:	53                   	push   %ebx
 8056db9:	e8 6f 06 00 00       	call   805742d <net_ipv6_finalize>

	NET_DBG("Sending Echo Reply from %s to %s",
		net_sprint_ipv6_addr(src),
		net_sprint_ipv6_addr(&ip_hdr->src));

	if (net_send_data(reply) < 0) {
 8056dbe:	89 1c 24             	mov    %ebx,(%esp)
 8056dc1:	e8 6a 96 ff ff       	call   8050430 <net_send_data>
 8056dc6:	83 c4 10             	add    $0x10,%esp
 8056dc9:	85 c0                	test   %eax,%eax
 8056dcb:	78 10                	js     8056ddd <icmpv6_handle_echo_request+0xfe>
		goto drop;
	}

	net_stats_update_icmp_sent(net_pkt_iface(reply));

	net_pkt_unref(pkt);
 8056dcd:	83 ec 0c             	sub    $0xc,%esp
 8056dd0:	56                   	push   %esi
 8056dd1:	e8 12 e0 ff ff       	call   8054de8 <net_pkt_unref>
 8056dd6:	83 c4 10             	add    $0x10,%esp

	return NET_OK;
 8056dd9:	31 c0                	xor    %eax,%eax
 8056ddb:	eb 11                	jmp    8056dee <icmpv6_handle_echo_request+0x10f>

drop:
	if (reply) {
		net_pkt_unref(reply);
 8056ddd:	83 ec 0c             	sub    $0xc,%esp
 8056de0:	53                   	push   %ebx
 8056de1:	e8 02 e0 ff ff       	call   8054de8 <net_pkt_unref>
 8056de6:	83 c4 10             	add    $0x10,%esp
	}

	net_stats_update_icmp_drop(net_pkt_iface(pkt));

	return NET_DROP;
 8056de9:	b8 02 00 00 00       	mov    $0x2,%eax
}
 8056dee:	8d 65 f4             	lea    -0xc(%ebp),%esp
 8056df1:	5b                   	pop    %ebx
 8056df2:	5e                   	pop    %esi
 8056df3:	5f                   	pop    %edi
 8056df4:	5d                   	pop    %ebp
 8056df5:	c3                   	ret    

08056df6 <net_icmpv6_send_error>:

int net_icmpv6_send_error(struct net_pkt *orig, uint8_t type, uint8_t code,
			  uint32_t param)
{
 8056df6:	55                   	push   %ebp
 8056df7:	89 e5                	mov    %esp,%ebp
 8056df9:	57                   	push   %edi
 8056dfa:	56                   	push   %esi
 8056dfb:	53                   	push   %ebx
 8056dfc:	83 ec 48             	sub    $0x48,%esp
 8056dff:	8b 45 0c             	mov    0xc(%ebp),%eax
 8056e02:	8b 75 08             	mov    0x8(%ebp),%esi
 8056e05:	89 45 c0             	mov    %eax,-0x40(%ebp)
 8056e08:	8b 45 10             	mov    0x10(%ebp),%eax
 8056e0b:	89 45 bc             	mov    %eax,-0x44(%ebp)
 8056e0e:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 8056e14:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 8056e17:	31 c0                	xor    %eax,%eax
	const struct in6_addr *src;
	struct net_pkt *pkt;
	size_t copy_len;
	int ret;

	net_pkt_cursor_init(orig);
 8056e19:	56                   	push   %esi
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv6_access, struct net_ipv6_hdr);
 8056e1a:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
 8056e21:	c7 45 d8 28 00 00 00 	movl   $0x28,-0x28(%ebp)
	net_pkt_cursor_init(orig);
 8056e28:	e8 27 e1 ff ff       	call   8054f54 <net_pkt_cursor_init>
 8056e2d:	58                   	pop    %eax

	ip_hdr = (struct net_ipv6_hdr *)net_pkt_get_data(orig, &ipv6_access);
 8056e2e:	8d 45 d4             	lea    -0x2c(%ebp),%eax
	net_pkt_cursor_init(orig);
 8056e31:	5a                   	pop    %edx
	ip_hdr = (struct net_ipv6_hdr *)net_pkt_get_data(orig, &ipv6_access);
 8056e32:	50                   	push   %eax
 8056e33:	56                   	push   %esi
 8056e34:	e8 99 ea ff ff       	call   80558d2 <net_pkt_get_data>
 8056e39:	83 c4 10             	add    $0x10,%esp
	int err = -EIO;
 8056e3c:	b9 fb ff ff ff       	mov    $0xfffffffb,%ecx
	ip_hdr = (struct net_ipv6_hdr *)net_pkt_get_data(orig, &ipv6_access);
 8056e41:	89 45 c4             	mov    %eax,-0x3c(%ebp)
	if (!ip_hdr) {
 8056e44:	85 c0                	test   %eax,%eax
 8056e46:	0f 84 ff 01 00 00    	je     805704b <net_icmpv6_send_error+0x255>
		goto drop_no_pkt;
	}

	if (ip_hdr->nexthdr == IPPROTO_ICMPV6) {
 8056e4c:	80 78 06 3a          	cmpb   $0x3a,0x6(%eax)
 8056e50:	75 48                	jne    8056e9a <net_icmpv6_send_error+0xa4>
	return net_pkt_skip(pkt, access->size);
 8056e52:	51                   	push   %ecx
 8056e53:	51                   	push   %ecx
 8056e54:	ff 75 d8             	push   -0x28(%ebp)
 8056e57:	56                   	push   %esi
		NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmpv6_access,
 8056e58:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
 8056e5f:	c7 45 e0 04 00 00 00 	movl   $0x4,-0x20(%ebp)
 8056e66:	e8 06 e5 ff ff       	call   8055371 <net_pkt_skip>
						      struct net_icmp_hdr);
		struct net_icmp_hdr *icmp_hdr;

		net_pkt_acknowledge_data(orig, &ipv6_access);

		icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(
 8056e6b:	8d 45 dc             	lea    -0x24(%ebp),%eax
 8056e6e:	5b                   	pop    %ebx
 8056e6f:	5f                   	pop    %edi
 8056e70:	50                   	push   %eax
 8056e71:	56                   	push   %esi
 8056e72:	e8 5b ea ff ff       	call   80558d2 <net_pkt_get_data>
 8056e77:	83 c4 10             	add    $0x10,%esp
							orig, &icmpv6_access);
		if (!icmp_hdr || icmp_hdr->code < 128) {
 8056e7a:	85 c0                	test   %eax,%eax
 8056e7c:	74 06                	je     8056e84 <net_icmpv6_send_error+0x8e>
 8056e7e:	80 78 01 00          	cmpb   $0x0,0x1(%eax)
 8056e82:	78 0a                	js     8056e8e <net_icmpv6_send_error+0x98>
			/* We must not send ICMP errors back */
			err = -EINVAL;
 8056e84:	b9 ea ff ff ff       	mov    $0xffffffea,%ecx
 8056e89:	e9 bd 01 00 00       	jmp    805704b <net_icmpv6_send_error+0x255>
			goto drop_no_pkt;
		}

		net_pkt_cursor_init(orig);
 8056e8e:	83 ec 0c             	sub    $0xc,%esp
 8056e91:	56                   	push   %esi
 8056e92:	e8 bd e0 ff ff       	call   8054f54 <net_pkt_cursor_init>
 8056e97:	83 c4 10             	add    $0x10,%esp
	}

	if (ip_hdr->nexthdr == IPPROTO_UDP) {
 8056e9a:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 8056e9d:	8a 50 06             	mov    0x6(%eax),%dl
		copy_len = sizeof(struct net_ipv6_hdr) +
 8056ea0:	b8 30 00 00 00       	mov    $0x30,%eax
	if (ip_hdr->nexthdr == IPPROTO_UDP) {
 8056ea5:	80 fa 11             	cmp    $0x11,%dl
 8056ea8:	74 1e                	je     8056ec8 <net_icmpv6_send_error+0xd2>
			sizeof(struct net_udp_hdr);
	} else if (ip_hdr->nexthdr == IPPROTO_TCP) {
		copy_len = sizeof(struct net_ipv6_hdr) +
 8056eaa:	b8 3c 00 00 00       	mov    $0x3c,%eax
	} else if (ip_hdr->nexthdr == IPPROTO_TCP) {
 8056eaf:	80 fa 06             	cmp    $0x6,%dl
 8056eb2:	74 14                	je     8056ec8 <net_icmpv6_send_error+0xd2>
			sizeof(struct net_tcp_hdr);
	} else {
		copy_len = net_pkt_get_len(orig);
 8056eb4:	8b 56 08             	mov    0x8(%esi),%edx
	size_t bytes = 0;
 8056eb7:	31 c0                	xor    %eax,%eax
	while (buf) {
 8056eb9:	85 d2                	test   %edx,%edx
 8056ebb:	74 0b                	je     8056ec8 <net_icmpv6_send_error+0xd2>
		bytes += buf->len;
 8056ebd:	0f b7 4a 10          	movzwl 0x10(%edx),%ecx
		buf = buf->frags;
 8056ec1:	8b 52 04             	mov    0x4(%edx),%edx
		bytes += buf->len;
 8056ec4:	01 c8                	add    %ecx,%eax
		buf = buf->frags;
 8056ec6:	eb f1                	jmp    8056eb9 <net_icmpv6_send_error+0xc3>
	}

	pkt = net_pkt_alloc_with_buffer(net_pkt_iface(orig),
 8056ec8:	52                   	push   %edx
 8056ec9:	52                   	push   %edx
 8056eca:	6a 00                	push   $0x0
 8056ecc:	6a 64                	push   $0x64
 8056ece:	6a 3a                	push   $0x3a
 8056ed0:	6a 02                	push   $0x2
					net_pkt_lladdr_src(orig)->len * 2 +
 8056ed2:	0f b6 56 24          	movzbl 0x24(%esi),%edx
 8056ed6:	01 d2                	add    %edx,%edx
	pkt = net_pkt_alloc_with_buffer(net_pkt_iface(orig),
 8056ed8:	8d 44 10 04          	lea    0x4(%eax,%edx,1),%eax
 8056edc:	50                   	push   %eax
 8056edd:	ff 76 18             	push   0x18(%esi)
 8056ee0:	e8 22 e4 ff ff       	call   8055307 <net_pkt_alloc_with_buffer>
 8056ee5:	83 c4 20             	add    $0x20,%esp
					copy_len + NET_ICMPV6_UNUSED_LEN,
					AF_INET6, IPPROTO_ICMPV6,
					PKT_WAIT_TIME);
	if (!pkt) {
		err = -ENOMEM;
 8056ee8:	b9 f4 ff ff ff       	mov    $0xfffffff4,%ecx
	pkt = net_pkt_alloc_with_buffer(net_pkt_iface(orig),
 8056eed:	89 c3                	mov    %eax,%ebx
	if (!pkt) {
 8056eef:	85 c0                	test   %eax,%eax
 8056ef1:	0f 84 54 01 00 00    	je     805704b <net_icmpv6_send_error+0x255>
	 * as the link address will be set in the pkt when the packet is
	 * constructed in L2. So basically all this for just to create some
	 * extra space for link addresses so that we can set the lladdr
	 * pointers in net_pkt.
	 */
	ret = net_pkt_write(pkt, net_pkt_lladdr_src(orig)->addr,
 8056ef7:	57                   	push   %edi
 8056ef8:	0f b6 46 24          	movzbl 0x24(%esi),%eax
 8056efc:	50                   	push   %eax
 8056efd:	ff 76 20             	push   0x20(%esi)
 8056f00:	53                   	push   %ebx
 8056f01:	e8 73 e9 ff ff       	call   8055879 <net_pkt_write>
 8056f06:	83 c4 10             	add    $0x10,%esp
 8056f09:	89 c7                	mov    %eax,%edi
			    net_pkt_lladdr_src(orig)->len);
	if (ret < 0) {
 8056f0b:	85 c0                	test   %eax,%eax
 8056f0d:	0f 88 2a 01 00 00    	js     805703d <net_icmpv6_send_error+0x247>
		err = ret;
		goto drop;
	}

	net_pkt_lladdr_dst(pkt)->addr = pkt->buffer->data;
 8056f13:	8b 43 08             	mov    0x8(%ebx),%eax
 8056f16:	8b 40 0c             	mov    0xc(%eax),%eax
 8056f19:	89 43 28             	mov    %eax,0x28(%ebx)

	ret = net_pkt_write(pkt, net_pkt_lladdr_dst(orig)->addr,
 8056f1c:	51                   	push   %ecx
 8056f1d:	0f b6 46 2c          	movzbl 0x2c(%esi),%eax
 8056f21:	50                   	push   %eax
 8056f22:	ff 76 28             	push   0x28(%esi)
 8056f25:	53                   	push   %ebx
 8056f26:	e8 4e e9 ff ff       	call   8055879 <net_pkt_write>
 8056f2b:	83 c4 10             	add    $0x10,%esp
 8056f2e:	89 c7                	mov    %eax,%edi
			    net_pkt_lladdr_dst(orig)->len);
	if (ret < 0) {
 8056f30:	85 c0                	test   %eax,%eax
 8056f32:	0f 88 05 01 00 00    	js     805703d <net_icmpv6_send_error+0x247>
	return net_buf_simple_pull_mem(&buf->b, len);
 8056f38:	57                   	push   %edi
 8056f39:	57                   	push   %edi
		err = ret;
		goto drop;
	}

	net_buf_pull_mem(pkt->buffer, net_pkt_lladdr_dst(orig)->len);
 8056f3a:	0f b6 46 2c          	movzbl 0x2c(%esi),%eax
 8056f3e:	50                   	push   %eax
 8056f3f:	8b 43 08             	mov    0x8(%ebx),%eax
 8056f42:	83 c0 0c             	add    $0xc,%eax
 8056f45:	50                   	push   %eax
 8056f46:	e8 3b 83 ff ff       	call   804f286 <net_buf_simple_pull_mem>
 8056f4b:	58                   	pop    %eax

	net_pkt_lladdr_src(pkt)->addr = pkt->buffer->data;
 8056f4c:	8b 43 08             	mov    0x8(%ebx),%eax
 8056f4f:	5a                   	pop    %edx
 8056f50:	8b 50 0c             	mov    0xc(%eax),%edx
 8056f53:	83 c0 0c             	add    $0xc,%eax
 8056f56:	89 53 20             	mov    %edx,0x20(%ebx)

	net_buf_pull_mem(pkt->buffer, net_pkt_lladdr_src(orig)->len);
 8056f59:	0f b6 56 24          	movzbl 0x24(%esi),%edx
 8056f5d:	52                   	push   %edx
 8056f5e:	50                   	push   %eax
 8056f5f:	e8 22 83 ff ff       	call   804f286 <net_buf_simple_pull_mem>

	net_pkt_lladdr_src(pkt)->len = net_pkt_lladdr_dst(orig)->len;
 8056f64:	8a 46 2c             	mov    0x2c(%esi),%al
	net_pkt_lladdr_dst(pkt)->len = net_pkt_lladdr_src(orig)->len;

	if (net_ipv6_is_addr_mcast((struct in6_addr *)ip_hdr->dst)) {
 8056f67:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
 8056f6a:	83 c4 10             	add    $0x10,%esp
	net_pkt_lladdr_src(pkt)->len = net_pkt_lladdr_dst(orig)->len;
 8056f6d:	88 43 24             	mov    %al,0x24(%ebx)
	net_pkt_lladdr_dst(pkt)->len = net_pkt_lladdr_src(orig)->len;
 8056f70:	8a 46 24             	mov    0x24(%esi),%al
 8056f73:	88 43 2c             	mov    %al,0x2c(%ebx)
		src = net_if_ipv6_select_src_addr(net_pkt_iface(pkt),
						  (struct in6_addr *)ip_hdr->dst);
 8056f76:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 8056f79:	83 c0 18             	add    $0x18,%eax
	if (net_ipv6_is_addr_mcast((struct in6_addr *)ip_hdr->dst)) {
 8056f7c:	80 79 18 ff          	cmpb   $0xff,0x18(%ecx)
 8056f80:	75 0e                	jne    8056f90 <net_icmpv6_send_error+0x19a>
		src = net_if_ipv6_select_src_addr(net_pkt_iface(pkt),
 8056f82:	51                   	push   %ecx
 8056f83:	51                   	push   %ecx
 8056f84:	50                   	push   %eax
 8056f85:	ff 73 18             	push   0x18(%ebx)
 8056f88:	e8 d3 b3 ff ff       	call   8052360 <net_if_ipv6_select_src_addr>
 8056f8d:	83 c4 10             	add    $0x10,%esp
	} else {
		src = (struct in6_addr *)ip_hdr->dst;
	}

	if (net_ipv6_create(pkt, src, (struct in6_addr *)ip_hdr->src) ||
 8056f90:	8b 7d c4             	mov    -0x3c(%ebp),%edi
 8056f93:	52                   	push   %edx
 8056f94:	83 c7 08             	add    $0x8,%edi
 8056f97:	57                   	push   %edi
 8056f98:	50                   	push   %eax
 8056f99:	53                   	push   %ebx
 8056f9a:	e8 b3 03 00 00       	call   8057352 <net_ipv6_create>
 8056f9f:	83 c4 10             	add    $0x10,%esp
 8056fa2:	85 c0                	test   %eax,%eax
 8056fa4:	74 0a                	je     8056fb0 <net_icmpv6_send_error+0x1ba>
	int err = -EIO;
 8056fa6:	bf fb ff ff ff       	mov    $0xfffffffb,%edi
 8056fab:	e9 8d 00 00 00       	jmp    805703d <net_icmpv6_send_error+0x247>
	    net_icmpv6_create(pkt, type, code)) {
 8056fb0:	50                   	push   %eax
 8056fb1:	0f b6 45 bc          	movzbl -0x44(%ebp),%eax
 8056fb5:	50                   	push   %eax
 8056fb6:	0f b6 45 c0          	movzbl -0x40(%ebp),%eax
 8056fba:	50                   	push   %eax
 8056fbb:	53                   	push   %ebx
 8056fbc:	e8 a1 fc ff ff       	call   8056c62 <net_icmpv6_create>
 8056fc1:	83 c4 10             	add    $0x10,%esp
	if (net_ipv6_create(pkt, src, (struct in6_addr *)ip_hdr->src) ||
 8056fc4:	85 c0                	test   %eax,%eax
 8056fc6:	75 de                	jne    8056fa6 <net_icmpv6_send_error+0x1b0>
		goto drop;
	}

	/* Depending on error option, we store the param into the ICMP message.
	 */
	if (type == NET_ICMPV6_PARAM_PROBLEM) {
 8056fc8:	80 7d c0 04          	cmpb   $0x4,-0x40(%ebp)
 8056fcc:	75 17                	jne    8056fe5 <net_icmpv6_send_error+0x1ef>
	uint32_t data_be32 = htonl(data);
 8056fce:	8b 45 14             	mov    0x14(%ebp),%eax
 8056fd1:	0f c8                	bswap  %eax
 8056fd3:	89 45 dc             	mov    %eax,-0x24(%ebp)
	return net_pkt_write(pkt, &data_be32, sizeof(uint32_t));
 8056fd6:	50                   	push   %eax
 8056fd7:	8d 45 dc             	lea    -0x24(%ebp),%eax
 8056fda:	6a 04                	push   $0x4
 8056fdc:	50                   	push   %eax
 8056fdd:	53                   	push   %ebx
 8056fde:	e8 96 e8 ff ff       	call   8055879 <net_pkt_write>
 8056fe3:	eb 0b                	jmp    8056ff0 <net_icmpv6_send_error+0x1fa>
		err = net_pkt_write_be32(pkt, param);
	} else {
		err = net_pkt_memset(pkt, 0, NET_ICMPV6_UNUSED_LEN);
 8056fe5:	57                   	push   %edi
 8056fe6:	6a 04                	push   $0x4
 8056fe8:	6a 00                	push   $0x0
 8056fea:	53                   	push   %ebx
 8056feb:	e8 0d e5 ff ff       	call   80554fd <net_pkt_memset>
 8056ff0:	83 c4 10             	add    $0x10,%esp
 8056ff3:	89 c7                	mov    %eax,%edi
	}

	/* Allocator might not have been able to allocate all requested space,
	 * so let's copy as much as we can.
	 */
	copy_len = net_pkt_available_buffer(pkt);
 8056ff5:	83 ec 0c             	sub    $0xc,%esp
 8056ff8:	53                   	push   %ebx
 8056ff9:	e8 67 de ff ff       	call   8054e65 <net_pkt_available_buffer>
 8056ffe:	83 c4 10             	add    $0x10,%esp

	if (err || net_pkt_copy(pkt, orig, copy_len)) {
 8057001:	85 ff                	test   %edi,%edi
 8057003:	75 38                	jne    805703d <net_icmpv6_send_error+0x247>
 8057005:	51                   	push   %ecx
 8057006:	50                   	push   %eax
 8057007:	56                   	push   %esi
 8057008:	53                   	push   %ebx
 8057009:	e8 6f e5 ff ff       	call   805557d <net_pkt_copy>
 805700e:	83 c4 10             	add    $0x10,%esp
 8057011:	85 c0                	test   %eax,%eax
 8057013:	89 45 c4             	mov    %eax,-0x3c(%ebp)
 8057016:	75 25                	jne    805703d <net_icmpv6_send_error+0x247>
		goto drop;
	}

	net_pkt_cursor_init(pkt);
 8057018:	83 ec 0c             	sub    $0xc,%esp
 805701b:	53                   	push   %ebx
 805701c:	e8 33 df ff ff       	call   8054f54 <net_pkt_cursor_init>
 8057021:	58                   	pop    %eax
 8057022:	5a                   	pop    %edx
	net_ipv6_finalize(pkt, IPPROTO_ICMPV6);
 8057023:	6a 3a                	push   $0x3a
 8057025:	53                   	push   %ebx
 8057026:	e8 02 04 00 00       	call   805742d <net_ipv6_finalize>
	NET_DBG("Sending ICMPv6 Error Message type %d code %d param %d"
		" from %s to %s", type, code, param,
		net_sprint_ipv6_addr(src),
		net_sprint_ipv6_addr(&ip_hdr->src));

	if (net_send_data(pkt) >= 0) {
 805702b:	89 1c 24             	mov    %ebx,(%esp)
 805702e:	e8 fd 93 ff ff       	call   8050430 <net_send_data>
 8057033:	83 c4 10             	add    $0x10,%esp
 8057036:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
 8057039:	85 c0                	test   %eax,%eax
 805703b:	79 0e                	jns    805704b <net_icmpv6_send_error+0x255>
		net_stats_update_icmp_sent(net_pkt_iface(pkt));
		return 0;
	}

drop:
	net_pkt_unref(pkt);
 805703d:	83 ec 0c             	sub    $0xc,%esp
 8057040:	53                   	push   %ebx
 8057041:	e8 a2 dd ff ff       	call   8054de8 <net_pkt_unref>
 8057046:	83 c4 10             	add    $0x10,%esp
 8057049:	89 f9                	mov    %edi,%ecx

drop_no_pkt:
	net_stats_update_icmp_drop(net_pkt_iface(orig));

	return err;
}
 805704b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 805704e:	65 2b 05 14 00 00 00 	sub    %gs:0x14,%eax
 8057055:	74 05                	je     805705c <net_icmpv6_send_error+0x266>
 8057057:	e8 a4 22 ff ff       	call   8049300 <__stack_chk_fail@plt>
 805705c:	8d 65 f4             	lea    -0xc(%ebp),%esp
 805705f:	89 c8                	mov    %ecx,%eax
 8057061:	5b                   	pop    %ebx
 8057062:	5e                   	pop    %esi
 8057063:	5f                   	pop    %edi
 8057064:	5d                   	pop    %ebp
 8057065:	c3                   	ret    

08057066 <net_icmpv6_input>:
	return ret;
}

enum net_verdict net_icmpv6_input(struct net_pkt *pkt,
				  struct net_ipv6_hdr *ip_hdr)
{
 8057066:	55                   	push   %ebp
 8057067:	89 e5                	mov    %esp,%ebp
 8057069:	57                   	push   %edi
 805706a:	56                   	push   %esi
 805706b:	53                   	push   %ebx
 805706c:	83 ec 24             	sub    $0x24,%esp
 805706f:	8b 75 08             	mov    0x8(%ebp),%esi
 8057072:	8b 7d 0c             	mov    0xc(%ebp),%edi
 8057075:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 805707b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 805707e:	31 c0                	xor    %eax,%eax
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmp_access,
					      struct net_icmp_hdr);
	struct net_icmp_hdr *icmp_hdr;
	struct net_icmpv6_handler *cb;

	icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(pkt, &icmp_access);
 8057080:	8d 45 dc             	lea    -0x24(%ebp),%eax
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmp_access,
 8057083:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(pkt, &icmp_access);
 805708a:	50                   	push   %eax
 805708b:	56                   	push   %esi
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmp_access,
 805708c:	c7 45 e0 04 00 00 00 	movl   $0x4,-0x20(%ebp)
	icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(pkt, &icmp_access);
 8057093:	e8 3a e8 ff ff       	call   80558d2 <net_pkt_get_data>
 8057098:	83 c4 10             	add    $0x10,%esp
	if (!icmp_hdr) {
 805709b:	85 c0                	test   %eax,%eax
 805709d:	75 07                	jne    80570a6 <net_icmpv6_input+0x40>
		NET_DBG("DROP: NULL ICMPv6 header");
		return NET_DROP;
 805709f:	b8 02 00 00 00       	mov    $0x2,%eax
 80570a4:	eb 66                	jmp    805710c <net_icmpv6_input+0xa6>
	}


	if (net_if_need_calc_rx_checksum(net_pkt_iface(pkt))) {
 80570a6:	83 ec 0c             	sub    $0xc,%esp
 80570a9:	ff 76 18             	push   0x18(%esi)
 80570ac:	89 c3                	mov    %eax,%ebx
 80570ae:	e8 be b9 ff ff       	call   8052a71 <net_if_need_calc_rx_checksum>
 80570b3:	83 c4 10             	add    $0x10,%esp
 80570b6:	84 c0                	test   %al,%al
 80570b8:	75 1b                	jne    80570d5 <net_icmpv6_input+0x6f>
	return net_pkt_skip(pkt, access->size);
 80570ba:	50                   	push   %eax
 80570bb:	50                   	push   %eax
 80570bc:	ff 75 e0             	push   -0x20(%ebp)
 80570bf:	56                   	push   %esi
 80570c0:	e8 ac e2 ff ff       	call   8055371 <net_pkt_skip>
	return list->head;
 80570c5:	a1 1c 8a 06 08       	mov    0x8068a1c,%eax
 80570ca:	83 c4 10             	add    $0x10,%esp
		net_icmpv6_type2str(icmp_hdr->type),
		icmp_hdr->type, icmp_hdr->code);

	net_stats_update_icmp_recv(net_pkt_iface(pkt));

	SYS_SLIST_FOR_EACH_CONTAINER(&handlers, cb, node) {
 80570cd:	85 c0                	test   %eax,%eax
 80570cf:	74 ce                	je     805709f <net_icmpv6_input+0x39>
		if (cb->type == icmp_hdr->type &&
 80570d1:	8a 0b                	mov    (%ebx),%cl
 80570d3:	eb 26                	jmp    80570fb <net_icmpv6_input+0x95>
 80570d5:	51                   	push   %ecx
 80570d6:	51                   	push   %ecx
 80570d7:	6a 3a                	push   $0x3a
 80570d9:	56                   	push   %esi
 80570da:	e8 34 c4 ff ff       	call   8053513 <net_calc_chksum>
 80570df:	83 c4 10             	add    $0x10,%esp
		if (net_calc_chksum_icmpv6(pkt) != 0U) {
 80570e2:	66 85 c0             	test   %ax,%ax
 80570e5:	74 d3                	je     80570ba <net_icmpv6_input+0x54>
 80570e7:	eb b6                	jmp    805709f <net_icmpv6_input+0x39>
		    (cb->code == icmp_hdr->code || cb->code == 0U)) {
 80570e9:	8a 50 09             	mov    0x9(%eax),%dl
 80570ec:	38 53 01             	cmp    %dl,0x1(%ebx)
 80570ef:	74 11                	je     8057102 <net_icmpv6_input+0x9c>
 80570f1:	84 d2                	test   %dl,%dl
 80570f3:	74 0d                	je     8057102 <net_icmpv6_input+0x9c>
	return node->next;
 80570f5:	8b 00                	mov    (%eax),%eax
	SYS_SLIST_FOR_EACH_CONTAINER(&handlers, cb, node) {
 80570f7:	85 c0                	test   %eax,%eax
 80570f9:	74 a4                	je     805709f <net_icmpv6_input+0x39>
		if (cb->type == icmp_hdr->type &&
 80570fb:	38 48 08             	cmp    %cl,0x8(%eax)
 80570fe:	75 f5                	jne    80570f5 <net_icmpv6_input+0x8f>
 8057100:	eb e7                	jmp    80570e9 <net_icmpv6_input+0x83>
			return cb->handler(pkt, ip_hdr, icmp_hdr);
 8057102:	52                   	push   %edx
 8057103:	53                   	push   %ebx
 8057104:	57                   	push   %edi
 8057105:	56                   	push   %esi
 8057106:	ff 50 04             	call   *0x4(%eax)
 8057109:	83 c4 10             	add    $0x10,%esp
	}
drop:
	net_stats_update_icmp_drop(net_pkt_iface(pkt));

	return NET_DROP;
}
 805710c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 805710f:	65 2b 15 14 00 00 00 	sub    %gs:0x14,%edx
 8057116:	74 05                	je     805711d <net_icmpv6_input+0xb7>
 8057118:	e8 e3 21 ff ff       	call   8049300 <__stack_chk_fail@plt>
 805711d:	8d 65 f4             	lea    -0xc(%ebp),%esp
 8057120:	5b                   	pop    %ebx
 8057121:	5e                   	pop    %esi
 8057122:	5f                   	pop    %edi
 8057123:	5d                   	pop    %ebp
 8057124:	c3                   	ret    

08057125 <net_icmpv6_init>:
	.code = 0,
	.handler = icmpv6_handle_echo_request,
};

void net_icmpv6_init(void)
{
 8057125:	55                   	push   %ebp
 8057126:	89 e5                	mov    %esp,%ebp
 8057128:	83 ec 14             	sub    $0x14,%esp
	net_icmpv6_register_handler(&echo_request_handler);
 805712b:	68 80 73 06 08       	push   $0x8067380
 8057130:	e8 7f fa ff ff       	call   8056bb4 <net_icmpv6_register_handler>
 8057135:	83 c4 10             	add    $0x10,%esp
}
 8057138:	c9                   	leave  
 8057139:	c3                   	ret    

0805713a <net_nbr_unref>:
void net_nbr_unref_debug(struct net_nbr *nbr, const char *caller, int line)
#define net_nbr_unref(nbr) net_nbr_unref_debug(nbr, __func__, __LINE__)
#else
void net_nbr_unref(struct net_nbr *nbr)
#endif
{
 805713a:	55                   	push   %ebp
 805713b:	89 e5                	mov    %esp,%ebp
 805713d:	8b 55 08             	mov    0x8(%ebp),%edx
#if defined(CONFIG_NET_IPV6_NBR_CACHE_LOG_LEVEL_DBG)
	NET_DBG("nbr %p ref %u (%s():%d)", nbr, nbr->ref - 1, caller, line);
#else
	NET_DBG("nbr %p ref %u", nbr, nbr->ref - 1);
#endif
	if (--nbr->ref) {
 8057140:	fe 0a                	decb   (%edx)
 8057142:	75 0a                	jne    805714e <net_nbr_unref+0x14>
		return;
	}

	if (nbr->remove) {
 8057144:	8b 42 10             	mov    0x10(%edx),%eax
 8057147:	85 c0                	test   %eax,%eax
 8057149:	74 03                	je     805714e <net_nbr_unref+0x14>
		nbr->remove(nbr);
	}
}
 805714b:	5d                   	pop    %ebp
		nbr->remove(nbr);
 805714c:	ff e0                	jmp    *%eax
}
 805714e:	5d                   	pop    %ebp
 805714f:	c3                   	ret    

08057150 <net_nbr_ref>:
struct net_nbr *net_nbr_ref_debug(struct net_nbr *nbr, const char *caller,
				  int line)
#else
struct net_nbr *net_nbr_ref(struct net_nbr *nbr)
#endif
{
 8057150:	55                   	push   %ebp
 8057151:	89 e5                	mov    %esp,%ebp
 8057153:	8b 45 08             	mov    0x8(%ebp),%eax
#if defined(CONFIG_NET_IPV6_NBR_CACHE_LOG_LEVEL_DBG)
	NET_DBG("nbr %p ref %u (%s():%d)", nbr, nbr->ref + 1, caller, line);
#else
	NET_DBG("nbr %p ref %u", nbr, nbr->ref + 1);
#endif
	nbr->ref++;
 8057156:	fe 00                	incb   (%eax)

	return nbr;
}
 8057158:	5d                   	pop    %ebp
 8057159:	c3                   	ret    

0805715a <net_nbr_get>:
			((sizeof(struct net_nbr) +
			  start->size + start->extra_data_size) * idx));
}

struct net_nbr *net_nbr_get(struct net_nbr_table *table)
{
 805715a:	55                   	push   %ebp
	int i;

	for (i = 0; i < table->nbr_count; i++) {
 805715b:	31 d2                	xor    %edx,%edx
{
 805715d:	89 e5                	mov    %esp,%ebp
 805715f:	57                   	push   %edi
 8057160:	56                   	push   %esi
 8057161:	53                   	push   %ebx
 8057162:	8b 5d 08             	mov    0x8(%ebp),%ebx
	for (i = 0; i < table->nbr_count; i++) {
 8057165:	0f b7 73 08          	movzwl 0x8(%ebx),%esi
 8057169:	39 d6                	cmp    %edx,%esi
 805716b:	7e 26                	jle    8057193 <net_nbr_get+0x39>
		struct net_nbr *nbr = get_nbr(table->nbr, i);
 805716d:	8b 03                	mov    (%ebx),%eax
			  start->size + start->extra_data_size) * idx));
 805716f:	0f b7 78 02          	movzwl 0x2(%eax),%edi
 8057173:	0f b7 48 04          	movzwl 0x4(%eax),%ecx
 8057177:	8d 4c 0f 14          	lea    0x14(%edi,%ecx,1),%ecx
 805717b:	0f af ca             	imul   %edx,%ecx
	return (struct net_nbr *)((uint8_t *)start +
 805717e:	01 c8                	add    %ecx,%eax

		if (!nbr->ref) {
 8057180:	80 38 00             	cmpb   $0x0,(%eax)
 8057183:	75 0b                	jne    8057190 <net_nbr_get+0x36>
			nbr->data = nbr->__nbr;
 8057185:	8d 50 14             	lea    0x14(%eax),%edx
	nbr->ref++;
 8057188:	c6 00 01             	movb   $0x1,(%eax)
			nbr->data = nbr->__nbr;
 805718b:	89 50 0c             	mov    %edx,0xc(%eax)

			return net_nbr_ref(nbr);
 805718e:	eb 05                	jmp    8057195 <net_nbr_get+0x3b>
	for (i = 0; i < table->nbr_count; i++) {
 8057190:	42                   	inc    %edx
 8057191:	eb d6                	jmp    8057169 <net_nbr_get+0xf>
		}
	}

	return NULL;
 8057193:	31 c0                	xor    %eax,%eax
}
 8057195:	5b                   	pop    %ebx
 8057196:	5e                   	pop    %esi
 8057197:	5f                   	pop    %edi
 8057198:	5d                   	pop    %ebp
 8057199:	c3                   	ret    

0805719a <net_nbr_link>:

int net_nbr_link(struct net_nbr *nbr, struct net_if *iface,
		 const struct net_linkaddr *lladdr)
{
 805719a:	55                   	push   %ebp
	int i, avail = -1;

	if (nbr->idx != NET_NBR_LLADDR_UNKNOWN) {
		return -EALREADY;
 805719b:	b8 8e ff ff ff       	mov    $0xffffff8e,%eax
{
 80571a0:	89 e5                	mov    %esp,%ebp
 80571a2:	57                   	push   %edi
 80571a3:	56                   	push   %esi
 80571a4:	53                   	push   %ebx
 80571a5:	83 ec 1c             	sub    $0x1c,%esp
	if (nbr->idx != NET_NBR_LLADDR_UNKNOWN) {
 80571a8:	8b 7d 08             	mov    0x8(%ebp),%edi
{
 80571ab:	8b 5d 10             	mov    0x10(%ebp),%ebx
	if (nbr->idx != NET_NBR_LLADDR_UNKNOWN) {
 80571ae:	80 7f 01 ff          	cmpb   $0xff,0x1(%edi)
 80571b2:	0f 85 bc 00 00 00    	jne    8057274 <net_nbr_link+0xda>
 80571b8:	bf 00 85 06 08       	mov    $0x8068500,%edi
	int i, avail = -1;
 80571bd:	83 ca ff             	or     $0xffffffff,%edx
	}

	for (i = 0; i < CONFIG_NET_IPV6_MAX_NEIGHBORS; i++) {
 80571c0:	31 f6                	xor    %esi,%esi
		if (avail < 0 && !net_neighbor_lladdr[i].ref) {
 80571c2:	8a 4f 08             	mov    0x8(%edi),%cl
 80571c5:	83 fa ff             	cmp    $0xffffffff,%edx
 80571c8:	75 06                	jne    80571d0 <net_nbr_link+0x36>
 80571ca:	84 c9                	test   %cl,%cl
 80571cc:	74 44                	je     8057212 <net_nbr_link+0x78>
 80571ce:	eb 04                	jmp    80571d4 <net_nbr_link+0x3a>
			avail = i;
		}

		if (net_neighbor_lladdr[i].ref &&
 80571d0:	84 c9                	test   %cl,%cl
 80571d2:	74 40                	je     8057214 <net_nbr_link+0x7a>
		    !memcmp(lladdr->addr,
 80571d4:	50                   	push   %eax
 80571d5:	0f b6 43 04          	movzbl 0x4(%ebx),%eax
 80571d9:	89 55 e0             	mov    %edx,-0x20(%ebp)
 80571dc:	50                   	push   %eax
 80571dd:	8d 47 02             	lea    0x2(%edi),%eax
 80571e0:	50                   	push   %eax
 80571e1:	ff 33                	push   (%ebx)
 80571e3:	88 4d e7             	mov    %cl,-0x19(%ebp)
 80571e6:	e8 85 1e ff ff       	call   8049070 <memcmp@plt>
 80571eb:	83 c4 10             	add    $0x10,%esp
		if (net_neighbor_lladdr[i].ref &&
 80571ee:	8a 4d e7             	mov    -0x19(%ebp),%cl
 80571f1:	8b 55 e0             	mov    -0x20(%ebp),%edx
 80571f4:	85 c0                	test   %eax,%eax
 80571f6:	75 1c                	jne    8057214 <net_nbr_link+0x7a>
			/* We found same lladdr in nbr cache so just
			 * increase the ref count.
			 */
			net_neighbor_lladdr[i].ref++;

			nbr->idx = i;
 80571f8:	8b 7d 08             	mov    0x8(%ebp),%edi
			net_neighbor_lladdr[i].ref++;
 80571fb:	8d 14 f6             	lea    (%esi,%esi,8),%edx
			nbr->idx = i;
 80571fe:	89 f3                	mov    %esi,%ebx
			nbr->iface = iface;
 8057200:	8b 75 0c             	mov    0xc(%ebp),%esi
			net_neighbor_lladdr[i].ref++;
 8057203:	41                   	inc    %ecx
 8057204:	88 8a 08 85 06 08    	mov    %cl,0x8068508(%edx)
			nbr->idx = i;
 805720a:	88 5f 01             	mov    %bl,0x1(%edi)
			nbr->iface = iface;
 805720d:	89 77 08             	mov    %esi,0x8(%edi)

			return 0;
 8057210:	eb 62                	jmp    8057274 <net_nbr_link+0xda>
 8057212:	89 f2                	mov    %esi,%edx
	for (i = 0; i < CONFIG_NET_IPV6_MAX_NEIGHBORS; i++) {
 8057214:	46                   	inc    %esi
 8057215:	83 c7 09             	add    $0x9,%edi
 8057218:	83 fe 08             	cmp    $0x8,%esi
 805721b:	75 a5                	jne    80571c2 <net_nbr_link+0x28>
		}
	}

	if (avail < 0) {
		return -ENOENT;
 805721d:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
	if (avail < 0) {
 8057222:	83 fa ff             	cmp    $0xffffffff,%edx
 8057225:	74 4d                	je     8057274 <net_nbr_link+0xda>

	/* There was no existing entry in the lladdr cache,
	 * so allocate one for this lladdr.
	 */
	net_neighbor_lladdr[avail].ref++;
	nbr->idx = avail;
 8057227:	8b 75 08             	mov    0x8(%ebp),%esi
	net_neighbor_lladdr[avail].ref++;
 805722a:	8d 04 d2             	lea    (%edx,%edx,8),%eax
 805722d:	fe 80 08 85 06 08    	incb   0x8068508(%eax)
	nbr->idx = avail;
 8057233:	88 56 01             	mov    %dl,0x1(%esi)

	net_linkaddr_set(&net_neighbor_lladdr[avail].lladdr, lladdr->addr,
			 lladdr->len);
 8057236:	0f b6 4b 04          	movzbl 0x4(%ebx),%ecx
	net_linkaddr_set(&net_neighbor_lladdr[avail].lladdr, lladdr->addr,
 805723a:	8b 33                	mov    (%ebx),%esi
	if (new_len > NET_LINK_ADDR_MAX_LENGTH) {
 805723c:	80 f9 06             	cmp    $0x6,%cl
 805723f:	77 13                	ja     8057254 <net_nbr_link+0xba>
 8057241:	85 f6                	test   %esi,%esi
 8057243:	74 0f                	je     8057254 <net_nbr_link+0xba>
	lladdr_store->len = new_len;
 8057245:	88 88 01 85 06 08    	mov    %cl,0x8068501(%eax)
	memcpy(lladdr_store->addr, new_addr, new_len);
 805724b:	05 02 85 06 08       	add    $0x8068502,%eax
 8057250:	89 c7                	mov    %eax,%edi
 8057252:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
	net_neighbor_lladdr[avail].lladdr.len = lladdr->len;
 8057254:	8a 43 04             	mov    0x4(%ebx),%al
 8057257:	8d 14 d2             	lea    (%edx,%edx,8),%edx
 805725a:	88 82 01 85 06 08    	mov    %al,0x8068501(%edx)
	net_neighbor_lladdr[avail].lladdr.type = lladdr->type;
 8057260:	8a 43 05             	mov    0x5(%ebx),%al

	nbr->iface = iface;
 8057263:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	net_neighbor_lladdr[avail].lladdr.type = lladdr->type;
 8057266:	88 82 00 85 06 08    	mov    %al,0x8068500(%edx)
	nbr->iface = iface;
 805726c:	8b 45 08             	mov    0x8(%ebp),%eax
 805726f:	89 58 08             	mov    %ebx,0x8(%eax)

	return 0;
 8057272:	31 c0                	xor    %eax,%eax
}
 8057274:	8d 65 f4             	lea    -0xc(%ebp),%esp
 8057277:	5b                   	pop    %ebx
 8057278:	5e                   	pop    %esi
 8057279:	5f                   	pop    %edi
 805727a:	5d                   	pop    %ebp
 805727b:	c3                   	ret    

0805727c <net_nbr_unlink>:

int net_nbr_unlink(struct net_nbr *nbr, struct net_linkaddr *lladdr)
{
 805727c:	55                   	push   %ebp
 805727d:	b8 8e ff ff ff       	mov    $0xffffff8e,%eax
 8057282:	89 e5                	mov    %esp,%ebp
 8057284:	57                   	push   %edi
 8057285:	53                   	push   %ebx
 8057286:	8b 5d 08             	mov    0x8(%ebp),%ebx
	ARG_UNUSED(lladdr);

	if (nbr->idx == NET_NBR_LLADDR_UNKNOWN) {
 8057289:	8a 53 01             	mov    0x1(%ebx),%dl
 805728c:	80 fa ff             	cmp    $0xff,%dl
 805728f:	74 3a                	je     80572cb <net_nbr_unlink+0x4f>
	}

	NET_ASSERT(nbr->idx < CONFIG_NET_IPV6_MAX_NEIGHBORS);
	NET_ASSERT(net_neighbor_lladdr[nbr->idx].ref > 0);

	net_neighbor_lladdr[nbr->idx].ref--;
 8057291:	0f b6 c2             	movzbl %dl,%eax
 8057294:	8d 04 c0             	lea    (%eax,%eax,8),%eax
 8057297:	fe 88 08 85 06 08    	decb   0x8068508(%eax)

	if (!net_neighbor_lladdr[nbr->idx].ref) {
 805729d:	0f b6 53 01          	movzbl 0x1(%ebx),%edx
 80572a1:	8d 14 d2             	lea    (%edx,%edx,8),%edx
 80572a4:	80 ba 08 85 06 08 00 	cmpb   $0x0,0x8068508(%edx)
 80572ab:	75 11                	jne    80572be <net_nbr_unlink+0x42>
		(void)memset(net_neighbor_lladdr[nbr->idx].lladdr.addr, 0,
 80572ad:	81 c2 02 85 06 08    	add    $0x8068502,%edx
  return __builtin___memset_chk (__dest, __ch, __len,
 80572b3:	b9 06 00 00 00       	mov    $0x6,%ecx
 80572b8:	31 c0                	xor    %eax,%eax
 80572ba:	89 d7                	mov    %edx,%edi
 80572bc:	f3 aa                	rep stos %al,%es:(%edi)
			     sizeof(net_neighbor_lladdr[nbr->idx].lladdr.addr));
	}

	nbr->idx = NET_NBR_LLADDR_UNKNOWN;
 80572be:	c6 43 01 ff          	movb   $0xff,0x1(%ebx)
	nbr->iface = NULL;

	return 0;
 80572c2:	31 c0                	xor    %eax,%eax
	nbr->iface = NULL;
 80572c4:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
}
 80572cb:	5b                   	pop    %ebx
 80572cc:	5f                   	pop    %edi
 80572cd:	5d                   	pop    %ebp
 80572ce:	c3                   	ret    

080572cf <net_nbr_get_lladdr>:

	return NULL;
}

struct net_linkaddr_storage *net_nbr_get_lladdr(uint8_t idx)
{
 80572cf:	55                   	push   %ebp
 80572d0:	89 e5                	mov    %esp,%ebp
	NET_ASSERT(idx < CONFIG_NET_IPV6_MAX_NEIGHBORS,
		   "idx %d >= max %d", idx,
		   CONFIG_NET_IPV6_MAX_NEIGHBORS);

	return &net_neighbor_lladdr[idx].lladdr;
 80572d2:	0f b6 45 08          	movzbl 0x8(%ebp),%eax
}
 80572d6:	5d                   	pop    %ebp
	return &net_neighbor_lladdr[idx].lladdr;
 80572d7:	8d 04 c0             	lea    (%eax,%eax,8),%eax
 80572da:	05 00 85 06 08       	add    $0x8068500,%eax
}
 80572df:	c3                   	ret    

080572e0 <net_ipv6_is_addr_loopback>:
{
 80572e0:	89 c2                	mov    %eax,%edx
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
 80572e2:	31 c0                	xor    %eax,%eax
 80572e4:	83 3a 00             	cmpl   $0x0,(%edx)
 80572e7:	75 18                	jne    8057301 <net_ipv6_is_addr_loopback+0x21>
	return UNALIGNED_GET(&addr->s6_addr32[0]) == 0 &&
 80572e9:	83 7a 04 00          	cmpl   $0x0,0x4(%edx)
 80572ed:	75 12                	jne    8057301 <net_ipv6_is_addr_loopback+0x21>
		UNALIGNED_GET(&addr->s6_addr32[1]) == 0 &&
 80572ef:	83 7a 08 00          	cmpl   $0x0,0x8(%edx)
 80572f3:	75 0c                	jne    8057301 <net_ipv6_is_addr_loopback+0x21>
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
 80572f5:	31 c0                	xor    %eax,%eax
 80572f7:	81 7a 0c 00 00 00 01 	cmpl   $0x1000000,0xc(%edx)
 80572fe:	0f 94 c0             	sete   %al
 8057301:	83 e0 01             	and    $0x1,%eax
}
 8057304:	c3                   	ret    

08057305 <net_ipv6_is_addr_mcast_group>:
{
 8057305:	89 c1                	mov    %eax,%ecx
		UNALIGNED_GET(&addr->s6_addr32[2]) == group->s6_addr32[1] &&
 8057307:	66 8b 40 02          	mov    0x2(%eax),%ax
 805730b:	66 39 42 02          	cmp    %ax,0x2(%edx)
 805730f:	75 35                	jne    8057346 <net_ipv6_is_addr_mcast_group+0x41>
{
 8057311:	55                   	push   %ebp
		UNALIGNED_GET(&addr->s6_addr32[2]) == group->s6_addr32[1] &&
 8057312:	31 c0                	xor    %eax,%eax
{
 8057314:	89 e5                	mov    %esp,%ebp
 8057316:	53                   	push   %ebx
	return UNALIGNED_GET(&addr->s6_addr16[1]) == group->s6_addr16[1] &&
 8057317:	66 8b 59 04          	mov    0x4(%ecx),%bx
 805731b:	66 39 5a 04          	cmp    %bx,0x4(%edx)
 805731f:	75 2b                	jne    805734c <net_ipv6_is_addr_mcast_group+0x47>
		UNALIGNED_GET(&addr->s6_addr16[2]) == group->s6_addr16[2] &&
 8057321:	66 8b 59 06          	mov    0x6(%ecx),%bx
 8057325:	66 39 5a 06          	cmp    %bx,0x6(%edx)
 8057329:	75 21                	jne    805734c <net_ipv6_is_addr_mcast_group+0x47>
		UNALIGNED_GET(&addr->s6_addr32[1]) == group->s6_addr32[1] &&
 805732b:	8b 5a 04             	mov    0x4(%edx),%ebx
		UNALIGNED_GET(&addr->s6_addr16[3]) == group->s6_addr16[3] &&
 805732e:	3b 59 04             	cmp    0x4(%ecx),%ebx
 8057331:	75 19                	jne    805734c <net_ipv6_is_addr_mcast_group+0x47>
		UNALIGNED_GET(&addr->s6_addr32[1]) == group->s6_addr32[1] &&
 8057333:	3b 59 08             	cmp    0x8(%ecx),%ebx
 8057336:	75 14                	jne    805734c <net_ipv6_is_addr_mcast_group+0x47>
		UNALIGNED_GET(&addr->s6_addr32[2]) == group->s6_addr32[1] &&
 8057338:	8b 41 0c             	mov    0xc(%ecx),%eax
 805733b:	39 42 0c             	cmp    %eax,0xc(%edx)
 805733e:	0f 94 c0             	sete   %al
 8057341:	0f b6 c0             	movzbl %al,%eax
 8057344:	eb 06                	jmp    805734c <net_ipv6_is_addr_mcast_group+0x47>
 8057346:	31 c0                	xor    %eax,%eax
 8057348:	83 e0 01             	and    $0x1,%eax
}
 805734b:	c3                   	ret    
		UNALIGNED_GET(&addr->s6_addr32[2]) == group->s6_addr32[1] &&
 805734c:	83 e0 01             	and    $0x1,%eax
}
 805734f:	5b                   	pop    %ebx
 8057350:	5d                   	pop    %ebp
 8057351:	c3                   	ret    

08057352 <net_ipv6_create>:
#define MAX_REACHABLE_TIME 3600000

int net_ipv6_create(struct net_pkt *pkt,
		    const struct in6_addr *src,
		    const struct in6_addr *dst)
{
 8057352:	55                   	push   %ebp
 8057353:	89 e5                	mov    %esp,%ebp
 8057355:	57                   	push   %edi
 8057356:	56                   	push   %esi
 8057357:	53                   	push   %ebx
 8057358:	83 ec 34             	sub    $0x34,%esp
 805735b:	8b 45 0c             	mov    0xc(%ebp),%eax
 805735e:	8b 55 08             	mov    0x8(%ebp),%edx
 8057361:	8b 75 10             	mov    0x10(%ebp),%esi
 8057364:	89 45 d4             	mov    %eax,-0x2c(%ebp)
 8057367:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 805736d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 8057370:	31 c0                	xor    %eax,%eax
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv6_access, struct net_ipv6_hdr);
	struct net_ipv6_hdr *ipv6_hdr;
	uint8_t tc = 0;

	ipv6_hdr = (struct net_ipv6_hdr *)net_pkt_get_data(pkt, &ipv6_access);
 8057372:	8d 45 dc             	lea    -0x24(%ebp),%eax
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv6_access, struct net_ipv6_hdr);
 8057375:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	ipv6_hdr = (struct net_ipv6_hdr *)net_pkt_get_data(pkt, &ipv6_access);
 805737c:	50                   	push   %eax
 805737d:	52                   	push   %edx
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv6_access, struct net_ipv6_hdr);
 805737e:	c7 45 e0 28 00 00 00 	movl   $0x28,-0x20(%ebp)
	ipv6_hdr = (struct net_ipv6_hdr *)net_pkt_get_data(pkt, &ipv6_access);
 8057385:	89 55 d0             	mov    %edx,-0x30(%ebp)
 8057388:	e8 45 e5 ff ff       	call   80558d2 <net_pkt_get_data>
 805738d:	83 c4 10             	add    $0x10,%esp
 8057390:	89 c3                	mov    %eax,%ebx
	if (!ipv6_hdr) {
 8057392:	b8 97 ff ff ff       	mov    $0xffffff97,%eax
 8057397:	85 db                	test   %ebx,%ebx
 8057399:	74 79                	je     8057414 <net_ipv6_create+0xc2>
 * @param ecn ECN value to set.
 */
static inline void net_ipv6_set_ecn(uint8_t *tc, uint8_t ecn)
{
	*tc &= ~NET_IPV6_ECN_MASK;
	*tc |= ecn & NET_IPV6_ECN_MASK;
 805739b:	8b 55 d0             	mov    -0x30(%ebp),%edx
 805739e:	8a 42 3c             	mov    0x3c(%edx),%al
		net_ipv6_set_ecn(&tc, net_pkt_ip_ecn(pkt));
	}

	ipv6_hdr->vtc     = 0x60 | ((tc >> 4) & 0x0F);
	ipv6_hdr->tcflow  = (tc << 4) & 0xF0;
	ipv6_hdr->flow    = 0U;
 80573a1:	c7 43 02 00 00 00 00 	movl   $0x0,0x2(%ebx)
	ipv6_hdr->len     = 0U;
	ipv6_hdr->nexthdr = 0U;
 80573a8:	c6 43 06 00          	movb   $0x0,0x6(%ebx)
 80573ac:	c0 c0 02             	rol    $0x2,%al
	ipv6_hdr->vtc     = 0x60 | ((tc >> 4) & 0x0F);
 80573af:	89 c1                	mov    %eax,%ecx
	ipv6_hdr->tcflow  = (tc << 4) & 0xF0;
 80573b1:	0f b6 c0             	movzbl %al,%eax
	ipv6_hdr->vtc     = 0x60 | ((tc >> 4) & 0x0F);
 80573b4:	c0 e9 04             	shr    $0x4,%cl
	ipv6_hdr->tcflow  = (tc << 4) & 0xF0;
 80573b7:	c1 e0 04             	shl    $0x4,%eax
	ipv6_hdr->vtc     = 0x60 | ((tc >> 4) & 0x0F);
 80573ba:	83 c9 60             	or     $0x60,%ecx
	ipv6_hdr->tcflow  = (tc << 4) & 0xF0;
 80573bd:	88 43 01             	mov    %al,0x1(%ebx)
	ipv6_hdr->vtc     = 0x60 | ((tc >> 4) & 0x0F);
 80573c0:	88 0b                	mov    %cl,(%ebx)
	return pkt->ipv6_hop_limit;
 80573c2:	8a 42 35             	mov    0x35(%edx),%al

	/* User can tweak the default hop limit if needed */
	ipv6_hdr->hop_limit = net_pkt_ipv6_hop_limit(pkt);
 80573c5:	88 43 07             	mov    %al,0x7(%ebx)
	if (ipv6_hdr->hop_limit == 0U) {
 80573c8:	84 c0                	test   %al,%al
 80573ca:	75 14                	jne    80573e0 <net_ipv6_create+0x8e>
		ipv6_hdr->hop_limit =
			net_if_ipv6_get_hop_limit(net_pkt_iface(pkt));
 80573cc:	83 ec 0c             	sub    $0xc,%esp
 80573cf:	ff 72 18             	push   0x18(%edx)
 80573d2:	e8 ba ae ff ff       	call   8052291 <net_if_ipv6_get_hop_limit>
		ipv6_hdr->hop_limit =
 80573d7:	8b 55 d0             	mov    -0x30(%ebp),%edx
			net_if_ipv6_get_hop_limit(net_pkt_iface(pkt));
 80573da:	83 c4 10             	add    $0x10,%esp
		ipv6_hdr->hop_limit =
 80573dd:	88 43 07             	mov    %al,0x7(%ebx)
  return __builtin___memcpy_chk (__dest, __src, __len,
 80573e0:	8d 43 18             	lea    0x18(%ebx),%eax
 80573e3:	b9 04 00 00 00       	mov    $0x4,%ecx
 80573e8:	83 c3 08             	add    $0x8,%ebx
 80573eb:	89 c7                	mov    %eax,%edi
 80573ed:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
 80573ef:	8b 75 d4             	mov    -0x2c(%ebp),%esi
 80573f2:	b9 04 00 00 00       	mov    $0x4,%ecx
 80573f7:	89 df                	mov    %ebx,%edi
 80573f9:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	pkt->ip_hdr_len = len;
 80573fb:	c6 42 32 28          	movb   $0x28,0x32(%edx)
	pkt->ipv6_ext_len = len;
 80573ff:	66 c7 42 36 00 00    	movw   $0x0,0x36(%edx)
	net_ipv6_addr_copy_raw(ipv6_hdr->src, (uint8_t *)src);

	net_pkt_set_ip_hdr_len(pkt, sizeof(struct net_ipv6_hdr));
	net_pkt_set_ipv6_ext_len(pkt, 0);

	return net_pkt_set_data(pkt, &ipv6_access);
 8057405:	50                   	push   %eax
 8057406:	50                   	push   %eax
 8057407:	8d 45 dc             	lea    -0x24(%ebp),%eax
 805740a:	50                   	push   %eax
 805740b:	52                   	push   %edx
 805740c:	e8 25 e5 ff ff       	call   8055936 <net_pkt_set_data>
 8057411:	83 c4 10             	add    $0x10,%esp
}
 8057414:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 8057417:	65 2b 15 14 00 00 00 	sub    %gs:0x14,%edx
 805741e:	74 05                	je     8057425 <net_ipv6_create+0xd3>
 8057420:	e8 db 1e ff ff       	call   8049300 <__stack_chk_fail@plt>
 8057425:	8d 65 f4             	lea    -0xc(%ebp),%esp
 8057428:	5b                   	pop    %ebx
 8057429:	5e                   	pop    %esi
 805742a:	5f                   	pop    %edi
 805742b:	5d                   	pop    %ebp
 805742c:	c3                   	ret    

0805742d <net_ipv6_finalize>:

int net_ipv6_finalize(struct net_pkt *pkt, uint8_t next_header_proto)
{
 805742d:	55                   	push   %ebp
 805742e:	89 e5                	mov    %esp,%ebp
 8057430:	57                   	push   %edi
 8057431:	56                   	push   %esi
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv6_access, struct net_ipv6_hdr);
	struct net_ipv6_hdr *ipv6_hdr;

	net_pkt_set_overwrite(pkt, true);

	ipv6_hdr = (struct net_ipv6_hdr *)net_pkt_get_data(pkt, &ipv6_access);
 8057432:	8d 75 dc             	lea    -0x24(%ebp),%esi
{
 8057435:	53                   	push   %ebx
 8057436:	83 ec 34             	sub    $0x34,%esp
 8057439:	8b 45 0c             	mov    0xc(%ebp),%eax
 805743c:	8b 5d 08             	mov    0x8(%ebp),%ebx
 805743f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
 8057442:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 8057448:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 805744b:	31 c0                	xor    %eax,%eax
	pkt->overwrite = overwrite;
 805744d:	80 4b 33 01          	orb    $0x1,0x33(%ebx)
	ipv6_hdr = (struct net_ipv6_hdr *)net_pkt_get_data(pkt, &ipv6_access);
 8057451:	56                   	push   %esi
 8057452:	53                   	push   %ebx
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv6_access, struct net_ipv6_hdr);
 8057453:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
 805745a:	c7 45 e0 28 00 00 00 	movl   $0x28,-0x20(%ebp)
	ipv6_hdr = (struct net_ipv6_hdr *)net_pkt_get_data(pkt, &ipv6_access);
 8057461:	e8 6c e4 ff ff       	call   80558d2 <net_pkt_get_data>
 8057466:	83 c4 10             	add    $0x10,%esp
	if (!ipv6_hdr) {
 8057469:	85 c0                	test   %eax,%eax
 805746b:	75 0a                	jne    8057477 <net_ipv6_finalize+0x4a>
		return -ENOBUFS;
 805746d:	b8 97 ff ff ff       	mov    $0xffffff97,%eax
 8057472:	e9 84 00 00 00       	jmp    80574fb <net_ipv6_finalize+0xce>
 8057477:	8b 4b 08             	mov    0x8(%ebx),%ecx
 805747a:	89 c2                	mov    %eax,%edx
	size_t bytes = 0;
 805747c:	31 c0                	xor    %eax,%eax
	while (buf) {
 805747e:	85 c9                	test   %ecx,%ecx
 8057480:	74 0b                	je     805748d <net_ipv6_finalize+0x60>
		bytes += buf->len;
 8057482:	0f b7 79 10          	movzwl 0x10(%ecx),%edi
		buf = buf->frags;
 8057486:	8b 49 04             	mov    0x4(%ecx),%ecx
		bytes += buf->len;
 8057489:	01 f8                	add    %edi,%eax
		buf = buf->frags;
 805748b:	eb f1                	jmp    805747e <net_ipv6_finalize+0x51>
	}

	ipv6_hdr->len = htons(net_pkt_get_len(pkt) -
 805748d:	8d 48 d8             	lea    -0x28(%eax),%ecx
 8057490:	83 e8 28             	sub    $0x28,%eax
 8057493:	8b 7d d4             	mov    -0x2c(%ebp),%edi
 8057496:	c1 e0 08             	shl    $0x8,%eax
 8057499:	66 c1 e9 08          	shr    $0x8,%cx
 805749d:	09 c1                	or     %eax,%ecx
 805749f:	66 89 4a 04          	mov    %cx,0x4(%edx)
	return pkt->ipv6_next_hdr;
 80574a3:	8a 43 3b             	mov    0x3b(%ebx),%al
 80574a6:	3c ff                	cmp    $0xff,%al
 80574a8:	0f 44 c7             	cmove  %edi,%eax
 80574ab:	88 42 06             	mov    %al,0x6(%edx)
		ipv6_hdr->nexthdr = net_pkt_ipv6_next_hdr(pkt);
	} else {
		ipv6_hdr->nexthdr = next_header_proto;
	}

	net_pkt_set_data(pkt, &ipv6_access);
 80574ae:	52                   	push   %edx
 80574af:	52                   	push   %edx
 80574b0:	56                   	push   %esi
 80574b1:	53                   	push   %ebx
 80574b2:	e8 7f e4 ff ff       	call   8055936 <net_pkt_set_data>
 80574b7:	83 c4 10             	add    $0x10,%esp

	if (net_pkt_ipv6_next_hdr(pkt) != 255U &&
 80574ba:	80 7b 3b ff          	cmpb   $0xff,0x3b(%ebx)
 80574be:	75 11                	jne    80574d1 <net_ipv6_finalize+0xa4>
	    net_pkt_skip(pkt, net_pkt_ipv6_ext_len(pkt))) {
		return -ENOBUFS;
	}

	if (IS_ENABLED(CONFIG_NET_UDP) &&
 80574c0:	80 7d d4 11          	cmpb   $0x11,-0x2c(%ebp)
 80574c4:	75 21                	jne    80574e7 <net_ipv6_finalize+0xba>
	    next_header_proto == IPPROTO_UDP) {
		return net_udp_finalize(pkt);
 80574c6:	83 ec 0c             	sub    $0xc,%esp
 80574c9:	53                   	push   %ebx
 80574ca:	e8 16 32 00 00       	call   805a6e5 <net_udp_finalize>
 80574cf:	eb 27                	jmp    80574f8 <net_ipv6_finalize+0xcb>
	    net_pkt_skip(pkt, net_pkt_ipv6_ext_len(pkt))) {
 80574d1:	50                   	push   %eax
 80574d2:	50                   	push   %eax
 80574d3:	0f b7 43 36          	movzwl 0x36(%ebx),%eax
 80574d7:	50                   	push   %eax
 80574d8:	53                   	push   %ebx
 80574d9:	e8 93 de ff ff       	call   8055371 <net_pkt_skip>
 80574de:	83 c4 10             	add    $0x10,%esp
	if (net_pkt_ipv6_next_hdr(pkt) != 255U &&
 80574e1:	85 c0                	test   %eax,%eax
 80574e3:	74 db                	je     80574c0 <net_ipv6_finalize+0x93>
 80574e5:	eb 86                	jmp    805746d <net_ipv6_finalize+0x40>
		return net_tcp_finalize(pkt);
	} else if (next_header_proto == IPPROTO_ICMPV6) {
		return net_icmpv6_finalize(pkt);
	}

	return 0;
 80574e7:	31 c0                	xor    %eax,%eax
	} else if (next_header_proto == IPPROTO_ICMPV6) {
 80574e9:	80 7d d4 3a          	cmpb   $0x3a,-0x2c(%ebp)
 80574ed:	75 0c                	jne    80574fb <net_ipv6_finalize+0xce>
		return net_icmpv6_finalize(pkt);
 80574ef:	83 ec 0c             	sub    $0xc,%esp
 80574f2:	53                   	push   %ebx
 80574f3:	e8 df f6 ff ff       	call   8056bd7 <net_icmpv6_finalize>
 80574f8:	83 c4 10             	add    $0x10,%esp
}
 80574fb:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 80574fe:	65 2b 15 14 00 00 00 	sub    %gs:0x14,%edx
 8057505:	74 05                	je     805750c <net_ipv6_finalize+0xdf>
 8057507:	e8 f4 1d ff ff       	call   8049300 <__stack_chk_fail@plt>
 805750c:	8d 65 f4             	lea    -0xc(%ebp),%esp
 805750f:	5b                   	pop    %ebx
 8057510:	5e                   	pop    %esi
 8057511:	5f                   	pop    %edi
 8057512:	5d                   	pop    %ebp
 8057513:	c3                   	ret    

08057514 <net_ipv6_input>:
		return 0;
	}
}

enum net_verdict net_ipv6_input(struct net_pkt *pkt, bool is_loopback)
{
 8057514:	55                   	push   %ebp
 8057515:	89 e5                	mov    %esp,%ebp
 8057517:	57                   	push   %edi
 8057518:	56                   	push   %esi
	size_t bytes = 0;
 8057519:	31 f6                	xor    %esi,%esi
 805751b:	53                   	push   %ebx
 805751c:	83 ec 5c             	sub    $0x5c,%esp
 805751f:	8b 45 0c             	mov    0xc(%ebp),%eax
 8057522:	8b 5d 08             	mov    0x8(%ebp),%ebx
 8057525:	89 45 b4             	mov    %eax,-0x4c(%ebp)
 8057528:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 805752e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 8057531:	31 c0                	xor    %eax,%eax
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv6_access, struct net_ipv6_hdr);
	NET_PKT_DATA_ACCESS_DEFINE(udp_access, struct net_udp_hdr);
 8057533:	8d 45 dc             	lea    -0x24(%ebp),%eax
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv6_access, struct net_ipv6_hdr);
 8057536:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
	NET_PKT_DATA_ACCESS_DEFINE(udp_access, struct net_udp_hdr);
 805753d:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	NET_PKT_DATA_ACCESS_DEFINE(tcp_access, struct net_tcp_hdr);
	struct net_if *pkt_iface = net_pkt_iface(pkt);
 8057540:	8b 43 18             	mov    0x18(%ebx),%eax
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv6_access, struct net_ipv6_hdr);
 8057543:	c7 45 d0 28 00 00 00 	movl   $0x28,-0x30(%ebp)
	NET_PKT_DATA_ACCESS_DEFINE(udp_access, struct net_udp_hdr);
 805754a:	c7 45 d8 08 00 00 00 	movl   $0x8,-0x28(%ebp)
	struct net_if *pkt_iface = net_pkt_iface(pkt);
 8057551:	89 45 bc             	mov    %eax,-0x44(%ebp)
	enum net_verdict verdict = NET_DROP;
	int real_len = net_pkt_get_len(pkt);
 8057554:	8b 43 08             	mov    0x8(%ebx),%eax
	while (buf) {
 8057557:	85 c0                	test   %eax,%eax
 8057559:	74 0b                	je     8057566 <net_ipv6_input+0x52>
		bytes += buf->len;
 805755b:	0f b7 50 10          	movzwl 0x10(%eax),%edx
		buf = buf->frags;
 805755f:	8b 40 04             	mov    0x4(%eax),%eax
		bytes += buf->len;
 8057562:	01 d6                	add    %edx,%esi
		buf = buf->frags;
 8057564:	eb f1                	jmp    8057557 <net_ipv6_input+0x43>
	net_pkt_cursor_backup(pkt, &hdr_start);
#endif

	net_stats_update_ipv6_recv(pkt_iface);

	hdr = (struct net_ipv6_hdr *)net_pkt_get_data(pkt, &ipv6_access);
 8057566:	8d 45 cc             	lea    -0x34(%ebp),%eax
 8057569:	57                   	push   %edi
 805756a:	57                   	push   %edi
 805756b:	50                   	push   %eax
 805756c:	53                   	push   %ebx
 805756d:	e8 60 e3 ff ff       	call   80558d2 <net_pkt_get_data>
 8057572:	83 c4 10             	add    $0x10,%esp
 8057575:	89 c7                	mov    %eax,%edi
	if (!hdr) {
 8057577:	85 c0                	test   %eax,%eax
 8057579:	0f 84 b4 04 00 00    	je     8057a33 <net_ipv6_input+0x51f>
		NET_DBG("DROP: no buffer");
		goto drop;
	}

	pkt_len = ntohs(hdr->len) + sizeof(struct net_ipv6_hdr);
 805757f:	66 8b 40 04          	mov    0x4(%eax),%ax
 8057583:	86 e0                	xchg   %ah,%al
 8057585:	66 89 45 ac          	mov    %ax,-0x54(%ebp)
 8057589:	0f b7 c0             	movzwl %ax,%eax
 805758c:	83 c0 28             	add    $0x28,%eax
	if (real_len < pkt_len) {
 805758f:	39 f0                	cmp    %esi,%eax
 8057591:	0f 8f 9c 04 00 00    	jg     8057a33 <net_ipv6_input+0x51f>
		NET_DBG("DROP: pkt len per hdr %d != pkt real len %d",
			pkt_len, real_len);
		goto drop;
	} else if (real_len > pkt_len) {
 8057597:	7d 0c                	jge    80575a5 <net_ipv6_input+0x91>
		net_pkt_update_length(pkt, pkt_len);
 8057599:	56                   	push   %esi
 805759a:	56                   	push   %esi
 805759b:	50                   	push   %eax
 805759c:	53                   	push   %ebx
 805759d:	e8 16 e1 ff ff       	call   80556b8 <net_pkt_update_length>
 80575a2:	83 c4 10             	add    $0x10,%esp
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
 80575a5:	83 7f 08 00          	cmpl   $0x0,0x8(%edi)
 80575a9:	75 16                	jne    80575c1 <net_ipv6_input+0xad>
	return UNALIGNED_GET(&addr->s6_addr32[0]) == 0 &&
 80575ab:	83 7f 0c 00          	cmpl   $0x0,0xc(%edi)
 80575af:	75 10                	jne    80575c1 <net_ipv6_input+0xad>
		UNALIGNED_GET(&addr->s6_addr32[1]) == 0 &&
 80575b1:	83 7f 10 00          	cmpl   $0x0,0x10(%edi)
 80575b5:	75 0a                	jne    80575c1 <net_ipv6_input+0xad>
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
 80575b7:	83 7f 14 00          	cmpl   $0x0,0x14(%edi)
 80575bb:	0f 84 72 04 00 00    	je     8057a33 <net_ipv6_input+0x51f>
	if (net_ipv6_is_addr_unspecified((struct in6_addr *)hdr->src)) {
		NET_DBG("DROP: src addr is %s", "unspecified");
		goto drop;
	}

	if (net_ipv6_is_addr_mcast((struct in6_addr *)hdr->src) ||
 80575c1:	80 7f 08 ff          	cmpb   $0xff,0x8(%edi)
 80575c5:	0f 84 68 04 00 00    	je     8057a33 <net_ipv6_input+0x51f>
	return (addr->s6_addr[0] == 0xff) && (addr->s6_addr[1] == scope);
 80575cb:	8a 4f 18             	mov    0x18(%edi),%cl
	    net_ipv6_is_addr_mcast_scope((struct in6_addr *)hdr->dst, 0)) {
 80575ce:	8d 77 18             	lea    0x18(%edi),%esi
 80575d1:	80 f9 ff             	cmp    $0xff,%cl
 80575d4:	75 0a                	jne    80575e0 <net_ipv6_input+0xcc>
 80575d6:	80 7f 19 00          	cmpb   $0x0,0x19(%edi)
 80575da:	0f 84 53 04 00 00    	je     8057a33 <net_ipv6_input+0x51f>
		NET_DBG("DROP: multicast packet");
		goto drop;
	}

	if (!is_loopback) {
 80575e0:	80 7d b4 00          	cmpb   $0x0,-0x4c(%ebp)
 80575e4:	75 58                	jne    805763e <net_ipv6_input+0x12a>
		if (net_ipv6_is_addr_loopback((struct in6_addr *)hdr->dst) ||
 80575e6:	89 f0                	mov    %esi,%eax
 80575e8:	e8 f3 fc ff ff       	call   80572e0 <net_ipv6_is_addr_loopback>
 80575ed:	84 c0                	test   %al,%al
 80575ef:	0f 85 3e 04 00 00    	jne    8057a33 <net_ipv6_input+0x51f>
	if (net_ipv6_is_addr_unspecified((struct in6_addr *)hdr->src)) {
 80575f5:	8d 47 08             	lea    0x8(%edi),%eax
		    net_ipv6_is_addr_loopback((struct in6_addr *)hdr->src)) {
 80575f8:	e8 e3 fc ff ff       	call   80572e0 <net_ipv6_is_addr_loopback>
		if (net_ipv6_is_addr_loopback((struct in6_addr *)hdr->dst) ||
 80575fd:	84 c0                	test   %al,%al
 80575ff:	0f 85 2e 04 00 00    	jne    8057a33 <net_ipv6_input+0x51f>
 8057605:	fe c1                	inc    %cl
 8057607:	75 0a                	jne    8057613 <net_ipv6_input+0xff>
 8057609:	80 7f 19 01          	cmpb   $0x1,0x19(%edi)
 805760d:	0f 84 20 04 00 00    	je     8057a33 <net_ipv6_input+0x51f>
			NET_DBG("DROP: ::1 packet");
			goto drop;
		}

		if (net_ipv6_is_addr_mcast_iface((struct in6_addr *)hdr->dst) ||
		    (net_ipv6_is_addr_mcast_group(
 8057613:	e8 62 c1 ff ff       	call   805377a <net_ipv6_unspecified_address>
 8057618:	89 c2                	mov    %eax,%edx
 805761a:	89 f0                	mov    %esi,%eax
 805761c:	e8 e4 fc ff ff       	call   8057305 <net_ipv6_is_addr_mcast_group>
		if (net_ipv6_is_addr_mcast_iface((struct in6_addr *)hdr->dst) ||
 8057621:	84 c0                	test   %al,%al
 8057623:	74 19                	je     805763e <net_ipv6_input+0x12a>
 8057625:	80 7f 18 ff          	cmpb   $0xff,0x18(%edi)
 8057629:	75 13                	jne    805763e <net_ipv6_input+0x12a>
 805762b:	8a 47 19             	mov    0x19(%edi),%al
 805762e:	3c 05                	cmp    $0x5,%al
 8057630:	0f 84 fd 03 00 00    	je     8057a33 <net_ipv6_input+0x51f>
 8057636:	3c 08                	cmp    $0x8,%al
 8057638:	0f 84 f5 03 00 00    	je     8057a33 <net_ipv6_input+0x51f>
	}

	/* Reconstruct TC field. */

	if (IS_ENABLED(CONFIG_NET_IP_DSCP_ECN)) {
		uint8_t tc = ((hdr->vtc << 4) & 0xF0) | ((hdr->tcflow >> 4) & 0x0F);
 805763e:	0f b6 17             	movzbl (%edi),%edx
 8057641:	8a 47 01             	mov    0x1(%edi),%al
 8057644:	c1 e2 04             	shl    $0x4,%edx
 8057647:	c0 e8 04             	shr    $0x4,%al
 805764a:	09 c2                	or     %eax,%edx
	pkt->ip_dscp = dscp;
 805764c:	c1 e0 06             	shl    $0x6,%eax
	return (tc & NET_IPV6_DSCP_MASK) >> NET_IPV6_DSCP_OFFSET;
 805764f:	c0 ea 02             	shr    $0x2,%dl
 8057652:	09 d0                	or     %edx,%eax
 8057654:	88 43 3c             	mov    %al,0x3c(%ebx)
		net_pkt_set_ip_dscp(pkt, net_ipv6_get_dscp(tc));
		net_pkt_set_ip_ecn(pkt, net_ipv6_get_ecn(tc));
	}

	/* Check extension headers */
	net_pkt_set_ipv6_next_hdr(pkt, hdr->nexthdr);
 8057657:	8a 47 06             	mov    0x6(%edi),%al
	pkt->ipv6_ext_len = len;
 805765a:	66 c7 43 36 00 00    	movw   $0x0,0x36(%ebx)
	pkt->ipv6_next_hdr = next_hdr;
 8057660:	88 43 3b             	mov    %al,0x3b(%ebx)
	return pkt->frags->data;
 8057663:	8b 43 08             	mov    0x8(%ebx),%eax
	pkt->ip_hdr_len = len;
 8057666:	c6 43 32 28          	movb   $0x28,0x32(%ebx)
	net_pkt_set_ipv6_ext_len(pkt, 0);
	net_pkt_set_ip_hdr_len(pkt, sizeof(struct net_ipv6_hdr));
	net_pkt_set_ipv6_hop_limit(pkt, NET_IPV6_HDR(pkt)->hop_limit);
 805766a:	8b 40 0c             	mov    0xc(%eax),%eax
 805766d:	8a 40 07             	mov    0x7(%eax),%al
	pkt->ipv6_hop_limit = hop_limit;
 8057670:	88 43 35             	mov    %al,0x35(%ebx)
	pkt->family = family;
 8057673:	8a 43 33             	mov    0x33(%ebx),%al
 8057676:	83 e0 1f             	and    $0x1f,%eax
 8057679:	83 c8 40             	or     $0x40,%eax
 805767c:	88 43 33             	mov    %al,0x33(%ebx)
		if (ipv6_forward_mcast_packet(pkt, hdr) == NET_DROP) {
			goto drop;
		}
	}

	if (!net_ipv6_is_addr_mcast((struct in6_addr *)hdr->dst)) {
 805767f:	80 7f 18 ff          	cmpb   $0xff,0x18(%edi)
 8057683:	75 10                	jne    8057695 <net_ipv6_input+0x181>
 8057685:	8a 47 19             	mov    0x19(%edi),%al
					   (struct in6_addr *)hdr->dst);
			goto drop;
		}
	}

	if (net_ipv6_is_addr_mcast((struct in6_addr *)hdr->dst) &&
 8057688:	3c 01                	cmp    $0x1,%al
 805768a:	0f 84 b0 00 00 00    	je     8057740 <net_ipv6_input+0x22c>
 8057690:	e9 e7 00 00 00       	jmp    805777c <net_ipv6_input+0x268>
	return net_if_ipv6_addr_lookup(addr, NULL) != NULL;
 8057695:	51                   	push   %ecx
 8057696:	51                   	push   %ecx
 8057697:	6a 00                	push   $0x0
 8057699:	56                   	push   %esi
 805769a:	e8 80 9c ff ff       	call   805131f <net_if_ipv6_addr_lookup>
 805769f:	83 c4 10             	add    $0x10,%esp
		if (!net_ipv6_is_my_addr((struct in6_addr *)hdr->dst)) {
 80576a2:	85 c0                	test   %eax,%eax
 80576a4:	0f 85 8c 00 00 00    	jne    8057736 <net_ipv6_input+0x222>
		found = net_route_get_info(net_pkt_iface(pkt),
 80576aa:	8d 45 c4             	lea    -0x3c(%ebp),%eax
 80576ad:	50                   	push   %eax
 80576ae:	8d 45 c0             	lea    -0x40(%ebp),%eax
 80576b1:	50                   	push   %eax
 80576b2:	56                   	push   %esi
 80576b3:	ff 73 18             	push   0x18(%ebx)
 80576b6:	e8 c8 2d 00 00       	call   805a483 <net_route_get_info>
 80576bb:	83 c4 10             	add    $0x10,%esp
	if (found) {
 80576be:	84 c0                	test   %al,%al
 80576c0:	74 39                	je     80576fb <net_ipv6_input+0x1e7>
		if (route) {
 80576c2:	8b 45 c0             	mov    -0x40(%ebp),%eax
 80576c5:	85 c0                	test   %eax,%eax
 80576c7:	74 1a                	je     80576e3 <net_ipv6_input+0x1cf>
			net_pkt_set_iface(pkt, route->iface);
 80576c9:	8b 40 0c             	mov    0xc(%eax),%eax
	pkt->iface = iface;
 80576cc:	89 43 18             	mov    %eax,0x18(%ebx)
	if (iface) {
 80576cf:	85 c0                	test   %eax,%eax
 80576d1:	74 10                	je     80576e3 <net_ipv6_input+0x1cf>
		pkt->lladdr_src.type = net_if_get_link_addr(iface)->type;
 80576d3:	8b 10                	mov    (%eax),%edx
 80576d5:	8a 52 15             	mov    0x15(%edx),%dl
 80576d8:	88 53 25             	mov    %dl,0x25(%ebx)
		pkt->lladdr_dst.type = net_if_get_link_addr(iface)->type;
 80576db:	8b 00                	mov    (%eax),%eax
 80576dd:	8a 40 15             	mov    0x15(%eax),%al
 80576e0:	88 43 2d             	mov    %al,0x2d(%ebx)
		ret = net_route_packet(pkt, nexthop);
 80576e3:	52                   	push   %edx
 80576e4:	52                   	push   %edx
 80576e5:	ff 75 c4             	push   -0x3c(%ebp)
 80576e8:	53                   	push   %ebx
 80576e9:	e8 21 2e 00 00       	call   805a50f <net_route_packet>
 80576ee:	83 c4 10             	add    $0x10,%esp
		return verdict;
	}

drop:
	net_stats_update_ipv6_drop(pkt_iface);
	return NET_DROP;
 80576f1:	c1 e8 1f             	shr    $0x1f,%eax
 80576f4:	01 c0                	add    %eax,%eax
 80576f6:	e9 55 03 00 00       	jmp    8057a50 <net_ipv6_input+0x53c>
		if (net_if_ipv6_addr_onlink(&iface, (struct in6_addr *)hdr->dst)) {
 80576fb:	50                   	push   %eax
 80576fc:	50                   	push   %eax
 80576fd:	8d 45 c8             	lea    -0x38(%ebp),%eax
 8057700:	56                   	push   %esi
 8057701:	50                   	push   %eax
		struct net_if *iface = NULL;
 8057702:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
		if (net_if_ipv6_addr_onlink(&iface, (struct in6_addr *)hdr->dst)) {
 8057709:	e8 fc a8 ff ff       	call   805200a <net_if_ipv6_addr_onlink>
 805770e:	83 c4 10             	add    $0x10,%esp
 8057711:	84 c0                	test   %al,%al
 8057713:	0f 84 1a 03 00 00    	je     8057a33 <net_ipv6_input+0x51f>
			ret = net_route_packet_if(pkt, iface);
 8057719:	50                   	push   %eax
 805771a:	50                   	push   %eax
 805771b:	ff 75 c8             	push   -0x38(%ebp)
 805771e:	53                   	push   %ebx
 805771f:	e8 e5 2e 00 00       	call   805a609 <net_route_packet_if>
 8057724:	83 c4 10             	add    $0x10,%esp
			if (ret < 0) {
 8057727:	85 c0                	test   %eax,%eax
 8057729:	0f 88 04 03 00 00    	js     8057a33 <net_ipv6_input+0x51f>
				return NET_OK;
 805772f:	31 c0                	xor    %eax,%eax
 8057731:	e9 1a 03 00 00       	jmp    8057a50 <net_ipv6_input+0x53c>
	if (net_ipv6_is_addr_mcast((struct in6_addr *)hdr->dst) &&
 8057736:	80 7f 18 ff          	cmpb   $0xff,0x18(%edi)
 805773a:	0f 84 45 ff ff ff    	je     8057685 <net_ipv6_input+0x171>
	return net_pkt_skip(pkt, access->size);
 8057740:	50                   	push   %eax
 8057741:	50                   	push   %eax
 8057742:	ff 75 d0             	push   -0x30(%ebp)
 8057745:	53                   	push   %ebx
 8057746:	e8 26 dc ff ff       	call   8055371 <net_pkt_skip>
	current_hdr = hdr->nexthdr;
 805774b:	8a 4f 06             	mov    0x6(%edi),%cl
		return NET_IPV6_EXT_HDR_BITMAP_FRAG;
 805774e:	c6 45 af 08          	movb   $0x8,-0x51(%ebp)
 8057752:	83 c4 10             	add    $0x10,%esp
	switch (header) {
 8057755:	80 f9 2c             	cmp    $0x2c,%cl
 8057758:	74 58                	je     80577b2 <net_ipv6_input+0x29e>
 805775a:	77 13                	ja     805776f <net_ipv6_input+0x25b>
 805775c:	c6 45 af 01          	movb   $0x1,-0x51(%ebp)
 8057760:	84 c9                	test   %cl,%cl
 8057762:	74 4e                	je     80577b2 <net_ipv6_input+0x29e>
 8057764:	80 f9 2b             	cmp    $0x2b,%cl
 8057767:	0f 94 c0             	sete   %al
 805776a:	c1 e0 02             	shl    $0x2,%eax
 805776d:	eb 08                	jmp    8057777 <net_ipv6_input+0x263>
 805776f:	80 f9 3c             	cmp    $0x3c,%cl
 8057772:	0f 94 c0             	sete   %al
 8057775:	01 c0                	add    %eax,%eax
 8057777:	88 45 af             	mov    %al,-0x51(%ebp)
 805777a:	eb 36                	jmp    80577b2 <net_ipv6_input+0x29e>
	return net_ipv6_is_addr_mcast_link(addr) &&
 805777c:	3c 02                	cmp    $0x2,%al
 805777e:	75 10                	jne    8057790 <net_ipv6_input+0x27c>
	return net_ipv6_is_addr_mcast_group(addr, &all_nodes_mcast_group);
 8057780:	ba 90 24 06 08       	mov    $0x8062490,%edx
 8057785:	89 f0                	mov    %esi,%eax
 8057787:	e8 79 fb ff ff       	call   8057305 <net_ipv6_is_addr_mcast_group>
	    !(net_ipv6_is_addr_mcast_iface((struct in6_addr *)hdr->dst) ||
 805778c:	84 c0                	test   %al,%al
 805778e:	75 b0                	jne    8057740 <net_ipv6_input+0x22c>
		if_mcast_addr = net_if_ipv6_maddr_lookup(
 8057790:	50                   	push   %eax
 8057791:	50                   	push   %eax
 8057792:	8d 45 bc             	lea    -0x44(%ebp),%eax
 8057795:	50                   	push   %eax
 8057796:	56                   	push   %esi
 8057797:	e8 13 a5 ff ff       	call   8051caf <net_if_ipv6_maddr_lookup>
 805779c:	83 c4 10             	add    $0x10,%esp
		if (!if_mcast_addr ||
 805779f:	85 c0                	test   %eax,%eax
 80577a1:	0f 84 8c 02 00 00    	je     8057a33 <net_ipv6_input+0x51f>
 80577a7:	f6 40 14 02          	testb  $0x2,0x14(%eax)
 80577ab:	75 93                	jne    8057740 <net_ipv6_input+0x22c>
 80577ad:	e9 81 02 00 00       	jmp    8057a33 <net_ipv6_input+0x51f>
	uint16_t ext_len = 0U;
 80577b2:	66 c7 45 aa 00 00    	movw   $0x0,-0x56(%ebp)
}
 80577b8:	b8 06 00 00 00       	mov    $0x6,%eax
	return (nexthdr == IPPROTO_ICMPV6 || nexthdr == IPPROTO_UDP ||
 80577bd:	80 f9 3a             	cmp    $0x3a,%cl
	pkt->ipv6_prev_hdr_start = offset;
 80577c0:	66 89 43 38          	mov    %ax,0x38(%ebx)
 80577c4:	0f 94 c2             	sete   %dl
 80577c7:	80 f9 11             	cmp    $0x11,%cl
 80577ca:	0f 94 c0             	sete   %al
 80577cd:	09 c2                	or     %eax,%edx
	while (!net_ipv6_is_nexthdr_upper_layer(current_hdr)) {
 80577cf:	80 f9 06             	cmp    $0x6,%cl
 80577d2:	0f 84 04 02 00 00    	je     80579dc <net_ipv6_input+0x4c8>
 80577d8:	84 d2                	test   %dl,%dl
 80577da:	0f 85 fc 01 00 00    	jne    80579dc <net_ipv6_input+0x4c8>
		if (current_hdr == NET_IPV6_NEXTHDR_NONE) {
 80577e0:	80 f9 3b             	cmp    $0x3b,%cl
 80577e3:	88 4d a6             	mov    %cl,-0x5a(%ebp)
 80577e6:	0f 84 47 02 00 00    	je     8057a33 <net_ipv6_input+0x51f>
		prev_hdr_offset = net_pkt_get_current_offset(pkt);
 80577ec:	83 ec 0c             	sub    $0xc,%esp
 80577ef:	53                   	push   %ebx
 80577f0:	e8 f3 de ff ff       	call   80556e8 <net_pkt_get_current_offset>
 80577f5:	83 c4 0c             	add    $0xc,%esp
 80577f8:	66 89 45 a8          	mov    %ax,-0x58(%ebp)
	return net_pkt_read(pkt, data, 1);
 80577fc:	8d 45 c0             	lea    -0x40(%ebp),%eax
 80577ff:	6a 01                	push   $0x1
 8057801:	50                   	push   %eax
 8057802:	53                   	push   %ebx
 8057803:	e8 12 dd ff ff       	call   805551a <net_pkt_read>
 8057808:	83 c4 10             	add    $0x10,%esp
		if (net_pkt_read_u8(pkt, &nexthdr)) {
 805780b:	85 c0                	test   %eax,%eax
 805780d:	0f 85 20 02 00 00    	jne    8057a33 <net_ipv6_input+0x51f>
		ext_bit = extension_to_bitmap(nexthdr, ext_bitmap);
 8057813:	8a 45 c0             	mov    -0x40(%ebp),%al
	switch (header) {
 8057816:	8a 4d a6             	mov    -0x5a(%ebp),%cl
		return NET_IPV6_EXT_HDR_BITMAP_FRAG;
 8057819:	c6 45 b0 08          	movb   $0x8,-0x50(%ebp)
	switch (header) {
 805781d:	3c 2c                	cmp    $0x2c,%al
		ext_bit = extension_to_bitmap(nexthdr, ext_bitmap);
 805781f:	88 45 b4             	mov    %al,-0x4c(%ebp)
	switch (header) {
 8057822:	74 37                	je     805785b <net_ipv6_input+0x347>
 8057824:	77 15                	ja     805783b <net_ipv6_input+0x327>
 8057826:	c6 45 b0 01          	movb   $0x1,-0x50(%ebp)
 805782a:	84 c0                	test   %al,%al
 805782c:	74 2d                	je     805785b <net_ipv6_input+0x347>
 805782e:	3c 2b                	cmp    $0x2b,%al
 8057830:	0f 94 c2             	sete   %dl
 8057833:	c1 e2 02             	shl    $0x2,%edx
 8057836:	88 55 b0             	mov    %dl,-0x50(%ebp)
 8057839:	eb 20                	jmp    805785b <net_ipv6_input+0x347>
 805783b:	80 7d b4 3c          	cmpb   $0x3c,-0x4c(%ebp)
		return 0;
 805783f:	c6 45 b0 00          	movb   $0x0,-0x50(%ebp)
	switch (header) {
 8057843:	75 16                	jne    805785b <net_ipv6_input+0x347>
		if (ext_bitmap & NET_IPV6_EXT_HDR_BITMAP_DESTO1) {
 8057845:	8a 55 af             	mov    -0x51(%ebp),%dl
 8057848:	83 e2 02             	and    $0x2,%edx
			return NET_IPV6_EXT_HDR_BITMAP_DESTO2;
 805784b:	80 fa 01             	cmp    $0x1,%dl
 805784e:	19 c0                	sbb    %eax,%eax
 8057850:	89 45 b0             	mov    %eax,-0x50(%ebp)
 8057853:	80 65 b0 c2          	andb   $0xc2,-0x50(%ebp)
 8057857:	80 45 b0 40          	addb   $0x40,-0x50(%ebp)
		if (ext_bit & ext_bitmap) {
 805785b:	8a 45 b0             	mov    -0x50(%ebp),%al
 805785e:	84 45 af             	test   %al,-0x51(%ebp)
 8057861:	0f 85 ae 01 00 00    	jne    8057a15 <net_ipv6_input+0x501>
		switch (nexthdr) {
 8057867:	80 7d b4 2c          	cmpb   $0x2c,-0x4c(%ebp)
 805786b:	74 35                	je     80578a2 <net_ipv6_input+0x38e>
 805786d:	77 0c                	ja     805787b <net_ipv6_input+0x367>
 805786f:	80 7d b4 00          	cmpb   $0x0,-0x4c(%ebp)
 8057873:	0f 84 9c 01 00 00    	je     8057a15 <net_ipv6_input+0x501>
 8057879:	eb 0b                	jmp    8057886 <net_ipv6_input+0x372>
 805787b:	8a 45 b4             	mov    -0x4c(%ebp),%al
 805787e:	8d 50 c5             	lea    -0x3b(%eax),%edx
 8057881:	80 fa 01             	cmp    $0x1,%dl
 8057884:	76 1c                	jbe    80578a2 <net_ipv6_input+0x38e>
 8057886:	80 7d b4 3a          	cmpb   $0x3a,-0x4c(%ebp)
 805788a:	0f 94 c0             	sete   %al
 805788d:	80 7d b4 11          	cmpb   $0x11,-0x4c(%ebp)
 8057891:	0f 94 c2             	sete   %dl
			if (net_ipv6_is_nexthdr_upper_layer(nexthdr)) {
 8057894:	08 c2                	or     %al,%dl
 8057896:	75 0a                	jne    80578a2 <net_ipv6_input+0x38e>
 8057898:	80 7d b4 06          	cmpb   $0x6,-0x4c(%ebp)
 805789c:	0f 85 73 01 00 00    	jne    8057a15 <net_ipv6_input+0x501>
		switch (current_hdr) {
 80578a2:	84 c9                	test   %cl,%cl
 80578a4:	74 09                	je     80578af <net_ipv6_input+0x39b>
 80578a6:	80 f9 3c             	cmp    $0x3c,%cl
 80578a9:	0f 85 66 01 00 00    	jne    8057a15 <net_ipv6_input+0x501>
		exthdr_len = ipv6_handle_ext_hdr_options(pkt, hdr, pkt_len);
 80578af:	8b 45 ac             	mov    -0x54(%ebp),%eax
		uint8_t val = 0U;
 80578b2:	c6 45 c8 00          	movb   $0x0,-0x38(%ebp)
		exthdr_len = ipv6_handle_ext_hdr_options(pkt, hdr, pkt_len);
 80578b6:	8d 70 28             	lea    0x28(%eax),%esi
 80578b9:	50                   	push   %eax
 80578ba:	8d 45 c8             	lea    -0x38(%ebp),%eax
 80578bd:	6a 01                	push   $0x1
 80578bf:	50                   	push   %eax
 80578c0:	53                   	push   %ebx
 80578c1:	e8 54 dc ff ff       	call   805551a <net_pkt_read>
 80578c6:	83 c4 10             	add    $0x10,%esp
		if (net_pkt_read_u8(pkt, &val)) {
 80578c9:	85 c0                	test   %eax,%eax
 80578cb:	0f 85 62 01 00 00    	jne    8057a33 <net_ipv6_input+0x51f>
		exthdr_len = val * 8U + 8;
 80578d1:	0f b6 45 c8          	movzbl -0x38(%ebp),%eax
 80578d5:	8d 04 c5 08 00 00 00 	lea    0x8(,%eax,8),%eax
 80578dc:	66 89 45 b4          	mov    %ax,-0x4c(%ebp)
	if (exthdr_len > pkt_len) {
 80578e0:	66 39 c6             	cmp    %ax,%si
 80578e3:	0f 82 4a 01 00 00    	jb     8057a33 <net_ipv6_input+0x51f>
			if (opt_len > (exthdr_len - (1 + 1 + 1 + 1))) {
 80578e9:	0f b7 c0             	movzwl %ax,%eax
	length += 2U;
 80578ec:	be 02 00 00 00       	mov    $0x2,%esi
			if (opt_len > (exthdr_len - (1 + 1 + 1 + 1))) {
 80578f1:	89 45 a0             	mov    %eax,-0x60(%ebp)
		opt_type_offset = net_pkt_get_current_offset(pkt);
 80578f4:	83 ec 0c             	sub    $0xc,%esp
 80578f7:	53                   	push   %ebx
 80578f8:	e8 eb dd ff ff       	call   80556e8 <net_pkt_get_current_offset>
 80578fd:	83 c4 0c             	add    $0xc,%esp
 8057900:	66 89 45 a6          	mov    %ax,-0x5a(%ebp)
 8057904:	8d 45 c4             	lea    -0x3c(%ebp),%eax
 8057907:	6a 01                	push   $0x1
 8057909:	50                   	push   %eax
 805790a:	53                   	push   %ebx
 805790b:	e8 0a dc ff ff       	call   805551a <net_pkt_read>
 8057910:	83 c4 10             	add    $0x10,%esp
		if (net_pkt_read_u8(pkt, &opt_type)) {
 8057913:	85 c0                	test   %eax,%eax
 8057915:	0f 85 18 01 00 00    	jne    8057a33 <net_ipv6_input+0x51f>
		if (opt_type != NET_IPV6_EXT_HDR_OPT_PAD1) {
 805791b:	80 7d c4 00          	cmpb   $0x0,-0x3c(%ebp)
 805791f:	75 25                	jne    8057946 <net_ipv6_input+0x432>
		switch (opt_type) {
 8057921:	8a 55 c4             	mov    -0x3c(%ebp),%dl
 8057924:	84 d2                	test   %dl,%dl
 8057926:	74 37                	je     805795f <net_ipv6_input+0x44b>
 8057928:	80 fa 01             	cmp    $0x1,%dl
 805792b:	0f b6 45 c8          	movzbl -0x38(%ebp),%eax
 805792f:	75 31                	jne    8057962 <net_ipv6_input+0x44e>
			length += opt_len + 2;
 8057931:	0f b6 d0             	movzbl %al,%edx
 8057934:	8d 74 16 02          	lea    0x2(%esi,%edx,1),%esi
			net_pkt_skip(pkt, opt_len);
 8057938:	52                   	push   %edx
 8057939:	52                   	push   %edx
 805793a:	50                   	push   %eax
 805793b:	53                   	push   %ebx
 805793c:	e8 30 da ff ff       	call   8055371 <net_pkt_skip>
 8057941:	83 c4 10             	add    $0x10,%esp
			break;
 8057944:	eb 73                	jmp    80579b9 <net_ipv6_input+0x4a5>
 8057946:	8d 45 c8             	lea    -0x38(%ebp),%eax
 8057949:	51                   	push   %ecx
 805794a:	6a 01                	push   $0x1
 805794c:	50                   	push   %eax
 805794d:	53                   	push   %ebx
 805794e:	e8 c7 db ff ff       	call   805551a <net_pkt_read>
 8057953:	83 c4 10             	add    $0x10,%esp
			if (net_pkt_read_u8(pkt, &opt_len)) {
 8057956:	85 c0                	test   %eax,%eax
 8057958:	74 c7                	je     8057921 <net_ipv6_input+0x40d>
 805795a:	e9 d4 00 00 00       	jmp    8057a33 <net_ipv6_input+0x51f>
			length++;
 805795f:	46                   	inc    %esi
			break;
 8057960:	eb 57                	jmp    80579b9 <net_ipv6_input+0x4a5>
			if (opt_len > (exthdr_len - (1 + 1 + 1 + 1))) {
 8057962:	8b 4d a0             	mov    -0x60(%ebp),%ecx
 8057965:	83 e9 03             	sub    $0x3,%ecx
 8057968:	39 c1                	cmp    %eax,%ecx
 805796a:	0f 8e c3 00 00 00    	jle    8057a33 <net_ipv6_input+0x51f>
	switch (opt_type & 0xc0) {
 8057970:	83 e2 c0             	and    $0xffffffc0,%edx
 8057973:	80 fa 80             	cmp    $0x80,%dl
 8057976:	74 19                	je     8057991 <net_ipv6_input+0x47d>
 8057978:	80 fa c0             	cmp    $0xc0,%dl
 805797b:	74 0a                	je     8057987 <net_ipv6_input+0x473>
 805797d:	84 d2                	test   %dl,%dl
 805797f:	0f 85 ae 00 00 00    	jne    8057a33 <net_ipv6_input+0x51f>
 8057985:	eb 16                	jmp    805799d <net_ipv6_input+0x489>
		if (net_ipv6_is_addr_mcast((struct in6_addr *)hdr->dst)) {
 8057987:	80 7f 18 ff          	cmpb   $0xff,0x18(%edi)
 805798b:	0f 84 a2 00 00 00    	je     8057a33 <net_ipv6_input+0x51f>
		net_icmpv6_send_error(pkt, NET_ICMPV6_PARAM_PROBLEM,
 8057991:	0f b7 45 a6          	movzwl -0x5a(%ebp),%eax
 8057995:	50                   	push   %eax
 8057996:	6a 02                	push   $0x2
 8057998:	e9 8b 00 00 00       	jmp    8057a28 <net_ipv6_input+0x514>
			if (net_pkt_skip(pkt, opt_len)) {
 805799d:	51                   	push   %ecx
 805799e:	51                   	push   %ecx
 805799f:	50                   	push   %eax
 80579a0:	53                   	push   %ebx
 80579a1:	e8 cb d9 ff ff       	call   8055371 <net_pkt_skip>
 80579a6:	83 c4 10             	add    $0x10,%esp
 80579a9:	85 c0                	test   %eax,%eax
 80579ab:	0f 85 82 00 00 00    	jne    8057a33 <net_ipv6_input+0x51f>
			length += opt_len + 2;
 80579b1:	0f b6 45 c8          	movzbl -0x38(%ebp),%eax
 80579b5:	8d 74 06 02          	lea    0x2(%esi,%eax,1),%esi
	while (length < exthdr_len) {
 80579b9:	66 39 75 b4          	cmp    %si,-0x4c(%ebp)
 80579bd:	0f 87 31 ff ff ff    	ja     80578f4 <net_ipv6_input+0x3e0>
		ext_bitmap |= ext_bit;
 80579c3:	8a 4d b0             	mov    -0x50(%ebp),%cl
		ext_len += exthdr_len;
 80579c6:	8b 75 b4             	mov    -0x4c(%ebp),%esi
		ext_bitmap |= ext_bit;
 80579c9:	08 4d af             	or     %cl,-0x51(%ebp)
 80579cc:	0f b6 45 a8          	movzbl -0x58(%ebp),%eax
		ext_len += exthdr_len;
 80579d0:	66 01 75 aa          	add    %si,-0x56(%ebp)
		current_hdr = nexthdr;
 80579d4:	8a 4d c0             	mov    -0x40(%ebp),%cl
}
 80579d7:	e9 e1 fd ff ff       	jmp    80577bd <net_ipv6_input+0x2a9>
	pkt->ipv6_ext_len = len;
 80579dc:	66 8b 45 aa          	mov    -0x56(%ebp),%ax
 80579e0:	66 89 43 36          	mov    %ax,0x36(%ebx)
	switch (current_hdr) {
 80579e4:	80 f9 11             	cmp    $0x11,%cl
 80579e7:	74 14                	je     80579fd <net_ipv6_input+0x4e9>
 80579e9:	b8 02 00 00 00       	mov    $0x2,%eax
 80579ee:	84 d2                	test   %dl,%dl
 80579f0:	74 5e                	je     8057a50 <net_ipv6_input+0x53c>
		verdict = net_icmpv6_input(pkt, hdr);
 80579f2:	52                   	push   %edx
 80579f3:	52                   	push   %edx
 80579f4:	57                   	push   %edi
 80579f5:	53                   	push   %ebx
 80579f6:	e8 6b f6 ff ff       	call   8057066 <net_icmpv6_input>
 80579fb:	eb 50                	jmp    8057a4d <net_ipv6_input+0x539>
		proto_hdr.udp = net_udp_input(pkt, &udp_access);
 80579fd:	50                   	push   %eax
 80579fe:	50                   	push   %eax
 80579ff:	8d 45 d4             	lea    -0x2c(%ebp),%eax
 8057a02:	50                   	push   %eax
 8057a03:	53                   	push   %ebx
 8057a04:	e8 8c 2d 00 00       	call   805a795 <net_udp_input>
 8057a09:	83 c4 10             	add    $0x10,%esp
 8057a0c:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		if (proto_hdr.udp) {
 8057a0f:	85 c0                	test   %eax,%eax
 8057a11:	75 27                	jne    8057a3a <net_ipv6_input+0x526>
 8057a13:	eb 1e                	jmp    8057a33 <net_ipv6_input+0x51f>

bad_hdr:
	/* Send error message about parameter problem (RFC 2460) */
	net_icmpv6_send_error(pkt, NET_ICMPV6_PARAM_PROBLEM,
			      NET_ICMPV6_PARAM_PROB_NEXTHEADER,
			      net_pkt_get_current_offset(pkt) - 1);
 8057a15:	83 ec 0c             	sub    $0xc,%esp
 8057a18:	53                   	push   %ebx
 8057a19:	e8 ca dc ff ff       	call   80556e8 <net_pkt_get_current_offset>
 8057a1e:	83 c4 10             	add    $0x10,%esp
 8057a21:	0f b7 c0             	movzwl %ax,%eax
 8057a24:	48                   	dec    %eax
	net_icmpv6_send_error(pkt, NET_ICMPV6_PARAM_PROBLEM,
 8057a25:	50                   	push   %eax
 8057a26:	6a 01                	push   $0x1
 8057a28:	6a 04                	push   $0x4
 8057a2a:	53                   	push   %ebx
 8057a2b:	e8 c6 f3 ff ff       	call   8056df6 <net_icmpv6_send_error>
 8057a30:	83 c4 10             	add    $0x10,%esp

	NET_DBG("DROP: Unknown/wrong nexthdr type");
	net_stats_update_ip_errors_protoerr(pkt_iface);

	return NET_DROP;
 8057a33:	b8 02 00 00 00       	mov    $0x2,%eax
 8057a38:	eb 16                	jmp    8057a50 <net_ipv6_input+0x53c>
	verdict = net_conn_input(pkt, &ip, current_hdr, &proto_hdr);
 8057a3a:	8d 45 c4             	lea    -0x3c(%ebp),%eax
	ip.ipv6 = hdr;
 8057a3d:	89 7d c8             	mov    %edi,-0x38(%ebp)
	verdict = net_conn_input(pkt, &ip, current_hdr, &proto_hdr);
 8057a40:	50                   	push   %eax
 8057a41:	8d 45 c8             	lea    -0x38(%ebp),%eax
 8057a44:	6a 11                	push   $0x11
 8057a46:	50                   	push   %eax
 8057a47:	53                   	push   %ebx
 8057a48:	e8 87 e4 ff ff       	call   8055ed4 <net_conn_input>
 8057a4d:	83 c4 10             	add    $0x10,%esp
}
 8057a50:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 8057a53:	65 2b 15 14 00 00 00 	sub    %gs:0x14,%edx
 8057a5a:	74 05                	je     8057a61 <net_ipv6_input+0x54d>
 8057a5c:	e8 9f 18 ff ff       	call   8049300 <__stack_chk_fail@plt>
 8057a61:	8d 65 f4             	lea    -0xc(%ebp),%esp
 8057a64:	5b                   	pop    %ebx
 8057a65:	5e                   	pop    %esi
 8057a66:	5f                   	pop    %edi
 8057a67:	5d                   	pop    %ebp
 8057a68:	c3                   	ret    

08057a69 <net_ipv6_init>:

void net_ipv6_init(void)
{
 8057a69:	55                   	push   %ebp
 8057a6a:	89 e5                	mov    %esp,%ebp
 8057a6c:	83 ec 08             	sub    $0x8,%esp
	net_ipv6_nbr_init();
 8057a6f:	e8 69 1d 00 00       	call   80597dd <net_ipv6_nbr_init>

#if defined(CONFIG_NET_IPV6_MLD)
	net_ipv6_mld_init();
#endif
}
 8057a74:	c9                   	leave  
	net_ipv6_mld_init();
 8057a75:	e9 bf 22 00 00       	jmp    8059d39 <net_ipv6_mld_init>

08057a7a <net_ipv6_is_addr_unspecified>:
{
 8057a7a:	89 c2                	mov    %eax,%edx
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
 8057a7c:	31 c0                	xor    %eax,%eax
 8057a7e:	83 3a 00             	cmpl   $0x0,(%edx)
 8057a81:	75 15                	jne    8057a98 <net_ipv6_is_addr_unspecified+0x1e>
	return UNALIGNED_GET(&addr->s6_addr32[0]) == 0 &&
 8057a83:	83 7a 04 00          	cmpl   $0x0,0x4(%edx)
 8057a87:	75 0f                	jne    8057a98 <net_ipv6_is_addr_unspecified+0x1e>
		UNALIGNED_GET(&addr->s6_addr32[1]) == 0 &&
 8057a89:	83 7a 08 00          	cmpl   $0x0,0x8(%edx)
 8057a8d:	75 09                	jne    8057a98 <net_ipv6_is_addr_unspecified+0x1e>
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
 8057a8f:	31 c0                	xor    %eax,%eax
 8057a91:	83 7a 0c 00          	cmpl   $0x0,0xc(%edx)
 8057a95:	0f 94 c0             	sete   %al
 8057a98:	83 e0 01             	and    $0x1,%eax
}
 8057a9b:	c3                   	ret    

08057a9c <net_neighbor_data_remove>:
void net_neighbor_data_remove(struct net_nbr *nbr)
{
	NET_DBG("Neighbor %p removed", nbr);

	return;
}
 8057a9c:	c3                   	ret    

08057a9d <nbr_clear_ns_pending>:
{
 8057a9d:	55                   	push   %ebp
 8057a9e:	89 e5                	mov    %esp,%ebp
 8057aa0:	53                   	push   %ebx
 8057aa1:	89 c3                	mov    %eax,%ebx
 8057aa3:	52                   	push   %edx
	data->send_ns = 0;
 8057aa4:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
 8057aab:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%eax)
	if (data->pending) {
 8057ab2:	8b 00                	mov    (%eax),%eax
 8057ab4:	85 c0                	test   %eax,%eax
 8057ab6:	74 12                	je     8057aca <nbr_clear_ns_pending+0x2d>
		net_pkt_unref(data->pending);
 8057ab8:	83 ec 0c             	sub    $0xc,%esp
 8057abb:	50                   	push   %eax
 8057abc:	e8 27 d3 ff ff       	call   8054de8 <net_pkt_unref>
		data->pending = NULL;
 8057ac1:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
		net_pkt_unref(data->pending);
 8057ac7:	83 c4 10             	add    $0x10,%esp
}
 8057aca:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 8057acd:	c9                   	leave  
 8057ace:	c3                   	ret    

08057acf <nbr_free>:
{
 8057acf:	55                   	push   %ebp
 8057ad0:	89 e5                	mov    %esp,%ebp
 8057ad2:	53                   	push   %ebx
 8057ad3:	89 c3                	mov    %eax,%ebx
 8057ad5:	52                   	push   %edx
	nbr_clear_ns_pending(net_ipv6_nbr_data(nbr));
 8057ad6:	8b 40 0c             	mov    0xc(%eax),%eax
 8057ad9:	e8 bf ff ff ff       	call   8057a9d <nbr_clear_ns_pending>
	return (struct net_ipv6_nbr_data *)nbr->data;
 8057ade:	8b 43 0c             	mov    0xc(%ebx),%eax
	net_nbr_unref(nbr);
 8057ae1:	83 ec 0c             	sub    $0xc,%esp
	net_ipv6_nbr_data(nbr)->reachable = 0;
 8057ae4:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
 8057aeb:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
 8057af2:	8b 43 0c             	mov    0xc(%ebx),%eax
	net_ipv6_nbr_data(nbr)->reachable_timeout = 0;
 8057af5:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
	net_nbr_unref(nbr);
 8057afc:	53                   	push   %ebx
 8057afd:	e8 38 f6 ff ff       	call   805713a <net_nbr_unref>
 8057b02:	59                   	pop    %ecx
 8057b03:	58                   	pop    %eax
	net_nbr_unlink(nbr, NULL);
 8057b04:	6a 00                	push   $0x0
 8057b06:	53                   	push   %ebx
 8057b07:	e8 70 f7 ff ff       	call   805727c <net_nbr_unlink>
}
 8057b0c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
	net_nbr_unlink(nbr, NULL);
 8057b0f:	83 c4 10             	add    $0x10,%esp
}
 8057b12:	c9                   	leave  
 8057b13:	c3                   	ret    

08057b14 <k_uptime_get>:
{
 8057b14:	55                   	push   %ebp
 8057b15:	89 e5                	mov    %esp,%ebp
 8057b17:	83 ec 08             	sub    $0x8,%esp
	return z_impl_k_uptime_ticks();
 8057b1a:	e8 f5 90 00 00       	call   8060c14 <z_impl_k_uptime_ticks>
}
 8057b1f:	c9                   	leave  
			return t * ((uint64_t)to_hz / from_hz);
 8057b20:	6b ca 0a             	imul   $0xa,%edx,%ecx
 8057b23:	ba 0a 00 00 00       	mov    $0xa,%edx
 8057b28:	f7 e2                	mul    %edx
 8057b2a:	01 ca                	add    %ecx,%edx
 8057b2c:	c3                   	ret    

08057b2d <ipv6_nd_restart_reachable_timer>:
}
#endif /* CONFIG_NET_IPV6_NBR_CACHE */

#if defined(CONFIG_NET_IPV6_ND)
static void ipv6_nd_restart_reachable_timer(struct net_nbr *nbr, int64_t time)
{
 8057b2d:	55                   	push   %ebp
 8057b2e:	89 e5                	mov    %esp,%ebp
 8057b30:	57                   	push   %edi
 8057b31:	89 d7                	mov    %edx,%edi
 8057b33:	56                   	push   %esi
 8057b34:	89 ce                	mov    %ecx,%esi
 8057b36:	53                   	push   %ebx
 8057b37:	89 c3                	mov    %eax,%ebx
 8057b39:	83 ec 1c             	sub    $0x1c,%esp
	int64_t remaining;

	if (nbr) {
 8057b3c:	85 c0                	test   %eax,%eax
 8057b3e:	74 1a                	je     8057b5a <ipv6_nd_restart_reachable_timer+0x2d>
 8057b40:	8b 4b 0c             	mov    0xc(%ebx),%ecx
 8057b43:	89 4d dc             	mov    %ecx,-0x24(%ebp)
		net_ipv6_nbr_data(nbr)->reachable = k_uptime_get();
 8057b46:	e8 c9 ff ff ff       	call   8057b14 <k_uptime_get>
 8057b4b:	8b 4d dc             	mov    -0x24(%ebp),%ecx
 8057b4e:	89 41 14             	mov    %eax,0x14(%ecx)
 8057b51:	89 51 18             	mov    %edx,0x18(%ecx)
 8057b54:	8b 43 0c             	mov    0xc(%ebx),%eax
		net_ipv6_nbr_data(nbr)->reachable_timeout = time;
 8057b57:	89 78 1c             	mov    %edi,0x1c(%eax)
	return z_timeout_remaining(&dwork->timeout);
 8057b5a:	83 ec 0c             	sub    $0xc,%esp
 8057b5d:	68 b0 85 06 08       	push   $0x80685b0
 8057b62:	e8 32 8f 00 00       	call   8060a99 <z_timeout_remaining>
 8057b67:	83 c4 10             	add    $0x10,%esp
			return ((uint32_t)t) * (to_hz / from_hz);
 8057b6a:	6b c0 0a             	imul   $0xa,%eax,%eax
	}

	remaining = k_ticks_to_ms_ceil32(
		k_work_delayable_remaining_get(&ipv6_nd_reachable_timer));
	if (!remaining || remaining > time) {
 8057b6d:	85 c0                	test   %eax,%eax
 8057b6f:	74 09                	je     8057b7a <ipv6_nd_restart_reachable_timer+0x4d>
 8057b71:	39 c7                	cmp    %eax,%edi
 8057b73:	89 f0                	mov    %esi,%eax
 8057b75:	83 d8 00             	sbb    $0x0,%eax
 8057b78:	7d 3f                	jge    8057bb9 <ipv6_nd_restart_reachable_timer+0x8c>
		k_work_reschedule(&ipv6_nd_reachable_timer, K_MSEC(time));
 8057b7a:	31 d2                	xor    %edx,%edx
 8057b7c:	31 c0                	xor    %eax,%eax
 8057b7e:	89 f1                	mov    %esi,%ecx
			return t / ((uint64_t)from_hz / to_hz);
 8057b80:	6a 00                	push   $0x0
 8057b82:	39 d7                	cmp    %edx,%edi
 8057b84:	6a 0a                	push   $0xa
 8057b86:	19 c1                	sbb    %eax,%ecx
 8057b88:	0f 4d d7             	cmovge %edi,%edx
 8057b8b:	0f 4d c6             	cmovge %esi,%eax
 8057b8e:	89 55 e0             	mov    %edx,-0x20(%ebp)
 8057b91:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		t += off;
 8057b94:	8b 45 e0             	mov    -0x20(%ebp),%eax
 8057b97:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 8057b9a:	83 c0 09             	add    $0x9,%eax
 8057b9d:	83 d2 00             	adc    $0x0,%edx
			return t / ((uint64_t)from_hz / to_hz);
 8057ba0:	52                   	push   %edx
 8057ba1:	50                   	push   %eax
 8057ba2:	e8 a9 19 ff ff       	call   8049550 <__udivdi3>
 8057ba7:	83 c4 0c             	add    $0xc,%esp
 8057baa:	52                   	push   %edx
 8057bab:	50                   	push   %eax
 8057bac:	68 a0 85 06 08       	push   $0x80685a0
 8057bb1:	e8 2a 81 00 00       	call   805fce0 <k_work_reschedule>
 8057bb6:	83 c4 10             	add    $0x10,%esp
	}
}
 8057bb9:	8d 65 f4             	lea    -0xc(%ebp),%esp
 8057bbc:	5b                   	pop    %ebx
 8057bbd:	5e                   	pop    %esi
 8057bbe:	5f                   	pop    %edi
 8057bbf:	5d                   	pop    %ebp
 8057bc0:	c3                   	ret    

08057bc1 <ipv6_ns_reply_timeout>:
{
 8057bc1:	55                   	push   %ebp
 8057bc2:	89 e5                	mov    %esp,%ebp
 8057bc4:	57                   	push   %edi
 8057bc5:	56                   	push   %esi
 8057bc6:	53                   	push   %ebx
 8057bc7:	bb a0 61 06 08       	mov    $0x80661a0,%ebx
 8057bcc:	83 ec 1c             	sub    $0x1c,%esp
	int64_t current = k_uptime_get();
 8057bcf:	e8 40 ff ff ff       	call   8057b14 <k_uptime_get>
 8057bd4:	89 45 e0             	mov    %eax,-0x20(%ebp)
 8057bd7:	89 55 e4             	mov    %edx,-0x1c(%ebp)
		if (!nbr || !nbr->ref) {
 8057bda:	80 3b 00             	cmpb   $0x0,(%ebx)
 8057bdd:	0f 84 a7 00 00 00    	je     8057c8a <ipv6_ns_reply_timeout+0xc9>
 8057be3:	8b 43 0c             	mov    0xc(%ebx),%eax
		if (!data) {
 8057be6:	85 c0                	test   %eax,%eax
 8057be8:	0f 84 9c 00 00 00    	je     8057c8a <ipv6_ns_reply_timeout+0xc9>
		if (!data->send_ns) {
 8057bee:	8b 78 24             	mov    0x24(%eax),%edi
 8057bf1:	8b 70 20             	mov    0x20(%eax),%esi
 8057bf4:	89 f9                	mov    %edi,%ecx
 8057bf6:	09 f1                	or     %esi,%ecx
 8057bf8:	0f 84 8c 00 00 00    	je     8057c8a <ipv6_ns_reply_timeout+0xc9>
		remaining = data->send_ns + NS_REPLY_TIMEOUT - current;
 8057bfe:	81 c6 e8 03 00 00    	add    $0x3e8,%esi
 8057c04:	83 d7 00             	adc    $0x0,%edi
 8057c07:	2b 75 e0             	sub    -0x20(%ebp),%esi
 8057c0a:	1b 7d e4             	sbb    -0x1c(%ebp),%edi
		if (remaining > 0) {
 8057c0d:	31 d2                	xor    %edx,%edx
 8057c0f:	39 f2                	cmp    %esi,%edx
 8057c11:	19 fa                	sbb    %edi,%edx
 8057c13:	7d 36                	jge    8057c4b <ipv6_ns_reply_timeout+0x8a>
 8057c15:	83 ec 0c             	sub    $0xc,%esp
 8057c18:	68 70 85 06 08       	push   $0x8068570
 8057c1d:	e8 77 8e 00 00       	call   8060a99 <z_timeout_remaining>
 8057c22:	83 c4 10             	add    $0x10,%esp
			if (!k_work_delayable_remaining_get(
 8057c25:	09 c2                	or     %eax,%edx
 8057c27:	75 61                	jne    8057c8a <ipv6_ns_reply_timeout+0xc9>
		t += off;
 8057c29:	83 c6 09             	add    $0x9,%esi
			return t / ((uint64_t)from_hz / to_hz);
 8057c2c:	6a 00                	push   $0x0
		t += off;
 8057c2e:	83 d7 00             	adc    $0x0,%edi
			return t / ((uint64_t)from_hz / to_hz);
 8057c31:	6a 0a                	push   $0xa
 8057c33:	57                   	push   %edi
 8057c34:	56                   	push   %esi
 8057c35:	e8 16 19 ff ff       	call   8049550 <__udivdi3>
 8057c3a:	83 c4 0c             	add    $0xc,%esp
				k_work_reschedule(&ipv6_ns_reply_timer,
 8057c3d:	52                   	push   %edx
 8057c3e:	50                   	push   %eax
 8057c3f:	68 60 85 06 08       	push   $0x8068560
 8057c44:	e8 97 80 00 00       	call   805fce0 <k_work_reschedule>
 8057c49:	eb 3c                	jmp    8057c87 <ipv6_ns_reply_timeout+0xc6>
		if (!data->pending) {
 8057c4b:	8b 10                	mov    (%eax),%edx
		data->send_ns = 0;
 8057c4d:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
 8057c54:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%eax)
		if (!data->pending) {
 8057c5b:	89 45 dc             	mov    %eax,-0x24(%ebp)
 8057c5e:	85 d2                	test   %edx,%edx
 8057c60:	74 28                	je     8057c8a <ipv6_ns_reply_timeout+0xc9>
		net_pkt_unref(data->pending);
 8057c62:	83 ec 0c             	sub    $0xc,%esp
 8057c65:	52                   	push   %edx
 8057c66:	e8 7d d1 ff ff       	call   8054de8 <net_pkt_unref>
 8057c6b:	58                   	pop    %eax
		net_pkt_unref(data->pending);
 8057c6c:	8b 45 dc             	mov    -0x24(%ebp),%eax
 8057c6f:	ff 30                	push   (%eax)
 8057c71:	e8 72 d1 ff ff       	call   8054de8 <net_pkt_unref>
		data->pending = NULL;
 8057c76:	8b 45 dc             	mov    -0x24(%ebp),%eax
 8057c79:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		net_nbr_unref(nbr);
 8057c7f:	89 1c 24             	mov    %ebx,(%esp)
 8057c82:	e8 b3 f4 ff ff       	call   805713a <net_nbr_unref>
 8057c87:	83 c4 10             	add    $0x10,%esp
	for (i = 0; i < CONFIG_NET_IPV6_MAX_NEIGHBORS; i++) {
 8057c8a:	83 c3 48             	add    $0x48,%ebx
 8057c8d:	81 fb e0 63 06 08    	cmp    $0x80663e0,%ebx
 8057c93:	0f 85 41 ff ff ff    	jne    8057bda <ipv6_ns_reply_timeout+0x19>
}
 8057c99:	8d 65 f4             	lea    -0xc(%ebp),%esp
 8057c9c:	5b                   	pop    %ebx
 8057c9d:	5e                   	pop    %esi
 8057c9e:	5f                   	pop    %edi
 8057c9f:	5d                   	pop    %ebp
 8057ca0:	c3                   	ret    

08057ca1 <set_llao>:
{
 8057ca1:	55                   	push   %ebp
 8057ca2:	89 e5                	mov    %esp,%ebp
 8057ca4:	57                   	push   %edi
 8057ca5:	89 d7                	mov    %edx,%edi
 8057ca7:	56                   	push   %esi
 8057ca8:	89 c6                	mov    %eax,%esi
 8057caa:	53                   	push   %ebx
 8057cab:	89 cb                	mov    %ecx,%ebx
 8057cad:	83 ec 20             	sub    $0x20,%esp
	struct net_icmpv6_nd_opt_hdr opt_hdr = {
 8057cb0:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 8057cb6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 8057cb9:	8b 45 08             	mov    0x8(%ebp),%eax
	if (net_pkt_write(pkt, &opt_hdr,
 8057cbc:	6a 02                	push   $0x2
	struct net_icmpv6_nd_opt_hdr opt_hdr = {
 8057cbe:	88 45 e2             	mov    %al,-0x1e(%ebp)
 8057cc1:	89 c8                	mov    %ecx,%eax
 8057cc3:	c0 e8 03             	shr    $0x3,%al
 8057cc6:	88 45 e3             	mov    %al,-0x1d(%ebp)
	if (net_pkt_write(pkt, &opt_hdr,
 8057cc9:	8d 45 e2             	lea    -0x1e(%ebp),%eax
 8057ccc:	50                   	push   %eax
 8057ccd:	56                   	push   %esi
 8057cce:	e8 a6 db ff ff       	call   8055879 <net_pkt_write>
 8057cd3:	83 c4 10             	add    $0x10,%esp
 8057cd6:	85 c0                	test   %eax,%eax
 8057cd8:	74 04                	je     8057cde <set_llao+0x3d>
		return false;
 8057cda:	31 c0                	xor    %eax,%eax
 8057cdc:	eb 33                	jmp    8057d11 <set_llao+0x70>
	    net_pkt_write(pkt, lladdr->addr, lladdr->len) ||
 8057cde:	0f b6 47 04          	movzbl 0x4(%edi),%eax
 8057ce2:	52                   	push   %edx
 8057ce3:	50                   	push   %eax
 8057ce4:	ff 37                	push   (%edi)
 8057ce6:	56                   	push   %esi
 8057ce7:	e8 8d db ff ff       	call   8055879 <net_pkt_write>
 8057cec:	83 c4 10             	add    $0x10,%esp
			  sizeof(struct net_icmpv6_nd_opt_hdr)) ||
 8057cef:	85 c0                	test   %eax,%eax
 8057cf1:	75 e7                	jne    8057cda <set_llao+0x39>
	    net_pkt_memset(pkt, 0, llao_len - lladdr->len - 2)) {
 8057cf3:	50                   	push   %eax
 8057cf4:	0f b6 47 04          	movzbl 0x4(%edi),%eax
 8057cf8:	0f b6 db             	movzbl %bl,%ebx
 8057cfb:	29 c3                	sub    %eax,%ebx
 8057cfd:	83 eb 02             	sub    $0x2,%ebx
 8057d00:	53                   	push   %ebx
 8057d01:	6a 00                	push   $0x0
 8057d03:	56                   	push   %esi
 8057d04:	e8 f4 d7 ff ff       	call   80554fd <net_pkt_memset>
 8057d09:	83 c4 10             	add    $0x10,%esp
	    net_pkt_write(pkt, lladdr->addr, lladdr->len) ||
 8057d0c:	85 c0                	test   %eax,%eax
 8057d0e:	0f 94 c0             	sete   %al
}
 8057d11:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 8057d14:	65 2b 15 14 00 00 00 	sub    %gs:0x14,%edx
 8057d1b:	74 05                	je     8057d22 <set_llao+0x81>
 8057d1d:	e8 de 15 ff ff       	call   8049300 <__stack_chk_fail@plt>
 8057d22:	8d 65 f4             	lea    -0xc(%ebp),%esp
 8057d25:	5b                   	pop    %ebx
 8057d26:	5e                   	pop    %esi
 8057d27:	5f                   	pop    %edi
 8057d28:	5d                   	pop    %ebp
 8057d29:	c3                   	ret    

08057d2a <dbg_update_neighbor_lladdr.constprop.0>:
static void dbg_update_neighbor_lladdr(const struct net_linkaddr *new_lladdr,
 8057d2a:	55                   	push   %ebp
		 net_sprint_ll_addr(old_lladdr->addr, old_lladdr->len));
 8057d2b:	83 c0 02             	add    $0x2,%eax
static void dbg_update_neighbor_lladdr(const struct net_linkaddr *new_lladdr,
 8057d2e:	89 e5                	mov    %esp,%ebp
 8057d30:	83 ec 28             	sub    $0x28,%esp
 8057d33:	65 8b 15 14 00 00 00 	mov    %gs:0x14,%edx
 8057d3a:	89 55 f4             	mov    %edx,-0xc(%ebp)
 8057d3d:	31 d2                	xor    %edx,%edx

static inline char *net_sprint_ll_addr(const uint8_t *ll, uint8_t ll_len)
{
	static char buf[sizeof("xx:xx:xx:xx:xx:xx:xx:xx")];

	return net_sprint_ll_addr_buf(ll, ll_len, (char *)buf, sizeof(buf));
 8057d3f:	6a 18                	push   $0x18
 8057d41:	68 24 8a 06 08       	push   $0x8068a24
	snprintk(out, sizeof(out), "%s",
 8057d46:	0f b6 50 ff          	movzbl -0x1(%eax),%edx
 8057d4a:	52                   	push   %edx
 8057d4b:	50                   	push   %eax
 8057d4c:	e8 80 b1 ff ff       	call   8052ed1 <net_sprint_ll_addr_buf>
 8057d51:	83 c4 10             	add    $0x10,%esp
 8057d54:	50                   	push   %eax
 8057d55:	8d 45 dc             	lea    -0x24(%ebp),%eax
 8057d58:	68 d2 32 06 08       	push   $0x80632d2
 8057d5d:	6a 18                	push   $0x18
 8057d5f:	50                   	push   %eax
 8057d60:	e8 d3 21 ff ff       	call   8049f38 <snprintk>
 8057d65:	83 c4 10             	add    $0x10,%esp
}
 8057d68:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8057d6b:	65 2b 05 14 00 00 00 	sub    %gs:0x14,%eax
 8057d72:	74 05                	je     8057d79 <dbg_update_neighbor_lladdr.constprop.0+0x4f>
 8057d74:	e8 87 15 ff ff       	call   8049300 <__stack_chk_fail@plt>
 8057d79:	c9                   	leave  
 8057d7a:	c3                   	ret    

08057d7b <nbr_lookup.constprop.0>:
static struct net_nbr *nbr_lookup(struct net_nbr_table *table,
 8057d7b:	55                   	push   %ebp
 8057d7c:	89 e5                	mov    %esp,%ebp
 8057d7e:	57                   	push   %edi
 8057d7f:	89 c7                	mov    %eax,%edi
 8057d81:	56                   	push   %esi
 8057d82:	be a0 61 06 08       	mov    $0x80661a0,%esi
 8057d87:	53                   	push   %ebx
	for (i = 0; i < CONFIG_NET_IPV6_MAX_NEIGHBORS; i++) {
 8057d88:	31 db                	xor    %ebx,%ebx
static struct net_nbr *nbr_lookup(struct net_nbr_table *table,
 8057d8a:	83 ec 1c             	sub    $0x1c,%esp
		if (!nbr->ref) {
 8057d8d:	80 3e 00             	cmpb   $0x0,(%esi)
 8057d90:	74 26                	je     8057db8 <nbr_lookup.constprop.0+0x3d>
		if (iface && nbr->iface != iface) {
 8057d92:	85 ff                	test   %edi,%edi
 8057d94:	74 05                	je     8057d9b <nbr_lookup.constprop.0+0x20>
 8057d96:	3b 7e 08             	cmp    0x8(%esi),%edi
 8057d99:	75 1d                	jne    8057db8 <nbr_lookup.constprop.0+0x3d>
	return !memcmp(addr1, addr2, sizeof(struct in6_addr));
 8057d9b:	50                   	push   %eax
 8057d9c:	8b 46 0c             	mov    0xc(%esi),%eax
 8057d9f:	6a 10                	push   $0x10
 8057da1:	83 c0 04             	add    $0x4,%eax
 8057da4:	52                   	push   %edx
 8057da5:	50                   	push   %eax
 8057da6:	89 55 e4             	mov    %edx,-0x1c(%ebp)
 8057da9:	e8 c2 12 ff ff       	call   8049070 <memcmp@plt>
 8057dae:	83 c4 10             	add    $0x10,%esp
		if (net_ipv6_addr_cmp(&net_ipv6_nbr_data(nbr)->addr, addr)) {
 8057db1:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 8057db4:	85 c0                	test   %eax,%eax
 8057db6:	74 0d                	je     8057dc5 <nbr_lookup.constprop.0+0x4a>
	for (i = 0; i < CONFIG_NET_IPV6_MAX_NEIGHBORS; i++) {
 8057db8:	43                   	inc    %ebx
 8057db9:	83 c6 48             	add    $0x48,%esi
 8057dbc:	83 fb 08             	cmp    $0x8,%ebx
 8057dbf:	75 cc                	jne    8057d8d <nbr_lookup.constprop.0+0x12>
	return NULL;
 8057dc1:	31 c0                	xor    %eax,%eax
 8057dc3:	eb 08                	jmp    8057dcd <nbr_lookup.constprop.0+0x52>
	return &net_neighbor_pool[idx].nbr;
 8057dc5:	6b c3 48             	imul   $0x48,%ebx,%eax
 8057dc8:	05 a0 61 06 08       	add    $0x80661a0,%eax
}
 8057dcd:	8d 65 f4             	lea    -0xc(%ebp),%esp
 8057dd0:	5b                   	pop    %ebx
 8057dd1:	5e                   	pop    %esi
 8057dd2:	5f                   	pop    %edi
 8057dd3:	5d                   	pop    %ebp
 8057dd4:	c3                   	ret    

08057dd5 <read_llao>:
{
 8057dd5:	55                   	push   %ebp
 8057dd6:	89 e5                	mov    %esp,%ebp
 8057dd8:	57                   	push   %edi
 8057dd9:	89 cf                	mov    %ecx,%edi
 8057ddb:	56                   	push   %esi
 8057ddc:	89 d6                	mov    %edx,%esi
		llstorage->len = net_pkt_lladdr_src(pkt)->len;
 8057dde:	ba 06 00 00 00       	mov    $0x6,%edx
{
 8057de3:	53                   	push   %ebx
 8057de4:	89 c3                	mov    %eax,%ebx
 8057de6:	83 ec 10             	sub    $0x10,%esp
	llstorage->len = NET_LINK_ADDR_MAX_LENGTH;
 8057de9:	c6 41 01 06          	movb   $0x6,0x1(%ecx)
	if (net_pkt_lladdr_src(pkt)->len < llstorage->len) {
 8057ded:	0f b6 40 24          	movzbl 0x24(%eax),%eax
		llstorage->len = net_pkt_lladdr_src(pkt)->len;
 8057df1:	38 d0                	cmp    %dl,%al
 8057df3:	0f 47 c2             	cmova  %edx,%eax
	if (net_pkt_read(pkt, llstorage->addr, llstorage->len)) {
 8057df6:	50                   	push   %eax
 8057df7:	88 41 01             	mov    %al,0x1(%ecx)
 8057dfa:	8d 41 02             	lea    0x2(%ecx),%eax
 8057dfd:	50                   	push   %eax
 8057dfe:	53                   	push   %ebx
 8057dff:	e8 16 d7 ff ff       	call   805551a <net_pkt_read>
 8057e04:	83 c4 10             	add    $0x10,%esp
		return false;
 8057e07:	31 d2                	xor    %edx,%edx
	if (net_pkt_read(pkt, llstorage->addr, llstorage->len)) {
 8057e09:	85 c0                	test   %eax,%eax
 8057e0b:	75 22                	jne    8057e2f <read_llao+0x5a>
	padding = len * 8U - 2 - llstorage->len;
 8057e0d:	8d 04 f5 fe ff ff ff 	lea    -0x2(,%esi,8),%eax
	return true;
 8057e14:	b2 01                	mov    $0x1,%dl
	if (padding) {
 8057e16:	2a 47 01             	sub    0x1(%edi),%al
 8057e19:	74 14                	je     8057e2f <read_llao+0x5a>
		if (net_pkt_skip(pkt, padding)) {
 8057e1b:	0f b6 c0             	movzbl %al,%eax
 8057e1e:	52                   	push   %edx
 8057e1f:	52                   	push   %edx
 8057e20:	50                   	push   %eax
 8057e21:	53                   	push   %ebx
 8057e22:	e8 4a d5 ff ff       	call   8055371 <net_pkt_skip>
 8057e27:	83 c4 10             	add    $0x10,%esp
 8057e2a:	85 c0                	test   %eax,%eax
 8057e2c:	0f 94 c2             	sete   %dl
}
 8057e2f:	8d 65 f4             	lea    -0xc(%ebp),%esp
 8057e32:	89 d0                	mov    %edx,%eax
 8057e34:	5b                   	pop    %ebx
 8057e35:	5e                   	pop    %esi
 8057e36:	5f                   	pop    %edi
 8057e37:	5d                   	pop    %ebp
 8057e38:	c3                   	ret    

08057e39 <net_pkt_acknowledge_data.isra.0>:
static inline int net_pkt_acknowledge_data(struct net_pkt *pkt,
 8057e39:	55                   	push   %ebp
 8057e3a:	89 e5                	mov    %esp,%ebp
 8057e3c:	83 ec 10             	sub    $0x10,%esp
	return net_pkt_skip(pkt, access->size);
 8057e3f:	52                   	push   %edx
 8057e40:	50                   	push   %eax
 8057e41:	e8 2b d5 ff ff       	call   8055371 <net_pkt_skip>
 8057e46:	83 c4 10             	add    $0x10,%esp
}
 8057e49:	c9                   	leave  
 8057e4a:	c3                   	ret    

08057e4b <net_linkaddr_set.isra.0>:
static inline int net_linkaddr_set(struct net_linkaddr_storage *lladdr_store,
 8057e4b:	55                   	push   %ebp
	if (!lladdr_store || !new_addr) {
 8057e4c:	85 d2                	test   %edx,%edx
static inline int net_linkaddr_set(struct net_linkaddr_storage *lladdr_store,
 8057e4e:	89 e5                	mov    %esp,%ebp
 8057e50:	57                   	push   %edi
 8057e51:	89 c7                	mov    %eax,%edi
 8057e53:	56                   	push   %esi
 8057e54:	89 d6                	mov    %edx,%esi
	if (!lladdr_store || !new_addr) {
 8057e56:	0f 94 c2             	sete   %dl
	if (new_len > NET_LINK_ADDR_MAX_LENGTH) {
 8057e59:	80 f9 06             	cmp    $0x6,%cl
 8057e5c:	0f 97 c0             	seta   %al
 8057e5f:	08 d0                	or     %dl,%al
 8057e61:	75 11                	jne    8057e74 <net_linkaddr_set.isra.0+0x29>
 8057e63:	85 ff                	test   %edi,%edi
 8057e65:	74 0d                	je     8057e74 <net_linkaddr_set.isra.0+0x29>
 8057e67:	8d 47 02             	lea    0x2(%edi),%eax
	lladdr_store->len = new_len;
 8057e6a:	88 4f 01             	mov    %cl,0x1(%edi)
	memcpy(lladdr_store->addr, new_addr, new_len);
 8057e6d:	0f b6 c9             	movzbl %cl,%ecx
 8057e70:	89 c7                	mov    %eax,%edi
 8057e72:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)

	return 0;
}
 8057e74:	5e                   	pop    %esi
 8057e75:	5f                   	pop    %edi
 8057e76:	5d                   	pop    %ebp
 8057e77:	c3                   	ret    

08057e78 <net_neighbor_table_clear>:
 8057e78:	c3                   	ret    

08057e79 <ipv6_nbr_set_state>:
{
 8057e79:	55                   	push   %ebp
 8057e7a:	89 e5                	mov    %esp,%ebp
 8057e7c:	56                   	push   %esi
 8057e7d:	89 c6                	mov    %eax,%esi
 8057e7f:	89 d0                	mov    %edx,%eax
 8057e81:	8b 4e 0c             	mov    0xc(%esi),%ecx
 8057e84:	53                   	push   %ebx
	if (new_state == net_ipv6_nbr_data(nbr)->state ||
 8057e85:	8b 51 28             	mov    0x28(%ecx),%edx
 8057e88:	83 fa 05             	cmp    $0x5,%edx
 8057e8b:	0f 94 c3             	sete   %bl
 8057e8e:	39 c2                	cmp    %eax,%edx
 8057e90:	0f 94 c2             	sete   %dl
 8057e93:	08 d3                	or     %dl,%bl
 8057e95:	0f 85 83 00 00 00    	jne    8057f1e <ipv6_nbr_set_state+0xa5>
	net_ipv6_nbr_data(nbr)->state = new_state;
 8057e9b:	89 41 28             	mov    %eax,0x28(%ecx)
 8057e9e:	8b 56 0c             	mov    0xc(%esi),%edx
	if (net_ipv6_nbr_data(nbr)->state == NET_IPV6_NBR_STATE_STALE) {
 8057ea1:	83 7a 28 02          	cmpl   $0x2,0x28(%edx)
 8057ea5:	75 77                	jne    8057f1e <ipv6_nbr_set_state+0xa5>
		if (stale_counter + 1 != UINT32_MAX) {
 8057ea7:	a1 54 8a 06 08       	mov    0x8068a54,%eax
 8057eac:	83 f8 fe             	cmp    $0xfffffffe,%eax
 8057eaf:	74 0e                	je     8057ebf <ipv6_nbr_set_state+0x46>
			net_ipv6_nbr_data(nbr)->stale_counter = stale_counter++;
 8057eb1:	8d 48 01             	lea    0x1(%eax),%ecx
 8057eb4:	89 42 30             	mov    %eax,0x30(%edx)
 8057eb7:	89 0d 54 8a 06 08    	mov    %ecx,0x8068a54
 8057ebd:	eb 5f                	jmp    8057f1e <ipv6_nbr_set_state+0xa5>
	return z_impl_k_sem_take(sem, timeout);
 8057ebf:	50                   	push   %eax
 8057ec0:	6a ff                	push   $0xffffffff
 8057ec2:	6a ff                	push   $0xffffffff
 8057ec4:	68 3c 8a 06 08       	push   $0x8068a3c
 8057ec9:	e8 e4 77 00 00       	call   805f6b2 <z_impl_k_sem_take>
 8057ece:	83 c4 10             	add    $0x10,%esp
			stale_counter = 0U;
 8057ed1:	ba a0 61 06 08       	mov    $0x80661a0,%edx
 8057ed6:	31 c0                	xor    %eax,%eax
 8057ed8:	c7 05 54 8a 06 08 00 	movl   $0x0,0x8068a54
 8057edf:	00 00 00 
				if (!n || !n->ref) {
 8057ee2:	80 3a 00             	cmpb   $0x0,(%edx)
 8057ee5:	74 13                	je     8057efa <ipv6_nbr_set_state+0x81>
 8057ee7:	8b 4e 0c             	mov    0xc(%esi),%ecx
				if (!data) {
 8057eea:	85 c9                	test   %ecx,%ecx
 8057eec:	74 0c                	je     8057efa <ipv6_nbr_set_state+0x81>
				if (data->state != NET_IPV6_NBR_STATE_STALE) {
 8057eee:	83 79 28 02          	cmpl   $0x2,0x28(%ecx)
 8057ef2:	75 06                	jne    8057efa <ipv6_nbr_set_state+0x81>
				data->stale_counter = stale_counter++;
 8057ef4:	89 41 30             	mov    %eax,0x30(%ecx)
 8057ef7:	b3 01                	mov    $0x1,%bl
 8057ef9:	40                   	inc    %eax
			for (i = 0; i < CONFIG_NET_IPV6_MAX_NEIGHBORS; i++) {
 8057efa:	83 c2 48             	add    $0x48,%edx
 8057efd:	81 fa e0 63 06 08    	cmp    $0x80663e0,%edx
 8057f03:	75 dd                	jne    8057ee2 <ipv6_nbr_set_state+0x69>
 8057f05:	84 db                	test   %bl,%bl
 8057f07:	74 05                	je     8057f0e <ipv6_nbr_set_state+0x95>
 8057f09:	a3 54 8a 06 08       	mov    %eax,0x8068a54
	z_impl_k_sem_give(sem);
 8057f0e:	83 ec 0c             	sub    $0xc,%esp
 8057f11:	68 3c 8a 06 08       	push   $0x8068a3c
 8057f16:	e8 2f 77 00 00       	call   805f64a <z_impl_k_sem_give>
 8057f1b:	83 c4 10             	add    $0x10,%esp
}
 8057f1e:	8d 65 f8             	lea    -0x8(%ebp),%esp
 8057f21:	5b                   	pop    %ebx
 8057f22:	5e                   	pop    %esi
 8057f23:	5d                   	pop    %ebp
 8057f24:	c3                   	ret    

08057f25 <nbr_new>:
{
 8057f25:	55                   	push   %ebp
 8057f26:	89 e5                	mov    %esp,%ebp
 8057f28:	57                   	push   %edi
 8057f29:	89 c7                	mov    %eax,%edi
 8057f2b:	56                   	push   %esi
 8057f2c:	89 d6                	mov    %edx,%esi
 8057f2e:	53                   	push   %ebx
 8057f2f:	89 cb                	mov    %ecx,%ebx
 8057f31:	83 ec 48             	sub    $0x48,%esp
 8057f34:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 8057f3a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 8057f3d:	31 c0                	xor    %eax,%eax
	struct net_nbr *nbr = net_nbr_get(&net_neighbor.table);
 8057f3f:	68 b0 73 06 08       	push   $0x80673b0
 8057f44:	e8 11 f2 ff ff       	call   805715a <net_nbr_get>
 8057f49:	83 c4 10             	add    $0x10,%esp
	if (!nbr) {
 8057f4c:	85 c0                	test   %eax,%eax
 8057f4e:	74 6a                	je     8057fba <nbr_new+0x95>
	nbr->iface = iface;
 8057f50:	89 78 08             	mov    %edi,0x8(%eax)
	net_ipaddr_copy(&net_ipv6_nbr_data(nbr)->addr, addr);
 8057f53:	b9 04 00 00 00       	mov    $0x4,%ecx
 8057f58:	8d 7d d4             	lea    -0x2c(%ebp),%edi
	ipv6_nbr_set_state(nbr, state);
 8057f5b:	8b 55 08             	mov    0x8(%ebp),%edx
	nbr->idx = NET_NBR_LLADDR_UNKNOWN;
 8057f5e:	c6 40 01 ff          	movb   $0xff,0x1(%eax)
	net_ipaddr_copy(&net_ipv6_nbr_data(nbr)->addr, addr);
 8057f62:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
 8057f64:	8b 70 0c             	mov    0xc(%eax),%esi
 8057f67:	b9 04 00 00 00       	mov    $0x4,%ecx
	ipv6_nbr_set_state(nbr, state);
 8057f6c:	89 45 c4             	mov    %eax,-0x3c(%ebp)
	net_ipaddr_copy(&net_ipv6_nbr_data(nbr)->addr, addr);
 8057f6f:	8d 7e 04             	lea    0x4(%esi),%edi
 8057f72:	8d 75 d4             	lea    -0x2c(%ebp),%esi
 8057f75:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	ipv6_nbr_set_state(nbr, state);
 8057f77:	e8 fd fe ff ff       	call   8057e79 <ipv6_nbr_set_state>
 8057f7c:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 8057f7f:	8b 50 0c             	mov    0xc(%eax),%edx
	net_ipv6_nbr_data(nbr)->is_router = is_router;
 8057f82:	88 5a 2f             	mov    %bl,0x2f(%edx)
 8057f85:	8b 50 0c             	mov    0xc(%eax),%edx
	net_ipv6_nbr_data(nbr)->pending = NULL;
 8057f88:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
 8057f8e:	8b 50 0c             	mov    0xc(%eax),%edx
	net_ipv6_nbr_data(nbr)->send_ns = 0;
 8057f91:	c7 42 20 00 00 00 00 	movl   $0x0,0x20(%edx)
 8057f98:	c7 42 24 00 00 00 00 	movl   $0x0,0x24(%edx)
 8057f9f:	8b 50 0c             	mov    0xc(%eax),%edx
	net_ipv6_nbr_data(nbr)->reachable = 0;
 8057fa2:	c7 42 14 00 00 00 00 	movl   $0x0,0x14(%edx)
 8057fa9:	c7 42 18 00 00 00 00 	movl   $0x0,0x18(%edx)
 8057fb0:	8b 50 0c             	mov    0xc(%eax),%edx
	net_ipv6_nbr_data(nbr)->reachable_timeout = 0;
 8057fb3:	c7 42 1c 00 00 00 00 	movl   $0x0,0x1c(%edx)
}
 8057fba:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 8057fbd:	65 2b 15 14 00 00 00 	sub    %gs:0x14,%edx
 8057fc4:	74 05                	je     8057fcb <nbr_new+0xa6>
 8057fc6:	e8 35 13 ff ff       	call   8049300 <__stack_chk_fail@plt>
 8057fcb:	8d 65 f4             	lea    -0xc(%ebp),%esp
 8057fce:	5b                   	pop    %ebx
 8057fcf:	5e                   	pop    %esi
 8057fd0:	5f                   	pop    %edi
 8057fd1:	5d                   	pop    %ebp
 8057fd2:	c3                   	ret    

08057fd3 <net_ipv6_nbr_rm>:
{
 8057fd3:	55                   	push   %ebp
 8057fd4:	89 e5                	mov    %esp,%ebp
 8057fd6:	57                   	push   %edi
 8057fd7:	56                   	push   %esi
 8057fd8:	53                   	push   %ebx
 8057fd9:	83 ec 0c             	sub    $0xc,%esp
 8057fdc:	8b 75 08             	mov    0x8(%ebp),%esi
 8057fdf:	8b 7d 0c             	mov    0xc(%ebp),%edi
	nbr = nbr_lookup(&net_neighbor.table, iface, addr);
 8057fe2:	89 f0                	mov    %esi,%eax
 8057fe4:	89 fa                	mov    %edi,%edx
 8057fe6:	e8 90 fd ff ff       	call   8057d7b <nbr_lookup.constprop.0>
 8057feb:	89 c3                	mov    %eax,%ebx
	if (!nbr) {
 8057fed:	31 c0                	xor    %eax,%eax
 8057fef:	85 db                	test   %ebx,%ebx
 8057ff1:	74 15                	je     8058008 <net_ipv6_nbr_rm+0x35>
	net_route_del_by_nexthop(iface, addr);
 8057ff3:	50                   	push   %eax
 8057ff4:	50                   	push   %eax
 8057ff5:	57                   	push   %edi
 8057ff6:	56                   	push   %esi
 8057ff7:	e8 bf 21 00 00       	call   805a1bb <net_route_del_by_nexthop>
	nbr_free(nbr);
 8057ffc:	89 d8                	mov    %ebx,%eax
	net_route_del_by_nexthop(iface, addr);
 8057ffe:	83 c4 10             	add    $0x10,%esp
	nbr_free(nbr);
 8058001:	e8 c9 fa ff ff       	call   8057acf <nbr_free>
	return true;
 8058006:	b0 01                	mov    $0x1,%al
}
 8058008:	8d 65 f4             	lea    -0xc(%ebp),%esp
 805800b:	5b                   	pop    %ebx
 805800c:	5e                   	pop    %esi
 805800d:	5f                   	pop    %edi
 805800e:	5d                   	pop    %ebp
 805800f:	c3                   	ret    

08058010 <add_nbr>:
{
 8058010:	55                   	push   %ebp
 8058011:	89 e5                	mov    %esp,%ebp
 8058013:	57                   	push   %edi
 8058014:	56                   	push   %esi
 8058015:	53                   	push   %ebx
 8058016:	89 cb                	mov    %ecx,%ebx
 8058018:	83 ec 1c             	sub    $0x1c,%esp
 805801b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 805801e:	8b 75 08             	mov    0x8(%ebp),%esi
 8058021:	89 55 e0             	mov    %edx,-0x20(%ebp)
	nbr = nbr_lookup(&net_neighbor.table, iface, addr);
 8058024:	e8 52 fd ff ff       	call   8057d7b <nbr_lookup.constprop.0>
	if (nbr) {
 8058029:	85 c0                	test   %eax,%eax
 805802b:	0f 85 ba 00 00 00    	jne    80580eb <add_nbr+0xdb>
	nbr = nbr_new(iface, addr, is_router, state);
 8058031:	83 ec 0c             	sub    $0xc,%esp
 8058034:	8b 55 e0             	mov    -0x20(%ebp),%edx
 8058037:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 805803a:	0f b6 db             	movzbl %bl,%ebx
 805803d:	56                   	push   %esi
 805803e:	89 d9                	mov    %ebx,%ecx
 8058040:	e8 e0 fe ff ff       	call   8057f25 <nbr_new>
 8058045:	83 c4 10             	add    $0x10,%esp
	if (nbr) {
 8058048:	85 c0                	test   %eax,%eax
 805804a:	0f 85 9b 00 00 00    	jne    80580eb <add_nbr+0xdb>
	return z_impl_k_sem_take(sem, timeout);
 8058050:	51                   	push   %ecx
	uint32_t oldest = UINT32_MAX;
 8058051:	83 cf ff             	or     $0xffffffff,%edi
 8058054:	6a ff                	push   $0xffffffff
 8058056:	6a ff                	push   $0xffffffff
 8058058:	68 3c 8a 06 08       	push   $0x8068a3c
 805805d:	e8 50 76 00 00       	call   805f6b2 <z_impl_k_sem_take>
 8058062:	83 c4 10             	add    $0x10,%esp
	int nbr_idx = -1;
 8058065:	83 c8 ff             	or     $0xffffffff,%eax
	for (i = 0; i < CONFIG_NET_IPV6_MAX_NEIGHBORS; i++) {
 8058068:	31 d2                	xor    %edx,%edx
		if (!nbr || !nbr->ref) {
 805806a:	6b ca 48             	imul   $0x48,%edx,%ecx
 805806d:	80 b9 a0 61 06 08 00 	cmpb   $0x0,0x80661a0(%ecx)
 8058074:	74 26                	je     805809c <add_nbr+0x8c>
 8058076:	8b 89 ac 61 06 08    	mov    0x80661ac(%ecx),%ecx
		if (!data || data->is_router ||
 805807c:	85 c9                	test   %ecx,%ecx
 805807e:	74 1c                	je     805809c <add_nbr+0x8c>
 8058080:	80 79 2f 00          	cmpb   $0x0,0x2f(%ecx)
 8058084:	75 16                	jne    805809c <add_nbr+0x8c>
 8058086:	83 79 28 02          	cmpl   $0x2,0x28(%ecx)
 805808a:	75 10                	jne    805809c <add_nbr+0x8c>
		if (nbr_idx == -1) {
 805808c:	83 f8 ff             	cmp    $0xffffffff,%eax
 805808f:	8b 49 30             	mov    0x30(%ecx),%ecx
 8058092:	74 04                	je     8058098 <add_nbr+0x88>
		if (oldest == MIN(oldest, data->stale_counter)) {
 8058094:	39 f9                	cmp    %edi,%ecx
 8058096:	73 04                	jae    805809c <add_nbr+0x8c>
 8058098:	89 cf                	mov    %ecx,%edi
 805809a:	89 d0                	mov    %edx,%eax
	for (i = 0; i < CONFIG_NET_IPV6_MAX_NEIGHBORS; i++) {
 805809c:	42                   	inc    %edx
 805809d:	83 fa 08             	cmp    $0x8,%edx
 80580a0:	75 c8                	jne    805806a <add_nbr+0x5a>
	if (nbr_idx != -1) {
 80580a2:	83 f8 ff             	cmp    $0xffffffff,%eax
 80580a5:	74 1d                	je     80580c4 <add_nbr+0xb4>
 80580a7:	6b c0 48             	imul   $0x48,%eax,%eax
		net_ipv6_nbr_rm(nbr->iface,
 80580aa:	52                   	push   %edx
 80580ab:	52                   	push   %edx
 80580ac:	8b b8 ac 61 06 08    	mov    0x80661ac(%eax),%edi
 80580b2:	8d 57 04             	lea    0x4(%edi),%edx
 80580b5:	52                   	push   %edx
 80580b6:	ff b0 a8 61 06 08    	push   0x80661a8(%eax)
 80580bc:	e8 12 ff ff ff       	call   8057fd3 <net_ipv6_nbr_rm>
 80580c1:	83 c4 10             	add    $0x10,%esp
	z_impl_k_sem_give(sem);
 80580c4:	83 ec 0c             	sub    $0xc,%esp
 80580c7:	68 3c 8a 06 08       	push   $0x8068a3c
 80580cc:	e8 79 75 00 00       	call   805f64a <z_impl_k_sem_give>
	nbr = nbr_new(iface, addr, is_router, state);
 80580d1:	89 75 08             	mov    %esi,0x8(%ebp)
 80580d4:	8b 55 e0             	mov    -0x20(%ebp),%edx
 80580d7:	83 c4 10             	add    $0x10,%esp
 80580da:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
 80580dd:	8d 65 f4             	lea    -0xc(%ebp),%esp
	nbr = nbr_new(iface, addr, is_router, state);
 80580e0:	89 d9                	mov    %ebx,%ecx
}
 80580e2:	5b                   	pop    %ebx
 80580e3:	5e                   	pop    %esi
 80580e4:	5f                   	pop    %edi
 80580e5:	5d                   	pop    %ebp
	nbr = nbr_new(iface, addr, is_router, state);
 80580e6:	e9 3a fe ff ff       	jmp    8057f25 <nbr_new>
}
 80580eb:	8d 65 f4             	lea    -0xc(%ebp),%esp
 80580ee:	5b                   	pop    %ebx
 80580ef:	5e                   	pop    %esi
 80580f0:	5f                   	pop    %edi
 80580f1:	5d                   	pop    %ebp
 80580f2:	c3                   	ret    

080580f3 <net_ipv6_nbr_lookup>:
{
 80580f3:	55                   	push   %ebp
 80580f4:	89 e5                	mov    %esp,%ebp
	return nbr_lookup(&net_neighbor.table, iface, addr);
 80580f6:	8b 55 0c             	mov    0xc(%ebp),%edx
 80580f9:	8b 45 08             	mov    0x8(%ebp),%eax
}
 80580fc:	5d                   	pop    %ebp
	return nbr_lookup(&net_neighbor.table, iface, addr);
 80580fd:	e9 79 fc ff ff       	jmp    8057d7b <nbr_lookup.constprop.0>

08058102 <net_ipv6_send_na>:
{
 8058102:	55                   	push   %ebp
 8058103:	89 e5                	mov    %esp,%ebp
 8058105:	57                   	push   %edi
 8058106:	56                   	push   %esi
		return -ENOMEM;
 8058107:	be f4 ff ff ff       	mov    $0xfffffff4,%esi
{
 805810c:	53                   	push   %ebx
 805810d:	83 ec 44             	sub    $0x44,%esp
 8058110:	8b 45 08             	mov    0x8(%ebp),%eax
 8058113:	8b 55 10             	mov    0x10(%ebp),%edx
 8058116:	8b 7d 0c             	mov    0xc(%ebp),%edi
 8058119:	89 45 d4             	mov    %eax,-0x2c(%ebp)
 805811c:	8b 45 14             	mov    0x14(%ebp),%eax
 805811f:	89 55 d0             	mov    %edx,-0x30(%ebp)
 8058122:	89 45 c8             	mov    %eax,-0x38(%ebp)
 8058125:	8b 45 18             	mov    0x18(%ebp),%eax
 8058128:	89 45 c4             	mov    %eax,-0x3c(%ebp)
 805812b:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 8058131:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 8058134:	31 c0                	xor    %eax,%eax
	uint8_t total_len = net_if_get_link_addr(iface)->len +
 8058136:	8b 45 d4             	mov    -0x2c(%ebp),%eax
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(na_access,
 8058139:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
 8058140:	c7 45 e0 14 00 00 00 	movl   $0x14,-0x20(%ebp)
	uint8_t total_len = net_if_get_link_addr(iface)->len +
 8058147:	8b 00                	mov    (%eax),%eax
	return ROUND_UP(total_len, 8U);
 8058149:	8a 40 14             	mov    0x14(%eax),%al
	pkt = net_pkt_alloc_with_buffer(iface,
 805814c:	6a 00                	push   $0x0
 805814e:	6a 0a                	push   $0xa
	return ROUND_UP(total_len, 8U);
 8058150:	83 c0 09             	add    $0x9,%eax
	pkt = net_pkt_alloc_with_buffer(iface,
 8058153:	6a 3a                	push   $0x3a
 8058155:	25 f8 00 00 00       	and    $0xf8,%eax
 805815a:	6a 02                	push   $0x2
 805815c:	89 45 cc             	mov    %eax,-0x34(%ebp)
 805815f:	83 c0 14             	add    $0x14,%eax
 8058162:	50                   	push   %eax
 8058163:	ff 75 d4             	push   -0x2c(%ebp)
 8058166:	e8 9c d1 ff ff       	call   8055307 <net_pkt_alloc_with_buffer>
 805816b:	83 c4 20             	add    $0x20,%esp
	if (!pkt) {
 805816e:	85 c0                	test   %eax,%eax
 8058170:	0f 84 da 00 00 00    	je     8058250 <net_ipv6_send_na+0x14e>
	if (net_ipv6_create(pkt, src, dst) ||
 8058176:	8b 55 d0             	mov    -0x30(%ebp),%edx
 8058179:	89 c3                	mov    %eax,%ebx
	pkt->ipv6_hop_limit = hop_limit;
 805817b:	c6 40 35 ff          	movb   $0xff,0x35(%eax)
 805817f:	50                   	push   %eax
 8058180:	52                   	push   %edx
 8058181:	57                   	push   %edi
 8058182:	53                   	push   %ebx
 8058183:	e8 ca f1 ff ff       	call   8057352 <net_ipv6_create>
 8058188:	83 c4 10             	add    $0x10,%esp
 805818b:	85 c0                	test   %eax,%eax
 805818d:	74 0a                	je     8058199 <net_ipv6_send_na+0x97>
	int ret = -ENOBUFS;
 805818f:	be 97 ff ff ff       	mov    $0xffffff97,%esi
 8058194:	e9 ab 00 00 00       	jmp    8058244 <net_ipv6_send_na+0x142>
	    net_icmpv6_create(pkt, NET_ICMPV6_NA, 0)) {
 8058199:	57                   	push   %edi
 805819a:	6a 00                	push   $0x0
 805819c:	68 88 00 00 00       	push   $0x88
 80581a1:	53                   	push   %ebx
 80581a2:	e8 bb ea ff ff       	call   8056c62 <net_icmpv6_create>
 80581a7:	83 c4 10             	add    $0x10,%esp
 80581aa:	89 45 d0             	mov    %eax,-0x30(%ebp)
	if (net_ipv6_create(pkt, src, dst) ||
 80581ad:	85 c0                	test   %eax,%eax
 80581af:	75 de                	jne    805818f <net_ipv6_send_na+0x8d>
	na_hdr = (struct net_icmpv6_na_hdr *)net_pkt_get_data(pkt, &na_access);
 80581b1:	8d 55 dc             	lea    -0x24(%ebp),%edx
 80581b4:	56                   	push   %esi
 80581b5:	56                   	push   %esi
 80581b6:	52                   	push   %edx
 80581b7:	53                   	push   %ebx
 80581b8:	e8 15 d7 ff ff       	call   80558d2 <net_pkt_get_data>
 80581bd:	83 c4 10             	add    $0x10,%esp
 80581c0:	89 c6                	mov    %eax,%esi
	if (!na_hdr) {
 80581c2:	85 c0                	test   %eax,%eax
 80581c4:	74 c9                	je     805818f <net_ipv6_send_na+0x8d>
  return __builtin___memset_chk (__dest, __ch, __len,
 80581c6:	89 c7                	mov    %eax,%edi
 80581c8:	8b 45 d0             	mov    -0x30(%ebp),%eax
 80581cb:	b9 05 00 00 00       	mov    $0x5,%ecx
	if (net_pkt_set_data(pkt, &na_access)) {
 80581d0:	8d 55 dc             	lea    -0x24(%ebp),%edx
 80581d3:	f3 ab                	rep stos %eax,%es:(%edi)
	na_hdr->flags = flags;
 80581d5:	8a 45 c4             	mov    -0x3c(%ebp),%al
  return __builtin___memcpy_chk (__dest, __src, __len,
 80581d8:	b9 04 00 00 00       	mov    $0x4,%ecx
 80581dd:	88 06                	mov    %al,(%esi)
 80581df:	8d 46 04             	lea    0x4(%esi),%eax
 80581e2:	8b 75 c8             	mov    -0x38(%ebp),%esi
 80581e5:	89 c7                	mov    %eax,%edi
 80581e7:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	if (net_pkt_set_data(pkt, &na_access)) {
 80581e9:	51                   	push   %ecx
 80581ea:	51                   	push   %ecx
 80581eb:	52                   	push   %edx
 80581ec:	53                   	push   %ebx
 80581ed:	e8 44 d7 ff ff       	call   8055936 <net_pkt_set_data>
 80581f2:	83 c4 10             	add    $0x10,%esp
 80581f5:	89 c6                	mov    %eax,%esi
 80581f7:	85 c0                	test   %eax,%eax
 80581f9:	75 94                	jne    805818f <net_ipv6_send_na+0x8d>
	return &iface->if_dev->link_addr;
 80581fb:	8b 45 d4             	mov    -0x2c(%ebp),%eax
	if (!set_llao(pkt, net_if_get_link_addr(iface),
 80581fe:	83 ec 0c             	sub    $0xc,%esp
 8058201:	8b 4d cc             	mov    -0x34(%ebp),%ecx
 8058204:	8b 10                	mov    (%eax),%edx
 8058206:	6a 02                	push   $0x2
 8058208:	89 d8                	mov    %ebx,%eax
 805820a:	83 c2 10             	add    $0x10,%edx
 805820d:	e8 8f fa ff ff       	call   8057ca1 <set_llao>
 8058212:	83 c4 10             	add    $0x10,%esp
 8058215:	84 c0                	test   %al,%al
 8058217:	0f 84 72 ff ff ff    	je     805818f <net_ipv6_send_na+0x8d>
	net_pkt_cursor_init(pkt);
 805821d:	83 ec 0c             	sub    $0xc,%esp
 8058220:	53                   	push   %ebx
 8058221:	e8 2e cd ff ff       	call   8054f54 <net_pkt_cursor_init>
 8058226:	58                   	pop    %eax
 8058227:	5a                   	pop    %edx
	net_ipv6_finalize(pkt, IPPROTO_ICMPV6);
 8058228:	6a 3a                	push   $0x3a
 805822a:	53                   	push   %ebx
 805822b:	e8 fd f1 ff ff       	call   805742d <net_ipv6_finalize>
	if (net_send_data(pkt) < 0) {
 8058230:	89 1c 24             	mov    %ebx,(%esp)
 8058233:	e8 f8 81 ff ff       	call   8050430 <net_send_data>
 8058238:	83 c4 10             	add    $0x10,%esp
 805823b:	85 c0                	test   %eax,%eax
 805823d:	79 11                	jns    8058250 <net_ipv6_send_na+0x14e>
		ret = -EINVAL;
 805823f:	be ea ff ff ff       	mov    $0xffffffea,%esi
	net_pkt_unref(pkt);
 8058244:	83 ec 0c             	sub    $0xc,%esp
 8058247:	53                   	push   %ebx
 8058248:	e8 9b cb ff ff       	call   8054de8 <net_pkt_unref>
 805824d:	83 c4 10             	add    $0x10,%esp
}
 8058250:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8058253:	65 2b 05 14 00 00 00 	sub    %gs:0x14,%eax
 805825a:	74 05                	je     8058261 <net_ipv6_send_na+0x15f>
 805825c:	e8 9f 10 ff ff       	call   8049300 <__stack_chk_fail@plt>
 8058261:	8d 65 f4             	lea    -0xc(%ebp),%esp
 8058264:	89 f0                	mov    %esi,%eax
 8058266:	5b                   	pop    %ebx
 8058267:	5e                   	pop    %esi
 8058268:	5f                   	pop    %edi
 8058269:	5d                   	pop    %ebp
 805826a:	c3                   	ret    

0805826b <net_ipv6_nbr_set_reachable_timer>:
	}
}

void net_ipv6_nbr_set_reachable_timer(struct net_if *iface,
				      struct net_nbr *nbr)
{
 805826b:	55                   	push   %ebp
 805826c:	89 e5                	mov    %esp,%ebp
	uint32_t time;

	time = net_if_ipv6_get_reachable_time(iface);
 805826e:	8b 55 08             	mov    0x8(%ebp),%edx
{
 8058271:	8b 45 0c             	mov    0xc(%ebp),%eax
 8058274:	8b 4a 04             	mov    0x4(%edx),%ecx
	if (!iface->config.ip.ipv6) {
 8058277:	31 d2                	xor    %edx,%edx
 8058279:	85 c9                	test   %ecx,%ecx
 805827b:	74 06                	je     8058283 <net_ipv6_nbr_set_reachable_timer+0x18>
	return iface->config.ip.ipv6->reachable_time;
 805827d:	8b 91 fc 00 00 00    	mov    0xfc(%ecx),%edx
	NET_ASSERT(time, "Zero reachable timeout!");

	NET_DBG("Starting reachable timer nbr %p data %p time %d ms",
		nbr, net_ipv6_nbr_data(nbr), time);

	ipv6_nd_restart_reachable_timer(nbr, time);
 8058283:	31 c9                	xor    %ecx,%ecx
}
 8058285:	5d                   	pop    %ebp
	ipv6_nd_restart_reachable_timer(nbr, time);
 8058286:	e9 a2 f8 ff ff       	jmp    8057b2d <ipv6_nd_restart_reachable_timer>

0805828b <handle_na_input>:
}

static enum net_verdict handle_na_input(struct net_pkt *pkt,
					struct net_ipv6_hdr *ip_hdr,
					struct net_icmp_hdr *icmp_hdr)
{
 805828b:	55                   	push   %ebp
 805828c:	89 e5                	mov    %esp,%ebp
 805828e:	57                   	push   %edi
 805828f:	56                   	push   %esi
 8058290:	53                   	push   %ebx
	size_t bytes = 0;
 8058291:	31 db                	xor    %ebx,%ebx
 8058293:	83 ec 4c             	sub    $0x4c,%esp
 8058296:	8b 75 08             	mov    0x8(%ebp),%esi
 8058299:	8b 55 0c             	mov    0xc(%ebp),%edx
 805829c:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 80582a2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 80582a5:	31 c0                	xor    %eax,%eax
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(na_access,
					      struct net_icmpv6_na_hdr);
	NET_PKT_DATA_ACCESS_DEFINE(nd_access, struct net_icmpv6_nd_opt_hdr);
 80582a7:	8d 45 c2             	lea    -0x3e(%ebp),%eax
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(na_access,
 80582aa:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
{
 80582b1:	8b 4d 10             	mov    0x10(%ebp),%ecx
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(na_access,
 80582b4:	c7 45 c8 14 00 00 00 	movl   $0x14,-0x38(%ebp)
	NET_PKT_DATA_ACCESS_DEFINE(nd_access, struct net_icmpv6_nd_opt_hdr);
 80582bb:	c7 45 d0 02 00 00 00 	movl   $0x2,-0x30(%ebp)
 80582c2:	89 45 cc             	mov    %eax,-0x34(%ebp)
 80582c5:	8b 46 08             	mov    0x8(%esi),%eax
	while (buf) {
 80582c8:	85 c0                	test   %eax,%eax
 80582ca:	74 0b                	je     80582d7 <handle_na_input+0x4c>
		bytes += buf->len;
 80582cc:	0f b7 78 10          	movzwl 0x10(%eax),%edi
		buf = buf->frags;
 80582d0:	8b 40 04             	mov    0x4(%eax),%eax
		bytes += buf->len;
 80582d3:	01 fb                	add    %edi,%ebx
		buf = buf->frags;
 80582d5:	eb f1                	jmp    80582c8 <handle_na_input+0x3d>
	uint16_t tllao_offset = 0U;
	struct net_icmpv6_nd_opt_hdr *nd_opt_hdr;
	struct net_icmpv6_na_hdr *na_hdr;
	struct net_if_addr *ifaddr;

	na_hdr = (struct net_icmpv6_na_hdr *)net_pkt_get_data(pkt, &na_access);
 80582d7:	50                   	push   %eax
	uint16_t length = net_pkt_get_len(pkt);
 80582d8:	89 df                	mov    %ebx,%edi
	na_hdr = (struct net_icmpv6_na_hdr *)net_pkt_get_data(pkt, &na_access);
 80582da:	50                   	push   %eax
 80582db:	8d 45 c4             	lea    -0x3c(%ebp),%eax
 80582de:	50                   	push   %eax
 80582df:	56                   	push   %esi
 80582e0:	89 4d ac             	mov    %ecx,-0x54(%ebp)
 80582e3:	89 55 b0             	mov    %edx,-0x50(%ebp)
 80582e6:	e8 e7 d5 ff ff       	call   80558d2 <net_pkt_get_data>
 80582eb:	83 c4 10             	add    $0x10,%esp
	if (!na_hdr) {
 80582ee:	8b 55 b0             	mov    -0x50(%ebp),%edx
 80582f1:	8b 4d ac             	mov    -0x54(%ebp),%ecx
 80582f4:	85 c0                	test   %eax,%eax
	na_hdr = (struct net_icmpv6_na_hdr *)net_pkt_get_data(pkt, &na_access);
 80582f6:	89 45 b4             	mov    %eax,-0x4c(%ebp)
	if (!na_hdr) {
 80582f9:	0f 84 42 02 00 00    	je     8058541 <handle_na_input+0x2b6>
	dbg_addr_recv_tgt("Neighbor Advertisement",
			  &ip_hdr->src, &ip_hdr->dst, &na_hdr->tgt, pkt);

	net_stats_update_ipv6_nd_recv(net_pkt_iface(pkt));

	if (((length < (sizeof(struct net_ipv6_hdr) +
 80582ff:	66 83 fb 41          	cmp    $0x41,%bx
 8058303:	76 1a                	jbe    805831f <handle_na_input+0x94>
			sizeof(struct net_icmp_hdr) +
			sizeof(struct net_icmpv6_na_hdr) +
			sizeof(struct net_icmpv6_nd_opt_hdr))) ||
 8058305:	80 7a 07 ff          	cmpb   $0xff,0x7(%edx)
 8058309:	75 14                	jne    805831f <handle_na_input+0x94>
	     (ip_hdr->hop_limit != NET_IPV6_ND_HOP_LIMIT) ||
 805830b:	8b 45 b4             	mov    -0x4c(%ebp),%eax
 805830e:	80 78 04 ff          	cmpb   $0xff,0x4(%eax)
 8058312:	74 0b                	je     805831f <handle_na_input+0x94>
	     net_ipv6_is_addr_mcast((struct in6_addr *)na_hdr->tgt) ||
 8058314:	f6 00 40             	testb  $0x40,(%eax)
 8058317:	74 10                	je     8058329 <handle_na_input+0x9e>
	     (na_hdr->flags & NET_ICMPV6_NA_FLAG_SOLICITED &&
 8058319:	80 7a 18 ff          	cmpb   $0xff,0x18(%edx)
 805831d:	75 0a                	jne    8058329 <handle_na_input+0x9e>
	      net_ipv6_is_addr_mcast((struct in6_addr *)ip_hdr->dst))) &&
 805831f:	80 79 01 00          	cmpb   $0x0,0x1(%ecx)
 8058323:	0f 85 18 02 00 00    	jne    8058541 <handle_na_input+0x2b6>
	    (icmp_hdr->code != 0U)) {
		goto drop;
	}

	net_pkt_acknowledge_data(pkt, &na_access);
 8058329:	8b 55 c8             	mov    -0x38(%ebp),%edx
 805832c:	89 f0                	mov    %esi,%eax

	net_pkt_set_ipv6_ext_opt_len(pkt, sizeof(struct net_icmpv6_na_hdr));
	length -= (sizeof(struct net_ipv6_hdr) + sizeof(struct net_icmp_hdr));
 805832e:	83 ef 2c             	sub    $0x2c,%edi
	net_pkt_acknowledge_data(pkt, &na_access);
 8058331:	e8 03 fb ff ff       	call   8057e39 <net_pkt_acknowledge_data.isra.0>
	pkt->ipv6_ext_opt_len = len;
 8058336:	c6 46 3a 14          	movb   $0x14,0x3a(%esi)

	nd_opt_hdr = (struct net_icmpv6_nd_opt_hdr *)
				net_pkt_get_data(pkt, &nd_access);
 805833a:	50                   	push   %eax
 805833b:	50                   	push   %eax
 805833c:	8d 45 cc             	lea    -0x34(%ebp),%eax
 805833f:	50                   	push   %eax
 8058340:	56                   	push   %esi
 8058341:	e8 8c d5 ff ff       	call   80558d2 <net_pkt_get_data>
	uint16_t tllao_offset = 0U;
 8058346:	66 c7 45 b0 00 00    	movw   $0x0,-0x50(%ebp)
				net_pkt_get_data(pkt, &nd_access);
 805834c:	83 c4 10             	add    $0x10,%esp

	while (nd_opt_hdr && nd_opt_hdr->len &&
 805834f:	85 c0                	test   %eax,%eax
 8058351:	74 52                	je     80583a5 <handle_na_input+0x11a>
 8058353:	8a 50 01             	mov    0x1(%eax),%dl
 8058356:	84 d2                	test   %dl,%dl
 8058358:	74 4b                	je     80583a5 <handle_na_input+0x11a>
	return pkt->ipv6_ext_opt_len;
 805835a:	0f b6 5e 3a          	movzbl 0x3a(%esi),%ebx
 805835e:	89 d9                	mov    %ebx,%ecx
 8058360:	66 39 fb             	cmp    %di,%bx
 8058363:	73 40                	jae    80583a5 <handle_na_input+0x11a>
	       net_pkt_ipv6_ext_opt_len(pkt) < length) {
		uint8_t prev_opt_len;

		switch (nd_opt_hdr->type) {
 8058365:	80 38 02             	cmpb   $0x2,(%eax)
 8058368:	75 12                	jne    805837c <handle_na_input+0xf1>
		case NET_ICMPV6_ND_OPT_TLLAO:
			tllao_offset = net_pkt_ip_hdr_len(pkt) +
 805836a:	66 8b 46 36          	mov    0x36(%esi),%ax
 805836e:	8d 44 03 06          	lea    0x6(%ebx,%eax,1),%eax
 8058372:	0f b6 5e 32          	movzbl 0x32(%esi),%ebx
 8058376:	01 d8                	add    %ebx,%eax
 8058378:	66 89 45 b0          	mov    %ax,-0x50(%ebp)
		}

		prev_opt_len = net_pkt_ipv6_ext_opt_len(pkt);

		net_pkt_set_ipv6_ext_opt_len(pkt,
					     net_pkt_ipv6_ext_opt_len(pkt) +
 805837c:	8d 14 d1             	lea    (%ecx,%edx,8),%edx
	pkt->ipv6_ext_opt_len = len;
 805837f:	88 56 3a             	mov    %dl,0x3a(%esi)
					     (nd_opt_hdr->len << 3));

		if (prev_opt_len >= net_pkt_ipv6_ext_opt_len(pkt)) {
 8058382:	38 ca                	cmp    %cl,%dl
 8058384:	0f 86 b7 01 00 00    	jbe    8058541 <handle_na_input+0x2b6>
			NET_ERR("DROP: Corrupted NA message");
			goto drop;
		}

		net_pkt_acknowledge_data(pkt, &nd_access);
 805838a:	8b 55 d0             	mov    -0x30(%ebp),%edx
 805838d:	89 f0                	mov    %esi,%eax
 805838f:	e8 a5 fa ff ff       	call   8057e39 <net_pkt_acknowledge_data.isra.0>
		nd_opt_hdr = (struct net_icmpv6_nd_opt_hdr *)
					net_pkt_get_data(pkt, &nd_access);
 8058394:	50                   	push   %eax
 8058395:	50                   	push   %eax
 8058396:	8d 45 cc             	lea    -0x34(%ebp),%eax
 8058399:	50                   	push   %eax
 805839a:	56                   	push   %esi
 805839b:	e8 32 d5 ff ff       	call   80558d2 <net_pkt_get_data>
 80583a0:	83 c4 10             	add    $0x10,%esp
 80583a3:	eb aa                	jmp    805834f <handle_na_input+0xc4>
	}

	ifaddr = net_if_ipv6_addr_lookup_by_iface(net_pkt_iface(pkt),
						  (struct in6_addr *)na_hdr->tgt);
 80583a5:	8b 45 b4             	mov    -0x4c(%ebp),%eax
	ifaddr = net_if_ipv6_addr_lookup_by_iface(net_pkt_iface(pkt),
 80583a8:	53                   	push   %ebx
 80583a9:	53                   	push   %ebx
						  (struct in6_addr *)na_hdr->tgt);
 80583aa:	8d 50 04             	lea    0x4(%eax),%edx
	ifaddr = net_if_ipv6_addr_lookup_by_iface(net_pkt_iface(pkt),
 80583ad:	52                   	push   %edx
 80583ae:	ff 76 18             	push   0x18(%esi)
 80583b1:	89 55 ac             	mov    %edx,-0x54(%ebp)
 80583b4:	e8 00 91 ff ff       	call   80514b9 <net_if_ipv6_addr_lookup_by_iface>
 80583b9:	83 c4 10             	add    $0x10,%esp
	if (ifaddr) {
 80583bc:	8b 55 ac             	mov    -0x54(%ebp),%edx
 80583bf:	85 c0                	test   %eax,%eax
 80583c1:	74 2d                	je     80583f0 <handle_na_input+0x165>
			net_pkt_iface(pkt),
			net_if_get_by_iface(net_pkt_iface(pkt)),
			net_sprint_ipv6_addr(&na_hdr->tgt));

#if defined(CONFIG_NET_IPV6_DAD)
		if (ifaddr->addr_state == NET_ADDR_TENTATIVE) {
 80583c3:	80 78 2d 00          	cmpb   $0x0,0x2d(%eax)
 80583c7:	0f 85 74 01 00 00    	jne    8058541 <handle_na_input+0x2b6>
	if (net_ipv6_is_ll_addr(addr)) {
 80583cd:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
	return pkt->iface;
 80583d0:	8b 46 18             	mov    0x18(%esi),%eax
 80583d3:	66 81 79 04 fe 80    	cmpw   $0x80fe,0x4(%ecx)
 80583d9:	0f 84 62 01 00 00    	je     8058541 <handle_na_input+0x2b6>
	net_if_ipv6_dad_failed(iface, addr);
 80583df:	51                   	push   %ecx
 80583e0:	51                   	push   %ecx
 80583e1:	52                   	push   %edx
 80583e2:	50                   	push   %eax
 80583e3:	e8 17 97 ff ff       	call   8051aff <net_if_ipv6_dad_failed>
 80583e8:	83 c4 10             	add    $0x10,%esp
	return true;
 80583eb:	e9 51 01 00 00       	jmp    8058541 <handle_na_input+0x2b6>
	struct net_linkaddr_storage lladdr = { 0 };
 80583f0:	8d 7d dc             	lea    -0x24(%ebp),%edi
 80583f3:	b9 02 00 00 00       	mov    $0x2,%ecx
 80583f8:	f3 ab                	rep stos %eax,%es:(%edi)
	nbr = nbr_lookup(&net_neighbor.table, net_pkt_iface(pkt),
 80583fa:	8b 46 18             	mov    0x18(%esi),%eax
 80583fd:	e8 79 f9 ff ff       	call   8057d7b <nbr_lookup.constprop.0>
 8058402:	89 c3                	mov    %eax,%ebx
	if (!nbr) {
 8058404:	85 c0                	test   %eax,%eax
 8058406:	0f 84 35 01 00 00    	je     8058541 <handle_na_input+0x2b6>
	if (tllao_offset) {
 805840c:	66 83 7d b0 00       	cmpw   $0x0,-0x50(%ebp)
 8058411:	75 08                	jne    805841b <handle_na_input+0x190>
	if (nbr->idx == NET_NBR_LLADDR_UNKNOWN) {
 8058413:	80 7b 01 ff          	cmpb   $0xff,0x1(%ebx)
 8058417:	74 45                	je     805845e <handle_na_input+0x1d3>
 8058419:	eb 7b                	jmp    8058496 <handle_na_input+0x20b>
		net_pkt_cursor_init(pkt);
 805841b:	83 ec 0c             	sub    $0xc,%esp
		lladdr.len = net_pkt_lladdr_src(pkt)->len;
 805841e:	8a 46 24             	mov    0x24(%esi),%al
		net_pkt_cursor_init(pkt);
 8058421:	56                   	push   %esi
		lladdr.len = net_pkt_lladdr_src(pkt)->len;
 8058422:	88 45 dd             	mov    %al,-0x23(%ebp)
		net_pkt_cursor_init(pkt);
 8058425:	e8 2a cb ff ff       	call   8054f54 <net_pkt_cursor_init>
 805842a:	58                   	pop    %eax
		if (net_pkt_skip(pkt, tllao_offset) ||
 805842b:	0f b7 45 b0          	movzwl -0x50(%ebp),%eax
		net_pkt_cursor_init(pkt);
 805842f:	5a                   	pop    %edx
		if (net_pkt_skip(pkt, tllao_offset) ||
 8058430:	50                   	push   %eax
 8058431:	56                   	push   %esi
 8058432:	e8 3a cf ff ff       	call   8055371 <net_pkt_skip>
 8058437:	83 c4 10             	add    $0x10,%esp
 805843a:	85 c0                	test   %eax,%eax
 805843c:	0f 85 ff 00 00 00    	jne    8058541 <handle_na_input+0x2b6>
		    net_pkt_read(pkt, lladdr.addr, lladdr.len)) {
 8058442:	0f b6 45 dd          	movzbl -0x23(%ebp),%eax
 8058446:	57                   	push   %edi
 8058447:	50                   	push   %eax
 8058448:	8d 45 de             	lea    -0x22(%ebp),%eax
 805844b:	50                   	push   %eax
 805844c:	56                   	push   %esi
 805844d:	e8 c8 d0 ff ff       	call   805551a <net_pkt_read>
 8058452:	83 c4 10             	add    $0x10,%esp
		if (net_pkt_skip(pkt, tllao_offset) ||
 8058455:	85 c0                	test   %eax,%eax
 8058457:	74 ba                	je     8058413 <handle_na_input+0x188>
 8058459:	e9 e3 00 00 00       	jmp    8058541 <handle_na_input+0x2b6>
		if (!tllao_offset) {
 805845e:	66 83 7d b0 00       	cmpw   $0x0,-0x50(%ebp)
 8058463:	0f 84 d8 00 00 00    	je     8058541 <handle_na_input+0x2b6>
		nbr_lladdr.len = lladdr.len;
 8058469:	8a 45 dd             	mov    -0x23(%ebp),%al
		if (net_nbr_link(nbr, net_pkt_iface(pkt), &nbr_lladdr)) {
 805846c:	51                   	push   %ecx
		nbr_lladdr.len = lladdr.len;
 805846d:	88 45 d8             	mov    %al,-0x28(%ebp)
		nbr_lladdr.addr = lladdr.addr;
 8058470:	8d 45 de             	lea    -0x22(%ebp),%eax
 8058473:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		if (net_nbr_link(nbr, net_pkt_iface(pkt), &nbr_lladdr)) {
 8058476:	8d 45 d4             	lea    -0x2c(%ebp),%eax
 8058479:	50                   	push   %eax
 805847a:	ff 76 18             	push   0x18(%esi)
 805847d:	53                   	push   %ebx
 805847e:	e8 17 ed ff ff       	call   805719a <net_nbr_link>
 8058483:	83 c4 10             	add    $0x10,%esp
 8058486:	85 c0                	test   %eax,%eax
 8058488:	74 0c                	je     8058496 <handle_na_input+0x20b>
			nbr_free(nbr);
 805848a:	89 d8                	mov    %ebx,%eax
 805848c:	e8 3e f6 ff ff       	call   8057acf <nbr_free>
			return false;
 8058491:	e9 ab 00 00 00       	jmp    8058541 <handle_na_input+0x2b6>
	cached_lladdr = net_nbr_get_lladdr(nbr->idx);
 8058496:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
 805849a:	83 ec 0c             	sub    $0xc,%esp
 805849d:	50                   	push   %eax
 805849e:	e8 2c ee ff ff       	call   80572cf <net_nbr_get_lladdr>
 80584a3:	83 c4 10             	add    $0x10,%esp
 80584a6:	89 c7                	mov    %eax,%edi
	if (!cached_lladdr) {
 80584a8:	85 c0                	test   %eax,%eax
 80584aa:	0f 84 91 00 00 00    	je     8058541 <handle_na_input+0x2b6>
	if (tllao_offset) {
 80584b0:	66 83 7d b0 00       	cmpw   $0x0,-0x50(%ebp)
	bool lladdr_changed = false;
 80584b5:	c6 45 ac 00          	movb   $0x0,-0x54(%ebp)
	if (tllao_offset) {
 80584b9:	74 1c                	je     80584d7 <handle_na_input+0x24c>
		lladdr_changed = memcmp(lladdr.addr,
 80584bb:	52                   	push   %edx
 80584bc:	0f b6 40 01          	movzbl 0x1(%eax),%eax
 80584c0:	50                   	push   %eax
 80584c1:	8d 47 02             	lea    0x2(%edi),%eax
 80584c4:	50                   	push   %eax
 80584c5:	8d 45 de             	lea    -0x22(%ebp),%eax
 80584c8:	50                   	push   %eax
 80584c9:	e8 a2 0b ff ff       	call   8049070 <memcmp@plt>
 80584ce:	83 c4 10             	add    $0x10,%esp
 80584d1:	85 c0                	test   %eax,%eax
 80584d3:	0f 95 45 ac          	setne  -0x54(%ebp)
	if (net_ipv6_nbr_data(nbr)->state == NET_IPV6_NBR_STATE_INCOMPLETE) {
 80584d7:	8b 43 0c             	mov    0xc(%ebx),%eax
 80584da:	8b 40 28             	mov    0x28(%eax),%eax
 80584dd:	85 c0                	test   %eax,%eax
 80584df:	75 43                	jne    8058524 <handle_na_input+0x299>
		if (!tllao_offset) {
 80584e1:	66 83 7d b0 00       	cmpw   $0x0,-0x50(%ebp)
 80584e6:	74 59                	je     8058541 <handle_na_input+0x2b6>
		if (lladdr_changed) {
 80584e8:	80 7d ac 00          	cmpb   $0x0,-0x54(%ebp)
 80584ec:	74 15                	je     8058503 <handle_na_input+0x278>
	dbg_update_neighbor_lladdr(&lladdr, old_lladdr, addr);
 80584ee:	89 f8                	mov    %edi,%eax
 80584f0:	e8 35 f8 ff ff       	call   8057d2a <dbg_update_neighbor_lladdr.constprop.0>
			net_linkaddr_set(cached_lladdr, lladdr.addr,
 80584f5:	0f b6 4f 01          	movzbl 0x1(%edi),%ecx
 80584f9:	8d 55 de             	lea    -0x22(%ebp),%edx
 80584fc:	89 f8                	mov    %edi,%eax
 80584fe:	e8 48 f9 ff ff       	call   8057e4b <net_linkaddr_set.isra.0>
		if (na_hdr->flags & NET_ICMPV6_NA_FLAG_SOLICITED) {
 8058503:	8b 45 b4             	mov    -0x4c(%ebp),%eax
 8058506:	f6 00 40             	testb  $0x40,(%eax)
 8058509:	0f 84 a5 00 00 00    	je     80585b4 <handle_na_input+0x329>
			ipv6_nbr_set_state(nbr, NET_IPV6_NBR_STATE_REACHABLE);
 805850f:	89 d8                	mov    %ebx,%eax
 8058511:	ba 01 00 00 00       	mov    $0x1,%edx
 8058516:	e8 5e f9 ff ff       	call   8057e79 <ipv6_nbr_set_state>
 805851b:	8b 43 0c             	mov    0xc(%ebx),%eax
			net_ipv6_nbr_data(nbr)->ns_count = 0U;
 805851e:	c6 40 2e 00          	movb   $0x0,0x2e(%eax)
 8058522:	eb 5f                	jmp    8058583 <handle_na_input+0x2f8>
	if (!(na_hdr->flags & NET_ICMPV6_NA_FLAG_OVERRIDE) && lladdr_changed) {
 8058524:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
 8058527:	f6 01 20             	testb  $0x20,(%ecx)
 805852a:	75 28                	jne    8058554 <handle_na_input+0x2c9>
 805852c:	80 7d ac 00          	cmpb   $0x0,-0x54(%ebp)
 8058530:	74 19                	je     805854b <handle_na_input+0x2c0>
		if (net_ipv6_nbr_data(nbr)->state ==
 8058532:	48                   	dec    %eax
 8058533:	75 0c                	jne    8058541 <handle_na_input+0x2b6>
			ipv6_nbr_set_state(nbr, NET_IPV6_NBR_STATE_STALE);
 8058535:	ba 02 00 00 00       	mov    $0x2,%edx
 805853a:	89 d8                	mov    %ebx,%eax
 805853c:	e8 38 f9 ff ff       	call   8057e79 <ipv6_nbr_set_state>
	return NET_OK;

drop:
	net_stats_update_ipv6_nd_drop(net_pkt_iface(pkt));

	return NET_DROP;
 8058541:	b8 02 00 00 00       	mov    $0x2,%eax
 8058546:	e9 c6 00 00 00       	jmp    8058611 <handle_na_input+0x386>
	if (na_hdr->flags & NET_ICMPV6_NA_FLAG_OVERRIDE ||
 805854b:	66 83 7d b0 00       	cmpw   $0x0,-0x50(%ebp)
 8058550:	75 1d                	jne    805856f <handle_na_input+0x2e4>
 8058552:	eb 6c                	jmp    80585c0 <handle_na_input+0x335>
		if (lladdr_changed) {
 8058554:	80 7d ac 00          	cmpb   $0x0,-0x54(%ebp)
 8058558:	74 15                	je     805856f <handle_na_input+0x2e4>
	dbg_update_neighbor_lladdr(&lladdr, old_lladdr, addr);
 805855a:	89 f8                	mov    %edi,%eax
 805855c:	e8 c9 f7 ff ff       	call   8057d2a <dbg_update_neighbor_lladdr.constprop.0>
			net_linkaddr_set(cached_lladdr, lladdr.addr,
 8058561:	0f b6 4f 01          	movzbl 0x1(%edi),%ecx
 8058565:	8d 55 de             	lea    -0x22(%ebp),%edx
 8058568:	89 f8                	mov    %edi,%eax
 805856a:	e8 dc f8 ff ff       	call   8057e4b <net_linkaddr_set.isra.0>
		if (na_hdr->flags & NET_ICMPV6_NA_FLAG_SOLICITED) {
 805856f:	8b 45 b4             	mov    -0x4c(%ebp),%eax
 8058572:	f6 00 40             	testb  $0x40,(%eax)
 8058575:	74 37                	je     80585ae <handle_na_input+0x323>
			ipv6_nbr_set_state(nbr, NET_IPV6_NBR_STATE_REACHABLE);
 8058577:	ba 01 00 00 00       	mov    $0x1,%edx
 805857c:	89 d8                	mov    %ebx,%eax
 805857e:	e8 f6 f8 ff ff       	call   8057e79 <ipv6_nbr_set_state>
 8058583:	8b 43 0c             	mov    0xc(%ebx),%eax
			net_ipv6_nbr_data(nbr)->reachable = 0;
 8058586:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
 805858d:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
 8058594:	8b 43 0c             	mov    0xc(%ebx),%eax
			net_ipv6_nbr_data(nbr)->reachable_timeout = 0;
 8058597:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
			net_ipv6_nbr_set_reachable_timer(net_pkt_iface(pkt),
 805859e:	50                   	push   %eax
 805859f:	50                   	push   %eax
 80585a0:	53                   	push   %ebx
 80585a1:	ff 76 18             	push   0x18(%esi)
 80585a4:	e8 c2 fc ff ff       	call   805826b <net_ipv6_nbr_set_reachable_timer>
 80585a9:	83 c4 10             	add    $0x10,%esp
 80585ac:	eb 12                	jmp    80585c0 <handle_na_input+0x335>
			if (lladdr_changed) {
 80585ae:	80 7d ac 00          	cmpb   $0x0,-0x54(%ebp)
 80585b2:	74 0c                	je     80585c0 <handle_na_input+0x335>
				ipv6_nbr_set_state(nbr,
 80585b4:	ba 02 00 00 00       	mov    $0x2,%edx
 80585b9:	89 d8                	mov    %ebx,%eax
 80585bb:	e8 b9 f8 ff ff       	call   8057e79 <ipv6_nbr_set_state>
		(na_hdr->flags & NET_ICMPV6_NA_FLAG_ROUTER);
 80585c0:	8b 45 b4             	mov    -0x4c(%ebp),%eax
 80585c3:	8b 53 0c             	mov    0xc(%ebx),%edx
 80585c6:	8a 00                	mov    (%eax),%al
 80585c8:	c0 e8 07             	shr    $0x7,%al
	net_ipv6_nbr_data(nbr)->is_router =
 80585cb:	88 42 2f             	mov    %al,0x2f(%edx)
	pending = net_ipv6_nbr_data(nbr)->pending;
 80585ce:	8b 43 0c             	mov    0xc(%ebx),%eax
 80585d1:	8b 38                	mov    (%eax),%edi
	if (pending) {
 80585d3:	85 ff                	test   %edi,%edi
 80585d5:	74 2c                	je     8058603 <handle_na_input+0x378>
		if (net_send_data(pending) < 0) {
 80585d7:	83 ec 0c             	sub    $0xc,%esp
 80585da:	57                   	push   %edi
 80585db:	e8 50 7e ff ff       	call   8050430 <net_send_data>
 80585e0:	83 c4 10             	add    $0x10,%esp
 80585e3:	85 c0                	test   %eax,%eax
 80585e5:	8b 43 0c             	mov    0xc(%ebx),%eax
 80585e8:	79 07                	jns    80585f1 <handle_na_input+0x366>
			nbr_clear_ns_pending(net_ipv6_nbr_data(nbr));
 80585ea:	e8 ae f4 ff ff       	call   8057a9d <nbr_clear_ns_pending>
 80585ef:	eb 06                	jmp    80585f7 <handle_na_input+0x36c>
			net_ipv6_nbr_data(nbr)->pending = NULL;
 80585f1:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		net_pkt_unref(pending);
 80585f7:	83 ec 0c             	sub    $0xc,%esp
 80585fa:	57                   	push   %edi
 80585fb:	e8 e8 c7 ff ff       	call   8054de8 <net_pkt_unref>
 8058600:	83 c4 10             	add    $0x10,%esp
	net_pkt_unref(pkt);
 8058603:	83 ec 0c             	sub    $0xc,%esp
 8058606:	56                   	push   %esi
 8058607:	e8 dc c7 ff ff       	call   8054de8 <net_pkt_unref>
 805860c:	83 c4 10             	add    $0x10,%esp
	return NET_OK;
 805860f:	31 c0                	xor    %eax,%eax
}
 8058611:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 8058614:	65 2b 15 14 00 00 00 	sub    %gs:0x14,%edx
 805861b:	74 05                	je     8058622 <handle_na_input+0x397>
 805861d:	e8 de 0c ff ff       	call   8049300 <__stack_chk_fail@plt>
 8058622:	8d 65 f4             	lea    -0xc(%ebp),%esp
 8058625:	5b                   	pop    %ebx
 8058626:	5e                   	pop    %esi
 8058627:	5f                   	pop    %edi
 8058628:	5d                   	pop    %ebp
 8058629:	c3                   	ret    

0805862a <net_ipv6_send_ns>:
		     struct net_pkt *pending,
		     const struct in6_addr *src,
		     const struct in6_addr *dst,
		     const struct in6_addr *tgt,
		     bool is_my_address)
{
 805862a:	55                   	push   %ebp
 805862b:	89 e5                	mov    %esp,%ebp
 805862d:	57                   	push   %edi
 805862e:	56                   	push   %esi
 805862f:	53                   	push   %ebx
 8058630:	83 ec 4c             	sub    $0x4c,%esp
 8058633:	8b 45 08             	mov    0x8(%ebp),%eax
 8058636:	8b 75 14             	mov    0x14(%ebp),%esi
 8058639:	8b 7d 10             	mov    0x10(%ebp),%edi
 805863c:	89 45 c0             	mov    %eax,-0x40(%ebp)
 805863f:	8b 45 0c             	mov    0xc(%ebp),%eax
 8058642:	89 45 c4             	mov    %eax,-0x3c(%ebp)
 8058645:	8b 45 18             	mov    0x18(%ebp),%eax
 8058648:	89 45 bc             	mov    %eax,-0x44(%ebp)
 805864b:	8b 45 1c             	mov    0x1c(%ebp),%eax
 805864e:	89 45 b8             	mov    %eax,-0x48(%ebp)
 8058651:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 8058657:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 805865a:	31 c0                	xor    %eax,%eax
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ns_access,
 805865c:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
 8058663:	c7 45 d0 14 00 00 00 	movl   $0x14,-0x30(%ebp)
	struct net_icmpv6_ns_hdr *ns_hdr;
	struct in6_addr node_dst;
	struct net_nbr *nbr;
	uint8_t llao_len;

	if (!dst) {
 805866a:	85 f6                	test   %esi,%esi
 805866c:	75 30                	jne    805869e <net_ipv6_send_ns+0x74>
	dst->s6_addr[13]  = src->s6_addr[13];
 805866e:	8b 45 bc             	mov    -0x44(%ebp),%eax
	dst->s6_addr[12]  = 0xFF;
 8058671:	c6 45 e0 ff          	movb   $0xff,-0x20(%ebp)
		net_ipv6_addr_create_solicited_node(tgt, &node_dst);
		dst = &node_dst;
 8058675:	8d 75 d4             	lea    -0x2c(%ebp),%esi
	dst->s6_addr[0]   = 0xFF;
 8058678:	c7 45 d4 ff 02 00 00 	movl   $0x2ff,-0x2c(%ebp)
	dst->s6_addr[13]  = src->s6_addr[13];
 805867f:	8a 40 0d             	mov    0xd(%eax),%al
	UNALIGNED_PUT(0, &dst->s6_addr16[2]);
 8058682:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	UNALIGNED_PUT(0, &dst->s6_addr16[4]);
 8058689:	c7 45 dc 00 00 00 01 	movl   $0x1000000,-0x24(%ebp)
	dst->s6_addr[13]  = src->s6_addr[13];
 8058690:	88 45 e1             	mov    %al,-0x1f(%ebp)
	UNALIGNED_PUT(UNALIGNED_GET(&src->s6_addr16[7]), &dst->s6_addr16[7]);
 8058693:	8b 45 bc             	mov    -0x44(%ebp),%eax
 8058696:	66 8b 40 0e          	mov    0xe(%eax),%ax
 805869a:	66 89 45 e2          	mov    %ax,-0x1e(%ebp)
	uint8_t total_len = net_if_get_link_addr(iface)->len +
 805869e:	8b 45 c0             	mov    -0x40(%ebp),%eax
	}

	llao_len = get_llao_len(iface);

	if (is_my_address) {
 80586a1:	80 7d b8 00          	cmpb   $0x0,-0x48(%ebp)
	uint8_t total_len = net_if_get_link_addr(iface)->len +
 80586a5:	8b 00                	mov    (%eax),%eax
 80586a7:	8a 58 14             	mov    0x14(%eax),%bl
	if (is_my_address) {
 80586aa:	74 0b                	je     80586b7 <net_ipv6_send_ns+0x8d>
		src = net_ipv6_unspecified_address();
 80586ac:	e8 c9 b0 ff ff       	call   805377a <net_ipv6_unspecified_address>
		llao_len = 0U;
 80586b1:	31 db                	xor    %ebx,%ebx
		src = net_ipv6_unspecified_address();
 80586b3:	89 c7                	mov    %eax,%edi
		llao_len = 0U;
 80586b5:	eb 2b                	jmp    80586e2 <net_ipv6_send_ns+0xb8>
	} else {
		if (!src) {
 80586b7:	85 ff                	test   %edi,%edi
 80586b9:	75 12                	jne    80586cd <net_ipv6_send_ns+0xa3>
			src = net_if_ipv6_select_src_addr(iface, tgt);
 80586bb:	50                   	push   %eax
 80586bc:	50                   	push   %eax
 80586bd:	ff 75 bc             	push   -0x44(%ebp)
 80586c0:	ff 75 c0             	push   -0x40(%ebp)
 80586c3:	e8 98 9c ff ff       	call   8052360 <net_if_ipv6_select_src_addr>
 80586c8:	83 c4 10             	add    $0x10,%esp
 80586cb:	89 c7                	mov    %eax,%edi
		}

		if (net_ipv6_is_addr_unspecified(src)) {
 80586cd:	89 f8                	mov    %edi,%eax
 80586cf:	e8 a6 f3 ff ff       	call   8057a7a <net_ipv6_is_addr_unspecified>
 80586d4:	84 c0                	test   %al,%al
 80586d6:	0f 85 c3 01 00 00    	jne    805889f <net_ipv6_send_ns+0x275>
	return ROUND_UP(total_len, 8U);
 80586dc:	83 c3 09             	add    $0x9,%ebx
 80586df:	83 e3 f8             	and    $0xfffffff8,%ebx

			goto drop;
		}
	}

	pkt = net_pkt_alloc_with_buffer(iface,
 80586e2:	50                   	push   %eax
 80586e3:	50                   	push   %eax
 80586e4:	0f b6 c3             	movzbl %bl,%eax
 80586e7:	89 45 b4             	mov    %eax,-0x4c(%ebp)
 80586ea:	83 c0 14             	add    $0x14,%eax
 80586ed:	6a 00                	push   $0x0
 80586ef:	6a 0a                	push   $0xa
 80586f1:	6a 3a                	push   $0x3a
 80586f3:	6a 02                	push   $0x2
 80586f5:	50                   	push   %eax
 80586f6:	ff 75 c0             	push   -0x40(%ebp)
 80586f9:	e8 09 cc ff ff       	call   8055307 <net_pkt_alloc_with_buffer>
 80586fe:	83 c4 20             	add    $0x20,%esp
 8058701:	89 c3                	mov    %eax,%ebx
					sizeof(struct net_icmpv6_ns_hdr) +
					llao_len,
					AF_INET6, IPPROTO_ICMPV6,
					ND_NET_BUF_TIMEOUT);
	if (!pkt) {
 8058703:	85 c0                	test   %eax,%eax
 8058705:	0f 84 9b 01 00 00    	je     80588a6 <net_ipv6_send_ns+0x27c>
	pkt->ipv6_hop_limit = hop_limit;
 805870b:	c6 40 35 ff          	movb   $0xff,0x35(%eax)
		net_pkt_set_captured(pkt, net_pkt_is_captured(pending));
	}

	net_pkt_set_ipv6_hop_limit(pkt, NET_IPV6_ND_HOP_LIMIT);

	if (net_ipv6_create(pkt, src, dst) ||
 805870f:	50                   	push   %eax
 8058710:	56                   	push   %esi
 8058711:	57                   	push   %edi
 8058712:	53                   	push   %ebx
 8058713:	e8 3a ec ff ff       	call   8057352 <net_ipv6_create>
 8058718:	83 c4 10             	add    $0x10,%esp
 805871b:	85 c0                	test   %eax,%eax
 805871d:	0f 85 6f 01 00 00    	jne    8058892 <net_ipv6_send_ns+0x268>
	    net_icmpv6_create(pkt, NET_ICMPV6_NS, 0)) {
 8058723:	50                   	push   %eax
 8058724:	6a 00                	push   $0x0
 8058726:	68 87 00 00 00       	push   $0x87
 805872b:	53                   	push   %ebx
 805872c:	e8 31 e5 ff ff       	call   8056c62 <net_icmpv6_create>
 8058731:	83 c4 10             	add    $0x10,%esp
	if (net_ipv6_create(pkt, src, dst) ||
 8058734:	85 c0                	test   %eax,%eax
 8058736:	0f 85 56 01 00 00    	jne    8058892 <net_ipv6_send_ns+0x268>
		goto drop;
	}

	ns_hdr = (struct net_icmpv6_ns_hdr *)net_pkt_get_data(pkt, &ns_access);
 805873c:	8d 55 cc             	lea    -0x34(%ebp),%edx
 805873f:	57                   	push   %edi
 8058740:	57                   	push   %edi
 8058741:	52                   	push   %edx
 8058742:	53                   	push   %ebx
 8058743:	e8 8a d1 ff ff       	call   80558d2 <net_pkt_get_data>
 8058748:	83 c4 10             	add    $0x10,%esp
	if (!ns_hdr) {
 805874b:	85 c0                	test   %eax,%eax
 805874d:	0f 84 3f 01 00 00    	je     8058892 <net_ipv6_send_ns+0x268>
		goto drop;
	}

	ns_hdr->reserved = 0U;
 8058753:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
 8058759:	83 c0 04             	add    $0x4,%eax
 805875c:	8b 75 bc             	mov    -0x44(%ebp),%esi
	net_ipv6_addr_copy_raw(ns_hdr->tgt, (uint8_t *)tgt);

	if (net_pkt_set_data(pkt, &ns_access)) {
 805875f:	8d 55 cc             	lea    -0x34(%ebp),%edx
 8058762:	89 c7                	mov    %eax,%edi
 8058764:	b9 04 00 00 00       	mov    $0x4,%ecx
 8058769:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
 805876b:	56                   	push   %esi
 805876c:	56                   	push   %esi
 805876d:	52                   	push   %edx
 805876e:	53                   	push   %ebx
 805876f:	e8 c2 d1 ff ff       	call   8055936 <net_pkt_set_data>
 8058774:	83 c4 10             	add    $0x10,%esp
 8058777:	89 c7                	mov    %eax,%edi
 8058779:	85 c0                	test   %eax,%eax
 805877b:	0f 85 11 01 00 00    	jne    8058892 <net_ipv6_send_ns+0x268>
		goto drop;
	}

	if (!is_my_address) {
 8058781:	80 7d b8 00          	cmpb   $0x0,-0x48(%ebp)
 8058785:	74 36                	je     80587bd <net_ipv6_send_ns+0x193>
			      llao_len, NET_ICMPV6_ND_OPT_SLLAO)) {
			goto drop;
		}
	}

	net_pkt_cursor_init(pkt);
 8058787:	83 ec 0c             	sub    $0xc,%esp
 805878a:	53                   	push   %ebx
 805878b:	e8 c4 c7 ff ff       	call   8054f54 <net_pkt_cursor_init>
 8058790:	5a                   	pop    %edx
 8058791:	59                   	pop    %ecx
	net_ipv6_finalize(pkt, IPPROTO_ICMPV6);
 8058792:	6a 3a                	push   $0x3a
 8058794:	53                   	push   %ebx
 8058795:	e8 93 ec ff ff       	call   805742d <net_ipv6_finalize>

	nbr = add_nbr(iface, tgt, false,
 805879a:	8b 55 bc             	mov    -0x44(%ebp),%edx
 805879d:	8b 45 c0             	mov    -0x40(%ebp),%eax
 80587a0:	31 c9                	xor    %ecx,%ecx
 80587a2:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 80587a9:	e8 62 f8 ff ff       	call   8058010 <add_nbr>
 80587ae:	83 c4 10             	add    $0x10,%esp
 80587b1:	89 45 c0             	mov    %eax,-0x40(%ebp)
		      NET_IPV6_NBR_STATE_INCOMPLETE);
	if (!nbr) {
 80587b4:	85 c0                	test   %eax,%eax
 80587b6:	75 2b                	jne    80587e3 <net_ipv6_send_ns+0x1b9>
 80587b8:	e9 d5 00 00 00       	jmp    8058892 <net_ipv6_send_ns+0x268>
	return &iface->if_dev->link_addr;
 80587bd:	8b 45 c0             	mov    -0x40(%ebp),%eax
		if (!set_llao(pkt, net_if_get_link_addr(iface),
 80587c0:	83 ec 0c             	sub    $0xc,%esp
 80587c3:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
 80587c6:	8b 00                	mov    (%eax),%eax
 80587c8:	6a 01                	push   $0x1
 80587ca:	89 45 b8             	mov    %eax,-0x48(%ebp)
 80587cd:	8d 50 10             	lea    0x10(%eax),%edx
 80587d0:	89 d8                	mov    %ebx,%eax
 80587d2:	e8 ca f4 ff ff       	call   8057ca1 <set_llao>
 80587d7:	83 c4 10             	add    $0x10,%esp
 80587da:	84 c0                	test   %al,%al
 80587dc:	75 a9                	jne    8058787 <net_ipv6_send_ns+0x15d>
 80587de:	e9 af 00 00 00       	jmp    8058892 <net_ipv6_send_ns+0x268>
		NET_DBG("Could not create new neighbor %s",
			net_sprint_ipv6_addr(&ns_hdr->tgt));
		goto drop;
	}

	if (pending) {
 80587e3:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
 80587e7:	74 52                	je     805883b <net_ipv6_send_ns+0x211>
 80587e9:	8b 45 c0             	mov    -0x40(%ebp),%eax
 80587ec:	8b 70 0c             	mov    0xc(%eax),%esi
		if (!net_ipv6_nbr_data(nbr)->pending) {
 80587ef:	83 3e 00             	cmpl   $0x0,(%esi)
 80587f2:	75 6a                	jne    805885e <net_ipv6_send_ns+0x234>
			net_ipv6_nbr_data(nbr)->pending = net_pkt_ref(pending);
 80587f4:	83 ec 0c             	sub    $0xc,%esp
 80587f7:	ff 75 c4             	push   -0x3c(%ebp)
 80587fa:	e8 b2 c5 ff ff       	call   8054db1 <net_pkt_ref>
 80587ff:	83 c4 10             	add    $0x10,%esp
 8058802:	89 06                	mov    %eax,(%esi)
 8058804:	8b 45 c0             	mov    -0x40(%ebp),%eax
 8058807:	8b 70 0c             	mov    0xc(%eax),%esi
			goto drop;
		}

		NET_DBG("Setting timeout %d for NS", NS_REPLY_TIMEOUT);

		net_ipv6_nbr_data(nbr)->send_ns = k_uptime_get();
 805880a:	e8 05 f3 ff ff       	call   8057b14 <k_uptime_get>
 805880f:	83 ec 0c             	sub    $0xc,%esp
 8058812:	89 46 20             	mov    %eax,0x20(%esi)
 8058815:	89 56 24             	mov    %edx,0x24(%esi)
 8058818:	68 70 85 06 08       	push   $0x8068570
 805881d:	e8 77 82 00 00       	call   8060a99 <z_timeout_remaining>
 8058822:	83 c4 10             	add    $0x10,%esp

		/* Let's start the timer if necessary */
		if (!k_work_delayable_remaining_get(&ipv6_ns_reply_timer)) {
 8058825:	09 c2                	or     %eax,%edx
 8058827:	75 12                	jne    805883b <net_ipv6_send_ns+0x211>
			k_work_reschedule(&ipv6_ns_reply_timer,
 8058829:	50                   	push   %eax
 805882a:	6a 00                	push   $0x0
 805882c:	6a 64                	push   $0x64
 805882e:	68 60 85 06 08       	push   $0x8068560
 8058833:	e8 a8 74 00 00       	call   805fce0 <k_work_reschedule>
 8058838:	83 c4 10             	add    $0x10,%esp
	}

	dbg_addr_sent_tgt("Neighbor Solicitation", src, dst, &ns_hdr->tgt,
			  pkt);

	if (net_send_data(pkt) < 0) {
 805883b:	83 ec 0c             	sub    $0xc,%esp
 805883e:	53                   	push   %ebx
 805883f:	e8 ec 7b ff ff       	call   8050430 <net_send_data>
 8058844:	83 c4 10             	add    $0x10,%esp
 8058847:	85 c0                	test   %eax,%eax
 8058849:	79 36                	jns    8058881 <net_ipv6_send_ns+0x257>
		NET_DBG("Cannot send NS %p (pending %p)", pkt, pending);

		if (pending) {
 805884b:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
 805884f:	74 64                	je     80588b5 <net_ipv6_send_ns+0x28b>
			nbr_clear_ns_pending(net_ipv6_nbr_data(nbr));
 8058851:	8b 45 c0             	mov    -0x40(%ebp),%eax
 8058854:	8b 40 0c             	mov    0xc(%eax),%eax
 8058857:	e8 41 f2 ff ff       	call   8057a9d <nbr_clear_ns_pending>
			pending = NULL;
 805885c:	eb 57                	jmp    80588b5 <net_ipv6_send_ns+0x28b>
	int ret = -ENOBUFS;
 805885e:	bf 97 ff ff ff       	mov    $0xffffff97,%edi

	return 0;

drop:
	if (pending) {
		net_pkt_unref(pending);
 8058863:	83 ec 0c             	sub    $0xc,%esp
 8058866:	ff 75 c4             	push   -0x3c(%ebp)
 8058869:	e8 7a c5 ff ff       	call   8054de8 <net_pkt_unref>
 805886e:	83 c4 10             	add    $0x10,%esp
	}

	if (pkt) {
 8058871:	85 db                	test   %ebx,%ebx
 8058873:	74 0c                	je     8058881 <net_ipv6_send_ns+0x257>
		net_pkt_unref(pkt);
 8058875:	83 ec 0c             	sub    $0xc,%esp
 8058878:	53                   	push   %ebx
 8058879:	e8 6a c5 ff ff       	call   8054de8 <net_pkt_unref>
 805887e:	83 c4 10             	add    $0x10,%esp
	}

	net_stats_update_ipv6_nd_drop(iface);

	return ret;
}
 8058881:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8058884:	65 2b 05 14 00 00 00 	sub    %gs:0x14,%eax
 805888b:	74 2f                	je     80588bc <net_ipv6_send_ns+0x292>
 805888d:	e8 6e 0a ff ff       	call   8049300 <__stack_chk_fail@plt>
	if (pending) {
 8058892:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
 8058896:	bf 97 ff ff ff       	mov    $0xffffff97,%edi
 805889b:	75 c6                	jne    8058863 <net_ipv6_send_ns+0x239>
 805889d:	eb d6                	jmp    8058875 <net_ipv6_send_ns+0x24b>
			ret = -EINVAL;
 805889f:	bf ea ff ff ff       	mov    $0xffffffea,%edi
 80588a4:	eb 05                	jmp    80588ab <net_ipv6_send_ns+0x281>
		ret = -ENOMEM;
 80588a6:	bf f4 ff ff ff       	mov    $0xfffffff4,%edi
	if (pending) {
 80588ab:	31 db                	xor    %ebx,%ebx
 80588ad:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
 80588b1:	75 b0                	jne    8058863 <net_ipv6_send_ns+0x239>
 80588b3:	eb cc                	jmp    8058881 <net_ipv6_send_ns+0x257>
 80588b5:	bf 97 ff ff ff       	mov    $0xffffff97,%edi
 80588ba:	eb b9                	jmp    8058875 <net_ipv6_send_ns+0x24b>
}
 80588bc:	8d 65 f4             	lea    -0xc(%ebp),%esp
 80588bf:	89 f8                	mov    %edi,%eax
 80588c1:	5b                   	pop    %ebx
 80588c2:	5e                   	pop    %esi
 80588c3:	5f                   	pop    %edi
 80588c4:	5d                   	pop    %ebp
 80588c5:	c3                   	ret    

080588c6 <net_ipv6_nbr_add>:
{
 80588c6:	55                   	push   %ebp
 80588c7:	89 e5                	mov    %esp,%ebp
 80588c9:	57                   	push   %edi
 80588ca:	56                   	push   %esi
 80588cb:	53                   	push   %ebx
 80588cc:	83 ec 18             	sub    $0x18,%esp
	nbr = add_nbr(iface, addr, is_router, state);
 80588cf:	0f b6 4d 14          	movzbl 0x14(%ebp),%ecx
 80588d3:	8b 55 0c             	mov    0xc(%ebp),%edx
 80588d6:	ff 75 18             	push   0x18(%ebp)
 80588d9:	8b 45 08             	mov    0x8(%ebp),%eax
{
 80588dc:	8b 75 10             	mov    0x10(%ebp),%esi
	nbr = add_nbr(iface, addr, is_router, state);
 80588df:	e8 2c f7 ff ff       	call   8058010 <add_nbr>
 80588e4:	83 c4 10             	add    $0x10,%esp
 80588e7:	89 c3                	mov    %eax,%ebx
	if (!nbr) {
 80588e9:	85 c0                	test   %eax,%eax
 80588eb:	0f 84 95 00 00 00    	je     8058986 <net_ipv6_nbr_add+0xc0>
	if (lladdr && net_nbr_link(nbr, iface, lladdr) == -EALREADY &&
 80588f1:	85 f6                	test   %esi,%esi
 80588f3:	74 70                	je     8058965 <net_ipv6_nbr_add+0x9f>
 80588f5:	52                   	push   %edx
 80588f6:	56                   	push   %esi
 80588f7:	ff 75 08             	push   0x8(%ebp)
 80588fa:	50                   	push   %eax
 80588fb:	e8 9a e8 ff ff       	call   805719a <net_nbr_link>
 8058900:	83 c4 10             	add    $0x10,%esp
 8058903:	83 f8 8e             	cmp    $0xffffff8e,%eax
 8058906:	75 5d                	jne    8058965 <net_ipv6_nbr_add+0x9f>
	    net_ipv6_nbr_data(nbr)->state != NET_IPV6_NBR_STATE_STATIC) {
 8058908:	8b 43 0c             	mov    0xc(%ebx),%eax
	if (lladdr && net_nbr_link(nbr, iface, lladdr) == -EALREADY &&
 805890b:	83 78 28 05          	cmpl   $0x5,0x28(%eax)
 805890f:	74 75                	je     8058986 <net_ipv6_nbr_add+0xc0>
		cached_lladdr = net_nbr_get_lladdr(nbr->idx);
 8058911:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
 8058915:	83 ec 0c             	sub    $0xc,%esp
 8058918:	50                   	push   %eax
 8058919:	e8 b1 e9 ff ff       	call   80572cf <net_nbr_get_lladdr>
 805891e:	83 c4 0c             	add    $0xc,%esp
 8058921:	89 c7                	mov    %eax,%edi
		if (memcmp(cached_lladdr->addr, lladdr->addr, lladdr->len)) {
 8058923:	0f b6 46 04          	movzbl 0x4(%esi),%eax
 8058927:	50                   	push   %eax
 8058928:	8d 47 02             	lea    0x2(%edi),%eax
 805892b:	ff 36                	push   (%esi)
 805892d:	50                   	push   %eax
 805892e:	e8 3d 07 ff ff       	call   8049070 <memcmp@plt>
 8058933:	83 c4 10             	add    $0x10,%esp
 8058936:	85 c0                	test   %eax,%eax
 8058938:	74 16                	je     8058950 <net_ipv6_nbr_add+0x8a>
			dbg_update_neighbor_lladdr(lladdr, cached_lladdr, addr);
 805893a:	89 f8                	mov    %edi,%eax
 805893c:	e8 e9 f3 ff ff       	call   8057d2a <dbg_update_neighbor_lladdr.constprop.0>
			net_linkaddr_set(cached_lladdr, lladdr->addr,
 8058941:	0f b6 4e 04          	movzbl 0x4(%esi),%ecx
 8058945:	8b 16                	mov    (%esi),%edx
 8058947:	89 f8                	mov    %edi,%eax
 8058949:	e8 fd f4 ff ff       	call   8057e4b <net_linkaddr_set.isra.0>
			ipv6_nbr_set_state(nbr, NET_IPV6_NBR_STATE_STALE);
 805894e:	eb 09                	jmp    8058959 <net_ipv6_nbr_add+0x93>
		} else if (net_ipv6_nbr_data(nbr)->state ==
 8058950:	8b 43 0c             	mov    0xc(%ebx),%eax
 8058953:	83 78 28 00          	cmpl   $0x0,0x28(%eax)
 8058957:	75 2d                	jne    8058986 <net_ipv6_nbr_add+0xc0>
			ipv6_nbr_set_state(nbr, NET_IPV6_NBR_STATE_STALE);
 8058959:	ba 02 00 00 00       	mov    $0x2,%edx
 805895e:	89 d8                	mov    %ebx,%eax
 8058960:	e8 14 f5 ff ff       	call   8057e79 <ipv6_nbr_set_state>
	if (net_ipv6_nbr_data(nbr)->state == NET_IPV6_NBR_STATE_INCOMPLETE) {
 8058965:	8b 43 0c             	mov    0xc(%ebx),%eax
 8058968:	83 78 28 00          	cmpl   $0x0,0x28(%eax)
 805896c:	75 18                	jne    8058986 <net_ipv6_nbr_add+0xc0>
		ret = net_ipv6_send_ns(iface, NULL, NULL, NULL, addr, false);
 805896e:	50                   	push   %eax
 805896f:	50                   	push   %eax
 8058970:	6a 00                	push   $0x0
 8058972:	ff 75 0c             	push   0xc(%ebp)
 8058975:	6a 00                	push   $0x0
 8058977:	6a 00                	push   $0x0
 8058979:	6a 00                	push   $0x0
 805897b:	ff 75 08             	push   0x8(%ebp)
 805897e:	e8 a7 fc ff ff       	call   805862a <net_ipv6_send_ns>
 8058983:	83 c4 20             	add    $0x20,%esp
}
 8058986:	8d 65 f4             	lea    -0xc(%ebp),%esp
 8058989:	89 d8                	mov    %ebx,%eax
 805898b:	5b                   	pop    %ebx
 805898c:	5e                   	pop    %esi
 805898d:	5f                   	pop    %edi
 805898e:	5d                   	pop    %ebp
 805898f:	c3                   	ret    

08058990 <handle_ra_input>:
#endif

static enum net_verdict handle_ra_input(struct net_pkt *pkt,
					struct net_ipv6_hdr *ip_hdr,
					struct net_icmp_hdr *icmp_hdr)
{
 8058990:	55                   	push   %ebp
 8058991:	89 e5                	mov    %esp,%ebp
 8058993:	57                   	push   %edi
 8058994:	56                   	push   %esi
 8058995:	53                   	push   %ebx
	size_t bytes = 0;
 8058996:	31 db                	xor    %ebx,%ebx
 8058998:	83 ec 7c             	sub    $0x7c,%esp
 805899b:	8b 45 0c             	mov    0xc(%ebp),%eax
 805899e:	8b 75 08             	mov    0x8(%ebp),%esi
 80589a1:	8b 55 10             	mov    0x10(%ebp),%edx
 80589a4:	89 45 80             	mov    %eax,-0x80(%ebp)
 80589a7:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 80589ad:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 80589b0:	31 c0                	xor    %eax,%eax
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ra_access,
					      struct net_icmpv6_ra_hdr);
	NET_PKT_DATA_ACCESS_DEFINE(nd_access, struct net_icmpv6_nd_opt_hdr);
 80589b2:	8d 45 8e             	lea    -0x72(%ebp),%eax
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ra_access,
 80589b5:	c7 45 9c 00 00 00 00 	movl   $0x0,-0x64(%ebp)
 80589bc:	c7 45 a0 0c 00 00 00 	movl   $0xc,-0x60(%ebp)
	NET_PKT_DATA_ACCESS_DEFINE(nd_access, struct net_icmpv6_nd_opt_hdr);
 80589c3:	c7 45 a8 02 00 00 00 	movl   $0x2,-0x58(%ebp)
 80589ca:	89 45 a4             	mov    %eax,-0x5c(%ebp)
 80589cd:	8b 46 08             	mov    0x8(%esi),%eax
	while (buf) {
 80589d0:	85 c0                	test   %eax,%eax
 80589d2:	74 0b                	je     80589df <handle_ra_input+0x4f>
		bytes += buf->len;
 80589d4:	0f b7 48 10          	movzwl 0x10(%eax),%ecx
		buf = buf->frags;
 80589d8:	8b 40 04             	mov    0x4(%eax),%eax
		bytes += buf->len;
 80589db:	01 cb                	add    %ecx,%ebx
		buf = buf->frags;
 80589dd:	eb f1                	jmp    80589d0 <handle_ra_input+0x40>
	struct net_icmpv6_ra_hdr *ra_hdr;
	struct net_if_router *router;
	uint32_t mtu, reachable_time, retrans_timer;
	uint16_t router_lifetime;

	ra_hdr = (struct net_icmpv6_ra_hdr *)net_pkt_get_data(pkt, &ra_access);
 80589df:	8d 45 9c             	lea    -0x64(%ebp),%eax
 80589e2:	57                   	push   %edi
 80589e3:	57                   	push   %edi
 80589e4:	50                   	push   %eax
 80589e5:	56                   	push   %esi
 80589e6:	89 55 84             	mov    %edx,-0x7c(%ebp)
 80589e9:	e8 e4 ce ff ff       	call   80558d2 <net_pkt_get_data>
 80589ee:	83 c4 10             	add    $0x10,%esp
	if (!ra_hdr) {
 80589f1:	8b 55 84             	mov    -0x7c(%ebp),%edx
 80589f4:	85 c0                	test   %eax,%eax
	ra_hdr = (struct net_icmpv6_ra_hdr *)net_pkt_get_data(pkt, &ra_access);
 80589f6:	89 c7                	mov    %eax,%edi
	if (!ra_hdr) {
 80589f8:	0f 84 62 01 00 00    	je     8058b60 <handle_ra_input+0x1d0>

	dbg_addr_recv("Router Advertisement", &ip_hdr->src, &ip_hdr->dst, pkt);

	net_stats_update_ipv6_nd_recv(net_pkt_iface(pkt));

	if (((length < (sizeof(struct net_ipv6_hdr) +
 80589fe:	66 83 fb 39          	cmp    $0x39,%bx
 8058a02:	76 11                	jbe    8058a15 <handle_ra_input+0x85>
			sizeof(struct net_icmp_hdr) +
			sizeof(struct net_icmpv6_ra_hdr) +
			sizeof(struct net_icmpv6_nd_opt_hdr))) ||
 8058a04:	8b 45 80             	mov    -0x80(%ebp),%eax
 8058a07:	80 78 07 ff          	cmpb   $0xff,0x7(%eax)
 8058a0b:	75 08                	jne    8058a15 <handle_ra_input+0x85>
	     (ip_hdr->hop_limit != NET_IPV6_ND_HOP_LIMIT) ||
 8058a0d:	66 81 78 08 fe 80    	cmpw   $0x80fe,0x8(%eax)
 8058a13:	74 0a                	je     8058a1f <handle_ra_input+0x8f>
	     !net_ipv6_is_ll_addr((struct in6_addr *)ip_hdr->src)) &&
 8058a15:	80 7a 01 00          	cmpb   $0x0,0x1(%edx)
 8058a19:	0f 85 41 01 00 00    	jne    8058b60 <handle_ra_input+0x1d0>
		icmp_hdr->code != 0U) {
		goto drop;
	}

	net_pkt_acknowledge_data(pkt, &ra_access);
 8058a1f:	8b 55 a0             	mov    -0x60(%ebp),%edx
 8058a22:	89 f0                	mov    %esi,%eax
 8058a24:	e8 10 f4 ff ff       	call   8057e39 <net_pkt_acknowledge_data.isra.0>

	router_lifetime = ntohs(ra_hdr->router_lifetime);
 8058a29:	66 8b 47 02          	mov    0x2(%edi),%ax
 8058a2d:	8b 5f 08             	mov    0x8(%edi),%ebx
	reachable_time = ntohl(ra_hdr->reachable_time);
	retrans_timer = ntohl(ra_hdr->retrans_timer);

	if (ra_hdr->cur_hop_limit) {
 8058a30:	0f b6 17             	movzbl (%edi),%edx
 8058a33:	66 89 85 7a ff ff ff 	mov    %ax,-0x86(%ebp)
	reachable_time = ntohl(ra_hdr->reachable_time);
 8058a3a:	8b 47 04             	mov    0x4(%edi),%eax
 8058a3d:	0f cb                	bswap  %ebx
 8058a3f:	0f c8                	bswap  %eax
	if (ra_hdr->cur_hop_limit) {
 8058a41:	84 d2                	test   %dl,%dl
 8058a43:	74 14                	je     8058a59 <handle_ra_input+0xc9>
		net_ipv6_set_hop_limit(net_pkt_iface(pkt),
 8058a45:	51                   	push   %ecx
 8058a46:	51                   	push   %ecx
 8058a47:	52                   	push   %edx
 8058a48:	ff 76 18             	push   0x18(%esi)
 8058a4b:	89 45 84             	mov    %eax,-0x7c(%ebp)
 8058a4e:	e8 6b 98 ff ff       	call   80522be <net_ipv6_set_hop_limit>
 8058a53:	8b 45 84             	mov    -0x7c(%ebp),%eax
 8058a56:	83 c4 10             	add    $0x10,%esp
				       ra_hdr->cur_hop_limit);
		NET_DBG("New hop limit %d",
			net_if_ipv6_get_hop_limit(net_pkt_iface(pkt)));
	}

	if (reachable_time && reachable_time <= MAX_REACHABLE_TIME &&
 8058a59:	8d 50 ff             	lea    -0x1(%eax),%edx
 8058a5c:	81 fa 7f ee 36 00    	cmp    $0x36ee7f,%edx
 8058a62:	77 3a                	ja     8058a9e <handle_ra_input+0x10e>
	return pkt->iface;
 8058a64:	8b 56 18             	mov    0x18(%esi),%edx
 8058a67:	8b 52 04             	mov    0x4(%edx),%edx
	if (!iface->config.ip.ipv6) {
 8058a6a:	85 d2                	test   %edx,%edx
 8058a6c:	74 0e                	je     8058a7c <handle_ra_input+0xec>
 8058a6e:	3b 82 fc 00 00 00    	cmp    0xfc(%edx),%eax
 8058a74:	74 28                	je     8058a9e <handle_ra_input+0x10e>
	iface->config.ip.ipv6->base_reachable_time = reachable_time;
 8058a76:	89 82 f8 00 00 00    	mov    %eax,0xf8(%edx)
	    (net_if_ipv6_get_reachable_time(net_pkt_iface(pkt)) !=
	     reachable_time)) {
		net_if_ipv6_set_base_reachable_time(net_pkt_iface(pkt),
						    reachable_time);
		net_if_ipv6_set_reachable_time(
 8058a7c:	8b 46 18             	mov    0x18(%esi),%eax
 8058a7f:	8b 50 04             	mov    0x4(%eax),%edx
	if (ipv6 == NULL) {
 8058a82:	85 d2                	test   %edx,%edx
 8058a84:	74 18                	je     8058a9e <handle_ra_input+0x10e>
	ipv6->reachable_time = net_if_ipv6_calc_reachable_time(ipv6);
 8058a86:	83 ec 0c             	sub    $0xc,%esp
 8058a89:	89 55 84             	mov    %edx,-0x7c(%ebp)
 8058a8c:	52                   	push   %edx
 8058a8d:	e8 1f 9a ff ff       	call   80524b1 <net_if_ipv6_calc_reachable_time>
 8058a92:	8b 55 84             	mov    -0x7c(%ebp),%edx
 8058a95:	83 c4 10             	add    $0x10,%esp
 8058a98:	89 82 fc 00 00 00    	mov    %eax,0xfc(%edx)
			net_pkt_iface(pkt)->config.ip.ipv6);
	}

	if (retrans_timer) {
 8058a9e:	85 db                	test   %ebx,%ebx
 8058aa0:	74 13                	je     8058ab5 <handle_ra_input+0x125>
 8058aa2:	8b 46 18             	mov    0x18(%esi),%eax
 8058aa5:	8b 40 04             	mov    0x4(%eax),%eax
	if (!iface->config.ip.ipv6) {
 8058aa8:	85 c0                	test   %eax,%eax
 8058aaa:	74 09                	je     8058ab5 <handle_ra_input+0x125>
		net_if_ipv6_set_retrans_timer(net_pkt_iface(pkt),
 8058aac:	8b 57 08             	mov    0x8(%edi),%edx
	iface->config.ip.ipv6->retrans_timer = retrans_timer;
 8058aaf:	89 90 00 01 00 00    	mov    %edx,0x100(%eax)
	pkt->ipv6_ext_opt_len = len;
 8058ab5:	c6 46 3a 0c          	movb   $0xc,0x3a(%esi)

	net_pkt_set_ipv6_ext_opt_len(pkt, sizeof(struct net_icmpv6_ra_hdr));
	length -= (sizeof(struct net_ipv6_hdr) + sizeof(struct net_icmp_hdr));

	nd_opt_hdr = (struct net_icmpv6_nd_opt_hdr *)
				net_pkt_get_data(pkt, &nd_access);
 8058ab9:	50                   	push   %eax
 8058aba:	50                   	push   %eax
 8058abb:	8d 45 a4             	lea    -0x5c(%ebp),%eax
 8058abe:	50                   	push   %eax
 8058abf:	56                   	push   %esi
 8058ac0:	e8 0d ce ff ff       	call   80558d2 <net_pkt_get_data>

	/* Add neighbor cache entry using link local address, regardless of link layer address
	 * presence in Router Advertisement.
	 */
	nbr = net_ipv6_nbr_add(net_pkt_iface(pkt), (struct in6_addr *)NET_IPV6_HDR(pkt)->src, NULL,
 8058ac5:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
				net_pkt_get_data(pkt, &nd_access);
 8058acc:	89 c3                	mov    %eax,%ebx
	nbr = net_ipv6_nbr_add(net_pkt_iface(pkt), (struct in6_addr *)NET_IPV6_HDR(pkt)->src, NULL,
 8058ace:	6a 01                	push   $0x1
 8058ad0:	6a 00                	push   $0x0
	return pkt->frags->data;
 8058ad2:	8b 46 08             	mov    0x8(%esi),%eax
 8058ad5:	8b 40 0c             	mov    0xc(%eax),%eax
 8058ad8:	83 c0 08             	add    $0x8,%eax
 8058adb:	50                   	push   %eax
 8058adc:	ff 76 18             	push   0x18(%esi)
 8058adf:	e8 e2 fd ff ff       	call   80588c6 <net_ipv6_nbr_add>
 8058ae4:	83 c4 20             	add    $0x20,%esp
 8058ae7:	89 45 84             	mov    %eax,-0x7c(%ebp)
				true, NET_IPV6_NBR_STATE_INCOMPLETE);

	while (nd_opt_hdr) {
 8058aea:	eb 44                	jmp    8058b30 <handle_ra_input+0x1a0>
	lladdr.len = llstorage.len;
 8058aec:	8a 45 c5             	mov    -0x3b(%ebp),%al
	return net_ipv6_nbr_add(net_pkt_iface(pkt),
 8058aef:	83 ec 0c             	sub    $0xc,%esp
 8058af2:	6a 02                	push   $0x2
	lladdr.len = llstorage.len;
 8058af4:	88 45 b0             	mov    %al,-0x50(%ebp)
	lladdr.addr = llstorage.addr;
 8058af7:	8d 45 c6             	lea    -0x3a(%ebp),%eax
 8058afa:	89 45 ac             	mov    %eax,-0x54(%ebp)
	return net_ipv6_nbr_add(net_pkt_iface(pkt),
 8058afd:	8d 45 ac             	lea    -0x54(%ebp),%eax
 8058b00:	6a 01                	push   $0x1
 8058b02:	50                   	push   %eax
 8058b03:	8b 46 08             	mov    0x8(%esi),%eax
				(struct in6_addr *)NET_IPV6_HDR(pkt)->src,
 8058b06:	8b 40 0c             	mov    0xc(%eax),%eax
 8058b09:	83 c0 08             	add    $0x8,%eax
	return net_ipv6_nbr_add(net_pkt_iface(pkt),
 8058b0c:	50                   	push   %eax
 8058b0d:	ff 76 18             	push   0x18(%esi)
 8058b10:	e8 b1 fd ff ff       	call   80588c6 <net_ipv6_nbr_add>
 8058b15:	83 c4 20             	add    $0x20,%esp
 8058b18:	89 45 84             	mov    %eax,-0x7c(%ebp)

		switch (nd_opt_hdr->type) {
		case NET_ICMPV6_ND_OPT_SLLAO:
			/* Update existing neighbor cache entry with link layer address. */
			nbr = handle_ra_neighbor(pkt, nd_opt_hdr->len);
			if (!nbr) {
 8058b1b:	85 c0                	test   %eax,%eax
 8058b1d:	74 41                	je     8058b60 <handle_ra_input+0x1d0>

			break;
		}

		nd_opt_hdr = (struct net_icmpv6_nd_opt_hdr *)
					net_pkt_get_data(pkt, &nd_access);
 8058b1f:	8d 45 a4             	lea    -0x5c(%ebp),%eax
 8058b22:	53                   	push   %ebx
 8058b23:	53                   	push   %ebx
 8058b24:	50                   	push   %eax
 8058b25:	56                   	push   %esi
 8058b26:	e8 a7 cd ff ff       	call   80558d2 <net_pkt_get_data>
 8058b2b:	83 c4 10             	add    $0x10,%esp
 8058b2e:	89 c3                	mov    %eax,%ebx
	while (nd_opt_hdr) {
 8058b30:	85 db                	test   %ebx,%ebx
 8058b32:	0f 84 7c 04 00 00    	je     8058fb4 <handle_ra_input+0x624>
		net_pkt_acknowledge_data(pkt, &nd_access);
 8058b38:	8b 55 a8             	mov    -0x58(%ebp),%edx
 8058b3b:	89 f0                	mov    %esi,%eax
 8058b3d:	e8 f7 f2 ff ff       	call   8057e39 <net_pkt_acknowledge_data.isra.0>
		switch (nd_opt_hdr->type) {
 8058b42:	8a 03                	mov    (%ebx),%al
 8058b44:	3c 05                	cmp    $0x5,%al
 8058b46:	74 40                	je     8058b88 <handle_ra_input+0x1f8>
 8058b48:	77 29                	ja     8058b73 <handle_ra_input+0x1e3>
 8058b4a:	3c 01                	cmp    $0x1,%al
 8058b4c:	75 1c                	jne    8058b6a <handle_ra_input+0x1da>
			nbr = handle_ra_neighbor(pkt, nd_opt_hdr->len);
 8058b4e:	0f b6 53 01          	movzbl 0x1(%ebx),%edx
	if (!read_llao(pkt, len, &llstorage)) {
 8058b52:	8d 4d c4             	lea    -0x3c(%ebp),%ecx
 8058b55:	89 f0                	mov    %esi,%eax
 8058b57:	e8 79 f2 ff ff       	call   8057dd5 <read_llao>
 8058b5c:	84 c0                	test   %al,%al
 8058b5e:	75 8c                	jne    8058aec <handle_ra_input+0x15c>
	return NET_OK;

drop:
	net_stats_update_ipv6_nd_drop(net_pkt_iface(pkt));

	return NET_DROP;
 8058b60:	b8 02 00 00 00       	mov    $0x2,%eax
 8058b65:	e9 02 05 00 00       	jmp    805906c <handle_ra_input+0x6dc>
		switch (nd_opt_hdr->type) {
 8058b6a:	3c 03                	cmp    $0x3,%al
 8058b6c:	74 65                	je     8058bd3 <handle_ra_input+0x243>
 8058b6e:	e9 1d 04 00 00       	jmp    8058f90 <handle_ra_input+0x600>
 8058b73:	3c 18                	cmp    $0x18,%al
 8058b75:	0f 84 77 02 00 00    	je     8058df2 <handle_ra_input+0x462>
 8058b7b:	3c 19                	cmp    $0x19,%al
 8058b7d:	0f 84 5b 03 00 00    	je     8058ede <handle_ra_input+0x54e>
 8058b83:	e9 08 04 00 00       	jmp    8058f90 <handle_ra_input+0x600>
			if (net_pkt_skip(pkt, 2) ||
 8058b88:	50                   	push   %eax
 8058b89:	50                   	push   %eax
 8058b8a:	6a 02                	push   $0x2
 8058b8c:	56                   	push   %esi
 8058b8d:	e8 df c7 ff ff       	call   8055371 <net_pkt_skip>
 8058b92:	83 c4 10             	add    $0x10,%esp
 8058b95:	85 c0                	test   %eax,%eax
 8058b97:	75 c7                	jne    8058b60 <handle_ra_input+0x1d0>
			    net_pkt_read_be32(pkt, &mtu)) {
 8058b99:	50                   	push   %eax
 8058b9a:	50                   	push   %eax
 8058b9b:	8d 45 90             	lea    -0x70(%ebp),%eax
 8058b9e:	50                   	push   %eax
 8058b9f:	56                   	push   %esi
 8058ba0:	e8 95 c9 ff ff       	call   805553a <net_pkt_read_be32>
 8058ba5:	83 c4 10             	add    $0x10,%esp
			if (net_pkt_skip(pkt, 2) ||
 8058ba8:	85 c0                	test   %eax,%eax
 8058baa:	75 b4                	jne    8058b60 <handle_ra_input+0x1d0>
			if (mtu < MIN_IPV6_MTU || mtu > MAX_IPV6_MTU) {
 8058bac:	8b 45 90             	mov    -0x70(%ebp),%eax
 8058baf:	8d 90 00 fb ff ff    	lea    -0x500(%eax),%edx
 8058bb5:	81 fa ff fa 00 00    	cmp    $0xfaff,%edx
 8058bbb:	77 a3                	ja     8058b60 <handle_ra_input+0x1d0>
	return pkt->iface;
 8058bbd:	8b 56 18             	mov    0x18(%esi),%edx
	if (iface == NULL) {
 8058bc0:	85 d2                	test   %edx,%edx
 8058bc2:	0f 84 57 ff ff ff    	je     8058b1f <handle_ra_input+0x18f>
	iface->if_dev->mtu = mtu;
 8058bc8:	8b 12                	mov    (%edx),%edx
 8058bca:	66 89 42 18          	mov    %ax,0x18(%edx)
 8058bce:	e9 4c ff ff ff       	jmp    8058b1f <handle_ra_input+0x18f>
			if (nd_opt_hdr->len != 4) {
 8058bd3:	80 7b 01 04          	cmpb   $0x4,0x1(%ebx)
 8058bd7:	75 87                	jne    8058b60 <handle_ra_input+0x1d0>
	NET_PKT_DATA_ACCESS_DEFINE(rapfx_access,
 8058bd9:	8d 45 c4             	lea    -0x3c(%ebp),%eax
 8058bdc:	c7 45 b0 1e 00 00 00 	movl   $0x1e,-0x50(%ebp)
 8058be3:	89 45 ac             	mov    %eax,-0x54(%ebp)
				net_pkt_get_data(pkt, &rapfx_access);
 8058be6:	50                   	push   %eax
 8058be7:	50                   	push   %eax
 8058be8:	8d 45 ac             	lea    -0x54(%ebp),%eax
 8058beb:	50                   	push   %eax
 8058bec:	56                   	push   %esi
 8058bed:	e8 e0 cc ff ff       	call   80558d2 <net_pkt_get_data>
 8058bf2:	83 c4 10             	add    $0x10,%esp
 8058bf5:	89 c3                	mov    %eax,%ebx
	if (!pfx_info) {
 8058bf7:	85 c0                	test   %eax,%eax
 8058bf9:	0f 84 61 ff ff ff    	je     8058b60 <handle_ra_input+0x1d0>
	net_pkt_acknowledge_data(pkt, &rapfx_access);
 8058bff:	8b 55 b0             	mov    -0x50(%ebp),%edx
 8058c02:	89 f0                	mov    %esi,%eax
 8058c04:	e8 30 f2 ff ff       	call   8057e39 <net_pkt_acknowledge_data.isra.0>
	valid_lifetime = ntohl(pfx_info->valid_lifetime);
 8058c09:	8b 7b 02             	mov    0x2(%ebx),%edi
 8058c0c:	8b 43 06             	mov    0x6(%ebx),%eax
 8058c0f:	0f cf                	bswap  %edi
	preferred_lifetime = ntohl(pfx_info->preferred_lifetime);
 8058c11:	0f c8                	bswap  %eax
	if (valid_lifetime >= preferred_lifetime &&
 8058c13:	39 c7                	cmp    %eax,%edi
 8058c15:	0f 82 04 ff ff ff    	jb     8058b1f <handle_ra_input+0x18f>
 8058c1b:	66 81 7b 0e fe 80    	cmpw   $0x80fe,0xe(%ebx)
 8058c21:	0f 84 f8 fe ff ff    	je     8058b1f <handle_ra_input+0x18f>
		if (pfx_info->flags & NET_ICMPV6_RA_FLAG_ONLINK) {
 8058c27:	80 7b 01 00          	cmpb   $0x0,0x1(%ebx)
 8058c2b:	79 7d                	jns    8058caa <handle_ra_input+0x31a>
	prefix = net_if_ipv6_prefix_lookup(net_pkt_iface(pkt),
 8058c2d:	50                   	push   %eax
 8058c2e:	0f b6 03             	movzbl (%ebx),%eax
					   (struct in6_addr *)prefix_info->prefix,
 8058c31:	8d 53 0e             	lea    0xe(%ebx),%edx
	prefix = net_if_ipv6_prefix_lookup(net_pkt_iface(pkt),
 8058c34:	89 95 7c ff ff ff    	mov    %edx,-0x84(%ebp)
 8058c3a:	50                   	push   %eax
 8058c3b:	52                   	push   %edx
 8058c3c:	ff 76 18             	push   0x18(%esi)
 8058c3f:	e8 48 93 ff ff       	call   8051f8c <net_if_ipv6_prefix_lookup>
 8058c44:	83 c4 10             	add    $0x10,%esp
	if (!prefix) {
 8058c47:	8b 95 7c ff ff ff    	mov    -0x84(%ebp),%edx
 8058c4d:	85 c0                	test   %eax,%eax
 8058c4f:	75 1c                	jne    8058c6d <handle_ra_input+0x2dd>
		if (!prefix_info->valid_lifetime) {
 8058c51:	8b 43 02             	mov    0x2(%ebx),%eax
 8058c54:	85 c0                	test   %eax,%eax
 8058c56:	74 52                	je     8058caa <handle_ra_input+0x31a>
		prefix = net_if_ipv6_prefix_add(net_pkt_iface(pkt),
 8058c58:	50                   	push   %eax
 8058c59:	0f b6 03             	movzbl (%ebx),%eax
 8058c5c:	50                   	push   %eax
 8058c5d:	52                   	push   %edx
 8058c5e:	ff 76 18             	push   0x18(%esi)
 8058c61:	e8 d3 91 ff ff       	call   8051e39 <net_if_ipv6_prefix_add>
 8058c66:	83 c4 10             	add    $0x10,%esp
		if (prefix) {
 8058c69:	85 c0                	test   %eax,%eax
 8058c6b:	74 3d                	je     8058caa <handle_ra_input+0x31a>
	switch (prefix_info->valid_lifetime) {
 8058c6d:	8b 53 02             	mov    0x2(%ebx),%edx
 8058c70:	85 d2                	test   %edx,%edx
 8058c72:	74 0e                	je     8058c82 <handle_ra_input+0x2f2>
 8058c74:	42                   	inc    %edx
 8058c75:	8a 50 25             	mov    0x25(%eax),%dl
 8058c78:	75 1c                	jne    8058c96 <handle_ra_input+0x306>
	prefix->is_infinite = is_infinite;
 8058c7a:	83 ca 01             	or     $0x1,%edx
 8058c7d:	88 50 25             	mov    %dl,0x25(%eax)
}
 8058c80:	eb 28                	jmp    8058caa <handle_ra_input+0x31a>
		net_if_ipv6_prefix_rm(net_pkt_iface(pkt),
 8058c82:	51                   	push   %ecx
 8058c83:	0f b6 50 24          	movzbl 0x24(%eax),%edx
 8058c87:	83 c0 10             	add    $0x10,%eax
 8058c8a:	52                   	push   %edx
 8058c8b:	50                   	push   %eax
 8058c8c:	ff 76 18             	push   0x18(%esi)
 8058c8f:	e8 be 94 ff ff       	call   8052152 <net_if_ipv6_prefix_rm>
 8058c94:	eb 11                	jmp    8058ca7 <handle_ra_input+0x317>
	prefix->is_infinite = is_infinite;
 8058c96:	83 e2 fe             	and    $0xfffffffe,%edx
 8058c99:	88 50 25             	mov    %dl,0x25(%eax)
		net_if_ipv6_prefix_set_timer(prefix,
 8058c9c:	52                   	push   %edx
 8058c9d:	52                   	push   %edx
 8058c9e:	ff 73 02             	push   0x2(%ebx)
 8058ca1:	50                   	push   %eax
 8058ca2:	e8 07 94 ff ff       	call   80520ae <net_if_ipv6_prefix_set_timer>
 8058ca7:	83 c4 10             	add    $0x10,%esp
		if ((pfx_info->flags & NET_ICMPV6_RA_FLAG_AUTONOMOUS) &&
 8058caa:	f6 43 01 40          	testb  $0x40,0x1(%ebx)
 8058cae:	0f 84 6b fe ff ff    	je     8058b1f <handle_ra_input+0x18f>
 8058cb4:	85 ff                	test   %edi,%edi
 8058cb6:	0f 84 63 fe ff ff    	je     8058b1f <handle_ra_input+0x18f>
		    valid_lifetime &&
 8058cbc:	80 3b 40             	cmpb   $0x40,(%ebx)
 8058cbf:	0f 85 5a fe ff ff    	jne    8058b1f <handle_ra_input+0x18f>
	struct in6_addr addr = { };
 8058cc5:	31 c0                	xor    %eax,%eax
 8058cc7:	8d 7d b4             	lea    -0x4c(%ebp),%edi
 8058cca:	b9 04 00 00 00       	mov    $0x4,%ecx
 8058ccf:	f3 ab                	rep stos %eax,%es:(%edi)
	return &iface->if_dev->link_addr;
 8058cd1:	8b 46 18             	mov    0x18(%esi),%eax
 8058cd4:	8b 00                	mov    (%eax),%eax
	UNALIGNED_PUT(htonl(0xfe800000), &addr->s6_addr32[0]);
 8058cd6:	c7 45 b4 fe 80 00 00 	movl   $0x80fe,-0x4c(%ebp)
	switch (lladdr->len) {
 8058cdd:	8a 50 14             	mov    0x14(%eax),%dl
 8058ce0:	80 fa 06             	cmp    $0x6,%dl
 8058ce3:	74 26                	je     8058d0b <handle_ra_input+0x37b>
 8058ce5:	80 fa 08             	cmp    $0x8,%dl
 8058ce8:	74 51                	je     8058d3b <handle_ra_input+0x3ab>
 8058cea:	80 fa 02             	cmp    $0x2,%dl
 8058ced:	75 60                	jne    8058d4f <handle_ra_input+0x3bf>
		if (lladdr->type == NET_LINK_IEEE802154) {
 8058cef:	80 78 15 01          	cmpb   $0x1,0x15(%eax)
 8058cf3:	75 5a                	jne    8058d4f <handle_ra_input+0x3bf>
			addr->s6_addr[11] = 0xff;
 8058cf5:	66 c7 45 bf ff fe    	movw   $0xfeff,-0x41(%ebp)
			addr->s6_addr[14] = lladdr->addr[0];
 8058cfb:	8b 40 10             	mov    0x10(%eax),%eax
 8058cfe:	8a 10                	mov    (%eax),%dl
 8058d00:	88 55 c2             	mov    %dl,-0x3e(%ebp)
			addr->s6_addr[15] = lladdr->addr[1];
 8058d03:	8a 40 01             	mov    0x1(%eax),%al
 8058d06:	88 45 c3             	mov    %al,-0x3d(%ebp)
 8058d09:	eb 44                	jmp    8058d4f <handle_ra_input+0x3bf>
		memcpy(&addr->s6_addr[8], lladdr->addr, 3);
 8058d0b:	8b 50 10             	mov    0x10(%eax),%edx
 8058d0e:	66 8b 0a             	mov    (%edx),%cx
 8058d11:	66 89 4d bc          	mov    %cx,-0x44(%ebp)
 8058d15:	8a 4a 02             	mov    0x2(%edx),%cl
		addr->s6_addr[11] = 0xff;
 8058d18:	66 c7 45 bf ff fe    	movw   $0xfeff,-0x41(%ebp)
 8058d1e:	88 4d be             	mov    %cl,-0x42(%ebp)
 8058d21:	66 8b 4a 03          	mov    0x3(%edx),%cx
 8058d25:	66 89 4d c1          	mov    %cx,-0x3f(%ebp)
 8058d29:	8a 52 05             	mov    0x5(%edx),%dl
 8058d2c:	88 55 c3             	mov    %dl,-0x3d(%ebp)
		if (lladdr->type == NET_LINK_ETHERNET) {
 8058d2f:	80 78 15 03          	cmpb   $0x3,0x15(%eax)
 8058d33:	75 1a                	jne    8058d4f <handle_ra_input+0x3bf>
			addr->s6_addr[8] ^= 0x02;
 8058d35:	80 75 bc 02          	xorb   $0x2,-0x44(%ebp)
 8058d39:	eb 14                	jmp    8058d4f <handle_ra_input+0x3bf>
 8058d3b:	8b 50 10             	mov    0x10(%eax),%edx
 8058d3e:	8b 02                	mov    (%edx),%eax
 8058d40:	8b 52 04             	mov    0x4(%edx),%edx
 8058d43:	89 45 bc             	mov    %eax,-0x44(%ebp)
		addr->s6_addr[8] ^= 0x02;
 8058d46:	83 f0 02             	xor    $0x2,%eax
 8058d49:	89 55 c0             	mov    %edx,-0x40(%ebp)
 8058d4c:	88 45 bc             	mov    %al,-0x44(%ebp)
	memcpy(&addr, prefix_info->prefix, sizeof(prefix_info->prefix) / 2);
 8058d4f:	8b 43 0e             	mov    0xe(%ebx),%eax
 8058d52:	8b 53 12             	mov    0x12(%ebx),%edx
	ifaddr = net_if_ipv6_addr_lookup(&addr, NULL);
 8058d55:	57                   	push   %edi
 8058d56:	57                   	push   %edi
 8058d57:	89 45 b4             	mov    %eax,-0x4c(%ebp)
 8058d5a:	8d 45 b4             	lea    -0x4c(%ebp),%eax
 8058d5d:	6a 00                	push   $0x0
 8058d5f:	50                   	push   %eax
 8058d60:	89 55 b8             	mov    %edx,-0x48(%ebp)
 8058d63:	e8 b7 85 ff ff       	call   805131f <net_if_ipv6_addr_lookup>
 8058d68:	83 c4 10             	add    $0x10,%esp
 8058d6b:	8b 4b 02             	mov    0x2(%ebx),%ecx
	if (ifaddr && ifaddr->addr_type == NET_ADDR_AUTOCONF) {
 8058d6e:	85 c0                	test   %eax,%eax
	ifaddr = net_if_ipv6_addr_lookup(&addr, NULL);
 8058d70:	89 c7                	mov    %eax,%edi
	if (ifaddr && ifaddr->addr_type == NET_ADDR_AUTOCONF) {
 8058d72:	74 60                	je     8058dd4 <handle_ra_input+0x444>
 8058d74:	80 78 2c 01          	cmpb   $0x1,0x2c(%eax)
 8058d78:	75 5a                	jne    8058dd4 <handle_ra_input+0x444>
		if (prefix_info->valid_lifetime ==
 8058d7a:	83 f9 ff             	cmp    $0xffffffff,%ecx
 8058d7d:	75 09                	jne    8058d88 <handle_ra_input+0x3f8>
	ifaddr->is_infinite = is_infinite;
 8058d7f:	80 48 2f 01          	orb    $0x1,0x2f(%eax)
			return;
 8058d83:	e9 97 fd ff ff       	jmp    8058b1f <handle_ra_input+0x18f>
		if ((prefix_info->valid_lifetime > TWO_HOURS) ||
 8058d88:	81 f9 20 1c 00 00    	cmp    $0x1c20,%ecx
 8058d8e:	76 07                	jbe    8058d97 <handle_ra_input+0x407>
			net_if_ipv6_addr_update_lifetime(
 8058d90:	51                   	push   %ecx
 8058d91:	51                   	push   %ecx
 8058d92:	ff 73 02             	push   0x2(%ebx)
 8058d95:	eb 2b                	jmp    8058dc2 <handle_ra_input+0x432>
 8058d97:	89 8d 7c ff ff ff    	mov    %ecx,-0x84(%ebp)
	return (uint32_t)k_uptime_get();
 8058d9d:	e8 72 ed ff ff       	call   8057b14 <k_uptime_get>
	return net_timeout_remaining(&ifaddr->lifetime, k_uptime_get_32());
 8058da2:	52                   	push   %edx
 8058da3:	52                   	push   %edx
 8058da4:	50                   	push   %eax
 8058da5:	8d 47 14             	lea    0x14(%edi),%eax
 8058da8:	50                   	push   %eax
 8058da9:	e8 a4 9f ff ff       	call   8052d52 <net_timeout_remaining>
		if ((prefix_info->valid_lifetime > TWO_HOURS) ||
 8058dae:	8b 8d 7c ff ff ff    	mov    -0x84(%ebp),%ecx
	return net_timeout_remaining(&ifaddr->lifetime, k_uptime_get_32());
 8058db4:	83 c4 10             	add    $0x10,%esp
		if ((prefix_info->valid_lifetime > TWO_HOURS) ||
 8058db7:	39 c1                	cmp    %eax,%ecx
 8058db9:	77 d5                	ja     8058d90 <handle_ra_input+0x400>
			net_if_ipv6_addr_update_lifetime(ifaddr, TWO_HOURS);
 8058dbb:	50                   	push   %eax
 8058dbc:	50                   	push   %eax
 8058dbd:	68 20 1c 00 00       	push   $0x1c20
 8058dc2:	57                   	push   %edi
 8058dc3:	e8 65 87 ff ff       	call   805152d <net_if_ipv6_addr_update_lifetime>
 8058dc8:	80 67 2f fe          	andb   $0xfe,0x2f(%edi)
 8058dcc:	83 c4 10             	add    $0x10,%esp
}
 8058dcf:	e9 4b fd ff ff       	jmp    8058b1f <handle_ra_input+0x18f>
		if (prefix_info->valid_lifetime ==
 8058dd4:	83 f9 ff             	cmp    $0xffffffff,%ecx
 8058dd7:	8b 46 18             	mov    0x18(%esi),%eax
 8058dda:	8d 55 b4             	lea    -0x4c(%ebp),%edx
 8058ddd:	75 04                	jne    8058de3 <handle_ra_input+0x453>
			net_if_ipv6_addr_add(net_pkt_iface(pkt),
 8058ddf:	6a 00                	push   $0x0
 8058de1:	eb 01                	jmp    8058de4 <handle_ra_input+0x454>
			net_if_ipv6_addr_add(net_pkt_iface(pkt),
 8058de3:	51                   	push   %ecx
 8058de4:	6a 01                	push   $0x1
 8058de6:	52                   	push   %edx
 8058de7:	50                   	push   %eax
 8058de8:	e8 95 87 ff ff       	call   8051582 <net_if_ipv6_addr_add>
 8058ded:	e9 96 01 00 00       	jmp    8058f88 <handle_ra_input+0x5f8>
			if (nd_opt_hdr->len == 0U || nd_opt_hdr->len > 3U) {
 8058df2:	8a 5b 01             	mov    0x1(%ebx),%bl
 8058df5:	8d 43 ff             	lea    -0x1(%ebx),%eax
 8058df8:	88 85 7c ff ff ff    	mov    %al,-0x84(%ebp)
 8058dfe:	3c 02                	cmp    $0x2,%al
 8058e00:	0f 87 5a fd ff ff    	ja     8058b60 <handle_ra_input+0x1d0>
	NET_PKT_DATA_ACCESS_DEFINE(routeinfo_access,
 8058e06:	8d 45 96             	lea    -0x6a(%ebp),%eax
	struct in6_addr prefix_buf = { 0 };
 8058e09:	8d 7d c4             	lea    -0x3c(%ebp),%edi
 8058e0c:	b9 04 00 00 00       	mov    $0x4,%ecx
	NET_PKT_DATA_ACCESS_DEFINE(routeinfo_access,
 8058e11:	c7 45 b0 06 00 00 00 	movl   $0x6,-0x50(%ebp)
 8058e18:	89 45 ac             	mov    %eax,-0x54(%ebp)
	struct in6_addr prefix_buf = { 0 };
 8058e1b:	31 c0                	xor    %eax,%eax
 8058e1d:	f3 ab                	rep stos %eax,%es:(%edi)
				net_pkt_get_data(pkt, &routeinfo_access);
 8058e1f:	50                   	push   %eax
 8058e20:	50                   	push   %eax
 8058e21:	8d 45 ac             	lea    -0x54(%ebp),%eax
 8058e24:	50                   	push   %eax
 8058e25:	56                   	push   %esi
 8058e26:	e8 a7 ca ff ff       	call   80558d2 <net_pkt_get_data>
 8058e2b:	83 c4 10             	add    $0x10,%esp
 8058e2e:	89 c3                	mov    %eax,%ebx
	if (!route_info) {
 8058e30:	85 c0                	test   %eax,%eax
 8058e32:	0f 84 28 fd ff ff    	je     8058b60 <handle_ra_input+0x1d0>
	ret = net_pkt_acknowledge_data(pkt, &routeinfo_access);
 8058e38:	8b 55 b0             	mov    -0x50(%ebp),%edx
 8058e3b:	89 f0                	mov    %esi,%eax
 8058e3d:	e8 f7 ef ff ff       	call   8057e39 <net_pkt_acknowledge_data.isra.0>
	if (ret < 0) {
 8058e42:	85 c0                	test   %eax,%eax
 8058e44:	0f 88 16 fd ff ff    	js     8058b60 <handle_ra_input+0x1d0>
	prefix_len = route_info->prefix_len;
 8058e4a:	8a 03                	mov    (%ebx),%al
	preference = route_info->flags.prf;
 8058e4c:	8a 53 01             	mov    0x1(%ebx),%dl
 8058e4f:	8b 7b 02             	mov    0x2(%ebx),%edi
	uint8_t prefix_field_len = (len - 1) * 8;
 8058e52:	8a 9d 7c ff ff ff    	mov    -0x84(%ebp),%bl
	prefix_len = route_info->prefix_len;
 8058e58:	88 85 79 ff ff ff    	mov    %al,-0x87(%ebp)
	preference = route_info->flags.prf;
 8058e5e:	c0 ea 03             	shr    $0x3,%dl
	uint8_t prefix_field_len = (len - 1) * 8;
 8058e61:	c1 e3 03             	shl    $0x3,%ebx
	ret = net_pkt_read(pkt, &prefix_buf, prefix_field_len);
 8058e64:	50                   	push   %eax
	preference = route_info->flags.prf;
 8058e65:	83 e2 03             	and    $0x3,%edx
	ret = net_pkt_read(pkt, &prefix_buf, prefix_field_len);
 8058e68:	0f b6 db             	movzbl %bl,%ebx
	preference = route_info->flags.prf;
 8058e6b:	88 95 78 ff ff ff    	mov    %dl,-0x88(%ebp)
	ret = net_pkt_read(pkt, &prefix_buf, prefix_field_len);
 8058e71:	53                   	push   %ebx
 8058e72:	8d 5d c4             	lea    -0x3c(%ebp),%ebx
 8058e75:	53                   	push   %ebx
 8058e76:	56                   	push   %esi
 8058e77:	e8 9e c6 ff ff       	call   805551a <net_pkt_read>
 8058e7c:	83 c4 10             	add    $0x10,%esp
	if (ret < 0) {
 8058e7f:	85 c0                	test   %eax,%eax
 8058e81:	0f 88 d9 fc ff ff    	js     8058b60 <handle_ra_input+0x1d0>
 8058e87:	0f cf                	bswap  %edi
	if (route_lifetime == 0) {
 8058e89:	85 ff                	test   %edi,%edi
	return pkt->iface;
 8058e8b:	8b 46 18             	mov    0x18(%esi),%eax
 8058e8e:	0f b6 95 78 ff ff ff 	movzbl -0x88(%ebp),%edx
 8058e95:	75 22                	jne    8058eb9 <handle_ra_input+0x529>
		route = net_route_lookup(net_pkt_orig_iface(pkt), &prefix_buf);
 8058e97:	57                   	push   %edi
 8058e98:	57                   	push   %edi
 8058e99:	53                   	push   %ebx
 8058e9a:	50                   	push   %eax
 8058e9b:	e8 cc 0f 00 00       	call   8059e6c <net_route_lookup>
 8058ea0:	83 c4 10             	add    $0x10,%esp
		if (route != NULL) {
 8058ea3:	85 c0                	test   %eax,%eax
 8058ea5:	0f 84 74 fc ff ff    	je     8058b1f <handle_ra_input+0x18f>
			ret = net_route_del(route);
 8058eab:	83 ec 0c             	sub    $0xc,%esp
 8058eae:	50                   	push   %eax
 8058eaf:	e8 86 11 00 00       	call   805a03a <net_route_del>
 8058eb4:	e9 cf 00 00 00       	jmp    8058f88 <handle_ra_input+0x5f8>
		route = net_route_add(net_pkt_orig_iface(pkt),
 8058eb9:	51                   	push   %ecx
 8058eba:	51                   	push   %ecx
 8058ebb:	52                   	push   %edx
 8058ebc:	57                   	push   %edi
	return pkt->frags->data;
 8058ebd:	8b 56 08             	mov    0x8(%esi),%edx
				      (struct in6_addr *)NET_IPV6_HDR(pkt)->src,
 8058ec0:	8b 52 0c             	mov    0xc(%edx),%edx
 8058ec3:	83 c2 08             	add    $0x8,%edx
		route = net_route_add(net_pkt_orig_iface(pkt),
 8058ec6:	52                   	push   %edx
 8058ec7:	0f b6 95 79 ff ff ff 	movzbl -0x87(%ebp),%edx
 8058ece:	52                   	push   %edx
 8058ecf:	53                   	push   %ebx
 8058ed0:	50                   	push   %eax
 8058ed1:	e8 aa 13 00 00       	call   805a280 <net_route_add>
 8058ed6:	83 c4 20             	add    $0x20,%esp
		if (route == NULL) {
 8058ed9:	e9 41 fc ff ff       	jmp    8058b1f <handle_ra_input+0x18f>
	NET_PKT_DATA_ACCESS_DEFINE(rdnss_access, struct net_icmpv6_nd_opt_rdnss);
 8058ede:	8d 45 96             	lea    -0x6a(%ebp),%eax
			if (!handle_ra_rdnss(pkt, nd_opt_hdr->len)) {
 8058ee1:	0f b6 5b 01          	movzbl 0x1(%ebx),%ebx
	struct sockaddr_in6 dns = {
 8058ee5:	8d 7d c4             	lea    -0x3c(%ebp),%edi
 8058ee8:	b9 06 00 00 00       	mov    $0x6,%ecx
	NET_PKT_DATA_ACCESS_DEFINE(rdnss_access, struct net_icmpv6_nd_opt_rdnss);
 8058eed:	89 45 ac             	mov    %eax,-0x54(%ebp)
	struct sockaddr_in6 dns = {
 8058ef0:	31 c0                	xor    %eax,%eax
 8058ef2:	f3 ab                	rep stos %eax,%es:(%edi)
	const struct sockaddr *dns_servers[] = {
 8058ef4:	8d 45 c4             	lea    -0x3c(%ebp),%eax
	NET_PKT_DATA_ACCESS_DEFINE(rdnss_access, struct net_icmpv6_nd_opt_rdnss);
 8058ef7:	c7 45 b0 06 00 00 00 	movl   $0x6,-0x50(%ebp)
	const struct sockaddr *dns_servers[] = {
 8058efe:	89 45 b4             	mov    %eax,-0x4c(%ebp)
	rdnss = (struct net_icmpv6_nd_opt_rdnss *) net_pkt_get_data(pkt, &rdnss_access);
 8058f01:	8d 45 ac             	lea    -0x54(%ebp),%eax
	struct sockaddr_in6 dns = {
 8058f04:	66 c7 45 c4 02 00    	movw   $0x2,-0x3c(%ebp)
	const struct sockaddr *dns_servers[] = {
 8058f0a:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
	rdnss = (struct net_icmpv6_nd_opt_rdnss *) net_pkt_get_data(pkt, &rdnss_access);
 8058f11:	57                   	push   %edi
 8058f12:	57                   	push   %edi
 8058f13:	50                   	push   %eax
 8058f14:	56                   	push   %esi
 8058f15:	e8 b8 c9 ff ff       	call   80558d2 <net_pkt_get_data>
 8058f1a:	83 c4 10             	add    $0x10,%esp
	if (!rdnss) {
 8058f1d:	85 c0                	test   %eax,%eax
 8058f1f:	0f 84 3b fc ff ff    	je     8058b60 <handle_ra_input+0x1d0>
	ret = net_pkt_acknowledge_data(pkt, &rdnss_access);
 8058f25:	8b 55 b0             	mov    -0x50(%ebp),%edx
 8058f28:	89 f0                	mov    %esi,%eax
 8058f2a:	e8 0a ef ff ff       	call   8057e39 <net_pkt_acknowledge_data.isra.0>
	if (ret < 0) {
 8058f2f:	85 c0                	test   %eax,%eax
 8058f31:	0f 88 29 fc ff ff    	js     8058b60 <handle_ra_input+0x1d0>
	rdnss_size = len * 8U - 2 - sizeof(struct net_icmpv6_nd_opt_rdnss);
 8058f37:	8d 3c dd f8 ff ff ff 	lea    -0x8(,%ebx,8),%edi
	if ((rdnss_size % NET_IPV6_ADDR_SIZE) != 0) {
 8058f3e:	80 e3 01             	and    $0x1,%bl
 8058f41:	0f 84 19 fc ff ff    	je     8058b60 <handle_ra_input+0x1d0>
	ret = net_pkt_read(pkt, dns.sin6_addr.s6_addr, NET_IPV6_ADDR_SIZE);
 8058f47:	8d 45 c8             	lea    -0x38(%ebp),%eax
 8058f4a:	53                   	push   %ebx
 8058f4b:	6a 10                	push   $0x10
 8058f4d:	50                   	push   %eax
 8058f4e:	56                   	push   %esi
 8058f4f:	e8 c6 c5 ff ff       	call   805551a <net_pkt_read>
 8058f54:	83 c4 10             	add    $0x10,%esp
	if (ret < 0) {
 8058f57:	85 c0                	test   %eax,%eax
 8058f59:	0f 88 01 fc ff ff    	js     8058b60 <handle_ra_input+0x1d0>
	if (net_pkt_skip(pkt, rdnss_size - NET_IPV6_ADDR_SIZE)) {
 8058f5f:	83 ef 10             	sub    $0x10,%edi
 8058f62:	51                   	push   %ecx
 8058f63:	51                   	push   %ecx
 8058f64:	57                   	push   %edi
 8058f65:	56                   	push   %esi
 8058f66:	e8 06 c4 ff ff       	call   8055371 <net_pkt_skip>
 8058f6b:	83 c4 10             	add    $0x10,%esp
 8058f6e:	85 c0                	test   %eax,%eax
 8058f70:	0f 85 ea fb ff ff    	jne    8058b60 <handle_ra_input+0x1d0>
	ctx = dns_resolve_get_default();
 8058f76:	e8 f1 2c 00 00       	call   805bc6c <dns_resolve_get_default>
	ret = dns_resolve_reconfigure(ctx, NULL, dns_servers);
 8058f7b:	52                   	push   %edx
 8058f7c:	8d 55 b4             	lea    -0x4c(%ebp),%edx
 8058f7f:	52                   	push   %edx
 8058f80:	6a 00                	push   $0x0
 8058f82:	50                   	push   %eax
 8058f83:	e8 d6 2b 00 00       	call   805bb5e <dns_resolve_reconfigure>
 8058f88:	83 c4 10             	add    $0x10,%esp
	if (ret < 0) {
 8058f8b:	e9 8f fb ff ff       	jmp    8058b1f <handle_ra_input+0x18f>
			if (net_pkt_skip(pkt, nd_opt_hdr->len * 8U - 2)) {
 8058f90:	57                   	push   %edi
 8058f91:	57                   	push   %edi
 8058f92:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
 8058f96:	8d 04 c5 fe ff ff ff 	lea    -0x2(,%eax,8),%eax
 8058f9d:	50                   	push   %eax
 8058f9e:	56                   	push   %esi
 8058f9f:	e8 cd c3 ff ff       	call   8055371 <net_pkt_skip>
 8058fa4:	83 c4 10             	add    $0x10,%esp
 8058fa7:	85 c0                	test   %eax,%eax
 8058fa9:	0f 84 70 fb ff ff    	je     8058b1f <handle_ra_input+0x18f>
 8058faf:	e9 ac fb ff ff       	jmp    8058b60 <handle_ra_input+0x1d0>
					   (struct in6_addr *)ip_hdr->src);
 8058fb4:	8b 7d 80             	mov    -0x80(%ebp),%edi
 8058fb7:	66 8b 9d 7a ff ff ff 	mov    -0x86(%ebp),%bx
	router = net_if_ipv6_router_lookup(net_pkt_iface(pkt),
 8058fbe:	51                   	push   %ecx
 8058fbf:	51                   	push   %ecx
 8058fc0:	86 fb                	xchg   %bh,%bl
					   (struct in6_addr *)ip_hdr->src);
 8058fc2:	83 c7 08             	add    $0x8,%edi
	router = net_if_ipv6_router_lookup(net_pkt_iface(pkt),
 8058fc5:	57                   	push   %edi
 8058fc6:	ff 76 18             	push   0x18(%esi)
 8058fc9:	e8 51 92 ff ff       	call   805221f <net_if_ipv6_router_lookup>
 8058fce:	83 c4 10             	add    $0x10,%esp
	if (router) {
 8058fd1:	85 c0                	test   %eax,%eax
 8058fd3:	74 2e                	je     8059003 <handle_ra_input+0x673>
		if (!router_lifetime) {
 8058fd5:	66 85 db             	test   %bx,%bx
 8058fd8:	75 0b                	jne    8058fe5 <handle_ra_input+0x655>
			net_if_ipv6_router_rm(router);
 8058fda:	83 ec 0c             	sub    $0xc,%esp
 8058fdd:	50                   	push   %eax
 8058fde:	e8 a2 92 ff ff       	call   8052285 <net_if_ipv6_router_rm>
 8058fe3:	eb 2c                	jmp    8059011 <handle_ra_input+0x681>
			if (nbr) {
 8058fe5:	83 7d 84 00          	cmpl   $0x0,-0x7c(%ebp)
 8058fe9:	74 0a                	je     8058ff5 <handle_ra_input+0x665>
 8058feb:	8b 4d 84             	mov    -0x7c(%ebp),%ecx
 8058fee:	8b 51 0c             	mov    0xc(%ecx),%edx
				net_ipv6_nbr_data(nbr)->is_router = true;
 8058ff1:	c6 42 2f 01          	movb   $0x1,0x2f(%edx)
			net_if_ipv6_router_update_lifetime(
 8058ff5:	0f b7 db             	movzwl %bx,%ebx
 8058ff8:	52                   	push   %edx
 8058ff9:	52                   	push   %edx
 8058ffa:	53                   	push   %ebx
 8058ffb:	50                   	push   %eax
 8058ffc:	e8 43 92 ff ff       	call   8052244 <net_if_ipv6_router_update_lifetime>
 8059001:	eb 0e                	jmp    8059011 <handle_ra_input+0x681>
		net_if_ipv6_router_add(net_pkt_iface(pkt),
 8059003:	0f b7 db             	movzwl %bx,%ebx
 8059006:	50                   	push   %eax
 8059007:	53                   	push   %ebx
 8059008:	57                   	push   %edi
 8059009:	ff 76 18             	push   0x18(%esi)
 805900c:	e8 52 92 ff ff       	call   8052263 <net_if_ipv6_router_add>
 8059011:	83 c4 10             	add    $0x10,%esp
	if (nbr && net_ipv6_nbr_data(nbr)->pending) {
 8059014:	83 7d 84 00          	cmpl   $0x0,-0x7c(%ebp)
 8059018:	74 3a                	je     8059054 <handle_ra_input+0x6c4>
 805901a:	8b 45 84             	mov    -0x7c(%ebp),%eax
 805901d:	8b 40 0c             	mov    0xc(%eax),%eax
 8059020:	8b 00                	mov    (%eax),%eax
 8059022:	85 c0                	test   %eax,%eax
 8059024:	74 2e                	je     8059054 <handle_ra_input+0x6c4>
		if (net_send_data(net_ipv6_nbr_data(nbr)->pending) < 0) {
 8059026:	83 ec 0c             	sub    $0xc,%esp
 8059029:	50                   	push   %eax
 805902a:	e8 01 74 ff ff       	call   8050430 <net_send_data>
 805902f:	83 c4 10             	add    $0x10,%esp
 8059032:	85 c0                	test   %eax,%eax
 8059034:	79 13                	jns    8059049 <handle_ra_input+0x6b9>
			net_pkt_unref(net_ipv6_nbr_data(nbr)->pending);
 8059036:	8b 45 84             	mov    -0x7c(%ebp),%eax
 8059039:	83 ec 0c             	sub    $0xc,%esp
 805903c:	8b 40 0c             	mov    0xc(%eax),%eax
 805903f:	ff 30                	push   (%eax)
 8059041:	e8 a2 bd ff ff       	call   8054de8 <net_pkt_unref>
 8059046:	83 c4 10             	add    $0x10,%esp
		nbr_clear_ns_pending(net_ipv6_nbr_data(nbr));
 8059049:	8b 45 84             	mov    -0x7c(%ebp),%eax
 805904c:	8b 40 0c             	mov    0xc(%eax),%eax
 805904f:	e8 49 ea ff ff       	call   8057a9d <nbr_clear_ns_pending>
	net_if_stop_rs(net_pkt_iface(pkt));
 8059054:	83 ec 0c             	sub    $0xc,%esp
 8059057:	ff 76 18             	push   0x18(%esi)
 805905a:	e8 8f 82 ff ff       	call   80512ee <net_if_stop_rs>
	net_pkt_unref(pkt);
 805905f:	89 34 24             	mov    %esi,(%esp)
 8059062:	e8 81 bd ff ff       	call   8054de8 <net_pkt_unref>
 8059067:	83 c4 10             	add    $0x10,%esp
	return NET_OK;
 805906a:	31 c0                	xor    %eax,%eax
}
 805906c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 805906f:	65 2b 15 14 00 00 00 	sub    %gs:0x14,%edx
 8059076:	74 05                	je     805907d <handle_ra_input+0x6ed>
 8059078:	e8 83 02 ff ff       	call   8049300 <__stack_chk_fail@plt>
 805907d:	8d 65 f4             	lea    -0xc(%ebp),%esp
 8059080:	5b                   	pop    %ebx
 8059081:	5e                   	pop    %esi
 8059082:	5f                   	pop    %edi
 8059083:	5d                   	pop    %ebp
 8059084:	c3                   	ret    

08059085 <handle_ns_input>:
{
 8059085:	55                   	push   %ebp
	size_t bytes = 0;
 8059086:	31 d2                	xor    %edx,%edx
 8059088:	89 e5                	mov    %esp,%ebp
 805908a:	57                   	push   %edi
 805908b:	56                   	push   %esi
 805908c:	53                   	push   %ebx
 805908d:	83 ec 5c             	sub    $0x5c,%esp
 8059090:	8b 45 08             	mov    0x8(%ebp),%eax
 8059093:	8b 5d 0c             	mov    0xc(%ebp),%ebx
 8059096:	8b 4d 10             	mov    0x10(%ebp),%ecx
 8059099:	89 45 a4             	mov    %eax,-0x5c(%ebp)
 805909c:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 80590a2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 80590a5:	31 c0                	xor    %eax,%eax
	NET_PKT_DATA_ACCESS_DEFINE(nd_access, struct net_icmpv6_nd_opt_hdr);
 80590a7:	8d 45 b2             	lea    -0x4e(%ebp),%eax
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ns_access,
 80590aa:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%ebp)
	NET_PKT_DATA_ACCESS_DEFINE(nd_access, struct net_icmpv6_nd_opt_hdr);
 80590b1:	89 45 bc             	mov    %eax,-0x44(%ebp)
 80590b4:	8b 45 a4             	mov    -0x5c(%ebp),%eax
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ns_access,
 80590b7:	c7 45 b8 14 00 00 00 	movl   $0x14,-0x48(%ebp)
	NET_PKT_DATA_ACCESS_DEFINE(nd_access, struct net_icmpv6_nd_opt_hdr);
 80590be:	c7 45 c0 02 00 00 00 	movl   $0x2,-0x40(%ebp)
	uint16_t length = net_pkt_get_len(pkt);
 80590c5:	8b 40 08             	mov    0x8(%eax),%eax
	while (buf) {
 80590c8:	85 c0                	test   %eax,%eax
 80590ca:	74 0b                	je     80590d7 <handle_ns_input+0x52>
		bytes += buf->len;
 80590cc:	0f b7 70 10          	movzwl 0x10(%eax),%esi
		buf = buf->frags;
 80590d0:	8b 40 04             	mov    0x4(%eax),%eax
		bytes += buf->len;
 80590d3:	01 f2                	add    %esi,%edx
		buf = buf->frags;
 80590d5:	eb f1                	jmp    80590c8 <handle_ns_input+0x43>
	ns_hdr = (struct net_icmpv6_ns_hdr *)net_pkt_get_data(pkt, &ns_access);
 80590d7:	50                   	push   %eax
	uint16_t length = net_pkt_get_len(pkt);
 80590d8:	89 d6                	mov    %edx,%esi
	ns_hdr = (struct net_icmpv6_ns_hdr *)net_pkt_get_data(pkt, &ns_access);
 80590da:	50                   	push   %eax
 80590db:	8d 45 b4             	lea    -0x4c(%ebp),%eax
 80590de:	50                   	push   %eax
 80590df:	ff 75 a4             	push   -0x5c(%ebp)
 80590e2:	89 4d 9c             	mov    %ecx,-0x64(%ebp)
	uint16_t length = net_pkt_get_len(pkt);
 80590e5:	89 55 a0             	mov    %edx,-0x60(%ebp)
	src_lladdr.len = 0;
 80590e8:	c6 45 c8 00          	movb   $0x0,-0x38(%ebp)
	ns_hdr = (struct net_icmpv6_ns_hdr *)net_pkt_get_data(pkt, &ns_access);
 80590ec:	e8 e1 c7 ff ff       	call   80558d2 <net_pkt_get_data>
 80590f1:	83 c4 10             	add    $0x10,%esp
	if (!ns_hdr) {
 80590f4:	8b 55 a0             	mov    -0x60(%ebp),%edx
 80590f7:	8b 4d 9c             	mov    -0x64(%ebp),%ecx
 80590fa:	85 c0                	test   %eax,%eax
	ns_hdr = (struct net_icmpv6_ns_hdr *)net_pkt_get_data(pkt, &ns_access);
 80590fc:	89 c7                	mov    %eax,%edi
	if (!ns_hdr) {
 80590fe:	0f 84 46 01 00 00    	je     805924a <handle_ns_input+0x1c5>
	if (((length < (sizeof(struct net_ipv6_hdr) +
 8059104:	66 83 fa 3f          	cmp    $0x3f,%dx
 8059108:	76 06                	jbe    8059110 <handle_ns_input+0x8b>
			  sizeof(struct net_icmpv6_ns_hdr))) ||
 805910a:	80 7b 07 ff          	cmpb   $0xff,0x7(%ebx)
 805910e:	74 10                	je     8059120 <handle_ns_input+0x9b>
	    (ip_hdr->hop_limit != NET_IPV6_ND_HOP_LIMIT)) &&
 8059110:	80 7f 04 ff          	cmpb   $0xff,0x4(%edi)
 8059114:	75 0a                	jne    8059120 <handle_ns_input+0x9b>
	    (net_ipv6_is_addr_mcast((struct in6_addr *)ns_hdr->tgt) &&
 8059116:	80 79 01 00          	cmpb   $0x0,0x1(%ecx)
 805911a:	0f 85 2a 01 00 00    	jne    805924a <handle_ns_input+0x1c5>
	net_pkt_acknowledge_data(pkt, &ns_access);
 8059120:	8b 55 b8             	mov    -0x48(%ebp),%edx
 8059123:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 8059126:	e8 0e ed ff ff       	call   8057e39 <net_pkt_acknowledge_data.isra.0>
	pkt->ipv6_ext_opt_len = len;
 805912b:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 805912e:	c6 40 3a 14          	movb   $0x14,0x3a(%eax)
	length -= (sizeof(struct net_ipv6_hdr) + sizeof(struct net_icmp_hdr));
 8059132:	8d 46 d4             	lea    -0x2c(%esi),%eax
 8059135:	66 89 45 a0          	mov    %ax,-0x60(%ebp)
				net_pkt_get_data(pkt, &nd_access);
 8059139:	50                   	push   %eax
 805913a:	50                   	push   %eax
 805913b:	8d 45 bc             	lea    -0x44(%ebp),%eax
 805913e:	50                   	push   %eax
 805913f:	ff 75 a4             	push   -0x5c(%ebp)
					net_pkt_get_data(pkt, &nd_access);
 8059142:	e8 8b c7 ff ff       	call   80558d2 <net_pkt_get_data>
 8059147:	83 c4 10             	add    $0x10,%esp
 805914a:	89 c6                	mov    %eax,%esi
	while (nd_opt_hdr && nd_opt_hdr->len > 0 &&
 805914c:	85 c0                	test   %eax,%eax
 805914e:	74 7c                	je     80591cc <handle_ns_input+0x147>
 8059150:	80 78 01 00          	cmpb   $0x0,0x1(%eax)
 8059154:	74 76                	je     80591cc <handle_ns_input+0x147>
	       net_pkt_ipv6_ext_opt_len(pkt) < length) {
 8059156:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 8059159:	0f b6 40 3a          	movzbl 0x3a(%eax),%eax
	while (nd_opt_hdr && nd_opt_hdr->len > 0 &&
 805915d:	66 3b 45 a0          	cmp    -0x60(%ebp),%ax
 8059161:	73 69                	jae    80591cc <handle_ns_input+0x147>
		net_pkt_acknowledge_data(pkt, &nd_access);
 8059163:	8b 55 c0             	mov    -0x40(%ebp),%edx
 8059166:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 8059169:	e8 cb ec ff ff       	call   8057e39 <net_pkt_acknowledge_data.isra.0>
		switch (nd_opt_hdr->type) {
 805916e:	80 3e 01             	cmpb   $0x1,(%esi)
 8059171:	75 33                	jne    80591a6 <handle_ns_input+0x121>
					(struct in6_addr *)ip_hdr->src)) {
 8059173:	8d 43 08             	lea    0x8(%ebx),%eax
			if (net_ipv6_is_addr_unspecified(
 8059176:	e8 ff e8 ff ff       	call   8057a7a <net_ipv6_is_addr_unspecified>
 805917b:	84 c0                	test   %al,%al
 805917d:	0f 85 c7 00 00 00    	jne    805924a <handle_ns_input+0x1c5>
			if (!read_llao(pkt, nd_opt_hdr->len, &src_lladdr_s)) {
 8059183:	0f b6 56 01          	movzbl 0x1(%esi),%edx
 8059187:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 805918a:	8d 4d cc             	lea    -0x34(%ebp),%ecx
 805918d:	e8 43 ec ff ff       	call   8057dd5 <read_llao>
 8059192:	84 c0                	test   %al,%al
 8059194:	0f 84 b0 00 00 00    	je     805924a <handle_ns_input+0x1c5>
			src_lladdr.len = src_lladdr_s.len;
 805919a:	8a 45 cd             	mov    -0x33(%ebp),%al
 805919d:	88 45 c8             	mov    %al,-0x38(%ebp)
			src_lladdr.addr = src_lladdr_s.addr;
 80591a0:	8d 45 ce             	lea    -0x32(%ebp),%eax
 80591a3:	89 45 c4             	mov    %eax,-0x3c(%ebp)
	return pkt->ipv6_ext_opt_len;
 80591a6:	8b 45 a4             	mov    -0x5c(%ebp),%eax
	pkt->ipv6_ext_opt_len = len;
 80591a9:	8b 4d a4             	mov    -0x5c(%ebp),%ecx
	return pkt->ipv6_ext_opt_len;
 80591ac:	8a 50 3a             	mov    0x3a(%eax),%dl
					     (nd_opt_hdr->len << 3));
 80591af:	8a 46 01             	mov    0x1(%esi),%al
					     net_pkt_ipv6_ext_opt_len(pkt) +
 80591b2:	8d 04 c2             	lea    (%edx,%eax,8),%eax
	pkt->ipv6_ext_opt_len = len;
 80591b5:	88 41 3a             	mov    %al,0x3a(%ecx)
		if (prev_opt_len >= net_pkt_ipv6_ext_opt_len(pkt)) {
 80591b8:	38 d0                	cmp    %dl,%al
 80591ba:	0f 86 8a 00 00 00    	jbe    805924a <handle_ns_input+0x1c5>
					net_pkt_get_data(pkt, &nd_access);
 80591c0:	50                   	push   %eax
 80591c1:	50                   	push   %eax
 80591c2:	8d 45 bc             	lea    -0x44(%ebp),%eax
 80591c5:	50                   	push   %eax
 80591c6:	51                   	push   %ecx
 80591c7:	e9 76 ff ff ff       	jmp    8059142 <handle_ns_input+0xbd>
		ifaddr = net_if_ipv6_addr_lookup_by_iface(
 80591cc:	8b 45 a4             	mov    -0x5c(%ebp),%eax
			    net_pkt_iface(pkt), (struct in6_addr *)ns_hdr->tgt);
 80591cf:	83 c7 04             	add    $0x4,%edi
		ifaddr = net_if_ipv6_addr_lookup_by_iface(
 80591d2:	56                   	push   %esi
 80591d3:	56                   	push   %esi
 80591d4:	57                   	push   %edi
 80591d5:	ff 70 18             	push   0x18(%eax)
 80591d8:	e8 dc 82 ff ff       	call   80514b9 <net_if_ipv6_addr_lookup_by_iface>
 80591dd:	83 c4 10             	add    $0x10,%esp
 80591e0:	89 c1                	mov    %eax,%ecx
	if (!ifaddr) {
 80591e2:	85 c0                	test   %eax,%eax
 80591e4:	74 64                	je     805924a <handle_ns_input+0x1c5>
		tgt = &ifaddr->address.in6_addr;
 80591e6:	8d 40 04             	lea    0x4(%eax),%eax
 80591e9:	89 45 98             	mov    %eax,-0x68(%ebp)
		na_src = (struct in6_addr *)ip_hdr->dst;
 80591ec:	8d 43 18             	lea    0x18(%ebx),%eax
 80591ef:	89 45 9c             	mov    %eax,-0x64(%ebp)
	if (net_ipv6_is_addr_unspecified((struct in6_addr *)ip_hdr->src)) {
 80591f2:	8d 43 08             	lea    0x8(%ebx),%eax
 80591f5:	89 45 a0             	mov    %eax,-0x60(%ebp)
 80591f8:	e8 7d e8 ff ff       	call   8057a7a <net_ipv6_is_addr_unspecified>
 80591fd:	84 c0                	test   %al,%al
 80591ff:	0f 84 93 00 00 00    	je     8059298 <handle_ns_input+0x213>
		UNALIGNED_GET(&addr->s6_addr32[2]) == htonl(0x00000001) &&
 8059205:	81 7b 18 ff 02 00 00 	cmpl   $0x2ff,0x18(%ebx)
 805920c:	75 3c                	jne    805924a <handle_ns_input+0x1c5>
	return UNALIGNED_GET(&addr->s6_addr32[0]) == htonl(0xff020000) &&
 805920e:	83 7b 1c 00          	cmpl   $0x0,0x1c(%ebx)
 8059212:	75 36                	jne    805924a <handle_ns_input+0x1c5>
		UNALIGNED_GET(&addr->s6_addr32[1]) == 0x00000000 &&
 8059214:	81 7b 20 00 00 00 01 	cmpl   $0x1000000,0x20(%ebx)
 805921b:	75 2d                	jne    805924a <handle_ns_input+0x1c5>
		((UNALIGNED_GET(&addr->s6_addr32[3]) & htonl(0xff000000)) ==
 805921d:	0f b6 43 24          	movzbl 0x24(%ebx),%eax
		UNALIGNED_GET(&addr->s6_addr32[2]) == htonl(0x00000001) &&
 8059221:	3d ff 00 00 00       	cmp    $0xff,%eax
 8059226:	75 22                	jne    805924a <handle_ns_input+0x1c5>
		if (ifaddr->addr_state == NET_ADDR_TENTATIVE) {
 8059228:	80 79 2d 00          	cmpb   $0x0,0x2d(%ecx)
 805922c:	75 26                	jne    8059254 <handle_ns_input+0x1cf>
	return pkt->iface;
 805922e:	8b 45 a4             	mov    -0x5c(%ebp),%eax
	if (net_ipv6_is_ll_addr(addr)) {
 8059231:	66 81 79 04 fe 80    	cmpw   $0x80fe,0x4(%ecx)
 8059237:	8b 40 18             	mov    0x18(%eax),%eax
 805923a:	74 0e                	je     805924a <handle_ns_input+0x1c5>
	net_if_ipv6_dad_failed(iface, addr);
 805923c:	53                   	push   %ebx
 805923d:	53                   	push   %ebx
 805923e:	ff 75 98             	push   -0x68(%ebp)
 8059241:	50                   	push   %eax
 8059242:	e8 b8 88 ff ff       	call   8051aff <net_if_ipv6_dad_failed>
 8059247:	83 c4 10             	add    $0x10,%esp
	return NET_DROP;
 805924a:	b8 02 00 00 00       	mov    $0x2,%eax
	return true;
 805924f:	e9 05 01 00 00       	jmp    8059359 <handle_ns_input+0x2d4>
		net_ipaddr_copy((struct in6_addr *)ip_hdr->src,
 8059254:	8b 45 a4             	mov    -0x5c(%ebp),%eax
	UNALIGNED_PUT(htons(addr4), &addr->s6_addr16[4]);
 8059257:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
 805925e:	8d 7d d4             	lea    -0x2c(%ebp),%edi
	UNALIGNED_PUT(htons(addr6), &addr->s6_addr16[6]);
 8059261:	c7 43 24 00 00 00 01 	movl   $0x1000000,0x24(%ebx)
		flags = NET_ICMPV6_NA_FLAG_OVERRIDE;
 8059268:	bb 20 00 00 00       	mov    $0x20,%ebx
		net_ipaddr_copy((struct in6_addr *)ip_hdr->src,
 805926d:	51                   	push   %ecx
 805926e:	51                   	push   %ecx
 805926f:	ff 75 9c             	push   -0x64(%ebp)
 8059272:	ff 70 18             	push   0x18(%eax)
 8059275:	e8 e6 90 ff ff       	call   8052360 <net_if_ipv6_select_src_addr>
 805927a:	b9 04 00 00 00       	mov    $0x4,%ecx
 805927f:	83 c4 10             	add    $0x10,%esp
 8059282:	89 c6                	mov    %eax,%esi
 8059284:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
 8059286:	8b 7d a0             	mov    -0x60(%ebp),%edi
 8059289:	8d 75 d4             	lea    -0x2c(%ebp),%esi
 805928c:	b9 04 00 00 00       	mov    $0x4,%ecx
 8059291:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
		na_src = (struct in6_addr *)ip_hdr->src;
 8059293:	8b 7d a0             	mov    -0x60(%ebp),%edi
		goto send_na;
 8059296:	eb 62                	jmp    80592fa <handle_ns_input+0x275>
	return net_if_ipv6_addr_lookup(addr, NULL) != NULL;
 8059298:	52                   	push   %edx
 8059299:	52                   	push   %edx
 805929a:	6a 00                	push   $0x0
 805929c:	ff 75 a0             	push   -0x60(%ebp)
 805929f:	e8 7b 80 ff ff       	call   805131f <net_if_ipv6_addr_lookup>
 80592a4:	83 c4 10             	add    $0x10,%esp
	if (net_ipv6_is_my_addr((struct in6_addr *)ip_hdr->src)) {
 80592a7:	85 c0                	test   %eax,%eax
 80592a9:	75 9f                	jne    805924a <handle_ns_input+0x1c5>
		UNALIGNED_GET(&addr->s6_addr32[2]) == htonl(0x00000001) &&
 80592ab:	81 7b 18 ff 02 00 00 	cmpl   $0x2ff,0x18(%ebx)
 80592b2:	75 1a                	jne    80592ce <handle_ns_input+0x249>
	return UNALIGNED_GET(&addr->s6_addr32[0]) == htonl(0xff020000) &&
 80592b4:	83 7b 1c 00          	cmpl   $0x0,0x1c(%ebx)
 80592b8:	75 14                	jne    80592ce <handle_ns_input+0x249>
		UNALIGNED_GET(&addr->s6_addr32[1]) == 0x00000000 &&
 80592ba:	81 7b 20 00 00 00 01 	cmpl   $0x1000000,0x20(%ebx)
 80592c1:	75 0b                	jne    80592ce <handle_ns_input+0x249>
		((UNALIGNED_GET(&addr->s6_addr32[3]) & htonl(0xff000000)) ==
 80592c3:	0f b6 43 24          	movzbl 0x24(%ebx),%eax
		UNALIGNED_GET(&addr->s6_addr32[2]) == htonl(0x00000001) &&
 80592c7:	3d ff 00 00 00       	cmp    $0xff,%eax
 80592cc:	74 21                	je     80592ef <handle_ns_input+0x26a>
		ifaddr = net_if_ipv6_addr_lookup_by_iface(
 80592ce:	50                   	push   %eax
 80592cf:	50                   	push   %eax
 80592d0:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 80592d3:	ff 75 9c             	push   -0x64(%ebp)
 80592d6:	ff 70 18             	push   0x18(%eax)
 80592d9:	e8 db 81 ff ff       	call   80514b9 <net_if_ipv6_addr_lookup_by_iface>
 80592de:	83 c4 10             	add    $0x10,%esp
	if (ifaddr) {
 80592e1:	85 c0                	test   %eax,%eax
 80592e3:	0f 84 61 ff ff ff    	je     805924a <handle_ns_input+0x1c5>
		tgt = &ifaddr->address.in6_addr;
 80592e9:	83 c0 04             	add    $0x4,%eax
 80592ec:	89 45 98             	mov    %eax,-0x68(%ebp)
		na_dst = (struct in6_addr *)ip_hdr->src;
 80592ef:	8b 45 a0             	mov    -0x60(%ebp),%eax
		flags = NET_ICMPV6_NA_FLAG_SOLICITED |
 80592f2:	bb 60 00 00 00       	mov    $0x60,%ebx
		na_dst = (struct in6_addr *)ip_hdr->src;
 80592f7:	89 45 9c             	mov    %eax,-0x64(%ebp)
 80592fa:	8b 45 a4             	mov    -0x5c(%ebp),%eax
	if (src_lladdr.len) {
 80592fd:	80 7d c8 00          	cmpb   $0x0,-0x38(%ebp)
 8059301:	8b 40 18             	mov    0x18(%eax),%eax
 8059304:	75 33                	jne    8059339 <handle_ns_input+0x2b4>
	if (!net_ipv6_send_na(net_pkt_iface(pkt), na_src,
 8059306:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 8059309:	83 ec 0c             	sub    $0xc,%esp
 805930c:	53                   	push   %ebx
 805930d:	ff 75 98             	push   -0x68(%ebp)
 8059310:	ff 75 9c             	push   -0x64(%ebp)
 8059313:	57                   	push   %edi
 8059314:	ff 70 18             	push   0x18(%eax)
 8059317:	e8 e6 ed ff ff       	call   8058102 <net_ipv6_send_na>
 805931c:	83 c4 20             	add    $0x20,%esp
 805931f:	85 c0                	test   %eax,%eax
 8059321:	0f 85 23 ff ff ff    	jne    805924a <handle_ns_input+0x1c5>
		net_pkt_unref(pkt);
 8059327:	83 ec 0c             	sub    $0xc,%esp
 805932a:	ff 75 a4             	push   -0x5c(%ebp)
 805932d:	e8 b6 ba ff ff       	call   8054de8 <net_pkt_unref>
 8059332:	83 c4 10             	add    $0x10,%esp
		return NET_OK;
 8059335:	31 c0                	xor    %eax,%eax
 8059337:	eb 20                	jmp    8059359 <handle_ns_input+0x2d4>
		if (!net_ipv6_nbr_add(net_pkt_iface(pkt),
 8059339:	83 ec 0c             	sub    $0xc,%esp
 805933c:	8d 55 c4             	lea    -0x3c(%ebp),%edx
 805933f:	6a 00                	push   $0x0
 8059341:	6a 00                	push   $0x0
 8059343:	52                   	push   %edx
 8059344:	ff 75 a0             	push   -0x60(%ebp)
 8059347:	50                   	push   %eax
 8059348:	e8 79 f5 ff ff       	call   80588c6 <net_ipv6_nbr_add>
 805934d:	83 c4 20             	add    $0x20,%esp
 8059350:	85 c0                	test   %eax,%eax
 8059352:	75 b2                	jne    8059306 <handle_ns_input+0x281>
 8059354:	e9 f1 fe ff ff       	jmp    805924a <handle_ns_input+0x1c5>
}
 8059359:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 805935c:	65 2b 15 14 00 00 00 	sub    %gs:0x14,%edx
 8059363:	74 05                	je     805936a <handle_ns_input+0x2e5>
 8059365:	e8 96 ff fe ff       	call   8049300 <__stack_chk_fail@plt>
 805936a:	8d 65 f4             	lea    -0xc(%ebp),%esp
 805936d:	5b                   	pop    %ebx
 805936e:	5e                   	pop    %esi
 805936f:	5f                   	pop    %edi
 8059370:	5d                   	pop    %ebp
 8059371:	c3                   	ret    

08059372 <net_ipv6_start_dad>:
{
 8059372:	55                   	push   %ebp
 8059373:	89 e5                	mov    %esp,%ebp
 8059375:	83 ec 10             	sub    $0x10,%esp
				&ifaddr->address.in6_addr, true);
 8059378:	8b 45 0c             	mov    0xc(%ebp),%eax
	return net_ipv6_send_ns(iface, NULL, NULL, NULL,
 805937b:	6a 01                	push   $0x1
				&ifaddr->address.in6_addr, true);
 805937d:	83 c0 04             	add    $0x4,%eax
	return net_ipv6_send_ns(iface, NULL, NULL, NULL,
 8059380:	50                   	push   %eax
 8059381:	6a 00                	push   $0x0
 8059383:	6a 00                	push   $0x0
 8059385:	6a 00                	push   $0x0
 8059387:	ff 75 08             	push   0x8(%ebp)
 805938a:	e8 9b f2 ff ff       	call   805862a <net_ipv6_send_ns>
 805938f:	83 c4 20             	add    $0x20,%esp
}
 8059392:	c9                   	leave  
 8059393:	c3                   	ret    

08059394 <net_ipv6_prepare_for_send>:
{
 8059394:	55                   	push   %ebp
 8059395:	89 e5                	mov    %esp,%ebp
 8059397:	57                   	push   %edi
 8059398:	56                   	push   %esi
 8059399:	53                   	push   %ebx
 805939a:	83 ec 34             	sub    $0x34,%esp
 805939d:	8b 75 08             	mov    0x8(%ebp),%esi
 80593a0:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 80593a6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 80593a9:	31 c0                	xor    %eax,%eax
	ip_hdr = (struct net_ipv6_hdr *)net_pkt_get_data(pkt, &ipv6_access);
 80593ab:	8d 45 dc             	lea    -0x24(%ebp),%eax
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv6_access, struct net_ipv6_hdr);
 80593ae:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	ip_hdr = (struct net_ipv6_hdr *)net_pkt_get_data(pkt, &ipv6_access);
 80593b5:	50                   	push   %eax
 80593b6:	56                   	push   %esi
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv6_access, struct net_ipv6_hdr);
 80593b7:	c7 45 e0 28 00 00 00 	movl   $0x28,-0x20(%ebp)
	struct net_if *iface = NULL;
 80593be:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	ip_hdr = (struct net_ipv6_hdr *)net_pkt_get_data(pkt, &ipv6_access);
 80593c5:	e8 08 c5 ff ff       	call   80558d2 <net_pkt_get_data>
 80593ca:	83 c4 10             	add    $0x10,%esp
 80593cd:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	if (!ip_hdr) {
 80593d0:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
		return NET_DROP;
 80593d4:	b8 02 00 00 00       	mov    $0x2,%eax
	if (!ip_hdr) {
 80593d9:	0f 84 7e 01 00 00    	je     805955d <net_ipv6_prepare_for_send+0x1c9>
	if ((net_pkt_lladdr_dst(pkt)->addr &&
 80593df:	83 7e 28 00          	cmpl   $0x0,0x28(%esi)
 80593e3:	0f 85 51 01 00 00    	jne    805953a <net_ipv6_prepare_for_send+0x1a6>
	      !IS_ENABLED(CONFIG_NET_ROUTING))) ||
 80593e9:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 80593ec:	80 78 18 ff          	cmpb   $0xff,0x18(%eax)
 80593f0:	0f 84 44 01 00 00    	je     805953a <net_ipv6_prepare_for_send+0x1a6>
 80593f6:	8b 46 18             	mov    0x18(%esi),%eax
	if (iface == NULL) {
 80593f9:	85 c0                	test   %eax,%eax
 80593fb:	75 1b                	jne    8059418 <net_ipv6_prepare_for_send+0x84>
	if (net_if_ipv6_addr_onlink(&iface, (struct in6_addr *)ip_hdr->dst)) {
 80593fd:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 8059400:	8d 7d d8             	lea    -0x28(%ebp),%edi
 8059403:	8d 58 18             	lea    0x18(%eax),%ebx
 8059406:	50                   	push   %eax
 8059407:	50                   	push   %eax
 8059408:	53                   	push   %ebx
 8059409:	57                   	push   %edi
 805940a:	e8 fb 8b ff ff       	call   805200a <net_if_ipv6_addr_onlink>
 805940f:	83 c4 10             	add    $0x10,%esp
 8059412:	84 c0                	test   %al,%al
 8059414:	75 11                	jne    8059427 <net_ipv6_prepare_for_send+0x93>
 8059416:	eb 2b                	jmp    8059443 <net_ipv6_prepare_for_send+0xaf>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
 8059418:	8b 00                	mov    (%eax),%eax
 805941a:	8b 40 0c             	mov    0xc(%eax),%eax
	    net_ipv6_is_addr_mcast((struct in6_addr *)ip_hdr->dst) ||
 805941d:	a8 02                	test   $0x2,%al
 805941f:	0f 85 15 01 00 00    	jne    805953a <net_ipv6_prepare_for_send+0x1a6>
 8059425:	eb d6                	jmp    80593fd <net_ipv6_prepare_for_send+0x69>
		net_pkt_set_iface(pkt, iface);
 8059427:	8b 45 d8             	mov    -0x28(%ebp),%eax
	pkt->iface = iface;
 805942a:	89 46 18             	mov    %eax,0x18(%esi)
	if (iface) {
 805942d:	85 c0                	test   %eax,%eax
 805942f:	74 65                	je     8059496 <net_ipv6_prepare_for_send+0x102>
		pkt->lladdr_src.type = net_if_get_link_addr(iface)->type;
 8059431:	8b 10                	mov    (%eax),%edx
 8059433:	8a 52 15             	mov    0x15(%edx),%dl
 8059436:	88 56 25             	mov    %dl,0x25(%esi)
		pkt->lladdr_dst.type = net_if_get_link_addr(iface)->type;
 8059439:	8b 00                	mov    (%eax),%eax
 805943b:	8a 40 15             	mov    0x15(%eax),%al
 805943e:	88 46 2d             	mov    %al,0x2d(%esi)
 8059441:	eb 53                	jmp    8059496 <net_ipv6_prepare_for_send+0x102>
	route = net_route_lookup(iface, dst);
 8059443:	50                   	push   %eax
 8059444:	50                   	push   %eax
 8059445:	53                   	push   %ebx
 8059446:	6a 00                	push   $0x0
 8059448:	e8 1f 0a 00 00       	call   8059e6c <net_route_lookup>
 805944d:	83 c4 10             	add    $0x10,%esp
	if (route) {
 8059450:	85 c0                	test   %eax,%eax
 8059452:	74 2e                	je     8059482 <net_ipv6_prepare_for_send+0xee>
		nexthop = net_route_get_nexthop(route);
 8059454:	83 ec 0c             	sub    $0xc,%esp
 8059457:	89 45 d0             	mov    %eax,-0x30(%ebp)
 805945a:	50                   	push   %eax
 805945b:	e8 de 0d 00 00       	call   805a23e <net_route_get_nexthop>
 8059460:	83 c4 10             	add    $0x10,%esp
		if (!nexthop) {
 8059463:	8b 55 d0             	mov    -0x30(%ebp),%edx
 8059466:	85 c0                	test   %eax,%eax
		nexthop = net_route_get_nexthop(route);
 8059468:	89 c3                	mov    %eax,%ebx
		if (!nexthop) {
 805946a:	75 2a                	jne    8059496 <net_ipv6_prepare_for_send+0x102>
			net_route_del(route);
 805946c:	83 ec 0c             	sub    $0xc,%esp
 805946f:	52                   	push   %edx
 8059470:	e8 c5 0b 00 00       	call   805a03a <net_route_del>
 8059475:	83 c4 10             	add    $0x10,%esp
			return NET_DROP;
 8059478:	b8 02 00 00 00       	mov    $0x2,%eax
 805947d:	e9 db 00 00 00       	jmp    805955d <net_ipv6_prepare_for_send+0x1c9>
		router = net_if_ipv6_router_find_default(NULL, dst);
 8059482:	50                   	push   %eax
 8059483:	50                   	push   %eax
 8059484:	53                   	push   %ebx
 8059485:	6a 00                	push   $0x0
 8059487:	e8 a7 8d ff ff       	call   8052233 <net_if_ipv6_router_find_default>
 805948c:	83 c4 10             	add    $0x10,%esp
		if (!router) {
 805948f:	85 c0                	test   %eax,%eax
 8059491:	74 54                	je     80594e7 <net_ipv6_prepare_for_send+0x153>
		nexthop = &router->address.in6_addr;
 8059493:	8d 58 08             	lea    0x8(%eax),%ebx
	if (!iface) {
 8059496:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
 805949a:	75 4b                	jne    80594e7 <net_ipv6_prepare_for_send+0x153>
		if (net_if_ipv6_addr_onlink(&iface, nexthop)) {
 805949c:	51                   	push   %ecx
 805949d:	51                   	push   %ecx
 805949e:	53                   	push   %ebx
 805949f:	57                   	push   %edi
 80594a0:	e8 65 8b ff ff       	call   805200a <net_if_ipv6_addr_onlink>
 80594a5:	83 c4 10             	add    $0x10,%esp
 80594a8:	84 c0                	test   %al,%al
 80594aa:	74 05                	je     80594b1 <net_ipv6_prepare_for_send+0x11d>
			net_pkt_set_iface(pkt, iface);
 80594ac:	8b 45 d8             	mov    -0x28(%ebp),%eax
	pkt->iface = iface;
 80594af:	eb 17                	jmp    80594c8 <net_ipv6_prepare_for_send+0x134>
			nbr = net_ipv6_nbr_lookup(NULL, nexthop);
 80594b1:	52                   	push   %edx
 80594b2:	52                   	push   %edx
 80594b3:	53                   	push   %ebx
 80594b4:	6a 00                	push   $0x0
 80594b6:	e8 38 ec ff ff       	call   80580f3 <net_ipv6_nbr_lookup>
 80594bb:	83 c4 10             	add    $0x10,%esp
			if (nbr) {
 80594be:	85 c0                	test   %eax,%eax
 80594c0:	74 1f                	je     80594e1 <net_ipv6_prepare_for_send+0x14d>
				iface = nbr->iface;
 80594c2:	8b 40 08             	mov    0x8(%eax),%eax
 80594c5:	89 45 d8             	mov    %eax,-0x28(%ebp)
 80594c8:	89 46 18             	mov    %eax,0x18(%esi)
	if (iface) {
 80594cb:	85 c0                	test   %eax,%eax
 80594cd:	74 18                	je     80594e7 <net_ipv6_prepare_for_send+0x153>
		pkt->lladdr_src.type = net_if_get_link_addr(iface)->type;
 80594cf:	8b 10                	mov    (%eax),%edx
 80594d1:	8a 52 15             	mov    0x15(%edx),%dl
 80594d4:	88 56 25             	mov    %dl,0x25(%esi)
		pkt->lladdr_dst.type = net_if_get_link_addr(iface)->type;
 80594d7:	8b 00                	mov    (%eax),%eax
 80594d9:	8a 40 15             	mov    0x15(%eax),%al
 80594dc:	88 46 2d             	mov    %al,0x2d(%esi)
 80594df:	eb 06                	jmp    80594e7 <net_ipv6_prepare_for_send+0x153>
				iface = net_pkt_iface(pkt);
 80594e1:	8b 46 18             	mov    0x18(%esi),%eax
 80594e4:	89 45 d8             	mov    %eax,-0x28(%ebp)
	nbr = nbr_lookup(&net_neighbor.table, iface, nexthop);
 80594e7:	8b 45 d8             	mov    -0x28(%ebp),%eax
 80594ea:	89 da                	mov    %ebx,%edx
 80594ec:	e8 8a e8 ff ff       	call   8057d7b <nbr_lookup.constprop.0>
 80594f1:	89 c7                	mov    %eax,%edi
	if (nbr && nbr->idx != NET_NBR_LLADDR_UNKNOWN) {
 80594f3:	85 c0                	test   %eax,%eax
 80594f5:	74 47                	je     805953e <net_ipv6_prepare_for_send+0x1aa>
 80594f7:	0f b6 40 01          	movzbl 0x1(%eax),%eax
 80594fb:	3c ff                	cmp    $0xff,%al
 80594fd:	74 3f                	je     805953e <net_ipv6_prepare_for_send+0x1aa>
		lladdr = net_nbr_get_lladdr(nbr->idx);
 80594ff:	83 ec 0c             	sub    $0xc,%esp
 8059502:	50                   	push   %eax
 8059503:	e8 c7 dd ff ff       	call   80572cf <net_nbr_get_lladdr>
 8059508:	83 c4 10             	add    $0x10,%esp
		net_pkt_lladdr_dst(pkt)->addr = lladdr->addr;
 805950b:	8d 50 02             	lea    0x2(%eax),%edx
 805950e:	89 56 28             	mov    %edx,0x28(%esi)
		net_pkt_lladdr_dst(pkt)->len = lladdr->len;
 8059511:	8a 40 01             	mov    0x1(%eax),%al
 8059514:	88 46 2c             	mov    %al,0x2c(%esi)
		if (net_ipv6_nbr_data(nbr)->state == NET_IPV6_NBR_STATE_STALE) {
 8059517:	8b 47 0c             	mov    0xc(%edi),%eax
 805951a:	83 78 28 02          	cmpl   $0x2,0x28(%eax)
 805951e:	75 1a                	jne    805953a <net_ipv6_prepare_for_send+0x1a6>
			ipv6_nbr_set_state(nbr, NET_IPV6_NBR_STATE_DELAY);
 8059520:	ba 03 00 00 00       	mov    $0x3,%edx
 8059525:	89 f8                	mov    %edi,%eax
 8059527:	e8 4d e9 ff ff       	call   8057e79 <ipv6_nbr_set_state>
			ipv6_nd_restart_reachable_timer(nbr,
 805952c:	ba 88 13 00 00       	mov    $0x1388,%edx
 8059531:	31 c9                	xor    %ecx,%ecx
 8059533:	89 f8                	mov    %edi,%eax
 8059535:	e8 f3 e5 ff ff       	call   8057b2d <ipv6_nd_restart_reachable_timer>
		return NET_OK;
 805953a:	31 c0                	xor    %eax,%eax
 805953c:	eb 1f                	jmp    805955d <net_ipv6_prepare_for_send+0x1c9>
	ret = net_ipv6_send_ns(net_pkt_iface(pkt), pkt,
 805953e:	50                   	push   %eax
 805953f:	50                   	push   %eax
			       (struct in6_addr *)ip_hdr->src, NULL, nexthop,
 8059540:	8b 45 d4             	mov    -0x2c(%ebp),%eax
	ret = net_ipv6_send_ns(net_pkt_iface(pkt), pkt,
 8059543:	6a 00                	push   $0x0
			       (struct in6_addr *)ip_hdr->src, NULL, nexthop,
 8059545:	83 c0 08             	add    $0x8,%eax
	ret = net_ipv6_send_ns(net_pkt_iface(pkt), pkt,
 8059548:	53                   	push   %ebx
 8059549:	6a 00                	push   $0x0
 805954b:	50                   	push   %eax
 805954c:	56                   	push   %esi
 805954d:	ff 76 18             	push   0x18(%esi)
 8059550:	e8 d5 f0 ff ff       	call   805862a <net_ipv6_send_ns>
 8059555:	83 c4 20             	add    $0x20,%esp
	return NET_CONTINUE;
 8059558:	b8 01 00 00 00       	mov    $0x1,%eax
}
 805955d:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 8059560:	65 2b 15 14 00 00 00 	sub    %gs:0x14,%edx
 8059567:	74 05                	je     805956e <net_ipv6_prepare_for_send+0x1da>
 8059569:	e8 92 fd fe ff       	call   8049300 <__stack_chk_fail@plt>
 805956e:	8d 65 f4             	lea    -0xc(%ebp),%esp
 8059571:	5b                   	pop    %ebx
 8059572:	5e                   	pop    %esi
 8059573:	5f                   	pop    %edi
 8059574:	5d                   	pop    %ebp
 8059575:	c3                   	ret    

08059576 <ipv6_nd_reachable_timeout>:
{
 8059576:	55                   	push   %ebp
 8059577:	89 e5                	mov    %esp,%ebp
 8059579:	57                   	push   %edi
 805957a:	56                   	push   %esi
 805957b:	53                   	push   %ebx
 805957c:	bb a0 61 06 08       	mov    $0x80661a0,%ebx
 8059581:	83 ec 1c             	sub    $0x1c,%esp
	int64_t current = k_uptime_get();
 8059584:	e8 8b e5 ff ff       	call   8057b14 <k_uptime_get>
 8059589:	89 45 e0             	mov    %eax,-0x20(%ebp)
 805958c:	89 55 e4             	mov    %edx,-0x1c(%ebp)
		if (!nbr || !nbr->ref) {
 805958f:	80 3b 00             	cmpb   $0x0,(%ebx)
 8059592:	0f 84 e2 00 00 00    	je     805967a <ipv6_nd_reachable_timeout+0x104>
 8059598:	8b 4b 0c             	mov    0xc(%ebx),%ecx
		if (!data) {
 805959b:	85 c9                	test   %ecx,%ecx
 805959d:	0f 84 d7 00 00 00    	je     805967a <ipv6_nd_reachable_timeout+0x104>
		if (!data->reachable) {
 80595a3:	8b 79 18             	mov    0x18(%ecx),%edi
 80595a6:	8b 71 14             	mov    0x14(%ecx),%esi
 80595a9:	89 f8                	mov    %edi,%eax
 80595ab:	09 f0                	or     %esi,%eax
 80595ad:	0f 84 c7 00 00 00    	je     805967a <ipv6_nd_reachable_timeout+0x104>
		remaining = data->reachable + data->reachable_timeout - current;
 80595b3:	8b 41 1c             	mov    0x1c(%ecx),%eax
 80595b6:	99                   	cltd   
 80595b7:	01 f0                	add    %esi,%eax
 80595b9:	11 fa                	adc    %edi,%edx
 80595bb:	2b 45 e0             	sub    -0x20(%ebp),%eax
 80595be:	1b 55 e4             	sbb    -0x1c(%ebp),%edx
		if (remaining > 0) {
 80595c1:	31 f6                	xor    %esi,%esi
 80595c3:	39 c6                	cmp    %eax,%esi
 80595c5:	19 d6                	sbb    %edx,%esi
 80595c7:	7d 0b                	jge    80595d4 <ipv6_nd_reachable_timeout+0x5e>
			ipv6_nd_restart_reachable_timer(NULL, remaining);
 80595c9:	89 d1                	mov    %edx,%ecx
 80595cb:	89 c2                	mov    %eax,%edx
 80595cd:	31 c0                	xor    %eax,%eax
 80595cf:	e9 a1 00 00 00       	jmp    8059675 <ipv6_nd_reachable_timeout+0xff>
		switch (data->state) {
 80595d4:	83 79 28 04          	cmpl   $0x4,0x28(%ecx)
		data->reachable = 0;
 80595d8:	c7 41 14 00 00 00 00 	movl   $0x0,0x14(%ecx)
 80595df:	c7 41 18 00 00 00 00 	movl   $0x0,0x18(%ecx)
		switch (data->state) {
 80595e6:	0f 87 8e 00 00 00    	ja     805967a <ipv6_nd_reachable_timeout+0x104>
 80595ec:	8b 41 28             	mov    0x28(%ecx),%eax
 80595ef:	ff 24 85 a0 24 06 08 	jmp    *0x80624a0(,%eax,4)
			if (data->ns_count >= MAX_MULTICAST_SOLICIT) {
 80595f6:	8a 41 2e             	mov    0x2e(%ecx),%al
				net_ipv6_nbr_rm(nbr->iface, &data->addr);
 80595f9:	8d 51 04             	lea    0x4(%ecx),%edx
			if (data->ns_count >= MAX_MULTICAST_SOLICIT) {
 80595fc:	3c 02                	cmp    $0x2,%al
 80595fe:	77 42                	ja     8059642 <ipv6_nd_reachable_timeout+0xcc>
				data->ns_count++;
 8059600:	40                   	inc    %eax
 8059601:	88 41 2e             	mov    %al,0x2e(%ecx)
				ret = net_ipv6_send_ns(nbr->iface, NULL, NULL,
 8059604:	57                   	push   %edi
 8059605:	57                   	push   %edi
 8059606:	6a 00                	push   $0x0
 8059608:	52                   	push   %edx
 8059609:	6a 00                	push   $0x0
 805960b:	6a 00                	push   $0x0
 805960d:	6a 00                	push   $0x0
 805960f:	ff 73 08             	push   0x8(%ebx)
 8059612:	e8 13 f0 ff ff       	call   805862a <net_ipv6_send_ns>
 8059617:	83 c4 20             	add    $0x20,%esp
				if (ret < 0) {
 805961a:	eb 5e                	jmp    805967a <ipv6_nd_reachable_timeout+0x104>
			data->state = NET_IPV6_NBR_STATE_STALE;
 805961c:	c7 41 28 02 00 00 00 	movl   $0x2,0x28(%ecx)
			NET_DBG("nbr %p moving %s state to STALE (%d)",
 8059623:	eb 55                	jmp    805967a <ipv6_nd_reachable_timeout+0x104>
			net_ipv6_nbr_rm(nbr->iface, &data->addr);
 8059625:	83 c1 04             	add    $0x4,%ecx
 8059628:	56                   	push   %esi
 8059629:	56                   	push   %esi
 805962a:	51                   	push   %ecx
 805962b:	eb 18                	jmp    8059645 <ipv6_nd_reachable_timeout+0xcf>
			data->state = NET_IPV6_NBR_STATE_PROBE;
 805962d:	c7 41 28 04 00 00 00 	movl   $0x4,0x28(%ecx)
			data->ns_count = 0U;
 8059634:	c6 41 2e 00          	movb   $0x0,0x2e(%ecx)
			if (data->ns_count >= MAX_UNICAST_SOLICIT) {
 8059638:	8a 41 2e             	mov    0x2e(%ecx),%al
				net_ipv6_nbr_rm(nbr->iface, &data->addr);
 805963b:	8d 51 04             	lea    0x4(%ecx),%edx
			if (data->ns_count >= MAX_UNICAST_SOLICIT) {
 805963e:	3c 02                	cmp    $0x2,%al
 8059640:	76 10                	jbe    8059652 <ipv6_nd_reachable_timeout+0xdc>
				net_ipv6_nbr_rm(nbr->iface, &data->addr);
 8059642:	51                   	push   %ecx
 8059643:	51                   	push   %ecx
 8059644:	52                   	push   %edx
 8059645:	ff 73 08             	push   0x8(%ebx)
 8059648:	e8 86 e9 ff ff       	call   8057fd3 <net_ipv6_nbr_rm>
 805964d:	83 c4 10             	add    $0x10,%esp
 8059650:	eb 28                	jmp    805967a <ipv6_nd_reachable_timeout+0x104>
				data->ns_count++;
 8059652:	40                   	inc    %eax
 8059653:	88 41 2e             	mov    %al,0x2e(%ecx)
				ret = net_ipv6_send_ns(nbr->iface, NULL, NULL,
 8059656:	50                   	push   %eax
 8059657:	50                   	push   %eax
 8059658:	6a 00                	push   $0x0
 805965a:	52                   	push   %edx
 805965b:	6a 00                	push   $0x0
 805965d:	6a 00                	push   $0x0
 805965f:	6a 00                	push   $0x0
 8059661:	ff 73 08             	push   0x8(%ebx)
 8059664:	e8 c1 ef ff ff       	call   805862a <net_ipv6_send_ns>
 8059669:	83 c4 20             	add    $0x20,%esp
				ipv6_nd_restart_reachable_timer(nbr,
 805966c:	ba e8 03 00 00       	mov    $0x3e8,%edx
 8059671:	31 c9                	xor    %ecx,%ecx
 8059673:	89 d8                	mov    %ebx,%eax
 8059675:	e8 b3 e4 ff ff       	call   8057b2d <ipv6_nd_restart_reachable_timer>
	for (i = 0; i < CONFIG_NET_IPV6_MAX_NEIGHBORS; i++) {
 805967a:	83 c3 48             	add    $0x48,%ebx
 805967d:	81 fb e0 63 06 08    	cmp    $0x80663e0,%ebx
 8059683:	0f 85 06 ff ff ff    	jne    805958f <ipv6_nd_reachable_timeout+0x19>
}
 8059689:	8d 65 f4             	lea    -0xc(%ebp),%esp
 805968c:	5b                   	pop    %ebx
 805968d:	5e                   	pop    %esi
 805968e:	5f                   	pop    %edi
 805968f:	5d                   	pop    %ebp
 8059690:	c3                   	ret    

08059691 <net_ipv6_send_rs>:
{
 8059691:	55                   	push   %ebp
 8059692:	89 e5                	mov    %esp,%ebp
 8059694:	57                   	push   %edi
 8059695:	56                   	push   %esi
 8059696:	53                   	push   %ebx
 8059697:	83 ec 44             	sub    $0x44,%esp
 805969a:	8b 7d 08             	mov    0x8(%ebp),%edi
 805969d:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 80596a3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 80596a6:	31 c0                	xor    %eax,%eax
	src = net_if_ipv6_select_src_addr(iface, &dst);
 80596a8:	8d 45 d4             	lea    -0x2c(%ebp),%eax
	UNALIGNED_PUT(htons(addr0), &addr->s6_addr16[0]);
 80596ab:	c7 45 d4 ff 02 00 00 	movl   $0x2ff,-0x2c(%ebp)
 80596b2:	50                   	push   %eax
 80596b3:	57                   	push   %edi
	UNALIGNED_PUT(htons(addr2), &addr->s6_addr16[2]);
 80596b4:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	UNALIGNED_PUT(htons(addr4), &addr->s6_addr16[4]);
 80596bb:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	UNALIGNED_PUT(htons(addr6), &addr->s6_addr16[6]);
 80596c2:	c7 45 e0 00 00 00 02 	movl   $0x2000000,-0x20(%ebp)
 80596c9:	e8 92 8c ff ff       	call   8052360 <net_if_ipv6_select_src_addr>
 80596ce:	83 c4 10             	add    $0x10,%esp
 80596d1:	89 45 c0             	mov    %eax,-0x40(%ebp)
	if (!net_ipv6_is_addr_unspecified(src)) {
 80596d4:	e8 a1 e3 ff ff       	call   8057a7a <net_ipv6_is_addr_unspecified>
	uint8_t llao_len = 0U;
 80596d9:	c6 45 c7 00          	movb   $0x0,-0x39(%ebp)
	if (!net_ipv6_is_addr_unspecified(src)) {
 80596dd:	84 c0                	test   %al,%al
 80596df:	75 0e                	jne    80596ef <net_ipv6_send_rs+0x5e>
	uint8_t total_len = net_if_get_link_addr(iface)->len +
 80596e1:	8b 07                	mov    (%edi),%eax
	return ROUND_UP(total_len, 8U);
 80596e3:	8a 40 14             	mov    0x14(%eax),%al
 80596e6:	83 c0 09             	add    $0x9,%eax
 80596e9:	83 e0 f8             	and    $0xfffffff8,%eax
 80596ec:	88 45 c7             	mov    %al,-0x39(%ebp)
	pkt = net_pkt_alloc_with_buffer(iface,
 80596ef:	50                   	push   %eax
		return -ENOMEM;
 80596f0:	be f4 ff ff ff       	mov    $0xfffffff4,%esi
	pkt = net_pkt_alloc_with_buffer(iface,
 80596f5:	50                   	push   %eax
 80596f6:	8a 45 c7             	mov    -0x39(%ebp),%al
 80596f9:	6a 00                	push   $0x0
 80596fb:	83 c0 04             	add    $0x4,%eax
 80596fe:	6a 0a                	push   $0xa
 8059700:	0f b6 c0             	movzbl %al,%eax
 8059703:	6a 3a                	push   $0x3a
 8059705:	6a 02                	push   $0x2
 8059707:	50                   	push   %eax
 8059708:	57                   	push   %edi
 8059709:	e8 f9 bb ff ff       	call   8055307 <net_pkt_alloc_with_buffer>
 805970e:	83 c4 20             	add    $0x20,%esp
 8059711:	89 c3                	mov    %eax,%ebx
	if (!pkt) {
 8059713:	85 c0                	test   %eax,%eax
 8059715:	0f 84 a2 00 00 00    	je     80597bd <net_ipv6_send_rs+0x12c>
	pkt->ipv6_hop_limit = hop_limit;
 805971b:	c6 40 35 ff          	movb   $0xff,0x35(%eax)
	if (net_ipv6_create(pkt, src, &dst) ||
 805971f:	50                   	push   %eax
 8059720:	8d 45 d4             	lea    -0x2c(%ebp),%eax
 8059723:	50                   	push   %eax
 8059724:	ff 75 c0             	push   -0x40(%ebp)
 8059727:	53                   	push   %ebx
 8059728:	e8 25 dc ff ff       	call   8057352 <net_ipv6_create>
 805972d:	83 c4 10             	add    $0x10,%esp
 8059730:	85 c0                	test   %eax,%eax
 8059732:	74 07                	je     805973b <net_ipv6_send_rs+0xaa>
	int ret = -ENOBUFS;
 8059734:	be 97 ff ff ff       	mov    $0xffffff97,%esi
 8059739:	eb 76                	jmp    80597b1 <net_ipv6_send_rs+0x120>
	    net_icmpv6_create(pkt, NET_ICMPV6_RS, 0) ||
 805973b:	56                   	push   %esi
 805973c:	6a 00                	push   $0x0
 805973e:	68 85 00 00 00       	push   $0x85
 8059743:	53                   	push   %ebx
 8059744:	e8 19 d5 ff ff       	call   8056c62 <net_icmpv6_create>
 8059749:	83 c4 10             	add    $0x10,%esp
	if (net_ipv6_create(pkt, src, &dst) ||
 805974c:	85 c0                	test   %eax,%eax
 805974e:	75 e4                	jne    8059734 <net_ipv6_send_rs+0xa3>
	    net_pkt_memset(pkt, 0, sizeof(struct net_icmpv6_rs_hdr))) {
 8059750:	51                   	push   %ecx
 8059751:	6a 04                	push   $0x4
 8059753:	6a 00                	push   $0x0
 8059755:	53                   	push   %ebx
 8059756:	e8 a2 bd ff ff       	call   80554fd <net_pkt_memset>
 805975b:	83 c4 10             	add    $0x10,%esp
 805975e:	89 c6                	mov    %eax,%esi
	    net_icmpv6_create(pkt, NET_ICMPV6_RS, 0) ||
 8059760:	85 c0                	test   %eax,%eax
 8059762:	75 d0                	jne    8059734 <net_ipv6_send_rs+0xa3>
	if (llao_len > 0) {
 8059764:	80 7d c7 00          	cmpb   $0x0,-0x39(%ebp)
 8059768:	75 29                	jne    8059793 <net_ipv6_send_rs+0x102>
	net_pkt_cursor_init(pkt);
 805976a:	83 ec 0c             	sub    $0xc,%esp
 805976d:	53                   	push   %ebx
 805976e:	e8 e1 b7 ff ff       	call   8054f54 <net_pkt_cursor_init>
 8059773:	58                   	pop    %eax
 8059774:	5a                   	pop    %edx
	net_ipv6_finalize(pkt, IPPROTO_ICMPV6);
 8059775:	6a 3a                	push   $0x3a
 8059777:	53                   	push   %ebx
 8059778:	e8 b0 dc ff ff       	call   805742d <net_ipv6_finalize>
	if (net_send_data(pkt) < 0) {
 805977d:	89 1c 24             	mov    %ebx,(%esp)
 8059780:	e8 ab 6c ff ff       	call   8050430 <net_send_data>
 8059785:	83 c4 10             	add    $0x10,%esp
 8059788:	85 c0                	test   %eax,%eax
 805978a:	79 31                	jns    80597bd <net_ipv6_send_rs+0x12c>
		ret = -EINVAL;
 805978c:	be ea ff ff ff       	mov    $0xffffffea,%esi
 8059791:	eb 1e                	jmp    80597b1 <net_ipv6_send_rs+0x120>
		if (!set_llao(pkt, net_if_get_link_addr(iface),
 8059793:	83 ec 0c             	sub    $0xc,%esp
	return &iface->if_dev->link_addr;
 8059796:	8b 17                	mov    (%edi),%edx
 8059798:	0f b6 4d c7          	movzbl -0x39(%ebp),%ecx
 805979c:	89 d8                	mov    %ebx,%eax
 805979e:	6a 01                	push   $0x1
 80597a0:	83 c2 10             	add    $0x10,%edx
 80597a3:	e8 f9 e4 ff ff       	call   8057ca1 <set_llao>
 80597a8:	83 c4 10             	add    $0x10,%esp
 80597ab:	84 c0                	test   %al,%al
 80597ad:	75 bb                	jne    805976a <net_ipv6_send_rs+0xd9>
 80597af:	eb 83                	jmp    8059734 <net_ipv6_send_rs+0xa3>
	net_pkt_unref(pkt);
 80597b1:	83 ec 0c             	sub    $0xc,%esp
 80597b4:	53                   	push   %ebx
 80597b5:	e8 2e b6 ff ff       	call   8054de8 <net_pkt_unref>
 80597ba:	83 c4 10             	add    $0x10,%esp
}
 80597bd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 80597c0:	65 2b 05 14 00 00 00 	sub    %gs:0x14,%eax
 80597c7:	74 05                	je     80597ce <net_ipv6_send_rs+0x13d>
 80597c9:	e8 32 fb fe ff       	call   8049300 <__stack_chk_fail@plt>
 80597ce:	8d 65 f4             	lea    -0xc(%ebp),%esp
 80597d1:	89 f0                	mov    %esi,%eax
 80597d3:	5b                   	pop    %ebx
 80597d4:	5e                   	pop    %esi
 80597d5:	5f                   	pop    %edi
 80597d6:	5d                   	pop    %ebp
 80597d7:	c3                   	ret    

080597d8 <net_ipv6_start_rs>:
	return net_ipv6_send_rs(iface);
 80597d8:	e9 b4 fe ff ff       	jmp    8059691 <net_ipv6_send_rs>

080597dd <net_ipv6_nbr_init>:
	.handler = handle_ra_input,
};
#endif /* CONFIG_NET_IPV6_ND */

void net_ipv6_nbr_init(void)
{
 80597dd:	55                   	push   %ebp
 80597de:	89 e5                	mov    %esp,%ebp
 80597e0:	83 ec 14             	sub    $0x14,%esp
#if defined(CONFIG_NET_IPV6_NBR_CACHE)
	net_icmpv6_register_handler(&ns_input_handler);
 80597e3:	68 a4 73 06 08       	push   $0x80673a4
 80597e8:	e8 c7 d3 ff ff       	call   8056bb4 <net_icmpv6_register_handler>
	net_icmpv6_register_handler(&na_input_handler);
 80597ed:	c7 04 24 98 73 06 08 	movl   $0x8067398,(%esp)
 80597f4:	e8 bb d3 ff ff       	call   8056bb4 <net_icmpv6_register_handler>
 80597f9:	58                   	pop    %eax
 80597fa:	5a                   	pop    %edx
	k_work_init_delayable(&ipv6_ns_reply_timer, ipv6_ns_reply_timeout);
 80597fb:	68 c1 7b 05 08       	push   $0x8057bc1
 8059800:	68 60 85 06 08       	push   $0x8068560
 8059805:	e8 3b 64 00 00       	call   805fc45 <k_work_init_delayable>
 805980a:	83 c4 0c             	add    $0xc,%esp
	return z_impl_k_sem_init(sem, initial_count, limit);
 805980d:	6a ff                	push   $0xffffffff
 805980f:	6a 01                	push   $0x1
 8059811:	68 3c 8a 06 08       	push   $0x8068a3c
 8059816:	e8 fc 5d 00 00       	call   805f617 <z_impl_k_sem_init>
	k_sem_init(&nbr_lock, 1, K_SEM_MAX_LIMIT);
#endif
#if defined(CONFIG_NET_IPV6_ND)
	net_icmpv6_register_handler(&ra_input_handler);
 805981b:	c7 04 24 8c 73 06 08 	movl   $0x806738c,(%esp)
 8059822:	e8 8d d3 ff ff       	call   8056bb4 <net_icmpv6_register_handler>
 8059827:	59                   	pop    %ecx
 8059828:	58                   	pop    %eax
	k_work_init_delayable(&ipv6_nd_reachable_timer,
 8059829:	68 76 95 05 08       	push   $0x8059576
 805982e:	68 a0 85 06 08       	push   $0x80685a0
 8059833:	e8 0d 64 00 00       	call   805fc45 <k_work_init_delayable>
 8059838:	83 c4 10             	add    $0x10,%esp
			      ipv6_nd_reachable_timeout);
#endif
}
 805983b:	c9                   	leave  
 805983c:	c3                   	ret    

0805983d <net_pkt_write_be16>:
	uint16_t data_be16 = htons(data);
 805983d:	86 f2                	xchg   %dh,%dl
{
 805983f:	55                   	push   %ebp
 8059840:	89 e5                	mov    %esp,%ebp
 8059842:	83 ec 1c             	sub    $0x1c,%esp
 8059845:	65 8b 0d 14 00 00 00 	mov    %gs:0x14,%ecx
 805984c:	89 4d f4             	mov    %ecx,-0xc(%ebp)
 805984f:	31 c9                	xor    %ecx,%ecx
	return net_pkt_write(pkt, &data_be16, sizeof(uint16_t));
 8059851:	6a 02                	push   $0x2
	uint16_t data_be16 = htons(data);
 8059853:	66 89 55 f2          	mov    %dx,-0xe(%ebp)
	return net_pkt_write(pkt, &data_be16, sizeof(uint16_t));
 8059857:	8d 55 f2             	lea    -0xe(%ebp),%edx
 805985a:	52                   	push   %edx
 805985b:	50                   	push   %eax
 805985c:	e8 18 c0 ff ff       	call   8055879 <net_pkt_write>
 8059861:	83 c4 10             	add    $0x10,%esp
}
 8059864:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8059867:	65 2b 15 14 00 00 00 	sub    %gs:0x14,%edx
 805986e:	74 05                	je     8059875 <net_pkt_write_be16+0x38>
 8059870:	e8 8b fa fe ff       	call   8049300 <__stack_chk_fail@plt>
 8059875:	c9                   	leave  
 8059876:	c3                   	ret    

08059877 <mld_create>:

static int mld_create(struct net_pkt *pkt,
		      const struct in6_addr *addr,
		      uint8_t record_type,
		      uint16_t num_sources)
{
 8059877:	55                   	push   %ebp
 8059878:	89 e5                	mov    %esp,%ebp
 805987a:	57                   	push   %edi
 805987b:	89 cf                	mov    %ecx,%edi
 805987d:	56                   	push   %esi
 805987e:	89 d6                	mov    %edx,%esi
	NET_PKT_DATA_ACCESS_DEFINE(mld_access,
				   struct net_icmpv6_mld_mcast_record);
	struct net_icmpv6_mld_mcast_record *mld;

	mld = (struct net_icmpv6_mld_mcast_record *)
				net_pkt_get_data(pkt, &mld_access);
 8059880:	8d 55 c8             	lea    -0x38(%ebp),%edx
{
 8059883:	53                   	push   %ebx
 8059884:	89 c3                	mov    %eax,%ebx
 8059886:	83 ec 44             	sub    $0x44,%esp
 8059889:	8b 45 08             	mov    0x8(%ebp),%eax
 805988c:	89 45 c4             	mov    %eax,-0x3c(%ebp)
 805988f:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 8059895:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 8059898:	31 c0                	xor    %eax,%eax
				net_pkt_get_data(pkt, &mld_access);
 805989a:	52                   	push   %edx
	NET_PKT_DATA_ACCESS_DEFINE(mld_access,
 805989b:	8d 45 d0             	lea    -0x30(%ebp),%eax
				net_pkt_get_data(pkt, &mld_access);
 805989e:	53                   	push   %ebx
	NET_PKT_DATA_ACCESS_DEFINE(mld_access,
 805989f:	89 45 c8             	mov    %eax,-0x38(%ebp)
 80598a2:	c7 45 cc 14 00 00 00 	movl   $0x14,-0x34(%ebp)
				net_pkt_get_data(pkt, &mld_access);
 80598a9:	e8 24 c0 ff ff       	call   80558d2 <net_pkt_get_data>
 80598ae:	83 c4 10             	add    $0x10,%esp
	if (!mld) {
 80598b1:	85 c0                	test   %eax,%eax
 80598b3:	74 52                	je     8059907 <mld_create+0x90>
		return -ENOBUFS;
	}

	mld->record_type = record_type;
	mld->aux_data_len = 0U;
	mld->num_sources = htons(num_sources);
 80598b5:	0f b7 4d c4          	movzwl -0x3c(%ebp),%ecx
	mld->record_type = record_type;
 80598b9:	89 fa                	mov    %edi,%edx
	mld->aux_data_len = 0U;
 80598bb:	c6 40 01 00          	movb   $0x0,0x1(%eax)
 80598bf:	83 c0 04             	add    $0x4,%eax
	mld->record_type = record_type;
 80598c2:	88 50 fc             	mov    %dl,-0x4(%eax)

	net_ipv6_addr_copy_raw(mld->mcast_address, (uint8_t *)addr);

	if (net_pkt_set_data(pkt, &mld_access)) {
 80598c5:	8d 55 c8             	lea    -0x38(%ebp),%edx
	mld->num_sources = htons(num_sources);
 80598c8:	c1 e1 08             	shl    $0x8,%ecx
 80598cb:	66 89 48 fe          	mov    %cx,-0x2(%eax)
 80598cf:	89 c7                	mov    %eax,%edi
 80598d1:	b9 04 00 00 00       	mov    $0x4,%ecx
 80598d6:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	if (net_pkt_set_data(pkt, &mld_access)) {
 80598d8:	51                   	push   %ecx
 80598d9:	51                   	push   %ecx
 80598da:	52                   	push   %edx
 80598db:	53                   	push   %ebx
 80598dc:	e8 55 c0 ff ff       	call   8055936 <net_pkt_set_data>
 80598e1:	83 c4 10             	add    $0x10,%esp
 80598e4:	89 c6                	mov    %eax,%esi
 80598e6:	85 c0                	test   %eax,%eax
 80598e8:	75 1d                	jne    8059907 <mld_create+0x90>
		return -ENOBUFS;
	}

	if (num_sources > 0) {
 80598ea:	66 83 7d c4 00       	cmpw   $0x0,-0x3c(%ebp)
 80598ef:	74 1b                	je     805990c <mld_create+0x95>
		/* All source addresses, RFC 3810 ch 3 */
		if (net_pkt_write(pkt,
				  net_ipv6_unspecified_address()->s6_addr,
 80598f1:	e8 84 9e ff ff       	call   805377a <net_ipv6_unspecified_address>
		if (net_pkt_write(pkt,
 80598f6:	52                   	push   %edx
 80598f7:	6a 10                	push   $0x10
 80598f9:	50                   	push   %eax
 80598fa:	53                   	push   %ebx
 80598fb:	e8 79 bf ff ff       	call   8055879 <net_pkt_write>
 8059900:	83 c4 10             	add    $0x10,%esp
 8059903:	85 c0                	test   %eax,%eax
 8059905:	74 05                	je     805990c <mld_create+0x95>
				  sizeof(struct in6_addr))) {
			return -ENOBUFS;
 8059907:	be 97 ff ff ff       	mov    $0xffffff97,%esi
		}
	}

	return 0;
}
 805990c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 805990f:	65 2b 05 14 00 00 00 	sub    %gs:0x14,%eax
 8059916:	74 05                	je     805991d <mld_create+0xa6>
 8059918:	e8 e3 f9 fe ff       	call   8049300 <__stack_chk_fail@plt>
 805991d:	8d 65 f4             	lea    -0xc(%ebp),%esp
 8059920:	89 f0                	mov    %esi,%eax
 8059922:	5b                   	pop    %ebx
 8059923:	5e                   	pop    %esi
 8059924:	5f                   	pop    %edi
 8059925:	5d                   	pop    %ebp
 8059926:	c3                   	ret    

08059927 <mld_send>:

	return 0;
}

static int mld_send(struct net_pkt *pkt)
{
 8059927:	55                   	push   %ebp
 8059928:	89 e5                	mov    %esp,%ebp
 805992a:	53                   	push   %ebx
 805992b:	89 c3                	mov    %eax,%ebx
 805992d:	83 ec 10             	sub    $0x10,%esp
	net_pkt_cursor_init(pkt);
 8059930:	50                   	push   %eax
 8059931:	e8 1e b6 ff ff       	call   8054f54 <net_pkt_cursor_init>
 8059936:	58                   	pop    %eax
 8059937:	5a                   	pop    %edx
	net_ipv6_finalize(pkt, IPPROTO_ICMPV6);
 8059938:	6a 3a                	push   $0x3a
 805993a:	53                   	push   %ebx
 805993b:	e8 ed da ff ff       	call   805742d <net_ipv6_finalize>

	if (net_send_data(pkt) < 0) {
 8059940:	89 1c 24             	mov    %ebx,(%esp)
 8059943:	e8 e8 6a ff ff       	call   8050430 <net_send_data>
 8059948:	83 c4 10             	add    $0x10,%esp
 805994b:	85 c0                	test   %eax,%eax
 805994d:	79 11                	jns    8059960 <mld_send+0x39>
		net_stats_update_icmp_drop(net_pkt_iface(pkt));
		net_stats_update_ipv6_mld_drop(net_pkt_iface(pkt));

		net_pkt_unref(pkt);
 805994f:	83 ec 0c             	sub    $0xc,%esp
 8059952:	53                   	push   %ebx
 8059953:	e8 90 b4 ff ff       	call   8054de8 <net_pkt_unref>
 8059958:	83 c4 10             	add    $0x10,%esp

		return -1;
 805995b:	83 c8 ff             	or     $0xffffffff,%eax
 805995e:	eb 02                	jmp    8059962 <mld_send+0x3b>
	}

	net_stats_update_icmp_sent(net_pkt_iface(pkt));
	net_stats_update_ipv6_mld_sent(net_pkt_iface(pkt));

	return 0;
 8059960:	31 c0                	xor    %eax,%eax
}
 8059962:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 8059965:	c9                   	leave  
 8059966:	c3                   	ret    

08059967 <mld_create_packet>:
{
 8059967:	55                   	push   %ebp
 8059968:	89 e5                	mov    %esp,%ebp
 805996a:	57                   	push   %edi
 805996b:	56                   	push   %esi
	if (net_ipv6_create(pkt, net_if_ipv6_select_src_addr(
 805996c:	8d 7d d4             	lea    -0x2c(%ebp),%edi
{
 805996f:	89 d6                	mov    %edx,%esi
 8059971:	53                   	push   %ebx
 8059972:	89 c3                	mov    %eax,%ebx
 8059974:	83 ec 34             	sub    $0x34,%esp
 8059977:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 805997d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 8059980:	31 c0                	xor    %eax,%eax
	if (net_ipv6_create(pkt, net_if_ipv6_select_src_addr(
 8059982:	57                   	push   %edi
	pkt->ipv6_hop_limit = hop_limit;
 8059983:	c6 43 35 01          	movb   $0x1,0x35(%ebx)
 8059987:	ff 73 18             	push   0x18(%ebx)
	UNALIGNED_PUT(htons(addr0), &addr->s6_addr16[0]);
 805998a:	c7 45 d4 ff 02 00 00 	movl   $0x2ff,-0x2c(%ebp)
	UNALIGNED_PUT(htons(addr2), &addr->s6_addr16[2]);
 8059991:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	UNALIGNED_PUT(htons(addr4), &addr->s6_addr16[4]);
 8059998:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	UNALIGNED_PUT(htons(addr6), &addr->s6_addr16[6]);
 805999f:	c7 45 e0 00 00 00 16 	movl   $0x16000000,-0x20(%ebp)
 80599a6:	e8 b5 89 ff ff       	call   8052360 <net_if_ipv6_select_src_addr>
 80599ab:	83 c4 0c             	add    $0xc,%esp
 80599ae:	57                   	push   %edi
 80599af:	50                   	push   %eax
 80599b0:	53                   	push   %ebx
 80599b1:	e8 9c d9 ff ff       	call   8057352 <net_ipv6_create>
 80599b6:	83 c4 10             	add    $0x10,%esp
 80599b9:	85 c0                	test   %eax,%eax
 80599bb:	74 0a                	je     80599c7 <mld_create_packet+0x60>
		return -ENOBUFS;
 80599bd:	b8 97 ff ff ff       	mov    $0xffffff97,%eax
 80599c2:	e9 99 00 00 00       	jmp    8059a60 <mld_create_packet+0xf9>
	return net_pkt_write(pkt, &data, sizeof(uint8_t));
 80599c7:	8d 7d d3             	lea    -0x2d(%ebp),%edi
 80599ca:	51                   	push   %ecx
 80599cb:	6a 01                	push   $0x1
 80599cd:	57                   	push   %edi
 80599ce:	53                   	push   %ebx
 80599cf:	c6 45 d3 3a          	movb   $0x3a,-0x2d(%ebp)
 80599d3:	e8 a1 be ff ff       	call   8055879 <net_pkt_write>
 80599d8:	83 c4 10             	add    $0x10,%esp
	if (net_pkt_write_u8(pkt, IPPROTO_ICMPV6) ||
 80599db:	85 c0                	test   %eax,%eax
 80599dd:	75 de                	jne    80599bd <mld_create_packet+0x56>
 80599df:	52                   	push   %edx
 80599e0:	6a 01                	push   $0x1
 80599e2:	57                   	push   %edi
 80599e3:	53                   	push   %ebx
 80599e4:	c6 45 d3 00          	movb   $0x0,-0x2d(%ebp)
 80599e8:	e8 8c be ff ff       	call   8055879 <net_pkt_write>
 80599ed:	83 c4 10             	add    $0x10,%esp
 80599f0:	85 c0                	test   %eax,%eax
 80599f2:	75 c9                	jne    80599bd <mld_create_packet+0x56>
	if (net_pkt_write_be16(pkt, 0x0502) ||
 80599f4:	ba 02 05 00 00       	mov    $0x502,%edx
 80599f9:	89 d8                	mov    %ebx,%eax
 80599fb:	e8 3d fe ff ff       	call   805983d <net_pkt_write_be16>
 8059a00:	85 c0                	test   %eax,%eax
 8059a02:	75 b9                	jne    80599bd <mld_create_packet+0x56>
	    net_pkt_write_be16(pkt, 0) ||
 8059a04:	31 d2                	xor    %edx,%edx
 8059a06:	89 d8                	mov    %ebx,%eax
 8059a08:	e8 30 fe ff ff       	call   805983d <net_pkt_write_be16>
	if (net_pkt_write_be16(pkt, 0x0502) ||
 8059a0d:	85 c0                	test   %eax,%eax
 8059a0f:	75 ac                	jne    80599bd <mld_create_packet+0x56>
	    net_pkt_write_be16(pkt, 0)) {
 8059a11:	31 d2                	xor    %edx,%edx
 8059a13:	89 d8                	mov    %ebx,%eax
 8059a15:	e8 23 fe ff ff       	call   805983d <net_pkt_write_be16>
	    net_pkt_write_be16(pkt, 0) ||
 8059a1a:	85 c0                	test   %eax,%eax
 8059a1c:	75 9f                	jne    80599bd <mld_create_packet+0x56>
	pkt->ipv6_ext_len = len;
 8059a1e:	66 c7 43 36 08 00    	movw   $0x8,0x36(%ebx)
	if (net_icmpv6_create(pkt, NET_ICMPV6_MLDv2, 0) ||
 8059a24:	50                   	push   %eax
 8059a25:	6a 00                	push   $0x0
 8059a27:	68 8f 00 00 00       	push   $0x8f
 8059a2c:	53                   	push   %ebx
 8059a2d:	e8 30 d2 ff ff       	call   8056c62 <net_icmpv6_create>
 8059a32:	83 c4 10             	add    $0x10,%esp
 8059a35:	85 c0                	test   %eax,%eax
 8059a37:	75 84                	jne    80599bd <mld_create_packet+0x56>
	    net_pkt_write_be16(pkt, 0) ||
 8059a39:	31 d2                	xor    %edx,%edx
 8059a3b:	89 d8                	mov    %ebx,%eax
 8059a3d:	e8 fb fd ff ff       	call   805983d <net_pkt_write_be16>
	if (net_icmpv6_create(pkt, NET_ICMPV6_MLDv2, 0) ||
 8059a42:	85 c0                	test   %eax,%eax
 8059a44:	0f 85 73 ff ff ff    	jne    80599bd <mld_create_packet+0x56>
	    net_pkt_write_be16(pkt, count)) {
 8059a4a:	0f b7 d6             	movzwl %si,%edx
 8059a4d:	89 d8                	mov    %ebx,%eax
 8059a4f:	e8 e9 fd ff ff       	call   805983d <net_pkt_write_be16>
	    net_pkt_write_be16(pkt, 0) ||
 8059a54:	85 c0                	test   %eax,%eax
 8059a56:	0f 85 61 ff ff ff    	jne    80599bd <mld_create_packet+0x56>
	pkt->ipv6_next_hdr = next_hdr;
 8059a5c:	c6 43 3b 00          	movb   $0x0,0x3b(%ebx)
}
 8059a60:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 8059a63:	65 2b 15 14 00 00 00 	sub    %gs:0x14,%edx
 8059a6a:	74 05                	je     8059a71 <mld_create_packet+0x10a>
 8059a6c:	e8 8f f8 fe ff       	call   8049300 <__stack_chk_fail@plt>
 8059a71:	8d 65 f4             	lea    -0xc(%ebp),%esp
 8059a74:	5b                   	pop    %ebx
 8059a75:	5e                   	pop    %esi
 8059a76:	5f                   	pop    %edi
 8059a77:	5d                   	pop    %ebp
 8059a78:	c3                   	ret    

08059a79 <mld_send_generic>:

static int mld_send_generic(struct net_if *iface,
			    const struct in6_addr *addr,
			    uint8_t mode)
{
 8059a79:	55                   	push   %ebp
 8059a7a:	89 e5                	mov    %esp,%ebp
 8059a7c:	57                   	push   %edi
 8059a7d:	89 d7                	mov    %edx,%edi
 8059a7f:	56                   	push   %esi
 8059a80:	89 ce                	mov    %ecx,%esi
 8059a82:	53                   	push   %ebx
 8059a83:	83 ec 24             	sub    $0x24,%esp
	struct net_pkt *pkt;
	int ret;

	pkt = net_pkt_alloc_with_buffer(iface, IPV6_OPT_HDR_ROUTER_ALERT_LEN +
 8059a86:	6a 00                	push   $0x0
 8059a88:	6a 05                	push   $0x5
 8059a8a:	6a 3a                	push   $0x3a
 8059a8c:	6a 02                	push   $0x2
 8059a8e:	6a 30                	push   $0x30
 8059a90:	50                   	push   %eax
 8059a91:	e8 71 b8 ff ff       	call   8055307 <net_pkt_alloc_with_buffer>
 8059a96:	83 c4 20             	add    $0x20,%esp
					NET_ICMPV6_UNUSED_LEN +
					MLDv2_MCAST_RECORD_LEN +
					sizeof(struct in6_addr),
					AF_INET6, IPPROTO_ICMPV6,
					PKT_WAIT_TIME);
	if (!pkt) {
 8059a99:	85 c0                	test   %eax,%eax
 8059a9b:	74 50                	je     8059aed <mld_send_generic+0x74>
		return -ENOMEM;
	}

	if (mld_create_packet(pkt, 1) ||
 8059a9d:	ba 01 00 00 00       	mov    $0x1,%edx
 8059aa2:	89 c3                	mov    %eax,%ebx
 8059aa4:	e8 be fe ff ff       	call   8059967 <mld_create_packet>
 8059aa9:	85 c0                	test   %eax,%eax
 8059aab:	74 07                	je     8059ab4 <mld_send_generic+0x3b>
	    mld_create(pkt, addr, mode, 1)) {
		ret = -ENOBUFS;
 8059aad:	b8 97 ff ff ff       	mov    $0xffffff97,%eax
 8059ab2:	eb 25                	jmp    8059ad9 <mld_send_generic+0x60>
	    mld_create(pkt, addr, mode, 1)) {
 8059ab4:	83 ec 0c             	sub    $0xc,%esp
 8059ab7:	89 f0                	mov    %esi,%eax
 8059ab9:	89 fa                	mov    %edi,%edx
 8059abb:	6a 01                	push   $0x1
 8059abd:	0f b6 c8             	movzbl %al,%ecx
 8059ac0:	89 d8                	mov    %ebx,%eax
 8059ac2:	e8 b0 fd ff ff       	call   8059877 <mld_create>
 8059ac7:	83 c4 10             	add    $0x10,%esp
	if (mld_create_packet(pkt, 1) ||
 8059aca:	85 c0                	test   %eax,%eax
 8059acc:	75 df                	jne    8059aad <mld_send_generic+0x34>
		goto drop;
	}

	ret = mld_send(pkt);
 8059ace:	89 d8                	mov    %ebx,%eax
 8059ad0:	e8 52 fe ff ff       	call   8059927 <mld_send>
	if (ret) {
 8059ad5:	85 c0                	test   %eax,%eax
 8059ad7:	74 19                	je     8059af2 <mld_send_generic+0x79>
	}

	return 0;

drop:
	net_pkt_unref(pkt);
 8059ad9:	83 ec 0c             	sub    $0xc,%esp
 8059adc:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 8059adf:	53                   	push   %ebx
 8059ae0:	e8 03 b3 ff ff       	call   8054de8 <net_pkt_unref>

	return ret;
 8059ae5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
	net_pkt_unref(pkt);
 8059ae8:	83 c4 10             	add    $0x10,%esp
	return ret;
 8059aeb:	eb 05                	jmp    8059af2 <mld_send_generic+0x79>
		return -ENOMEM;
 8059aed:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
}
 8059af2:	8d 65 f4             	lea    -0xc(%ebp),%esp
 8059af5:	5b                   	pop    %ebx
 8059af6:	5e                   	pop    %esi
 8059af7:	5f                   	pop    %edi
 8059af8:	5d                   	pop    %ebp
 8059af9:	c3                   	ret    

08059afa <handle_mld_query>:
	dbg_addr("Received", pkt_str, src, dst)

static enum net_verdict handle_mld_query(struct net_pkt *pkt,
					 struct net_ipv6_hdr *ip_hdr,
					 struct net_icmp_hdr *icmp_hdr)
{
 8059afa:	55                   	push   %ebp
 8059afb:	89 e5                	mov    %esp,%ebp
 8059afd:	57                   	push   %edi
 8059afe:	56                   	push   %esi
 8059aff:	53                   	push   %ebx
	size_t bytes = 0;
 8059b00:	31 db                	xor    %ebx,%ebx
 8059b02:	83 ec 2c             	sub    $0x2c,%esp
 8059b05:	8b 45 0c             	mov    0xc(%ebp),%eax
 8059b08:	8b 7d 08             	mov    0x8(%ebp),%edi
 8059b0b:	89 45 d4             	mov    %eax,-0x2c(%ebp)
 8059b0e:	8b 45 10             	mov    0x10(%ebp),%eax
 8059b11:	89 45 d0             	mov    %eax,-0x30(%ebp)
 8059b14:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 8059b1a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 8059b1d:	31 c0                	xor    %eax,%eax
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(mld_access,
 8059b1f:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
 8059b26:	8b 47 08             	mov    0x8(%edi),%eax
 8059b29:	c7 45 e0 18 00 00 00 	movl   $0x18,-0x20(%ebp)
	while (buf) {
 8059b30:	85 c0                	test   %eax,%eax
 8059b32:	74 0b                	je     8059b3f <handle_mld_query+0x45>
		bytes += buf->len;
 8059b34:	0f b7 50 10          	movzwl 0x10(%eax),%edx
		buf = buf->frags;
 8059b38:	8b 40 04             	mov    0x4(%eax),%eax
		bytes += buf->len;
 8059b3b:	01 d3                	add    %edx,%ebx
		buf = buf->frags;
 8059b3d:	eb f1                	jmp    8059b30 <handle_mld_query+0x36>
	uint16_t length = net_pkt_get_len(pkt);
	struct net_icmpv6_mld_query *mld_query;
	uint16_t pkt_len;

	mld_query = (struct net_icmpv6_mld_query *)
				net_pkt_get_data(pkt, &mld_access);
 8059b3f:	8d 45 dc             	lea    -0x24(%ebp),%eax
 8059b42:	56                   	push   %esi
 8059b43:	56                   	push   %esi
 8059b44:	50                   	push   %eax
 8059b45:	57                   	push   %edi
 8059b46:	e8 87 bd ff ff       	call   80558d2 <net_pkt_get_data>
 8059b4b:	83 c4 10             	add    $0x10,%esp
 8059b4e:	89 c6                	mov    %eax,%esi
	if (!mld_query) {
 8059b50:	85 c0                	test   %eax,%eax
 8059b52:	75 0a                	jne    8059b5e <handle_mld_query+0x64>
	return NET_OK;

drop:
	net_stats_update_ipv6_mld_drop(net_pkt_iface(pkt));

	return NET_DROP;
 8059b54:	b8 02 00 00 00       	mov    $0x2,%eax
 8059b59:	e9 21 01 00 00       	jmp    8059c7f <handle_mld_query+0x185>
	return net_pkt_skip(pkt, access->size);
 8059b5e:	51                   	push   %ecx
 8059b5f:	51                   	push   %ecx
 8059b60:	ff 75 e0             	push   -0x20(%ebp)
 8059b63:	57                   	push   %edi
 8059b64:	e8 08 b8 ff ff       	call   8055371 <net_pkt_skip>
 8059b69:	66 8b 46 16          	mov    0x16(%esi),%ax
	if (length < pkt_len || pkt_len > NET_IPV6_MTU ||
 8059b6d:	b9 00 05 00 00       	mov    $0x500,%ecx
 8059b72:	83 c4 10             	add    $0x10,%esp
	mld_query->num_sources = ntohs(mld_query->num_sources);
 8059b75:	86 e0                	xchg   %ah,%al
	if (length < pkt_len || pkt_len > NET_IPV6_MTU ||
 8059b77:	66 39 cb             	cmp    %cx,%bx
 8059b7a:	0f 46 cb             	cmovbe %ebx,%ecx
	mld_query->num_sources = ntohs(mld_query->num_sources);
 8059b7d:	66 89 46 16          	mov    %ax,0x16(%esi)
	pkt_len = sizeof(struct net_ipv6_hdr) +	net_pkt_ipv6_ext_len(pkt) +
 8059b81:	66 8b 5f 36          	mov    0x36(%edi),%bx
		sizeof(struct in6_addr) * mld_query->num_sources;
 8059b85:	c1 e0 04             	shl    $0x4,%eax
	pkt_len = sizeof(struct net_ipv6_hdr) +	net_pkt_ipv6_ext_len(pkt) +
 8059b88:	8d 5c 03 44          	lea    0x44(%ebx,%eax,1),%ebx
	if (length < pkt_len || pkt_len > NET_IPV6_MTU ||
 8059b8c:	66 39 d9             	cmp    %bx,%cx
 8059b8f:	72 c3                	jb     8059b54 <handle_mld_query+0x5a>
 8059b91:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 8059b94:	80 78 07 01          	cmpb   $0x1,0x7(%eax)
 8059b98:	75 ba                	jne    8059b54 <handle_mld_query+0x5a>
	    ip_hdr->hop_limit != 1U || icmp_hdr->code != 0U) {
 8059b9a:	8b 45 d0             	mov    -0x30(%ebp),%eax
 8059b9d:	80 78 01 00          	cmpb   $0x0,0x1(%eax)
 8059ba1:	75 b1                	jne    8059b54 <handle_mld_query+0x5a>
				   (uint8_t *)net_ipv6_unspecified_address())) {
 8059ba3:	e8 d2 9b ff ff       	call   805377a <net_ipv6_unspecified_address>
	return !memcmp(addr1, addr2, sizeof(struct in6_addr));
 8059ba8:	52                   	push   %edx
 8059ba9:	8d 56 04             	lea    0x4(%esi),%edx
 8059bac:	6a 10                	push   $0x10
 8059bae:	50                   	push   %eax
 8059baf:	52                   	push   %edx
 8059bb0:	e8 bb f4 fe ff       	call   8049070 <memcmp@plt>
 8059bb5:	83 c4 10             	add    $0x10,%esp
 8059bb8:	89 c6                	mov    %eax,%esi
	if (!net_ipv6_addr_cmp_raw(mld_query->mcast_address,
 8059bba:	85 c0                	test   %eax,%eax
 8059bbc:	75 96                	jne    8059b54 <handle_mld_query+0x5a>
	return pkt->iface;
 8059bbe:	8b 4f 18             	mov    0x18(%edi),%ecx
	for (i = 0; i < NET_IF_MAX_IPV6_MADDR; i++) {
 8059bc1:	31 d2                	xor    %edx,%edx
	struct net_if_ipv6 *ipv6 = iface->config.ip.ipv6;
 8059bc3:	8b 41 04             	mov    0x4(%ecx),%eax
 8059bc6:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		if (!ipv6->mcast[i].is_used || !ipv6->mcast[i].is_joined) {
 8059bc9:	6b c2 18             	imul   $0x18,%edx,%eax
 8059bcc:	8b 5d d4             	mov    -0x2c(%ebp),%ebx
 8059bcf:	8a 44 03 74          	mov    0x74(%ebx,%eax,1),%al
 8059bd3:	a8 01                	test   $0x1,%al
 8059bd5:	74 0a                	je     8059be1 <handle_mld_query+0xe7>
 8059bd7:	d0 e8                	shr    %al
 8059bd9:	83 e0 01             	and    $0x1,%eax
		count++;
 8059bdc:	3c 01                	cmp    $0x1,%al
 8059bde:	83 de ff             	sbb    $0xffffffff,%esi
	for (i = 0; i < NET_IF_MAX_IPV6_MADDR; i++) {
 8059be1:	42                   	inc    %edx
 8059be2:	83 fa 03             	cmp    $0x3,%edx
 8059be5:	75 e2                	jne    8059bc9 <handle_mld_query+0xcf>
	pkt = net_pkt_alloc_with_buffer(iface, IPV6_OPT_HDR_ROUTER_ALERT_LEN +
 8059be7:	50                   	push   %eax
 8059be8:	50                   	push   %eax
					count * MLDv2_MCAST_RECORD_LEN,
 8059be9:	6b c6 14             	imul   $0x14,%esi,%eax
	pkt = net_pkt_alloc_with_buffer(iface, IPV6_OPT_HDR_ROUTER_ALERT_LEN +
 8059bec:	6a 00                	push   $0x0
 8059bee:	6a 05                	push   $0x5
 8059bf0:	83 c0 0c             	add    $0xc,%eax
 8059bf3:	6a 3a                	push   $0x3a
 8059bf5:	6a 02                	push   $0x2
 8059bf7:	50                   	push   %eax
 8059bf8:	51                   	push   %ecx
 8059bf9:	e8 09 b7 ff ff       	call   8055307 <net_pkt_alloc_with_buffer>
 8059bfe:	83 c4 20             	add    $0x20,%esp
 8059c01:	89 c3                	mov    %eax,%ebx
	if (!pkt) {
 8059c03:	85 c0                	test   %eax,%eax
 8059c05:	74 6a                	je     8059c71 <handle_mld_query+0x177>
	if (mld_create_packet(pkt, count)) {
 8059c07:	0f b7 d6             	movzwl %si,%edx
 8059c0a:	e8 58 fd ff ff       	call   8059967 <mld_create_packet>
 8059c0f:	89 c6                	mov    %eax,%esi
 8059c11:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 8059c14:	8d 50 64             	lea    0x64(%eax),%edx
 8059c17:	85 f6                	test   %esi,%esi
 8059c19:	74 1b                	je     8059c36 <handle_mld_query+0x13c>
	net_pkt_unref(pkt);
 8059c1b:	83 ec 0c             	sub    $0xc,%esp
 8059c1e:	53                   	push   %ebx
 8059c1f:	e8 c4 b1 ff ff       	call   8054de8 <net_pkt_unref>
 8059c24:	83 c4 10             	add    $0x10,%esp
 8059c27:	eb 48                	jmp    8059c71 <handle_mld_query+0x177>
		if (!ipv6->mcast[i].is_used || !ipv6->mcast[i].is_joined) {
 8059c29:	a8 02                	test   $0x2,%al
 8059c2b:	75 19                	jne    8059c46 <handle_mld_query+0x14c>
	for (i = 0; i < NET_IF_MAX_IPV6_MADDR; i++) {
 8059c2d:	46                   	inc    %esi
 8059c2e:	83 c2 18             	add    $0x18,%edx
 8059c31:	83 fe 03             	cmp    $0x3,%esi
 8059c34:	74 30                	je     8059c66 <handle_mld_query+0x16c>
		if (!ipv6->mcast[i].is_used || !ipv6->mcast[i].is_joined) {
 8059c36:	6b c6 18             	imul   $0x18,%esi,%eax
 8059c39:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
 8059c3c:	8a 44 01 74          	mov    0x74(%ecx,%eax,1),%al
 8059c40:	a8 01                	test   $0x1,%al
 8059c42:	75 e5                	jne    8059c29 <handle_mld_query+0x12f>
 8059c44:	eb e7                	jmp    8059c2d <handle_mld_query+0x133>
		if (!mld_create(pkt, &ipv6->mcast[i].address.in6_addr,
 8059c46:	83 ec 0c             	sub    $0xc,%esp
 8059c49:	b9 02 00 00 00       	mov    $0x2,%ecx
 8059c4e:	89 d8                	mov    %ebx,%eax
 8059c50:	89 55 d0             	mov    %edx,-0x30(%ebp)
 8059c53:	6a 00                	push   $0x0
 8059c55:	e8 1d fc ff ff       	call   8059877 <mld_create>
 8059c5a:	83 c4 10             	add    $0x10,%esp
 8059c5d:	8b 55 d0             	mov    -0x30(%ebp),%edx
 8059c60:	85 c0                	test   %eax,%eax
 8059c62:	75 c9                	jne    8059c2d <handle_mld_query+0x133>
 8059c64:	eb b5                	jmp    8059c1b <handle_mld_query+0x121>
	if (!mld_send(pkt)) {
 8059c66:	89 d8                	mov    %ebx,%eax
 8059c68:	e8 ba fc ff ff       	call   8059927 <mld_send>
 8059c6d:	85 c0                	test   %eax,%eax
 8059c6f:	75 aa                	jne    8059c1b <handle_mld_query+0x121>
	net_pkt_unref(pkt);
 8059c71:	83 ec 0c             	sub    $0xc,%esp
 8059c74:	57                   	push   %edi
 8059c75:	e8 6e b1 ff ff       	call   8054de8 <net_pkt_unref>
 8059c7a:	83 c4 10             	add    $0x10,%esp
	return NET_OK;
 8059c7d:	31 c0                	xor    %eax,%eax
}
 8059c7f:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 8059c82:	65 2b 15 14 00 00 00 	sub    %gs:0x14,%edx
 8059c89:	74 05                	je     8059c90 <handle_mld_query+0x196>
 8059c8b:	e8 70 f6 fe ff       	call   8049300 <__stack_chk_fail@plt>
 8059c90:	8d 65 f4             	lea    -0xc(%ebp),%esp
 8059c93:	5b                   	pop    %ebx
 8059c94:	5e                   	pop    %esi
 8059c95:	5f                   	pop    %edi
 8059c96:	5d                   	pop    %ebp
 8059c97:	c3                   	ret    

08059c98 <net_ipv6_mld_join>:
{
 8059c98:	55                   	push   %ebp
 8059c99:	89 e5                	mov    %esp,%ebp
 8059c9b:	56                   	push   %esi
 8059c9c:	53                   	push   %ebx
	maddr = net_if_ipv6_maddr_lookup(addr, &iface);
 8059c9d:	8d 45 08             	lea    0x8(%ebp),%eax
{
 8059ca0:	83 ec 18             	sub    $0x18,%esp
 8059ca3:	8b 75 0c             	mov    0xc(%ebp),%esi
	maddr = net_if_ipv6_maddr_lookup(addr, &iface);
 8059ca6:	50                   	push   %eax
 8059ca7:	56                   	push   %esi
 8059ca8:	e8 02 80 ff ff       	call   8051caf <net_if_ipv6_maddr_lookup>
 8059cad:	83 c4 10             	add    $0x10,%esp
	if (maddr && net_if_ipv6_maddr_is_joined(maddr)) {
 8059cb0:	85 c0                	test   %eax,%eax
 8059cb2:	74 0f                	je     8059cc3 <net_ipv6_mld_join+0x2b>
 8059cb4:	89 c3                	mov    %eax,%ebx
		return -EALREADY;
 8059cb6:	b8 8e ff ff ff       	mov    $0xffffff8e,%eax
	if (maddr && net_if_ipv6_maddr_is_joined(maddr)) {
 8059cbb:	f6 43 14 02          	testb  $0x2,0x14(%ebx)
 8059cbf:	74 1b                	je     8059cdc <net_ipv6_mld_join+0x44>
 8059cc1:	eb 6f                	jmp    8059d32 <net_ipv6_mld_join+0x9a>
		maddr = net_if_ipv6_maddr_add(iface, addr);
 8059cc3:	50                   	push   %eax
 8059cc4:	50                   	push   %eax
 8059cc5:	56                   	push   %esi
 8059cc6:	ff 75 08             	push   0x8(%ebp)
 8059cc9:	e8 85 80 ff ff       	call   8051d53 <net_if_ipv6_maddr_add>
 8059cce:	83 c4 10             	add    $0x10,%esp
 8059cd1:	89 c3                	mov    %eax,%ebx
			return -ENOMEM;
 8059cd3:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
		if (!maddr) {
 8059cd8:	85 db                	test   %ebx,%ebx
 8059cda:	74 56                	je     8059d32 <net_ipv6_mld_join+0x9a>
	if (!net_if_is_up(iface)) {
 8059cdc:	8b 45 08             	mov    0x8(%ebp),%eax
	if (iface == NULL) {
 8059cdf:	85 c0                	test   %eax,%eax
 8059ce1:	75 07                	jne    8059cea <net_ipv6_mld_join+0x52>
		return -ENETDOWN;
 8059ce3:	b8 9c ff ff ff       	mov    $0xffffff9c,%eax
 8059ce8:	eb 48                	jmp    8059d32 <net_ipv6_mld_join+0x9a>
 8059cea:	8b 10                	mov    (%eax),%edx
 8059cec:	8b 52 0c             	mov    0xc(%edx),%edx
	return net_if_flag_is_set(iface, NET_IF_UP) &&
 8059cef:	80 e2 01             	and    $0x1,%dl
 8059cf2:	74 ef                	je     8059ce3 <net_ipv6_mld_join+0x4b>
 8059cf4:	8b 00                	mov    (%eax),%eax
 8059cf6:	8b 40 0c             	mov    0xc(%eax),%eax
	if (!net_if_is_up(iface)) {
 8059cf9:	0f ba e0 08          	bt     $0x8,%eax
 8059cfd:	73 e4                	jae    8059ce3 <net_ipv6_mld_join+0x4b>
	ret = mld_send_generic(iface, addr, NET_IPV6_MLDv2_MODE_IS_EXCLUDE);
 8059cff:	8b 45 08             	mov    0x8(%ebp),%eax
 8059d02:	b9 02 00 00 00       	mov    $0x2,%ecx
 8059d07:	89 f2                	mov    %esi,%edx
 8059d09:	e8 6b fd ff ff       	call   8059a79 <mld_send_generic>
	if (ret < 0) {
 8059d0e:	85 c0                	test   %eax,%eax
 8059d10:	78 20                	js     8059d32 <net_ipv6_mld_join+0x9a>
	net_if_ipv6_maddr_join(maddr);
 8059d12:	83 ec 0c             	sub    $0xc,%esp
 8059d15:	89 45 f4             	mov    %eax,-0xc(%ebp)
 8059d18:	53                   	push   %ebx
 8059d19:	e8 fd 80 ff ff       	call   8051e1b <net_if_ipv6_maddr_join>
 8059d1e:	83 c4 0c             	add    $0xc,%esp
	net_if_mcast_monitor(iface, &maddr->address, true);
 8059d21:	6a 01                	push   $0x1
 8059d23:	53                   	push   %ebx
 8059d24:	ff 75 08             	push   0x8(%ebp)
 8059d27:	e8 88 73 ff ff       	call   80510b4 <net_if_mcast_monitor>
 8059d2c:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8059d2f:	83 c4 10             	add    $0x10,%esp
}
 8059d32:	8d 65 f8             	lea    -0x8(%ebp),%esp
 8059d35:	5b                   	pop    %ebx
 8059d36:	5e                   	pop    %esi
 8059d37:	5d                   	pop    %ebp
 8059d38:	c3                   	ret    

08059d39 <net_ipv6_mld_init>:
	.code = 0,
	.handler = handle_mld_query,
};

void net_ipv6_mld_init(void)
{
 8059d39:	55                   	push   %ebp
 8059d3a:	89 e5                	mov    %esp,%ebp
 8059d3c:	83 ec 14             	sub    $0x14,%esp
	net_icmpv6_register_handler(&mld_query_input_handler);
 8059d3f:	68 bc 73 06 08       	push   $0x80673bc
 8059d44:	e8 6b ce ff ff       	call   8056bb4 <net_icmpv6_register_handler>
 8059d49:	83 c4 10             	add    $0x10,%esp
}
 8059d4c:	c9                   	leave  
 8059d4d:	c3                   	ret    

08059d4e <net_route_nexthop_remove>:
static K_MUTEX_DEFINE(lock);

static void net_route_nexthop_remove(struct net_nbr *nbr)
{
	NET_DBG("Nexthop %p removed", nbr);
}
 8059d4e:	c3                   	ret    

08059d4f <nbr_new>:
}

static struct net_nbr *nbr_new(struct net_if *iface,
			       struct in6_addr *addr,
			       uint8_t prefix_len)
{
 8059d4f:	55                   	push   %ebp
 8059d50:	89 e5                	mov    %esp,%ebp
 8059d52:	57                   	push   %edi
 8059d53:	89 c7                	mov    %eax,%edi
 8059d55:	56                   	push   %esi
 8059d56:	89 d6                	mov    %edx,%esi
 8059d58:	53                   	push   %ebx
 8059d59:	89 cb                	mov    %ecx,%ebx
 8059d5b:	83 ec 38             	sub    $0x38,%esp
 8059d5e:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 8059d64:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 8059d67:	31 c0                	xor    %eax,%eax
	struct net_nbr *nbr = net_nbr_get(&net_nbr_routes.table);
 8059d69:	68 c8 73 06 08       	push   $0x80673c8
 8059d6e:	e8 e7 d3 ff ff       	call   805715a <net_nbr_get>
 8059d73:	83 c4 10             	add    $0x10,%esp

	if (!nbr) {
 8059d76:	85 c0                	test   %eax,%eax
 8059d78:	74 23                	je     8059d9d <nbr_new+0x4e>
		return NULL;
	}

	nbr->iface = iface;
 8059d7a:	89 78 08             	mov    %edi,0x8(%eax)

	net_ipaddr_copy(&net_route_data(nbr)->addr, addr);
 8059d7d:	b9 04 00 00 00       	mov    $0x4,%ecx
 8059d82:	8d 7d d4             	lea    -0x2c(%ebp),%edi
 8059d85:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
 8059d87:	8b 70 0c             	mov    0xc(%eax),%esi
 8059d8a:	b9 04 00 00 00       	mov    $0x4,%ecx
 8059d8f:	8d 7e 20             	lea    0x20(%esi),%edi
 8059d92:	8d 75 d4             	lea    -0x2c(%ebp),%esi
 8059d95:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	return (struct net_route_entry *)nbr->data;
 8059d97:	8b 50 0c             	mov    0xc(%eax),%edx
	net_route_data(nbr)->prefix_len = prefix_len;
 8059d9a:	88 5a 30             	mov    %bl,0x30(%edx)
		nbr->idx, nbr, iface,
		net_sprint_ipv6_addr(&net_route_data(nbr)->addr),
		prefix_len);

	return nbr;
}
 8059d9d:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 8059da0:	65 2b 15 14 00 00 00 	sub    %gs:0x14,%edx
 8059da7:	74 05                	je     8059dae <nbr_new+0x5f>
 8059da9:	e8 52 f5 fe ff       	call   8049300 <__stack_chk_fail@plt>
 8059dae:	8d 65 f4             	lea    -0xc(%ebp),%esp
 8059db1:	5b                   	pop    %ebx
 8059db2:	5e                   	pop    %esi
 8059db3:	5f                   	pop    %edi
 8059db4:	5d                   	pop    %ebp
 8059db5:	c3                   	ret    

08059db6 <k_mutex_lock.constprop.0.isra.0>:
static inline int k_mutex_lock(struct k_mutex * mutex, k_timeout_t timeout)
 8059db6:	55                   	push   %ebp
 8059db7:	89 e5                	mov    %esp,%ebp
 8059db9:	83 ec 0c             	sub    $0xc,%esp
	return z_impl_k_mutex_lock(mutex, timeout);
 8059dbc:	52                   	push   %edx
 8059dbd:	50                   	push   %eax
 8059dbe:	68 d4 75 06 08       	push   $0x80675d4
 8059dc3:	e8 d0 53 00 00       	call   805f198 <z_impl_k_mutex_lock>
 8059dc8:	83 c4 10             	add    $0x10,%esp
}
 8059dcb:	c9                   	leave  
 8059dcc:	c3                   	ret    

08059dcd <k_mutex_unlock.constprop.0.isra.0>:
static inline int k_mutex_unlock(struct k_mutex * mutex)
 8059dcd:	55                   	push   %ebp
 8059dce:	89 e5                	mov    %esp,%ebp
 8059dd0:	83 ec 14             	sub    $0x14,%esp
	return z_impl_k_mutex_unlock(mutex);
 8059dd3:	68 d4 75 06 08       	push   $0x80675d4
 8059dd8:	e8 c9 54 00 00       	call   805f2a6 <z_impl_k_mutex_unlock>
 8059ddd:	83 c4 10             	add    $0x10,%esp
}
 8059de0:	c9                   	leave  
 8059de1:	c3                   	ret    

08059de2 <sys_slist_find_and_remove.isra.0>:
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
 8059de2:	55                   	push   %ebp
	return list->head;
 8059de3:	8b 08                	mov    (%eax),%ecx
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
 8059de5:	89 e5                	mov    %esp,%ebp
 8059de7:	53                   	push   %ebx
 8059de8:	31 db                	xor    %ebx,%ebx
 8059dea:	85 c9                	test   %ecx,%ecx
 8059dec:	74 2e                	je     8059e1c <sys_slist_find_and_remove.isra.0+0x3a>
 8059dee:	39 d1                	cmp    %edx,%ecx
 8059df0:	75 24                	jne    8059e16 <sys_slist_find_and_remove.isra.0+0x34>
	return node->next;
 8059df2:	8b 0a                	mov    (%edx),%ecx
Z_GENLIST_REMOVE(slist, snode)
 8059df4:	85 db                	test   %ebx,%ebx
 8059df6:	75 0c                	jne    8059e04 <sys_slist_find_and_remove.isra.0+0x22>
	list->head = node;
 8059df8:	89 08                	mov    %ecx,(%eax)
Z_GENLIST_REMOVE(slist, snode)
 8059dfa:	3b 50 04             	cmp    0x4(%eax),%edx
 8059dfd:	75 0f                	jne    8059e0e <sys_slist_find_and_remove.isra.0+0x2c>
	list->tail = node;
 8059dff:	89 48 04             	mov    %ecx,0x4(%eax)
}
 8059e02:	eb 0a                	jmp    8059e0e <sys_slist_find_and_remove.isra.0+0x2c>
	parent->next = child;
 8059e04:	89 0b                	mov    %ecx,(%ebx)
Z_GENLIST_REMOVE(slist, snode)
 8059e06:	3b 50 04             	cmp    0x4(%eax),%edx
 8059e09:	75 03                	jne    8059e0e <sys_slist_find_and_remove.isra.0+0x2c>
	list->tail = node;
 8059e0b:	89 58 04             	mov    %ebx,0x4(%eax)
	parent->next = child;
 8059e0e:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
Z_GENLIST_REMOVE(slist, snode)
 8059e14:	eb 06                	jmp    8059e1c <sys_slist_find_and_remove.isra.0+0x3a>
	return node->next;
 8059e16:	89 cb                	mov    %ecx,%ebx
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
 8059e18:	8b 09                	mov    (%ecx),%ecx
 8059e1a:	eb ce                	jmp    8059dea <sys_slist_find_and_remove.isra.0+0x8>
 8059e1c:	5b                   	pop    %ebx
 8059e1d:	5d                   	pop    %ebp
 8059e1e:	c3                   	ret    

08059e1f <net_route_entries_table_clear>:
 8059e1f:	c3                   	ret    

08059e20 <net_route_entry_remove>:
 8059e20:	c3                   	ret    

08059e21 <net_route_get_nbr>:
{
 8059e21:	55                   	push   %ebp
	k_mutex_lock(&lock, K_FOREVER);
 8059e22:	83 c8 ff             	or     $0xffffffff,%eax
 8059e25:	89 c2                	mov    %eax,%edx
{
 8059e27:	89 e5                	mov    %esp,%ebp
 8059e29:	83 ec 18             	sub    $0x18,%esp
	k_mutex_lock(&lock, K_FOREVER);
 8059e2c:	e8 85 ff ff ff       	call   8059db6 <k_mutex_lock.constprop.0.isra.0>
	for (i = 0; i < CONFIG_NET_MAX_ROUTES; i++) {
 8059e31:	ba e0 63 06 08       	mov    $0x80663e0,%edx
 8059e36:	31 c0                	xor    %eax,%eax
		if (!nbr->ref) {
 8059e38:	80 3a 00             	cmpb   $0x0,(%edx)
 8059e3b:	74 1d                	je     8059e5a <net_route_get_nbr+0x39>
		if (nbr->data == (uint8_t *)route) {
 8059e3d:	8b 4d 08             	mov    0x8(%ebp),%ecx
 8059e40:	39 4a 0c             	cmp    %ecx,0xc(%edx)
 8059e43:	75 15                	jne    8059e5a <net_route_get_nbr+0x39>
	return &net_route_entries_pool[idx].nbr;
 8059e45:	6b c0 48             	imul   $0x48,%eax,%eax
 8059e48:	05 e0 63 06 08       	add    $0x80663e0,%eax
 8059e4d:	89 45 f4             	mov    %eax,-0xc(%ebp)
			k_mutex_unlock(&lock);
 8059e50:	e8 78 ff ff ff       	call   8059dcd <k_mutex_unlock.constprop.0.isra.0>
			return nbr;
 8059e55:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8059e58:	eb 10                	jmp    8059e6a <net_route_get_nbr+0x49>
	for (i = 0; i < CONFIG_NET_MAX_ROUTES; i++) {
 8059e5a:	40                   	inc    %eax
 8059e5b:	83 c2 48             	add    $0x48,%edx
 8059e5e:	83 f8 08             	cmp    $0x8,%eax
 8059e61:	75 d5                	jne    8059e38 <net_route_get_nbr+0x17>
	k_mutex_unlock(&lock);
 8059e63:	e8 65 ff ff ff       	call   8059dcd <k_mutex_unlock.constprop.0.isra.0>
	return NULL;
 8059e68:	31 c0                	xor    %eax,%eax
}
 8059e6a:	c9                   	leave  
 8059e6b:	c3                   	ret    

08059e6c <net_route_lookup>:
	sys_slist_prepend(&routes, &route->node);
}

struct net_route_entry *net_route_lookup(struct net_if *iface,
					 struct in6_addr *dst)
{
 8059e6c:	55                   	push   %ebp
	struct net_route_entry *route, *found = NULL;
	uint8_t longest_match = 0U;
	int i;

	k_mutex_lock(&lock, K_FOREVER);
 8059e6d:	83 c8 ff             	or     $0xffffffff,%eax
 8059e70:	89 c2                	mov    %eax,%edx
{
 8059e72:	89 e5                	mov    %esp,%ebp
 8059e74:	57                   	push   %edi
 8059e75:	56                   	push   %esi
	uint8_t longest_match = 0U;
 8059e76:	31 f6                	xor    %esi,%esi
{
 8059e78:	53                   	push   %ebx
	struct net_route_entry *route, *found = NULL;
 8059e79:	31 db                	xor    %ebx,%ebx
{
 8059e7b:	83 ec 1c             	sub    $0x1c,%esp
	k_mutex_lock(&lock, K_FOREVER);
 8059e7e:	e8 33 ff ff ff       	call   8059db6 <k_mutex_lock.constprop.0.isra.0>

	for (i = 0; i < CONFIG_NET_MAX_ROUTES && longest_match < 128; i++) {
 8059e83:	c7 45 dc e0 63 06 08 	movl   $0x80663e0,-0x24(%ebp)
 8059e8a:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
		struct net_nbr *nbr = get_nbr(i);

		if (!nbr->ref) {
 8059e91:	8b 45 dc             	mov    -0x24(%ebp),%eax
 8059e94:	80 38 00             	cmpb   $0x0,(%eax)
 8059e97:	0f 84 95 00 00 00    	je     8059f32 <net_route_lookup+0xc6>
			continue;
		}

		if (iface && nbr->iface != iface) {
 8059e9d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 8059ea1:	74 0c                	je     8059eaf <net_route_lookup+0x43>
 8059ea3:	8b 7d 08             	mov    0x8(%ebp),%edi
 8059ea6:	39 78 08             	cmp    %edi,0x8(%eax)
 8059ea9:	0f 85 83 00 00 00    	jne    8059f32 <net_route_lookup+0xc6>
	return (struct net_route_entry *)nbr->data;
 8059eaf:	8b 45 dc             	mov    -0x24(%ebp),%eax
			continue;
		}

		route = net_route_data(nbr);

		if (route->prefix_len >= longest_match &&
 8059eb2:	89 f1                	mov    %esi,%ecx
	return (struct net_route_entry *)nbr->data;
 8059eb4:	8b 40 0c             	mov    0xc(%eax),%eax
 8059eb7:	89 45 e0             	mov    %eax,-0x20(%ebp)
		if (route->prefix_len >= longest_match &&
 8059eba:	8a 40 30             	mov    0x30(%eax),%al
 8059ebd:	88 45 e7             	mov    %al,-0x19(%ebp)
 8059ec0:	38 c8                	cmp    %cl,%al
 8059ec2:	72 6e                	jb     8059f32 <net_route_lookup+0xc6>
	if (length > 128) {
 8059ec4:	3c 80                	cmp    $0x80,%al
 8059ec6:	77 6a                	ja     8059f32 <net_route_lookup+0xc6>
	uint8_t bytes = length / 8U;
 8059ec8:	8a 55 e7             	mov    -0x19(%ebp),%dl
		    net_ipv6_is_prefix(dst->s6_addr,
				       route->addr.s6_addr,
 8059ecb:	8b 45 e0             	mov    -0x20(%ebp),%eax
 8059ece:	c0 ea 03             	shr    $0x3,%dl
 8059ed1:	83 c0 20             	add    $0x20,%eax
	if (memcmp(addr1, addr2, bytes)) {
 8059ed4:	0f b6 fa             	movzbl %dl,%edi
 8059ed7:	52                   	push   %edx
 8059ed8:	57                   	push   %edi
 8059ed9:	50                   	push   %eax
 8059eda:	ff 75 0c             	push   0xc(%ebp)
 8059edd:	e8 8e f1 fe ff       	call   8049070 <memcmp@plt>
 8059ee2:	83 c4 10             	add    $0x10,%esp
 8059ee5:	85 c0                	test   %eax,%eax
 8059ee7:	75 49                	jne    8059f32 <net_route_lookup+0xc6>
	if (!remain) {
 8059ee9:	8a 45 e7             	mov    -0x19(%ebp),%al
 8059eec:	f7 d8                	neg    %eax
 8059eee:	24 07                	and    $0x7,%al
 8059ef0:	88 45 e6             	mov    %al,-0x1a(%ebp)
 8059ef3:	74 36                	je     8059f2b <net_route_lookup+0xbf>
	mask = ((0xff << (8 - remain)) ^ 0xff) << remain;
 8059ef5:	0f b6 d0             	movzbl %al,%edx
	return (addr1[bytes] & mask) == (addr2[bytes] & mask);
 8059ef8:	8b 4d e0             	mov    -0x20(%ebp),%ecx
 8059efb:	8b 45 0c             	mov    0xc(%ebp),%eax
 8059efe:	8a 04 38             	mov    (%eax,%edi,1),%al
 8059f01:	32 44 39 20          	xor    0x20(%ecx,%edi,1),%al
	mask = ((0xff << (8 - remain)) ^ 0xff) << remain;
 8059f05:	b9 08 00 00 00       	mov    $0x8,%ecx
 8059f0a:	29 d1                	sub    %edx,%ecx
 8059f0c:	ba ff 00 00 00       	mov    $0xff,%edx
 8059f11:	d3 e2                	shl    %cl,%edx
 8059f13:	8a 4d e6             	mov    -0x1a(%ebp),%cl
 8059f16:	80 f2 ff             	xor    $0xff,%dl
 8059f19:	d3 e2                	shl    %cl,%edx
 8059f1b:	84 d0                	test   %dl,%al
 8059f1d:	8a 45 e7             	mov    -0x19(%ebp),%al
 8059f20:	0f 44 5d e0          	cmove  -0x20(%ebp),%ebx
 8059f24:	0f 45 c6             	cmovne %esi,%eax
 8059f27:	89 c6                	mov    %eax,%esi
 8059f29:	eb 07                	jmp    8059f32 <net_route_lookup+0xc6>
 8059f2b:	0f b6 75 e7          	movzbl -0x19(%ebp),%esi
 8059f2f:	8b 5d e0             	mov    -0x20(%ebp),%ebx
	for (i = 0; i < CONFIG_NET_MAX_ROUTES && longest_match < 128; i++) {
 8059f32:	ff 45 d8             	incl   -0x28(%ebp)
 8059f35:	83 45 dc 48          	addl   $0x48,-0x24(%ebp)
 8059f39:	83 7d d8 07          	cmpl   $0x7,-0x28(%ebp)
 8059f3d:	7f 0a                	jg     8059f49 <net_route_lookup+0xdd>
 8059f3f:	89 f0                	mov    %esi,%eax
 8059f41:	84 c0                	test   %al,%al
 8059f43:	0f 89 48 ff ff ff    	jns    8059e91 <net_route_lookup+0x25>
			found = route;
			longest_match = route->prefix_len;
		}
	}

	if (found) {
 8059f49:	85 db                	test   %ebx,%ebx
 8059f4b:	74 28                	je     8059f75 <net_route_lookup+0x109>
	sys_slist_find_and_remove(&routes, &route->node);
 8059f4d:	b8 60 8a 06 08       	mov    $0x8068a60,%eax
 8059f52:	89 da                	mov    %ebx,%edx
 8059f54:	e8 89 fe ff ff       	call   8059de2 <sys_slist_find_and_remove.isra.0>
	return list->head;
 8059f59:	a1 60 8a 06 08       	mov    0x8068a60,%eax
	parent->next = child;
 8059f5e:	89 03                	mov    %eax,(%ebx)
Z_GENLIST_PREPEND(slist, snode)
 8059f60:	83 3d 64 8a 06 08 00 	cmpl   $0x0,0x8068a64
	list->head = node;
 8059f67:	89 1d 60 8a 06 08    	mov    %ebx,0x8068a60
Z_GENLIST_PREPEND(slist, snode)
 8059f6d:	75 06                	jne    8059f75 <net_route_lookup+0x109>
	list->tail = node;
 8059f6f:	89 1d 64 8a 06 08    	mov    %ebx,0x8068a64
		net_route_info("Found", found, dst);

		update_route_access(found);
	}

	k_mutex_unlock(&lock);
 8059f75:	e8 53 fe ff ff       	call   8059dcd <k_mutex_unlock.constprop.0.isra.0>
	return found;
}
 8059f7a:	8d 65 f4             	lea    -0xc(%ebp),%esp
 8059f7d:	89 d8                	mov    %ebx,%eax
 8059f7f:	5b                   	pop    %ebx
 8059f80:	5e                   	pop    %esi
 8059f81:	5f                   	pop    %edi
 8059f82:	5d                   	pop    %ebp
 8059f83:	c3                   	ret    

08059f84 <net_route_update_lifetime>:

	k_mutex_unlock(&lock);
}

void net_route_update_lifetime(struct net_route_entry *route, uint32_t lifetime)
{
 8059f84:	55                   	push   %ebp
 8059f85:	89 e5                	mov    %esp,%ebp
 8059f87:	57                   	push   %edi
 8059f88:	56                   	push   %esi
 8059f89:	53                   	push   %ebx
 8059f8a:	83 ec 0c             	sub    $0xc,%esp
 8059f8d:	8b 75 08             	mov    0x8(%ebp),%esi
 8059f90:	8b 7d 0c             	mov    0xc(%ebp),%edi
	NET_DBG("Updating route lifetime of %s to %u secs",
		net_sprint_ipv6_addr(&route->addr),
		lifetime);

	if (!route) {
 8059f93:	85 f6                	test   %esi,%esi
 8059f95:	0f 84 97 00 00 00    	je     805a032 <net_route_update_lifetime+0xae>
		return;
	}

	k_mutex_lock(&lock, K_FOREVER);
 8059f9b:	83 c8 ff             	or     $0xffffffff,%eax

	if (lifetime == NET_IPV6_ND_INFINITE_LIFETIME) {
		route->is_infinite = true;

		(void)sys_slist_find_and_remove(&active_route_lifetime_timers,
 8059f9e:	8d 5e 10             	lea    0x10(%esi),%ebx
	k_mutex_lock(&lock, K_FOREVER);
 8059fa1:	89 c2                	mov    %eax,%edx
 8059fa3:	e8 0e fe ff ff       	call   8059db6 <k_mutex_lock.constprop.0.isra.0>
	if (lifetime == NET_IPV6_ND_INFINITE_LIFETIME) {
 8059fa8:	83 ff ff             	cmp    $0xffffffff,%edi
 8059fab:	8a 46 31             	mov    0x31(%esi),%al
 8059fae:	75 14                	jne    8059fc4 <net_route_update_lifetime+0x40>
		route->is_infinite = true;
 8059fb0:	83 c8 04             	or     $0x4,%eax
		(void)sys_slist_find_and_remove(&active_route_lifetime_timers,
 8059fb3:	89 da                	mov    %ebx,%edx
		route->is_infinite = true;
 8059fb5:	88 46 31             	mov    %al,0x31(%esi)
		(void)sys_slist_find_and_remove(&active_route_lifetime_timers,
 8059fb8:	b8 58 8a 06 08       	mov    $0x8068a58,%eax
 8059fbd:	e8 20 fe ff ff       	call   8059de2 <sys_slist_find_and_remove.isra.0>
 8059fc2:	eb 62                	jmp    805a026 <net_route_update_lifetime+0xa2>
						&route->lifetime.node);
	} else {
		route->is_infinite = false;
 8059fc4:	83 e0 fb             	and    $0xfffffffb,%eax
 8059fc7:	88 46 31             	mov    %al,0x31(%esi)
	return z_impl_k_uptime_ticks();
 8059fca:	e8 45 6c 00 00       	call   8060c14 <z_impl_k_uptime_ticks>
			return t * ((uint64_t)to_hz / from_hz);
 8059fcf:	ba 0a 00 00 00       	mov    $0xa,%edx
 8059fd4:	f7 e2                	mul    %edx

		net_timeout_set(&route->lifetime, lifetime, k_uptime_get_32());
 8059fd6:	51                   	push   %ecx
 8059fd7:	50                   	push   %eax
 8059fd8:	57                   	push   %edi
 8059fd9:	53                   	push   %ebx
 8059fda:	e8 0b 8d ff ff       	call   8052cea <net_timeout_set>

		(void)sys_slist_find_and_remove(&active_route_lifetime_timers,
 8059fdf:	b8 58 8a 06 08       	mov    $0x8068a58,%eax
		net_timeout_set(&route->lifetime, lifetime, k_uptime_get_32());
 8059fe4:	83 c4 10             	add    $0x10,%esp
		(void)sys_slist_find_and_remove(&active_route_lifetime_timers,
 8059fe7:	89 da                	mov    %ebx,%edx
 8059fe9:	e8 f4 fd ff ff       	call   8059de2 <sys_slist_find_and_remove.isra.0>
	return list->tail;
 8059fee:	a1 5c 8a 06 08       	mov    0x8068a5c,%eax
	parent->next = child;
 8059ff3:	c7 46 10 00 00 00 00 	movl   $0x0,0x10(%esi)
Z_GENLIST_APPEND(slist, snode)
 8059ffa:	85 c0                	test   %eax,%eax
 8059ffc:	75 0e                	jne    805a00c <net_route_update_lifetime+0x88>
	list->tail = node;
 8059ffe:	89 1d 5c 8a 06 08    	mov    %ebx,0x8068a5c
	list->head = node;
 805a004:	89 1d 58 8a 06 08    	mov    %ebx,0x8068a58
}
 805a00a:	eb 08                	jmp    805a014 <net_route_update_lifetime+0x90>
	parent->next = child;
 805a00c:	89 18                	mov    %ebx,(%eax)
	list->tail = node;
 805a00e:	89 1d 5c 8a 06 08    	mov    %ebx,0x8068a5c
						&route->lifetime.node);
		sys_slist_append(&active_route_lifetime_timers,
				 &route->lifetime.node);
		k_work_reschedule(&route_lifetime_timer, K_NO_WAIT);
 805a014:	50                   	push   %eax
 805a015:	6a 00                	push   $0x0
 805a017:	6a 00                	push   $0x0
 805a019:	68 e0 85 06 08       	push   $0x80685e0
 805a01e:	e8 bd 5c 00 00       	call   805fce0 <k_work_reschedule>
 805a023:	83 c4 10             	add    $0x10,%esp
	}

	k_mutex_unlock(&lock);
}
 805a026:	8d 65 f4             	lea    -0xc(%ebp),%esp
 805a029:	5b                   	pop    %ebx
 805a02a:	5e                   	pop    %esi
 805a02b:	5f                   	pop    %edi
 805a02c:	5d                   	pop    %ebp
	k_mutex_unlock(&lock);
 805a02d:	e9 9b fd ff ff       	jmp    8059dcd <k_mutex_unlock.constprop.0.isra.0>
}
 805a032:	8d 65 f4             	lea    -0xc(%ebp),%esp
 805a035:	5b                   	pop    %ebx
 805a036:	5e                   	pop    %esi
 805a037:	5f                   	pop    %edi
 805a038:	5d                   	pop    %ebp
 805a039:	c3                   	ret    

0805a03a <net_route_del>:

int net_route_del(struct net_route_entry *route)
{
 805a03a:	55                   	push   %ebp
#if defined(CONFIG_NET_MGMT_EVENT_INFO)
       struct net_event_ipv6_route info;
#endif

	if (!route) {
		return -EINVAL;
 805a03b:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
{
 805a040:	89 e5                	mov    %esp,%ebp
 805a042:	56                   	push   %esi
 805a043:	53                   	push   %ebx
 805a044:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (!route) {
 805a047:	85 db                	test   %ebx,%ebx
 805a049:	0f 84 9e 00 00 00    	je     805a0ed <net_route_del+0xb3>
	}

	k_mutex_lock(&lock, K_FOREVER);
 805a04f:	83 c8 ff             	or     $0xffffffff,%eax
 805a052:	89 c2                	mov    %eax,%edx
 805a054:	e8 5d fd ff ff       	call   8059db6 <k_mutex_lock.constprop.0.isra.0>
					sizeof(struct net_event_ipv6_route));
#else
	net_mgmt_event_notify(NET_EVENT_IPV6_ROUTE_DEL, route->iface);
#endif

	if (!route->is_infinite) {
 805a059:	f6 43 31 04          	testb  $0x4,0x31(%ebx)
 805a05d:	75 26                	jne    805a085 <net_route_del+0x4b>
		sys_slist_find_and_remove(&active_route_lifetime_timers,
 805a05f:	8d 53 10             	lea    0x10(%ebx),%edx
 805a062:	b8 58 8a 06 08       	mov    $0x8068a58,%eax
 805a067:	e8 76 fd ff ff       	call   8059de2 <sys_slist_find_and_remove.isra.0>
					  &route->lifetime.node);

		if (sys_slist_is_empty(&active_route_lifetime_timers)) {
 805a06c:	83 3d 58 8a 06 08 00 	cmpl   $0x0,0x8068a58
 805a073:	75 10                	jne    805a085 <net_route_del+0x4b>
			k_work_cancel_delayable(&route_lifetime_timer);
 805a075:	83 ec 0c             	sub    $0xc,%esp
 805a078:	68 e0 85 06 08       	push   $0x80685e0
 805a07d:	e8 7c 5c 00 00       	call   805fcfe <k_work_cancel_delayable>
 805a082:	83 c4 10             	add    $0x10,%esp
		}
	}

	sys_slist_find_and_remove(&routes, &route->node);
 805a085:	89 da                	mov    %ebx,%edx
 805a087:	b8 60 8a 06 08       	mov    $0x8068a60,%eax
 805a08c:	e8 51 fd ff ff       	call   8059de2 <sys_slist_find_and_remove.isra.0>

	nbr = net_route_get_nbr(route);
 805a091:	83 ec 0c             	sub    $0xc,%esp
 805a094:	53                   	push   %ebx
 805a095:	e8 87 fd ff ff       	call   8059e21 <net_route_get_nbr>
 805a09a:	83 c4 10             	add    $0x10,%esp
 805a09d:	89 c6                	mov    %eax,%esi
	if (!nbr) {
 805a09f:	85 c0                	test   %eax,%eax
 805a0a1:	75 0c                	jne    805a0af <net_route_del+0x75>
		k_mutex_unlock(&lock);
 805a0a3:	e8 25 fd ff ff       	call   8059dcd <k_mutex_unlock.constprop.0.isra.0>
		return -ENOENT;
 805a0a8:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
 805a0ad:	eb 3e                	jmp    805a0ed <net_route_del+0xb3>
	return list->head;
 805a0af:	8b 5b 04             	mov    0x4(%ebx),%ebx
	}

	net_route_info("Deleted", route, &route->addr);

	SYS_SLIST_FOR_EACH_CONTAINER(&route->nexthop, nexthop_route, node) {
 805a0b2:	85 db                	test   %ebx,%ebx
 805a0b4:	75 15                	jne    805a0cb <net_route_del+0x91>
	net_nbr_unref(nbr);
 805a0b6:	83 ec 0c             	sub    $0xc,%esp
 805a0b9:	56                   	push   %esi
 805a0ba:	e8 7b d0 ff ff       	call   805713a <net_nbr_unref>
 805a0bf:	83 c4 10             	add    $0x10,%esp
		release_nexthop_route(nexthop_route);
	}

	nbr_free(nbr);

	k_mutex_unlock(&lock);
 805a0c2:	e8 06 fd ff ff       	call   8059dcd <k_mutex_unlock.constprop.0.isra.0>
	return 0;
 805a0c7:	31 c0                	xor    %eax,%eax
 805a0c9:	eb 22                	jmp    805a0ed <net_route_del+0xb3>
		if (!nexthop_route->nbr) {
 805a0cb:	8b 43 04             	mov    0x4(%ebx),%eax
 805a0ce:	85 c0                	test   %eax,%eax
 805a0d0:	74 17                	je     805a0e9 <net_route_del+0xaf>
	net_nbr_unref(nbr);
 805a0d2:	83 ec 0c             	sub    $0xc,%esp
 805a0d5:	50                   	push   %eax
 805a0d6:	e8 5f d0 ff ff       	call   805713a <net_nbr_unref>
	struct net_nbr *nbr = CONTAINER_OF(route_nexthop, struct net_nbr, __nbr);
 805a0db:	8d 43 ec             	lea    -0x14(%ebx),%eax
	net_nbr_unref(nbr);
 805a0de:	89 04 24             	mov    %eax,(%esp)
 805a0e1:	e8 54 d0 ff ff       	call   805713a <net_nbr_unref>
 805a0e6:	83 c4 10             	add    $0x10,%esp
	return node->next;
 805a0e9:	8b 1b                	mov    (%ebx),%ebx
 805a0eb:	eb c5                	jmp    805a0b2 <net_route_del+0x78>
}
 805a0ed:	8d 65 f8             	lea    -0x8(%ebp),%esp
 805a0f0:	5b                   	pop    %ebx
 805a0f1:	5e                   	pop    %esi
 805a0f2:	5d                   	pop    %ebp
 805a0f3:	c3                   	ret    

0805a0f4 <route_lifetime_timeout>:
{
 805a0f4:	55                   	push   %ebp
 805a0f5:	89 e5                	mov    %esp,%ebp
 805a0f7:	57                   	push   %edi
 805a0f8:	56                   	push   %esi
 805a0f9:	53                   	push   %ebx
 805a0fa:	83 ec 1c             	sub    $0x1c,%esp
 805a0fd:	e8 12 6b 00 00       	call   8060c14 <z_impl_k_uptime_ticks>
 805a102:	ba 0a 00 00 00       	mov    $0xa,%edx
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&active_route_lifetime_timers,
 805a107:	31 ff                	xor    %edi,%edi
 805a109:	f7 e2                	mul    %edx
 805a10b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	k_mutex_lock(&lock, K_FOREVER);
 805a10e:	83 c8 ff             	or     $0xffffffff,%eax
 805a111:	89 c2                	mov    %eax,%edx
 805a113:	e8 9e fc ff ff       	call   8059db6 <k_mutex_lock.constprop.0.isra.0>
	return list->head;
 805a118:	8b 1d 58 8a 06 08    	mov    0x8068a58,%ebx
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&active_route_lifetime_timers,
 805a11e:	85 db                	test   %ebx,%ebx
 805a120:	74 0c                	je     805a12e <route_lifetime_timeout+0x3a>
 805a122:	8d 7b f0             	lea    -0x10(%ebx),%edi
	return node->next;
 805a125:	8b 1b                	mov    (%ebx),%ebx
 805a127:	85 db                	test   %ebx,%ebx
 805a129:	74 03                	je     805a12e <route_lifetime_timeout+0x3a>
 805a12b:	83 eb 10             	sub    $0x10,%ebx
 805a12e:	83 ce ff             	or     $0xffffffff,%esi
 805a131:	85 ff                	test   %edi,%edi
 805a133:	74 4e                	je     805a183 <route_lifetime_timeout+0x8f>
		struct net_timeout *timeout = &current->lifetime;
 805a135:	8d 57 10             	lea    0x10(%edi),%edx
		uint32_t this_update = net_timeout_evaluate(timeout,
 805a138:	50                   	push   %eax
 805a139:	50                   	push   %eax
 805a13a:	ff 75 e4             	push   -0x1c(%ebp)
 805a13d:	52                   	push   %edx
 805a13e:	89 55 e0             	mov    %edx,-0x20(%ebp)
 805a141:	e8 54 8c ff ff       	call   8052d9a <net_timeout_evaluate>
 805a146:	83 c4 10             	add    $0x10,%esp
		if (this_update == 0U) {
 805a149:	8b 55 e0             	mov    -0x20(%ebp),%edx
 805a14c:	85 c0                	test   %eax,%eax
 805a14e:	75 18                	jne    805a168 <route_lifetime_timeout+0x74>
	sys_slist_find_and_remove(&active_route_lifetime_timers,
 805a150:	b8 58 8a 06 08       	mov    $0x8068a58,%eax
 805a155:	e8 88 fc ff ff       	call   8059de2 <sys_slist_find_and_remove.isra.0>
	net_route_del(route);
 805a15a:	83 ec 0c             	sub    $0xc,%esp
 805a15d:	57                   	push   %edi
 805a15e:	e8 d7 fe ff ff       	call   805a03a <net_route_del>
 805a163:	83 c4 10             	add    $0x10,%esp
			continue;
 805a166:	eb 05                	jmp    805a16d <route_lifetime_timeout+0x79>
		if (this_update < next_update) {
 805a168:	39 c6                	cmp    %eax,%esi
 805a16a:	0f 47 f0             	cmova  %eax,%esi
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&active_route_lifetime_timers,
 805a16d:	31 c0                	xor    %eax,%eax
 805a16f:	85 db                	test   %ebx,%ebx
 805a171:	74 0a                	je     805a17d <route_lifetime_timeout+0x89>
 805a173:	8b 43 10             	mov    0x10(%ebx),%eax
 805a176:	85 c0                	test   %eax,%eax
 805a178:	74 03                	je     805a17d <route_lifetime_timeout+0x89>
 805a17a:	83 e8 10             	sub    $0x10,%eax
 805a17d:	89 df                	mov    %ebx,%edi
 805a17f:	89 c3                	mov    %eax,%ebx
 805a181:	eb ae                	jmp    805a131 <route_lifetime_timeout+0x3d>
	if (next_update != UINT32_MAX) {
 805a183:	83 fe ff             	cmp    $0xffffffff,%esi
 805a186:	74 27                	je     805a1af <route_lifetime_timeout+0xbb>
		k_work_reschedule(&route_lifetime_timer, K_MSEC(next_update));
 805a188:	89 f0                	mov    %esi,%eax
 805a18a:	31 d2                	xor    %edx,%edx
			return t / ((uint64_t)from_hz / to_hz);
 805a18c:	6a 00                	push   $0x0
		t += off;
 805a18e:	83 c0 09             	add    $0x9,%eax
			return t / ((uint64_t)from_hz / to_hz);
 805a191:	6a 0a                	push   $0xa
		t += off;
 805a193:	83 d2 00             	adc    $0x0,%edx
			return t / ((uint64_t)from_hz / to_hz);
 805a196:	52                   	push   %edx
 805a197:	50                   	push   %eax
 805a198:	e8 b3 f3 fe ff       	call   8049550 <__udivdi3>
 805a19d:	83 c4 0c             	add    $0xc,%esp
 805a1a0:	52                   	push   %edx
 805a1a1:	50                   	push   %eax
 805a1a2:	68 e0 85 06 08       	push   $0x80685e0
 805a1a7:	e8 34 5b 00 00       	call   805fce0 <k_work_reschedule>
 805a1ac:	83 c4 10             	add    $0x10,%esp
}
 805a1af:	8d 65 f4             	lea    -0xc(%ebp),%esp
 805a1b2:	5b                   	pop    %ebx
 805a1b3:	5e                   	pop    %esi
 805a1b4:	5f                   	pop    %edi
 805a1b5:	5d                   	pop    %ebp
	k_mutex_unlock(&lock);
 805a1b6:	e9 12 fc ff ff       	jmp    8059dcd <k_mutex_unlock.constprop.0.isra.0>

0805a1bb <net_route_del_by_nexthop>:

int net_route_del_by_nexthop(struct net_if *iface, struct in6_addr *nexthop)
{
 805a1bb:	55                   	push   %ebp
	int i, ret;

	NET_ASSERT(iface);
	NET_ASSERT(nexthop);

	k_mutex_lock(&lock, K_FOREVER);
 805a1bc:	83 c8 ff             	or     $0xffffffff,%eax
 805a1bf:	89 c2                	mov    %eax,%edx
{
 805a1c1:	89 e5                	mov    %esp,%ebp
 805a1c3:	57                   	push   %edi

	nbr_nexthop = net_ipv6_nbr_lookup(iface, nexthop);
 805a1c4:	31 ff                	xor    %edi,%edi
{
 805a1c6:	56                   	push   %esi
	int count = 0, status = 0;
 805a1c7:	31 f6                	xor    %esi,%esi
{
 805a1c9:	53                   	push   %ebx
	int count = 0, status = 0;
 805a1ca:	31 db                	xor    %ebx,%ebx
{
 805a1cc:	83 ec 1c             	sub    $0x1c,%esp
	k_mutex_lock(&lock, K_FOREVER);
 805a1cf:	e8 e2 fb ff ff       	call   8059db6 <k_mutex_lock.constprop.0.isra.0>
	nbr_nexthop = net_ipv6_nbr_lookup(iface, nexthop);
 805a1d4:	50                   	push   %eax
 805a1d5:	50                   	push   %eax
 805a1d6:	ff 75 0c             	push   0xc(%ebp)
 805a1d9:	ff 75 08             	push   0x8(%ebp)
 805a1dc:	e8 12 df ff ff       	call   80580f3 <net_ipv6_nbr_lookup>
 805a1e1:	83 c4 10             	add    $0x10,%esp
 805a1e4:	89 c2                	mov    %eax,%edx
	return (struct net_route_entry *)nbr->data;
 805a1e6:	8b 8f ec 63 06 08    	mov    0x80663ec(%edi),%ecx

	for (i = 0; i < CONFIG_NET_MAX_ROUTES; i++) {
		struct net_nbr *nbr = get_nbr(i);
		struct net_route_entry *route = net_route_data(nbr);

		if (!route) {
 805a1ec:	85 c9                	test   %ecx,%ecx
 805a1ee:	74 2b                	je     805a21b <net_route_del_by_nexthop+0x60>
	return list->head;
 805a1f0:	8b 41 04             	mov    0x4(%ecx),%eax
			continue;
		}

		SYS_SLIST_FOR_EACH_CONTAINER(&route->nexthop, nexthop_route,
 805a1f3:	85 c0                	test   %eax,%eax
 805a1f5:	74 24                	je     805a21b <net_route_del_by_nexthop+0x60>
					     node) {
			if (nexthop_route->nbr == nbr_nexthop) {
 805a1f7:	39 50 04             	cmp    %edx,0x4(%eax)
 805a1fa:	75 19                	jne    805a215 <net_route_del_by_nexthop+0x5a>
				/* This route contains this nexthop */
				ret = net_route_del(route);
 805a1fc:	83 ec 0c             	sub    $0xc,%esp
 805a1ff:	89 55 e4             	mov    %edx,-0x1c(%ebp)
 805a202:	51                   	push   %ecx
 805a203:	e8 32 fe ff ff       	call   805a03a <net_route_del>
 805a208:	83 c4 10             	add    $0x10,%esp
				if (!ret) {
 805a20b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 805a20e:	85 c0                	test   %eax,%eax
 805a210:	75 07                	jne    805a219 <net_route_del_by_nexthop+0x5e>
					count++;
 805a212:	43                   	inc    %ebx
 805a213:	eb 06                	jmp    805a21b <net_route_del_by_nexthop+0x60>
	return node->next;
 805a215:	8b 00                	mov    (%eax),%eax
 805a217:	eb da                	jmp    805a1f3 <net_route_del_by_nexthop+0x38>
 805a219:	89 c6                	mov    %eax,%esi
	for (i = 0; i < CONFIG_NET_MAX_ROUTES; i++) {
 805a21b:	83 c7 48             	add    $0x48,%edi
 805a21e:	81 ff 40 02 00 00    	cmp    $0x240,%edi
 805a224:	75 c0                	jne    805a1e6 <net_route_del_by_nexthop+0x2b>
				break;
			}
		}
	}

	k_mutex_unlock(&lock);
 805a226:	e8 a2 fb ff ff       	call   8059dcd <k_mutex_unlock.constprop.0.isra.0>

	if (count) {
 805a22b:	85 db                	test   %ebx,%ebx
 805a22d:	75 05                	jne    805a234 <net_route_del_by_nexthop+0x79>
		return count;
	} else if (status < 0) {
 805a22f:	85 f6                	test   %esi,%esi
 805a231:	0f 4e de             	cmovle %esi,%ebx
		return status;
	}

	return 0;
}
 805a234:	8d 65 f4             	lea    -0xc(%ebp),%esp
 805a237:	89 d8                	mov    %ebx,%eax
 805a239:	5b                   	pop    %ebx
 805a23a:	5e                   	pop    %esi
 805a23b:	5f                   	pop    %edi
 805a23c:	5d                   	pop    %ebp
 805a23d:	c3                   	ret    

0805a23e <net_route_get_nexthop>:

	return status;
}

struct in6_addr *net_route_get_nexthop(struct net_route_entry *route)
{
 805a23e:	55                   	push   %ebp
 805a23f:	89 e5                	mov    %esp,%ebp
 805a241:	53                   	push   %ebx
 805a242:	51                   	push   %ecx
 805a243:	8b 5d 08             	mov    0x8(%ebp),%ebx
	struct net_route_nexthop *nexthop_route;
	struct net_ipv6_nbr_data *ipv6_nbr_data;

	if (!route) {
 805a246:	85 db                	test   %ebx,%ebx
 805a248:	74 30                	je     805a27a <net_route_get_nexthop+0x3c>
		return NULL;
	}

	k_mutex_lock(&lock, K_FOREVER);
 805a24a:	83 c8 ff             	or     $0xffffffff,%eax
 805a24d:	89 c2                	mov    %eax,%edx
 805a24f:	e8 62 fb ff ff       	call   8059db6 <k_mutex_lock.constprop.0.isra.0>
	return list->head;
 805a254:	8b 43 04             	mov    0x4(%ebx),%eax

	SYS_SLIST_FOR_EACH_CONTAINER(&route->nexthop, nexthop_route, node) {
 805a257:	85 c0                	test   %eax,%eax
 805a259:	74 18                	je     805a273 <net_route_get_nexthop+0x35>
 805a25b:	8b 50 04             	mov    0x4(%eax),%edx
 805a25e:	8b 5a 0c             	mov    0xc(%edx),%ebx
		struct in6_addr *addr;

		ipv6_nbr_data = net_ipv6_nbr_data(nexthop_route->nbr);
		if (ipv6_nbr_data) {
 805a261:	85 db                	test   %ebx,%ebx
 805a263:	74 0a                	je     805a26f <net_route_get_nexthop+0x31>
			addr = &ipv6_nbr_data->addr;
 805a265:	83 c3 04             	add    $0x4,%ebx
			NET_ASSERT(addr);

			k_mutex_unlock(&lock);
 805a268:	e8 60 fb ff ff       	call   8059dcd <k_mutex_unlock.constprop.0.isra.0>
			return addr;
 805a26d:	eb 0b                	jmp    805a27a <net_route_get_nexthop+0x3c>
	return node->next;
 805a26f:	8b 00                	mov    (%eax),%eax
 805a271:	eb e4                	jmp    805a257 <net_route_get_nexthop+0x19>
		} else {
			NET_ERR("could not get neighbor data from next hop");
		}
	}

	k_mutex_unlock(&lock);
 805a273:	e8 55 fb ff ff       	call   8059dcd <k_mutex_unlock.constprop.0.isra.0>
	return NULL;
 805a278:	31 db                	xor    %ebx,%ebx
}
 805a27a:	89 d8                	mov    %ebx,%eax
 805a27c:	5a                   	pop    %edx
 805a27d:	5b                   	pop    %ebx
 805a27e:	5d                   	pop    %ebp
 805a27f:	c3                   	ret    

0805a280 <net_route_add>:
{
 805a280:	55                   	push   %ebp
 805a281:	89 e5                	mov    %esp,%ebp
 805a283:	57                   	push   %edi
 805a284:	56                   	push   %esi
 805a285:	31 f6                	xor    %esi,%esi
 805a287:	53                   	push   %ebx
 805a288:	83 ec 0c             	sub    $0xc,%esp
 805a28b:	8b 7d 10             	mov    0x10(%ebp),%edi
 805a28e:	8b 5d 1c             	mov    0x1c(%ebp),%ebx
	if (net_ipv6_addr_cmp(addr, net_ipv6_unspecified_address())) {
 805a291:	e8 e4 94 ff ff       	call   805377a <net_ipv6_unspecified_address>
	return !memcmp(addr1, addr2, sizeof(struct in6_addr));
 805a296:	52                   	push   %edx
 805a297:	6a 10                	push   $0x10
 805a299:	50                   	push   %eax
 805a29a:	ff 75 0c             	push   0xc(%ebp)
 805a29d:	e8 ce ed fe ff       	call   8049070 <memcmp@plt>
 805a2a2:	83 c4 10             	add    $0x10,%esp
 805a2a5:	85 c0                	test   %eax,%eax
 805a2a7:	0f 84 cc 01 00 00    	je     805a479 <net_route_add+0x1f9>
	k_mutex_lock(&lock, K_FOREVER);
 805a2ad:	83 c8 ff             	or     $0xffffffff,%eax
 805a2b0:	89 c2                	mov    %eax,%edx
 805a2b2:	e8 ff fa ff ff       	call   8059db6 <k_mutex_lock.constprop.0.isra.0>
	nbr_nexthop = net_ipv6_nbr_lookup(iface, nexthop);
 805a2b7:	56                   	push   %esi
 805a2b8:	56                   	push   %esi
 805a2b9:	ff 75 14             	push   0x14(%ebp)
 805a2bc:	ff 75 08             	push   0x8(%ebp)
 805a2bf:	e8 2f de ff ff       	call   80580f3 <net_ipv6_nbr_lookup>
 805a2c4:	83 c4 10             	add    $0x10,%esp
	if (!nbr_nexthop) {
 805a2c7:	85 c0                	test   %eax,%eax
 805a2c9:	75 07                	jne    805a2d2 <net_route_add+0x52>
	struct net_route_entry *route = NULL;
 805a2cb:	31 f6                	xor    %esi,%esi
 805a2cd:	e9 a2 01 00 00       	jmp    805a474 <net_route_add+0x1f4>
	if (nbr_nexthop && nbr_nexthop->idx != NET_NBR_LLADDR_UNKNOWN) {
 805a2d2:	0f b6 40 01          	movzbl 0x1(%eax),%eax
 805a2d6:	3c ff                	cmp    $0xff,%al
 805a2d8:	74 0c                	je     805a2e6 <net_route_add+0x66>
		nexthop_lladdr = net_nbr_get_lladdr(nbr_nexthop->idx);
 805a2da:	83 ec 0c             	sub    $0xc,%esp
 805a2dd:	50                   	push   %eax
 805a2de:	e8 ec cf ff ff       	call   80572cf <net_nbr_get_lladdr>
 805a2e3:	83 c4 10             	add    $0x10,%esp
	route = net_route_lookup(iface, addr);
 805a2e6:	51                   	push   %ecx
 805a2e7:	51                   	push   %ecx
 805a2e8:	ff 75 0c             	push   0xc(%ebp)
 805a2eb:	ff 75 08             	push   0x8(%ebp)
 805a2ee:	e8 79 fb ff ff       	call   8059e6c <net_route_lookup>
 805a2f3:	83 c4 10             	add    $0x10,%esp
 805a2f6:	89 c6                	mov    %eax,%esi
	if (route) {
 805a2f8:	85 c0                	test   %eax,%eax
 805a2fa:	74 76                	je     805a372 <net_route_add+0xf2>
		nexthop_addr = net_route_get_nexthop(route);
 805a2fc:	83 ec 0c             	sub    $0xc,%esp
 805a2ff:	50                   	push   %eax
 805a300:	e8 39 ff ff ff       	call   805a23e <net_route_get_nexthop>
 805a305:	83 c4 10             	add    $0x10,%esp
		if (nexthop_addr && net_ipv6_addr_cmp(nexthop, nexthop_addr)) {
 805a308:	85 c0                	test   %eax,%eax
 805a30a:	74 34                	je     805a340 <net_route_add+0xc0>
 805a30c:	52                   	push   %edx
 805a30d:	6a 10                	push   $0x10
 805a30f:	50                   	push   %eax
 805a310:	ff 75 14             	push   0x14(%ebp)
 805a313:	e8 58 ed fe ff       	call   8049070 <memcmp@plt>
 805a318:	83 c4 10             	add    $0x10,%esp
 805a31b:	85 c0                	test   %eax,%eax
 805a31d:	75 21                	jne    805a340 <net_route_add+0xc0>
			net_route_update_lifetime(route, lifetime);
 805a31f:	51                   	push   %ecx
			route->preference = preference;
 805a320:	83 e3 03             	and    $0x3,%ebx
			net_route_update_lifetime(route, lifetime);
 805a323:	51                   	push   %ecx
 805a324:	ff 75 18             	push   0x18(%ebp)
 805a327:	56                   	push   %esi
 805a328:	e8 57 fc ff ff       	call   8059f84 <net_route_update_lifetime>
			route->preference = preference;
 805a32d:	8a 46 31             	mov    0x31(%esi),%al
			net_route_update_lifetime(route, lifetime);
 805a330:	83 c4 10             	add    $0x10,%esp
			route->preference = preference;
 805a333:	83 e0 fc             	and    $0xfffffffc,%eax
 805a336:	09 c3                	or     %eax,%ebx
 805a338:	88 5e 31             	mov    %bl,0x31(%esi)
			goto exit;
 805a33b:	e9 34 01 00 00       	jmp    805a474 <net_route_add+0x1f4>
		if (route_preference_is_lower(route->preference, preference)) {
 805a340:	8a 46 31             	mov    0x31(%esi),%al
 805a343:	83 e0 03             	and    $0x3,%eax
	if (new == NET_ROUTE_PREFERENCE_RESERVED || (new & 0xfc) != 0) {
 805a346:	80 fb 02             	cmp    $0x2,%bl
 805a349:	74 80                	je     805a2cb <net_route_add+0x4b>
 805a34b:	f6 c3 fc             	test   $0xfc,%bl
 805a34e:	0f 85 77 ff ff ff    	jne    805a2cb <net_route_add+0x4b>
	old = (old + 1) & 0x3;
 805a354:	40                   	inc    %eax
	new = (new + 1) & 0x3;
 805a355:	8d 4b 01             	lea    0x1(%ebx),%ecx
	old = (old + 1) & 0x3;
 805a358:	83 e0 03             	and    $0x3,%eax
	new = (new + 1) & 0x3;
 805a35b:	83 e1 03             	and    $0x3,%ecx
		if (route_preference_is_lower(route->preference, preference)) {
 805a35e:	38 c8                	cmp    %cl,%al
 805a360:	0f 87 65 ff ff ff    	ja     805a2cb <net_route_add+0x4b>
		net_route_del(route);
 805a366:	83 ec 0c             	sub    $0xc,%esp
 805a369:	56                   	push   %esi
 805a36a:	e8 cb fc ff ff       	call   805a03a <net_route_del>
 805a36f:	83 c4 10             	add    $0x10,%esp
	nbr = nbr_new(iface, addr, prefix_len);
 805a372:	89 f8                	mov    %edi,%eax
 805a374:	8b 55 0c             	mov    0xc(%ebp),%edx
 805a377:	0f b6 f8             	movzbl %al,%edi
 805a37a:	8b 45 08             	mov    0x8(%ebp),%eax
 805a37d:	89 f9                	mov    %edi,%ecx
 805a37f:	e8 cb f9 ff ff       	call   8059d4f <nbr_new>
 805a384:	89 c6                	mov    %eax,%esi
	if (!nbr) {
 805a386:	85 c0                	test   %eax,%eax
 805a388:	75 33                	jne    805a3bd <net_route_add+0x13d>
	return list->tail;
 805a38a:	8b 15 64 8a 06 08    	mov    0x8068a64,%edx
		sys_slist_find_and_remove(&routes, last);
 805a390:	b8 60 8a 06 08       	mov    $0x8068a60,%eax
 805a395:	e8 48 fa ff ff       	call   8059de2 <sys_slist_find_and_remove.isra.0>
		net_route_del(route);
 805a39a:	83 ec 0c             	sub    $0xc,%esp
 805a39d:	52                   	push   %edx
 805a39e:	e8 97 fc ff ff       	call   805a03a <net_route_del>
		nbr = nbr_new(iface, addr, prefix_len);
 805a3a3:	8b 55 0c             	mov    0xc(%ebp),%edx
 805a3a6:	8b 45 08             	mov    0x8(%ebp),%eax
		net_route_del(route);
 805a3a9:	83 c4 10             	add    $0x10,%esp
		nbr = nbr_new(iface, addr, prefix_len);
 805a3ac:	89 f9                	mov    %edi,%ecx
 805a3ae:	e8 9c f9 ff ff       	call   8059d4f <nbr_new>
 805a3b3:	89 c6                	mov    %eax,%esi
		if (!nbr) {
 805a3b5:	85 c0                	test   %eax,%eax
 805a3b7:	0f 84 0e ff ff ff    	je     805a2cb <net_route_add+0x4b>
			((sizeof(struct net_nbr) + start->size) * idx));
 805a3bd:	0f b7 3d 22 66 06 08 	movzwl 0x8066622,%edi
 805a3c4:	b8 20 66 06 08       	mov    $0x8066620,%eax
 805a3c9:	b9 08 00 00 00       	mov    $0x8,%ecx
 805a3ce:	83 c7 14             	add    $0x14,%edi
		if (!nbr->ref) {
 805a3d1:	80 38 00             	cmpb   $0x0,(%eax)
 805a3d4:	75 1f                	jne    805a3f5 <net_route_add+0x175>
			return net_nbr_ref(nbr);
 805a3d6:	83 ec 0c             	sub    $0xc,%esp
			nbr->data = nbr->__nbr;
 805a3d9:	8d 48 14             	lea    0x14(%eax),%ecx
			nbr->idx = NET_NBR_LLADDR_UNKNOWN;
 805a3dc:	c6 40 01 ff          	movb   $0xff,0x1(%eax)
			nbr->data = nbr->__nbr;
 805a3e0:	89 48 0c             	mov    %ecx,0xc(%eax)
			return net_nbr_ref(nbr);
 805a3e3:	50                   	push   %eax
 805a3e4:	e8 67 cd ff ff       	call   8057150 <net_nbr_ref>
 805a3e9:	83 c4 10             	add    $0x10,%esp
	if (!tmp) {
 805a3ec:	85 c0                	test   %eax,%eax
 805a3ee:	75 0f                	jne    805a3ff <net_route_add+0x17f>
 805a3f0:	e9 d6 fe ff ff       	jmp    805a2cb <net_route_add+0x4b>
	for (i = 0; i < CONFIG_NET_MAX_NEXTHOPS; i++) {
 805a3f5:	01 f8                	add    %edi,%eax
 805a3f7:	49                   	dec    %ecx
 805a3f8:	75 d7                	jne    805a3d1 <net_route_add+0x151>
 805a3fa:	e9 cc fe ff ff       	jmp    805a2cb <net_route_add+0x4b>
	return (struct net_route_entry *)nbr->data;
 805a3ff:	8b 76 0c             	mov    0xc(%esi),%esi
	return (struct net_route_nexthop *)nbr->data;
 805a402:	8b 78 0c             	mov    0xc(%eax),%edi
	route->preference = preference;
 805a405:	83 e3 03             	and    $0x3,%ebx
	route->iface = iface;
 805a408:	8b 45 08             	mov    0x8(%ebp),%eax
 805a40b:	89 46 0c             	mov    %eax,0xc(%esi)
	route->preference = preference;
 805a40e:	8a 46 31             	mov    0x31(%esi),%al
 805a411:	83 e0 fc             	and    $0xfffffffc,%eax
 805a414:	09 d8                	or     %ebx,%eax
 805a416:	88 46 31             	mov    %al,0x31(%esi)
	net_route_update_lifetime(route, lifetime);
 805a419:	52                   	push   %edx
 805a41a:	52                   	push   %edx
 805a41b:	ff 75 18             	push   0x18(%ebp)
 805a41e:	56                   	push   %esi
 805a41f:	e8 60 fb ff ff       	call   8059f84 <net_route_update_lifetime>
	return list->head;
 805a424:	a1 60 8a 06 08       	mov    0x8068a60,%eax
 805a429:	83 c4 10             	add    $0x10,%esp
	parent->next = child;
 805a42c:	89 06                	mov    %eax,(%esi)
Z_GENLIST_PREPEND(slist, snode)
 805a42e:	83 3d 64 8a 06 08 00 	cmpl   $0x0,0x8068a64
	list->head = node;
 805a435:	89 35 60 8a 06 08    	mov    %esi,0x8068a60
Z_GENLIST_PREPEND(slist, snode)
 805a43b:	75 06                	jne    805a443 <net_route_add+0x1c3>
	list->tail = node;
 805a43d:	89 35 64 8a 06 08    	mov    %esi,0x8068a64
	nbr = net_ipv6_nbr_lookup(iface, addr);
 805a443:	50                   	push   %eax
 805a444:	50                   	push   %eax
 805a445:	ff 75 14             	push   0x14(%ebp)
 805a448:	ff 75 08             	push   0x8(%ebp)
 805a44b:	e8 a3 dc ff ff       	call   80580f3 <net_ipv6_nbr_lookup>
 805a450:	83 c4 10             	add    $0x10,%esp
 805a453:	89 c3                	mov    %eax,%ebx
	if (nbr == NULL) {
 805a455:	85 c0                	test   %eax,%eax
 805a457:	74 0c                	je     805a465 <net_route_add+0x1e5>
	net_nbr_ref(nbr);
 805a459:	83 ec 0c             	sub    $0xc,%esp
 805a45c:	50                   	push   %eax
 805a45d:	e8 ee cc ff ff       	call   8057150 <net_nbr_ref>
 805a462:	83 c4 10             	add    $0x10,%esp
	nexthop_route->nbr = tmp;
 805a465:	89 5f 04             	mov    %ebx,0x4(%edi)
	parent->next = child;
 805a468:	c7 07 00 00 00 00    	movl   $0x0,(%edi)
	list->head = node;
 805a46e:	89 7e 04             	mov    %edi,0x4(%esi)
	list->tail = node;
 805a471:	89 7e 08             	mov    %edi,0x8(%esi)
	k_mutex_unlock(&lock);
 805a474:	e8 54 f9 ff ff       	call   8059dcd <k_mutex_unlock.constprop.0.isra.0>
}
 805a479:	8d 65 f4             	lea    -0xc(%ebp),%esp
 805a47c:	89 f0                	mov    %esi,%eax
 805a47e:	5b                   	pop    %ebx
 805a47f:	5e                   	pop    %esi
 805a480:	5f                   	pop    %edi
 805a481:	5d                   	pop    %ebp
 805a482:	c3                   	ret    

0805a483 <net_route_get_info>:

bool net_route_get_info(struct net_if *iface,
			struct in6_addr *dst,
			struct net_route_entry **route,
			struct in6_addr **nexthop)
{
 805a483:	55                   	push   %ebp
	struct net_if_router *router;
	bool ret = false;

	k_mutex_lock(&lock, K_FOREVER);
 805a484:	83 c8 ff             	or     $0xffffffff,%eax
 805a487:	89 c2                	mov    %eax,%edx
{
 805a489:	89 e5                	mov    %esp,%ebp
 805a48b:	57                   	push   %edi
 805a48c:	56                   	push   %esi
 805a48d:	53                   	push   %ebx
 805a48e:	83 ec 0c             	sub    $0xc,%esp
 805a491:	8b 7d 08             	mov    0x8(%ebp),%edi
 805a494:	8b 5d 0c             	mov    0xc(%ebp),%ebx
 805a497:	8b 75 14             	mov    0x14(%ebp),%esi
	k_mutex_lock(&lock, K_FOREVER);
 805a49a:	e8 17 f9 ff ff       	call   8059db6 <k_mutex_lock.constprop.0.isra.0>

	/* Search in neighbor table first, if not search in routing table. */
	if (net_ipv6_nbr_lookup(iface, dst)) {
 805a49f:	51                   	push   %ecx
 805a4a0:	51                   	push   %ecx
 805a4a1:	53                   	push   %ebx
 805a4a2:	57                   	push   %edi
 805a4a3:	e8 4b dc ff ff       	call   80580f3 <net_ipv6_nbr_lookup>
 805a4a8:	83 c4 10             	add    $0x10,%esp
 805a4ab:	85 c0                	test   %eax,%eax
 805a4ad:	74 0d                	je     805a4bc <net_route_get_info+0x39>
		/* Found nexthop, no need to look into routing table. */
		*route = NULL;
 805a4af:	8b 45 10             	mov    0x10(%ebp),%eax
 805a4b2:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		*nexthop = dst;
 805a4b8:	89 1e                	mov    %ebx,(%esi)

		ret = true;
		goto exit;
 805a4ba:	eb 42                	jmp    805a4fe <net_route_get_info+0x7b>
	}

	*route = net_route_lookup(iface, dst);
 805a4bc:	52                   	push   %edx
 805a4bd:	52                   	push   %edx
 805a4be:	53                   	push   %ebx
 805a4bf:	57                   	push   %edi
 805a4c0:	e8 a7 f9 ff ff       	call   8059e6c <net_route_lookup>
 805a4c5:	8b 55 10             	mov    0x10(%ebp),%edx
 805a4c8:	83 c4 10             	add    $0x10,%esp
 805a4cb:	89 02                	mov    %eax,(%edx)
	if (*route) {
 805a4cd:	85 c0                	test   %eax,%eax
 805a4cf:	74 15                	je     805a4e6 <net_route_get_info+0x63>
		*nexthop = net_route_get_nexthop(*route);
 805a4d1:	83 ec 0c             	sub    $0xc,%esp
 805a4d4:	50                   	push   %eax
 805a4d5:	e8 64 fd ff ff       	call   805a23e <net_route_get_nexthop>
 805a4da:	83 c4 10             	add    $0x10,%esp
		if (!*nexthop) {
 805a4dd:	85 c0                	test   %eax,%eax
		*nexthop = net_route_get_nexthop(*route);
 805a4df:	89 06                	mov    %eax,(%esi)
		if (!*nexthop) {
 805a4e1:	0f 95 c3             	setne  %bl
 805a4e4:	eb 1a                	jmp    805a500 <net_route_get_info+0x7d>
		goto exit;
	} else {
		/* No specific route to this host, use the default
		 * route instead.
		 */
		router = net_if_ipv6_router_find_default(NULL, dst);
 805a4e6:	50                   	push   %eax
 805a4e7:	50                   	push   %eax
 805a4e8:	53                   	push   %ebx
	bool ret = false;
 805a4e9:	31 db                	xor    %ebx,%ebx
		router = net_if_ipv6_router_find_default(NULL, dst);
 805a4eb:	6a 00                	push   $0x0
 805a4ed:	e8 41 7d ff ff       	call   8052233 <net_if_ipv6_router_find_default>
 805a4f2:	83 c4 10             	add    $0x10,%esp
		if (!router) {
 805a4f5:	85 c0                	test   %eax,%eax
 805a4f7:	74 07                	je     805a500 <net_route_get_info+0x7d>
			goto exit;
		}

		*nexthop = &router->address.in6_addr;
 805a4f9:	83 c0 08             	add    $0x8,%eax
 805a4fc:	89 06                	mov    %eax,(%esi)

		ret = true;
 805a4fe:	b3 01                	mov    $0x1,%bl
		goto exit;
	}

exit:
	k_mutex_unlock(&lock);
 805a500:	e8 c8 f8 ff ff       	call   8059dcd <k_mutex_unlock.constprop.0.isra.0>
	return ret;
}
 805a505:	8d 65 f4             	lea    -0xc(%ebp),%esp
 805a508:	89 d8                	mov    %ebx,%eax
 805a50a:	5b                   	pop    %ebx
 805a50b:	5e                   	pop    %esi
 805a50c:	5f                   	pop    %edi
 805a50d:	5d                   	pop    %ebp
 805a50e:	c3                   	ret    

0805a50f <net_route_packet>:

int net_route_packet(struct net_pkt *pkt, struct in6_addr *nexthop)
{
 805a50f:	55                   	push   %ebp
	struct net_linkaddr_storage *lladdr;
	struct net_nbr *nbr;
	int err;

	k_mutex_lock(&lock, K_FOREVER);
 805a510:	83 c8 ff             	or     $0xffffffff,%eax
 805a513:	89 c2                	mov    %eax,%edx
{
 805a515:	89 e5                	mov    %esp,%ebp
 805a517:	57                   	push   %edi
 805a518:	56                   	push   %esi
 805a519:	53                   	push   %ebx
 805a51a:	83 ec 1c             	sub    $0x1c,%esp
 805a51d:	8b 75 0c             	mov    0xc(%ebp),%esi
 805a520:	8b 5d 08             	mov    0x8(%ebp),%ebx
	k_mutex_lock(&lock, K_FOREVER);
 805a523:	e8 8e f8 ff ff       	call   8059db6 <k_mutex_lock.constprop.0.isra.0>

	nbr = net_ipv6_nbr_lookup(NULL, nexthop);
 805a528:	57                   	push   %edi
 805a529:	57                   	push   %edi
 805a52a:	56                   	push   %esi
 805a52b:	6a 00                	push   $0x0
 805a52d:	e8 c1 db ff ff       	call   80580f3 <net_ipv6_nbr_lookup>
 805a532:	83 c4 10             	add    $0x10,%esp
	if (!nbr) {
 805a535:	85 c0                	test   %eax,%eax
 805a537:	0f 84 a6 00 00 00    	je     805a5e3 <net_route_packet+0xd4>
 805a53d:	89 c7                	mov    %eax,%edi
			net_sprint_ipv6_addr(nexthop));
		err = -ENOENT;
		goto error;
	}

	lladdr = net_nbr_get_lladdr(nbr->idx);
 805a53f:	0f b6 40 01          	movzbl 0x1(%eax),%eax
 805a543:	83 ec 0c             	sub    $0xc,%esp
 805a546:	50                   	push   %eax
 805a547:	e8 83 cd ff ff       	call   80572cf <net_nbr_get_lladdr>
 805a54c:	83 c4 10             	add    $0x10,%esp
 805a54f:	89 c6                	mov    %eax,%esi
	if (!lladdr) {
 805a551:	85 c0                	test   %eax,%eax
 805a553:	0f 84 91 00 00 00    	je     805a5ea <net_route_packet+0xdb>
#endif
#if defined(CONFIG_NET_L2_PPP)
		/* PPP does not populate the lladdr fields */
		if (net_if_l2(net_pkt_iface(pkt)) != &NET_L2_GET_NAME(PPP)) {
#endif
			if (!net_pkt_lladdr_src(pkt)->addr) {
 805a559:	8b 43 20             	mov    0x20(%ebx),%eax
 805a55c:	85 c0                	test   %eax,%eax
 805a55e:	0f 84 8d 00 00 00    	je     805a5f1 <net_route_packet+0xe2>

			/* Sanitycheck: If src and dst ll addresses are going
			 * to be same, then something went wrong in route
			 * lookup.
			 */
			if (!memcmp(net_pkt_lladdr_src(pkt)->addr, lladdr->addr,
 805a564:	51                   	push   %ecx
 805a565:	0f b6 4e 01          	movzbl 0x1(%esi),%ecx
 805a569:	8d 56 02             	lea    0x2(%esi),%edx
 805a56c:	89 55 e4             	mov    %edx,-0x1c(%ebp)
 805a56f:	51                   	push   %ecx
 805a570:	52                   	push   %edx
 805a571:	50                   	push   %eax
 805a572:	e8 f9 ea fe ff       	call   8049070 <memcmp@plt>
 805a577:	83 c4 10             	add    $0x10,%esp
 805a57a:	89 c1                	mov    %eax,%ecx
				err = -EINVAL;
 805a57c:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
			if (!memcmp(net_pkt_lladdr_src(pkt)->addr, lladdr->addr,
 805a581:	85 c9                	test   %ecx,%ecx
 805a583:	74 71                	je     805a5f6 <net_route_packet+0xe7>
	return net_if_get_link_addr(pkt->iface);
 805a585:	8b 4b 18             	mov    0x18(%ebx),%ecx
	pkt->forwarding = forward;
 805a588:	80 4b 33 10          	orb    $0x10,0x33(%ebx)
	 */
	net_pkt_lladdr_src(pkt)->addr = net_pkt_lladdr_if(pkt)->addr;
	net_pkt_lladdr_src(pkt)->type = net_pkt_lladdr_if(pkt)->type;
	net_pkt_lladdr_src(pkt)->len = net_pkt_lladdr_if(pkt)->len;

	net_pkt_lladdr_dst(pkt)->addr = lladdr->addr;
 805a58c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
	net_pkt_lladdr_src(pkt)->addr = net_pkt_lladdr_if(pkt)->addr;
 805a58f:	8b 01                	mov    (%ecx),%eax
 805a591:	8b 40 10             	mov    0x10(%eax),%eax
 805a594:	89 43 20             	mov    %eax,0x20(%ebx)
	net_pkt_lladdr_src(pkt)->type = net_pkt_lladdr_if(pkt)->type;
 805a597:	8b 01                	mov    (%ecx),%eax
 805a599:	8a 40 15             	mov    0x15(%eax),%al
 805a59c:	88 43 25             	mov    %al,0x25(%ebx)
	net_pkt_lladdr_src(pkt)->len = net_pkt_lladdr_if(pkt)->len;
 805a59f:	8b 01                	mov    (%ecx),%eax
 805a5a1:	8a 40 14             	mov    0x14(%eax),%al
	net_pkt_lladdr_dst(pkt)->addr = lladdr->addr;
 805a5a4:	89 53 28             	mov    %edx,0x28(%ebx)
	net_pkt_lladdr_src(pkt)->len = net_pkt_lladdr_if(pkt)->len;
 805a5a7:	88 43 24             	mov    %al,0x24(%ebx)
	net_pkt_lladdr_dst(pkt)->type = lladdr->type;
 805a5aa:	8a 06                	mov    (%esi),%al
 805a5ac:	88 43 2d             	mov    %al,0x2d(%ebx)
	net_pkt_lladdr_dst(pkt)->len = lladdr->len;
 805a5af:	8a 46 01             	mov    0x1(%esi),%al
 805a5b2:	88 43 2c             	mov    %al,0x2c(%ebx)

	net_pkt_set_iface(pkt, nbr->iface);
 805a5b5:	8b 47 08             	mov    0x8(%edi),%eax
	pkt->iface = iface;
 805a5b8:	89 43 18             	mov    %eax,0x18(%ebx)
	if (iface) {
 805a5bb:	85 c0                	test   %eax,%eax
 805a5bd:	74 10                	je     805a5cf <net_route_packet+0xc0>
		pkt->lladdr_src.type = net_if_get_link_addr(iface)->type;
 805a5bf:	8b 10                	mov    (%eax),%edx
 805a5c1:	8a 52 15             	mov    0x15(%edx),%dl
 805a5c4:	88 53 25             	mov    %dl,0x25(%ebx)
		pkt->lladdr_dst.type = net_if_get_link_addr(iface)->type;
 805a5c7:	8b 00                	mov    (%eax),%eax
 805a5c9:	8a 40 15             	mov    0x15(%eax),%al
 805a5cc:	88 43 2d             	mov    %al,0x2d(%ebx)

	k_mutex_unlock(&lock);
 805a5cf:	e8 f9 f7 ff ff       	call   8059dcd <k_mutex_unlock.constprop.0.isra.0>
	return net_send_data(pkt);
 805a5d4:	89 5d 08             	mov    %ebx,0x8(%ebp)

error:
	k_mutex_unlock(&lock);
	return err;
}
 805a5d7:	8d 65 f4             	lea    -0xc(%ebp),%esp
 805a5da:	5b                   	pop    %ebx
 805a5db:	5e                   	pop    %esi
 805a5dc:	5f                   	pop    %edi
 805a5dd:	5d                   	pop    %ebp
	return net_send_data(pkt);
 805a5de:	e9 4d 5e ff ff       	jmp    8050430 <net_send_data>
		err = -ENOENT;
 805a5e3:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
 805a5e8:	eb 0c                	jmp    805a5f6 <net_route_packet+0xe7>
		err = -ESRCH;
 805a5ea:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
 805a5ef:	eb 05                	jmp    805a5f6 <net_route_packet+0xe7>
				err = -EINVAL;
 805a5f1:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
 805a5f6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	k_mutex_unlock(&lock);
 805a5f9:	e8 cf f7 ff ff       	call   8059dcd <k_mutex_unlock.constprop.0.isra.0>
}
 805a5fe:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 805a601:	8d 65 f4             	lea    -0xc(%ebp),%esp
 805a604:	5b                   	pop    %ebx
 805a605:	5e                   	pop    %esi
 805a606:	5f                   	pop    %edi
 805a607:	5d                   	pop    %ebp
 805a608:	c3                   	ret    

0805a609 <net_route_packet_if>:

int net_route_packet_if(struct net_pkt *pkt, struct net_if *iface)
{
 805a609:	55                   	push   %ebp
 805a60a:	89 e5                	mov    %esp,%ebp
 805a60c:	8b 45 08             	mov    0x8(%ebp),%eax
 805a60f:	8b 55 0c             	mov    0xc(%ebp),%edx
	pkt->iface = iface;
 805a612:	89 50 18             	mov    %edx,0x18(%eax)
	if (iface) {
 805a615:	85 d2                	test   %edx,%edx
 805a617:	74 10                	je     805a629 <net_route_packet_if+0x20>
		pkt->lladdr_src.type = net_if_get_link_addr(iface)->type;
 805a619:	8b 0a                	mov    (%edx),%ecx
 805a61b:	8a 49 15             	mov    0x15(%ecx),%cl
 805a61e:	88 48 25             	mov    %cl,0x25(%eax)
		pkt->lladdr_dst.type = net_if_get_link_addr(iface)->type;
 805a621:	8b 0a                	mov    (%edx),%ecx
 805a623:	8a 49 15             	mov    0x15(%ecx),%cl
 805a626:	88 48 2d             	mov    %cl,0x2d(%eax)
	pkt->forwarding = forward;
 805a629:	80 48 33 10          	orb    $0x10,0x33(%eax)
	net_pkt_set_orig_iface(pkt, net_pkt_iface(pkt));
	net_pkt_set_iface(pkt, iface);

	net_pkt_set_forwarding(pkt, true);

	net_pkt_lladdr_src(pkt)->addr = net_pkt_lladdr_if(pkt)->addr;
 805a62d:	8b 0a                	mov    (%edx),%ecx
 805a62f:	8b 49 10             	mov    0x10(%ecx),%ecx
 805a632:	89 48 20             	mov    %ecx,0x20(%eax)
	net_pkt_lladdr_src(pkt)->type = net_pkt_lladdr_if(pkt)->type;
 805a635:	8b 0a                	mov    (%edx),%ecx
 805a637:	8a 49 15             	mov    0x15(%ecx),%cl
 805a63a:	88 48 25             	mov    %cl,0x25(%eax)
	net_pkt_lladdr_src(pkt)->len = net_pkt_lladdr_if(pkt)->len;
 805a63d:	8b 12                	mov    (%edx),%edx
 805a63f:	8a 52 14             	mov    0x14(%edx),%dl
 805a642:	88 50 24             	mov    %dl,0x24(%eax)

	return net_send_data(pkt);
 805a645:	89 45 08             	mov    %eax,0x8(%ebp)
}
 805a648:	5d                   	pop    %ebp
	return net_send_data(pkt);
 805a649:	e9 e2 5d ff ff       	jmp    8050430 <net_send_data>

0805a64e <net_route_init>:

void net_route_init(void)
{
 805a64e:	55                   	push   %ebp
 805a64f:	89 e5                	mov    %esp,%ebp
 805a651:	83 ec 10             	sub    $0x10,%esp
		CONFIG_NET_MAX_ROUTES, sizeof(net_route_entries_pool));

	NET_DBG("Allocated %d nexthop entries (%zu bytes)",
		CONFIG_NET_MAX_NEXTHOPS, sizeof(net_route_nexthop_pool));

	k_work_init_delayable(&route_lifetime_timer, route_lifetime_timeout);
 805a654:	68 f4 a0 05 08       	push   $0x805a0f4
 805a659:	68 e0 85 06 08       	push   $0x80685e0
 805a65e:	e8 e2 55 00 00       	call   805fc45 <k_work_init_delayable>
 805a663:	83 c4 10             	add    $0x10,%esp
}
 805a666:	c9                   	leave  
 805a667:	c3                   	ret    

0805a668 <net_udp_create>:
#include "net_stats.h"

#define PKT_WAIT_TIME K_SECONDS(1)

int net_udp_create(struct net_pkt *pkt, uint16_t src_port, uint16_t dst_port)
{
 805a668:	55                   	push   %ebp
 805a669:	89 e5                	mov    %esp,%ebp
 805a66b:	57                   	push   %edi
 805a66c:	56                   	push   %esi
	NET_PKT_DATA_ACCESS_DEFINE(udp_access, struct net_udp_hdr);
	struct net_udp_hdr *udp_hdr;

	udp_hdr = (struct net_udp_hdr *)net_pkt_get_data(pkt, &udp_access);
 805a66d:	8d 75 d4             	lea    -0x2c(%ebp),%esi
{
 805a670:	53                   	push   %ebx
 805a671:	83 ec 44             	sub    $0x44,%esp
 805a674:	8b 55 0c             	mov    0xc(%ebp),%edx
 805a677:	8b 5d 08             	mov    0x8(%ebp),%ebx
 805a67a:	8b 7d 10             	mov    0x10(%ebp),%edi
 805a67d:	89 55 c4             	mov    %edx,-0x3c(%ebp)
 805a680:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 805a686:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 805a689:	31 c0                	xor    %eax,%eax
	udp_hdr = (struct net_udp_hdr *)net_pkt_get_data(pkt, &udp_access);
 805a68b:	56                   	push   %esi
	NET_PKT_DATA_ACCESS_DEFINE(udp_access, struct net_udp_hdr);
 805a68c:	8d 45 dc             	lea    -0x24(%ebp),%eax
	udp_hdr = (struct net_udp_hdr *)net_pkt_get_data(pkt, &udp_access);
 805a68f:	53                   	push   %ebx
	NET_PKT_DATA_ACCESS_DEFINE(udp_access, struct net_udp_hdr);
 805a690:	89 45 d4             	mov    %eax,-0x2c(%ebp)
 805a693:	c7 45 d8 08 00 00 00 	movl   $0x8,-0x28(%ebp)
	udp_hdr = (struct net_udp_hdr *)net_pkt_get_data(pkt, &udp_access);
 805a69a:	e8 33 b2 ff ff       	call   80558d2 <net_pkt_get_data>
 805a69f:	83 c4 10             	add    $0x10,%esp
	if (!udp_hdr) {
 805a6a2:	b9 97 ff ff ff       	mov    $0xffffff97,%ecx
 805a6a7:	85 c0                	test   %eax,%eax
 805a6a9:	74 1f                	je     805a6ca <net_udp_create+0x62>
		return -ENOBUFS;
	}

	udp_hdr->src_port = src_port;
 805a6ab:	8b 55 c4             	mov    -0x3c(%ebp),%edx
	udp_hdr->dst_port = dst_port;
 805a6ae:	66 89 78 02          	mov    %di,0x2(%eax)
	udp_hdr->len      = 0U;
 805a6b2:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	udp_hdr->src_port = src_port;
 805a6b9:	66 89 10             	mov    %dx,(%eax)
	udp_hdr->chksum   = 0U;

	return net_pkt_set_data(pkt, &udp_access);
 805a6bc:	50                   	push   %eax
 805a6bd:	50                   	push   %eax
 805a6be:	56                   	push   %esi
 805a6bf:	53                   	push   %ebx
 805a6c0:	e8 71 b2 ff ff       	call   8055936 <net_pkt_set_data>
 805a6c5:	83 c4 10             	add    $0x10,%esp
 805a6c8:	89 c1                	mov    %eax,%ecx
}
 805a6ca:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 805a6cd:	65 2b 05 14 00 00 00 	sub    %gs:0x14,%eax
 805a6d4:	74 05                	je     805a6db <net_udp_create+0x73>
 805a6d6:	e8 25 ec fe ff       	call   8049300 <__stack_chk_fail@plt>
 805a6db:	8d 65 f4             	lea    -0xc(%ebp),%esp
 805a6de:	89 c8                	mov    %ecx,%eax
 805a6e0:	5b                   	pop    %ebx
 805a6e1:	5e                   	pop    %esi
 805a6e2:	5f                   	pop    %edi
 805a6e3:	5d                   	pop    %ebp
 805a6e4:	c3                   	ret    

0805a6e5 <net_udp_finalize>:

int net_udp_finalize(struct net_pkt *pkt)
{
 805a6e5:	55                   	push   %ebp
 805a6e6:	89 e5                	mov    %esp,%ebp
 805a6e8:	57                   	push   %edi
 805a6e9:	56                   	push   %esi
	NET_PKT_DATA_ACCESS_DEFINE(udp_access, struct net_udp_hdr);
	struct net_udp_hdr *udp_hdr;
	uint16_t length = 0;

	udp_hdr = (struct net_udp_hdr *)net_pkt_get_data(pkt, &udp_access);
 805a6ea:	8d 75 d4             	lea    -0x2c(%ebp),%esi
{
 805a6ed:	53                   	push   %ebx
 805a6ee:	83 ec 34             	sub    $0x34,%esp
 805a6f1:	8b 5d 08             	mov    0x8(%ebp),%ebx
 805a6f4:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 805a6fa:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 805a6fd:	31 c0                	xor    %eax,%eax
	udp_hdr = (struct net_udp_hdr *)net_pkt_get_data(pkt, &udp_access);
 805a6ff:	56                   	push   %esi
	NET_PKT_DATA_ACCESS_DEFINE(udp_access, struct net_udp_hdr);
 805a700:	8d 45 dc             	lea    -0x24(%ebp),%eax
	udp_hdr = (struct net_udp_hdr *)net_pkt_get_data(pkt, &udp_access);
 805a703:	53                   	push   %ebx
	NET_PKT_DATA_ACCESS_DEFINE(udp_access, struct net_udp_hdr);
 805a704:	89 45 d4             	mov    %eax,-0x2c(%ebp)
 805a707:	c7 45 d8 08 00 00 00 	movl   $0x8,-0x28(%ebp)
	udp_hdr = (struct net_udp_hdr *)net_pkt_get_data(pkt, &udp_access);
 805a70e:	e8 bf b1 ff ff       	call   80558d2 <net_pkt_get_data>
 805a713:	83 c4 10             	add    $0x10,%esp
 805a716:	89 c7                	mov    %eax,%edi
	if (!udp_hdr) {
 805a718:	b8 97 ff ff ff       	mov    $0xffffff97,%eax
 805a71d:	85 ff                	test   %edi,%edi
 805a71f:	74 5b                	je     805a77c <net_udp_finalize+0x97>
		return -ENOBUFS;
	}

	length = net_pkt_get_len(pkt) - net_pkt_ip_hdr_len(pkt) -
 805a721:	8b 53 08             	mov    0x8(%ebx),%edx
	size_t bytes = 0;
 805a724:	31 c0                	xor    %eax,%eax
	while (buf) {
 805a726:	85 d2                	test   %edx,%edx
 805a728:	74 0b                	je     805a735 <net_udp_finalize+0x50>
		bytes += buf->len;
 805a72a:	0f b7 4a 10          	movzwl 0x10(%edx),%ecx
		buf = buf->frags;
 805a72e:	8b 52 04             	mov    0x4(%edx),%edx
		bytes += buf->len;
 805a731:	01 c8                	add    %ecx,%eax
		buf = buf->frags;
 805a733:	eb f1                	jmp    805a726 <net_udp_finalize+0x41>
 805a735:	0f b6 53 32          	movzbl 0x32(%ebx),%edx
 805a739:	66 03 53 36          	add    0x36(%ebx),%dx
		 net_pkt_ip_opts_len(pkt);

	udp_hdr->len = htons(length);

	if (net_if_need_calc_tx_checksum(net_pkt_iface(pkt))) {
 805a73d:	83 ec 0c             	sub    $0xc,%esp
	length = net_pkt_get_len(pkt) - net_pkt_ip_hdr_len(pkt) -
 805a740:	29 d0                	sub    %edx,%eax
	udp_hdr->len = htons(length);
 805a742:	86 e0                	xchg   %ah,%al
 805a744:	66 89 47 04          	mov    %ax,0x4(%edi)
	if (net_if_need_calc_tx_checksum(net_pkt_iface(pkt))) {
 805a748:	ff 73 18             	push   0x18(%ebx)
 805a74b:	e8 10 83 ff ff       	call   8052a60 <net_if_need_calc_tx_checksum>
 805a750:	83 c4 10             	add    $0x10,%esp
 805a753:	84 c0                	test   %al,%al
 805a755:	74 19                	je     805a770 <net_udp_finalize+0x8b>
	uint16_t chksum = net_calc_chksum(pkt, IPPROTO_UDP);
 805a757:	52                   	push   %edx
 805a758:	52                   	push   %edx
 805a759:	6a 11                	push   $0x11
 805a75b:	53                   	push   %ebx
 805a75c:	e8 b2 8d ff ff       	call   8053513 <net_calc_chksum>
 805a761:	83 c4 10             	add    $0x10,%esp
	return chksum == 0U ? 0xffff : chksum;
 805a764:	66 85 c0             	test   %ax,%ax
 805a767:	75 03                	jne    805a76c <net_udp_finalize+0x87>
 805a769:	83 c8 ff             	or     $0xffffffff,%eax
		udp_hdr->chksum = net_calc_chksum_udp(pkt);
 805a76c:	66 89 47 06          	mov    %ax,0x6(%edi)
	}

	return net_pkt_set_data(pkt, &udp_access);
 805a770:	50                   	push   %eax
 805a771:	50                   	push   %eax
 805a772:	56                   	push   %esi
 805a773:	53                   	push   %ebx
 805a774:	e8 bd b1 ff ff       	call   8055936 <net_pkt_set_data>
 805a779:	83 c4 10             	add    $0x10,%esp
}
 805a77c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 805a77f:	65 2b 15 14 00 00 00 	sub    %gs:0x14,%edx
 805a786:	74 05                	je     805a78d <net_udp_finalize+0xa8>
 805a788:	e8 73 eb fe ff       	call   8049300 <__stack_chk_fail@plt>
 805a78d:	8d 65 f4             	lea    -0xc(%ebp),%esp
 805a790:	5b                   	pop    %ebx
 805a791:	5e                   	pop    %esi
 805a792:	5f                   	pop    %edi
 805a793:	5d                   	pop    %ebp
 805a794:	c3                   	ret    

0805a795 <net_udp_input>:
	return net_conn_unregister(handle);
}

struct net_udp_hdr *net_udp_input(struct net_pkt *pkt,
				  struct net_pkt_data_access *udp_access)
{
 805a795:	55                   	push   %ebp
 805a796:	89 e5                	mov    %esp,%ebp
 805a798:	57                   	push   %edi
 805a799:	56                   	push   %esi
 805a79a:	53                   	push   %ebx
 805a79b:	83 ec 14             	sub    $0x14,%esp
 805a79e:	8b 75 08             	mov    0x8(%ebp),%esi
 805a7a1:	8b 7d 0c             	mov    0xc(%ebp),%edi
	struct net_udp_hdr *udp_hdr;

	udp_hdr = (struct net_udp_hdr *)net_pkt_get_data(pkt, udp_access);
 805a7a4:	57                   	push   %edi
 805a7a5:	56                   	push   %esi
 805a7a6:	e8 27 b1 ff ff       	call   80558d2 <net_pkt_get_data>
 805a7ab:	83 c4 10             	add    $0x10,%esp
	if (!udp_hdr || net_pkt_set_data(pkt, udp_access)) {
 805a7ae:	85 c0                	test   %eax,%eax
 805a7b0:	75 04                	jne    805a7b6 <net_udp_input+0x21>
	}
out:
	return udp_hdr;
drop:
	net_stats_update_udp_chkerr(net_pkt_iface(pkt));
	return NULL;
 805a7b2:	31 db                	xor    %ebx,%ebx
 805a7b4:	eb 68                	jmp    805a81e <net_udp_input+0x89>
	if (!udp_hdr || net_pkt_set_data(pkt, udp_access)) {
 805a7b6:	52                   	push   %edx
 805a7b7:	89 c3                	mov    %eax,%ebx
 805a7b9:	52                   	push   %edx
 805a7ba:	57                   	push   %edi
 805a7bb:	56                   	push   %esi
 805a7bc:	e8 75 b1 ff ff       	call   8055936 <net_pkt_set_data>
 805a7c1:	83 c4 10             	add    $0x10,%esp
 805a7c4:	85 c0                	test   %eax,%eax
 805a7c6:	75 ea                	jne    805a7b2 <net_udp_input+0x1d>
	if (ntohs(udp_hdr->len) != (net_pkt_get_len(pkt) -
 805a7c8:	66 8b 53 04          	mov    0x4(%ebx),%dx
 805a7cc:	8b 4e 08             	mov    0x8(%esi),%ecx
 805a7cf:	86 f2                	xchg   %dh,%dl
 805a7d1:	0f b7 d2             	movzwl %dx,%edx
	while (buf) {
 805a7d4:	85 c9                	test   %ecx,%ecx
 805a7d6:	74 0b                	je     805a7e3 <net_udp_input+0x4e>
		bytes += buf->len;
 805a7d8:	0f b7 79 10          	movzwl 0x10(%ecx),%edi
		buf = buf->frags;
 805a7dc:	8b 49 04             	mov    0x4(%ecx),%ecx
		bytes += buf->len;
 805a7df:	01 f8                	add    %edi,%eax
		buf = buf->frags;
 805a7e1:	eb f1                	jmp    805a7d4 <net_udp_input+0x3f>
				    net_pkt_ip_hdr_len(pkt) -
 805a7e3:	0f b6 4e 32          	movzbl 0x32(%esi),%ecx
				    net_pkt_ip_opts_len(pkt))) {
 805a7e7:	0f b7 7e 36          	movzwl 0x36(%esi),%edi
				    net_pkt_ip_hdr_len(pkt) -
 805a7eb:	01 f9                	add    %edi,%ecx
 805a7ed:	29 c8                	sub    %ecx,%eax
	if (ntohs(udp_hdr->len) != (net_pkt_get_len(pkt) -
 805a7ef:	39 c2                	cmp    %eax,%edx
 805a7f1:	75 bf                	jne    805a7b2 <net_udp_input+0x1d>
	    net_if_need_calc_rx_checksum(net_pkt_iface(pkt))) {
 805a7f3:	83 ec 0c             	sub    $0xc,%esp
 805a7f6:	ff 76 18             	push   0x18(%esi)
 805a7f9:	e8 73 82 ff ff       	call   8052a71 <net_if_need_calc_rx_checksum>
 805a7fe:	83 c4 10             	add    $0x10,%esp
	if (IS_ENABLED(CONFIG_NET_UDP_CHECKSUM) &&
 805a801:	84 c0                	test   %al,%al
 805a803:	74 19                	je     805a81e <net_udp_input+0x89>
		if (!udp_hdr->chksum) {
 805a805:	66 83 7b 06 00       	cmpw   $0x0,0x6(%ebx)
 805a80a:	74 a6                	je     805a7b2 <net_udp_input+0x1d>
	return net_calc_chksum(pkt, IPPROTO_UDP);
 805a80c:	50                   	push   %eax
 805a80d:	50                   	push   %eax
 805a80e:	6a 11                	push   $0x11
 805a810:	56                   	push   %esi
 805a811:	e8 fd 8c ff ff       	call   8053513 <net_calc_chksum>
 805a816:	83 c4 10             	add    $0x10,%esp
		if (net_calc_verify_chksum_udp(pkt) != 0U) {
 805a819:	66 85 c0             	test   %ax,%ax
 805a81c:	75 94                	jne    805a7b2 <net_udp_input+0x1d>
}
 805a81e:	8d 65 f4             	lea    -0xc(%ebp),%esp
 805a821:	89 d8                	mov    %ebx,%eax
 805a823:	5b                   	pop    %ebx
 805a824:	5e                   	pop    %esi
 805a825:	5f                   	pop    %edi
 805a826:	5d                   	pop    %ebp
 805a827:	c3                   	ret    

0805a828 <dns_msg_pack_qname>:
	return (uint16_t)strlen(str);
}

int dns_msg_pack_qname(uint16_t *len, uint8_t *buf, uint16_t size,
		       const char *domain_name)
{
 805a828:	55                   	push   %ebp
 805a829:	89 e5                	mov    %esp,%ebp
 805a82b:	57                   	push   %edi
 805a82c:	56                   	push   %esi
 805a82d:	53                   	push   %ebx
 805a82e:	83 ec 1c             	sub    $0x1c,%esp
 805a831:	8b 45 10             	mov    0x10(%ebp),%eax
	if (str == NULL) {
 805a834:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
{
 805a838:	8b 75 0c             	mov    0xc(%ebp),%esi
 805a83b:	66 89 45 e2          	mov    %ax,-0x1e(%ebp)
	lb_index = 1U;
	lb_size = 0U;

	dn_size = dns_strlen(domain_name);
	if (dn_size == 0U) {
		return -EINVAL;
 805a83f:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
	if (str == NULL) {
 805a844:	74 79                	je     805a8bf <dns_msg_pack_qname+0x97>
	return (uint16_t)strlen(str);
 805a846:	83 ec 0c             	sub    $0xc,%esp
 805a849:	ff 75 14             	push   0x14(%ebp)
 805a84c:	e8 ef e9 fe ff       	call   8049240 <strlen@plt>
 805a851:	83 c4 10             	add    $0x10,%esp
 805a854:	89 c2                	mov    %eax,%edx
 805a856:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
		return -EINVAL;
 805a85a:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
	if (dn_size == 0U) {
 805a85f:	66 85 d2             	test   %dx,%dx
 805a862:	74 5b                	je     805a8bf <dns_msg_pack_qname+0x97>
 805a864:	31 c0                	xor    %eax,%eax
	lb_size = 0U;
 805a866:	31 c9                	xor    %ecx,%ecx
	lb_start = 0U;
 805a868:	31 d2                	xor    %edx,%edx
 805a86a:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
 805a86e:	8d 78 01             	lea    0x1(%eax),%edi
	}

	/* traverse the domain name str, including the null-terminator :) */
	for (i = 0U; i < dn_size + 1; i++) {
		if (lb_index >= size) {
 805a871:	66 3b 7d e2          	cmp    -0x1e(%ebp),%di
 805a875:	73 43                	jae    805a8ba <dns_msg_pack_qname+0x92>
			return -ENOMEM;
		}

		switch (domain_name[i]) {
 805a877:	8b 5d 14             	mov    0x14(%ebp),%ebx
 805a87a:	8a 1c 03             	mov    (%ebx,%eax,1),%bl
 805a87d:	84 db                	test   %bl,%bl
 805a87f:	74 16                	je     805a897 <dns_msg_pack_qname+0x6f>
 805a881:	80 fb 2e             	cmp    $0x2e,%bl
 805a884:	74 07                	je     805a88d <dns_msg_pack_qname+0x65>
		default:
			buf[lb_index] = domain_name[i];
 805a886:	88 5c 06 01          	mov    %bl,0x1(%esi,%eax,1)
			lb_size += 1U;
 805a88a:	41                   	inc    %ecx
			break;
 805a88b:	eb 15                	jmp    805a8a2 <dns_msg_pack_qname+0x7a>
		case '.':
			buf[lb_start] = lb_size;
 805a88d:	88 0c 16             	mov    %cl,(%esi,%edx,1)
			lb_size = 0U;
			lb_start = lb_index;
			break;
 805a890:	0f b7 d7             	movzwl %di,%edx
			lb_size = 0U;
 805a893:	31 c9                	xor    %ecx,%ecx
			break;
 805a895:	eb 0b                	jmp    805a8a2 <dns_msg_pack_qname+0x7a>
		case '\0':
			buf[lb_start] = lb_size;
 805a897:	0f b7 da             	movzwl %dx,%ebx
 805a89a:	88 0c 1e             	mov    %cl,(%esi,%ebx,1)
			buf[lb_index] = 0U;
 805a89d:	c6 44 06 01 00       	movb   $0x0,0x1(%esi,%eax,1)
			break;
		}
		lb_index += 1U;
 805a8a2:	66 8b 5d e6          	mov    -0x1a(%ebp),%bx
	for (i = 0U; i < dn_size + 1; i++) {
 805a8a6:	40                   	inc    %eax
 805a8a7:	83 c3 02             	add    $0x2,%ebx
 805a8aa:	66 39 45 e4          	cmp    %ax,-0x1c(%ebp)
 805a8ae:	73 ba                	jae    805a86a <dns_msg_pack_qname+0x42>
	}

	*len = lb_index;
 805a8b0:	8b 45 08             	mov    0x8(%ebp),%eax
 805a8b3:	66 89 18             	mov    %bx,(%eax)

	return 0;
 805a8b6:	31 c0                	xor    %eax,%eax
 805a8b8:	eb 05                	jmp    805a8bf <dns_msg_pack_qname+0x97>
			return -ENOMEM;
 805a8ba:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
}
 805a8bf:	8d 65 f4             	lea    -0xc(%ebp),%esp
 805a8c2:	5b                   	pop    %ebx
 805a8c3:	5e                   	pop    %esi
 805a8c4:	5f                   	pop    %edi
 805a8c5:	5d                   	pop    %ebp
 805a8c6:	c3                   	ret    

0805a8c7 <dns_unpack_answer>:
	return i;
}

int dns_unpack_answer(struct dns_msg_t *dns_msg, int dname_ptr, uint32_t *ttl,
		      enum dns_rr_type *type)
{
 805a8c7:	55                   	push   %ebp
 805a8c8:	89 e5                	mov    %esp,%ebp
 805a8ca:	57                   	push   %edi
	int i = 0;
 805a8cb:	31 ff                	xor    %edi,%edi
{
 805a8cd:	8b 45 08             	mov    0x8(%ebp),%eax
 805a8d0:	56                   	push   %esi
 805a8d1:	53                   	push   %ebx
	uint16_t rem_size;
	uint16_t pos;
	uint16_t len;
	uint8_t *answer;

	answer = dns_msg->msg + dns_msg->answer_offset;
 805a8d2:	0f b7 50 0e          	movzwl 0xe(%eax),%edx

	dname_len = skip_fqdn(answer,
			      dns_msg->msg_size - dns_msg->answer_offset);
 805a8d6:	0f b7 70 10          	movzwl 0x10(%eax),%esi
	answer = dns_msg->msg + dns_msg->answer_offset;
 805a8da:	8b 08                	mov    (%eax),%ecx
			      dns_msg->msg_size - dns_msg->answer_offset);
 805a8dc:	89 f3                	mov    %esi,%ebx
	dname_len = skip_fqdn(answer,
 805a8de:	29 d6                	sub    %edx,%esi
	answer = dns_msg->msg + dns_msg->answer_offset;
 805a8e0:	01 d1                	add    %edx,%ecx
		if (i >= buf_sz) {
 805a8e2:	39 fe                	cmp    %edi,%esi
 805a8e4:	7e 2d                	jle    805a913 <dns_unpack_answer+0x4c>
		if (answer[i] == 0) {
 805a8e6:	8a 14 39             	mov    (%ecx,%edi,1),%dl
 805a8e9:	84 d2                	test   %dl,%dl
 805a8eb:	75 03                	jne    805a8f0 <dns_unpack_answer+0x29>
			i += 1;
 805a8ed:	47                   	inc    %edi
			break;
 805a8ee:	eb 2a                	jmp    805a91a <dns_unpack_answer+0x53>
		} else if (answer[i] >= 0xc0) {
 805a8f0:	80 fa bf             	cmp    $0xbf,%dl
 805a8f3:	76 11                	jbe    805a906 <dns_unpack_answer+0x3f>
			i += 2;
 805a8f5:	83 c7 02             	add    $0x2,%edi
			if (i > buf_sz) {
 805a8f8:	ba ea ff ff ff       	mov    $0xffffffea,%edx
 805a8fd:	39 fe                	cmp    %edi,%esi
 805a8ff:	7d 19                	jge    805a91a <dns_unpack_answer+0x53>
 805a901:	e9 88 00 00 00       	jmp    805a98e <dns_unpack_answer+0xc7>
		} else if (answer[i] < DNS_LABEL_MAX_SIZE) {
 805a906:	80 fa 3e             	cmp    $0x3e,%dl
 805a909:	77 08                	ja     805a913 <dns_unpack_answer+0x4c>
			i += answer[i] + 1;
 805a90b:	42                   	inc    %edx
 805a90c:	0f b6 d2             	movzbl %dl,%edx
 805a90f:	01 d7                	add    %edx,%edi
		if (i >= buf_sz) {
 805a911:	eb cf                	jmp    805a8e2 <dns_unpack_answer+0x1b>
 805a913:	ba ea ff ff ff       	mov    $0xffffffea,%edx
 805a918:	eb 74                	jmp    805a98e <dns_unpack_answer+0xc7>
	 *
	 * So, answer size >= 12
	 *
	 * See RFC-1035 4.1.3. Resource record format
	 */
	rem_size = dns_msg->msg_size - dname_len;
 805a91a:	29 fb                	sub    %edi,%ebx
 805a91c:	89 fe                	mov    %edi,%esi
	if (rem_size < 2 + 2 + 4 + 2) {
 805a91e:	ba ea ff ff ff       	mov    $0xffffffea,%edx
 805a923:	66 83 fb 09          	cmp    $0x9,%bx
 805a927:	76 65                	jbe    805a98e <dns_unpack_answer+0xc7>
	}

	/* Only DNS_CLASS_IN answers. If mDNS is enabled, strip away the
	 * Cache-Flush bit (highest one).
	 */
	if ((dns_answer_class(dname_len, answer) &
 805a929:	66 81 7c 39 02 00 01 	cmpw   $0x100,0x2(%ecx,%edi,1)
 805a930:	ba ea ff ff ff       	mov    $0xffffffea,%edx
 805a935:	75 57                	jne    805a98e <dns_unpack_answer+0xc7>
	return ntohs(UNALIGNED_GET((uint16_t *)(answer + dname_size + 2)));
}

static inline int dns_answer_ttl(uint16_t dname_size, uint8_t *answer)
{
	return ntohl(UNALIGNED_GET((uint32_t *)(answer + dname_size + 4)));
 805a937:	8b 54 39 04          	mov    0x4(%ecx,%edi,1),%edx
							!= DNS_CLASS_IN) {
		return -EINVAL;
	}

	/* TTL value */
	*ttl = dns_answer_ttl(dname_len, answer);
 805a93b:	8b 5d 10             	mov    0x10(%ebp),%ebx
 805a93e:	0f ca                	bswap  %edx
 805a940:	89 13                	mov    %edx,(%ebx)
}

static inline int dns_answer_rdlength(uint16_t dname_size,
					     uint8_t *answer)
{
	return ntohs(UNALIGNED_GET((uint16_t *)(answer + dname_size + 8)));
 805a942:	66 8b 5c 39 08       	mov    0x8(%ecx,%edi,1),%bx
 805a947:	66 8b 0c 39          	mov    (%ecx,%edi,1),%cx
	len = dns_answer_rdlength(dname_len, answer);
	pos = dns_msg->answer_offset + dname_len +
 805a94b:	66 8b 50 0e          	mov    0xe(%eax),%dx
 805a94f:	86 fb                	xchg   %bh,%bl
 805a951:	86 e9                	xchg   %ch,%cl
 805a953:	8d 74 16 0a          	lea    0xa(%esi,%edx,1),%esi
		DNS_COMMON_UINT_SIZE + /* class length */
		DNS_COMMON_UINT_SIZE + /* type length */
		DNS_TTL_LEN +
		DNS_RDLENGTH_LEN;
	*type = dns_answer_type(dname_len, answer);
 805a957:	8b 55 14             	mov    0x14(%ebp),%edx
 805a95a:	0f b7 f9             	movzwl %cx,%edi
 805a95d:	89 3a                	mov    %edi,(%edx)

	switch (*type) {
 805a95f:	66 83 f9 05          	cmp    $0x5,%cx
 805a963:	74 18                	je     805a97d <dns_unpack_answer+0xb6>
 805a965:	66 83 f9 1c          	cmp    $0x1c,%cx
 805a969:	74 09                	je     805a974 <dns_unpack_answer+0xad>
 805a96b:	66 49                	dec    %cx
 805a96d:	ba ea ff ff ff       	mov    $0xffffffea,%edx
 805a972:	75 1a                	jne    805a98e <dns_unpack_answer+0xc7>
	dns_msg->response_type = type;
 805a974:	c7 40 04 eb ff ff ff 	movl   $0xffffffeb,0x4(%eax)
	dns_msg->response_position = pos;
 805a97b:	eb 07                	jmp    805a984 <dns_unpack_answer+0xbd>
	dns_msg->response_type = type;
 805a97d:	c7 40 04 ed ff ff ff 	movl   $0xffffffed,0x4(%eax)
	dns_msg->response_position = pos;
 805a984:	66 89 70 08          	mov    %si,0x8(%eax)
		return 0;

	case DNS_RR_TYPE_CNAME:
		set_dns_msg_response(dns_msg, DNS_RESPONSE_CNAME_NO_IP,
				     pos, len);
		return 0;
 805a988:	31 d2                	xor    %edx,%edx
	dns_msg->response_length = len;
 805a98a:	66 89 58 0a          	mov    %bx,0xa(%eax)
		/* malformed dns answer */
		return -EINVAL;
	}

	return 0;
}
 805a98e:	5b                   	pop    %ebx
 805a98f:	89 d0                	mov    %edx,%eax
 805a991:	5e                   	pop    %esi
 805a992:	5f                   	pop    %edi
 805a993:	5d                   	pop    %ebp
 805a994:	c3                   	ret    

0805a995 <dns_unpack_response_header>:

int dns_unpack_response_header(struct dns_msg_t *msg, int src_id)
{
 805a995:	55                   	push   %ebp

	dns_header = msg->msg;
	size = msg->msg_size;

	if (size < DNS_MSG_HEADER_SIZE) {
		return -ENOMEM;
 805a996:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
{
 805a99b:	89 e5                	mov    %esp,%ebp
 805a99d:	53                   	push   %ebx
 805a99e:	8b 4d 08             	mov    0x8(%ebp),%ecx
 805a9a1:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	if (size < DNS_MSG_HEADER_SIZE) {
 805a9a4:	66 83 79 10 0b       	cmpw   $0xb,0x10(%ecx)
	dns_header = msg->msg;
 805a9a9:	8b 11                	mov    (%ecx),%edx
	if (size < DNS_MSG_HEADER_SIZE) {
 805a9ab:	76 53                	jbe    805aa00 <dns_unpack_response_header+0x6b>
	return ntohs(UNALIGNED_GET((uint16_t *)(header)));
 805a9ad:	66 8b 0a             	mov    (%edx),%cx
	}

	if (dns_unpack_header_id(dns_header) != src_id) {
		return -EINVAL;
 805a9b0:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
 805a9b5:	86 e9                	xchg   %ch,%cl
 805a9b7:	0f b7 c9             	movzwl %cx,%ecx
	if (dns_unpack_header_id(dns_header) != src_id) {
 805a9ba:	39 cb                	cmp    %ecx,%ebx
 805a9bc:	75 42                	jne    805aa00 <dns_unpack_response_header+0x6b>
	return ((*(header + 2)) & 0x80) ? 1 : 0;
 805a9be:	8a 4a 02             	mov    0x2(%edx),%cl
	}

	if (dns_header_qr(dns_header) != DNS_RESPONSE) {
 805a9c1:	84 c9                	test   %cl,%cl
 805a9c3:	79 3b                	jns    805aa00 <dns_unpack_response_header+0x6b>
	return ((*(header + 2)) & 0x70) >> 1;
 805a9c5:	d1 e9                	shr    %ecx
		return -EINVAL;
	}

	if (dns_header_opcode(dns_header) != DNS_QUERY) {
 805a9c7:	80 e1 38             	and    $0x38,%cl
 805a9ca:	75 34                	jne    805aa00 <dns_unpack_response_header+0x6b>
	return ((*(header + 3)) & 0x70) >> 4;
 805a9cc:	8a 4a 03             	mov    0x3(%edx),%cl
 805a9cf:	89 c8                	mov    %ecx,%eax
 805a9d1:	c1 e8 04             	shr    $0x4,%eax
		return -EINVAL;
	}

	if (dns_header_z(dns_header) != 0) {
 805a9d4:	83 e0 07             	and    $0x7,%eax
 805a9d7:	75 22                	jne    805a9fb <dns_unpack_response_header+0x66>
		return -EINVAL;
	}

	rc = dns_header_rcode(dns_header);
	switch (rc) {
 805a9d9:	80 e1 0f             	and    $0xf,%cl
 805a9dc:	74 05                	je     805a9e3 <dns_unpack_response_header+0x4e>
	return ((*(header + 3)) & 0x0F);
 805a9de:	0f b6 c1             	movzbl %cl,%eax
 805a9e1:	eb 1d                	jmp    805aa00 <dns_unpack_response_header+0x6b>
	ancount = dns_unpack_header_ancount(dns_header);

	/* For mDNS (when src_id == 0) the query count is 0 so accept
	 * the packet in that case.
	 */
	if ((qdcount < 1 && src_id > 0) || ancount < 1) {
 805a9e3:	66 83 7a 04 00       	cmpw   $0x0,0x4(%edx)
 805a9e8:	0f 94 c1             	sete   %cl
 805a9eb:	85 db                	test   %ebx,%ebx
 805a9ed:	0f 9f c3             	setg   %bl
 805a9f0:	84 d9                	test   %bl,%cl
 805a9f2:	75 07                	jne    805a9fb <dns_unpack_response_header+0x66>
 805a9f4:	66 83 7a 06 00       	cmpw   $0x0,0x6(%edx)
 805a9f9:	75 05                	jne    805aa00 <dns_unpack_response_header+0x6b>
		return -EINVAL;
 805a9fb:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
		return -EINVAL;
	}

	return 0;
}
 805aa00:	5b                   	pop    %ebx
 805aa01:	5d                   	pop    %ebp
 805aa02:	c3                   	ret    

0805aa03 <dns_msg_pack_query>:
}

int dns_msg_pack_query(uint8_t *buf, uint16_t *len, uint16_t size,
		       uint8_t *qname, uint16_t qname_len, uint16_t id,
		       enum dns_rr_type qtype)
{
 805aa03:	55                   	push   %ebp
 805aa04:	89 e5                	mov    %esp,%ebp
 805aa06:	57                   	push   %edi
 805aa07:	56                   	push   %esi
 805aa08:	53                   	push   %ebx
 805aa09:	83 ec 08             	sub    $0x8,%esp
 805aa0c:	8b 5d 18             	mov    0x18(%ebp),%ebx
 805aa0f:	8b 45 1c             	mov    0x1c(%ebp),%eax
 805aa12:	8b 75 10             	mov    0x10(%ebp),%esi
 805aa15:	8b 55 08             	mov    0x8(%ebp),%edx
	uint16_t msg_size;
	uint16_t offset;
	int rc;

	msg_size = DNS_MSG_HEADER_SIZE + DNS_QTYPE_LEN + DNS_QCLASS_LEN;
	if (msg_size + qname_len > size) {
 805aa18:	0f b7 cb             	movzwl %bx,%ecx
{
 805aa1b:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (msg_size + qname_len > size) {
 805aa1e:	8d 41 10             	lea    0x10(%ecx),%eax
 805aa21:	0f b7 fe             	movzwl %si,%edi
 805aa24:	89 45 ec             	mov    %eax,-0x14(%ebp)
		return -ENOMEM;
 805aa27:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
	if (msg_size + qname_len > size) {
 805aa2c:	39 7d ec             	cmp    %edi,-0x14(%ebp)
 805aa2f:	7f 52                	jg     805aa83 <dns_msg_pack_query+0x80>
	if (size < DNS_MSG_HEADER_SIZE) {
 805aa31:	66 83 fe 0b          	cmp    $0xb,%si
 805aa35:	76 4c                	jbe    805aa83 <dns_msg_pack_query+0x80>
	UNALIGNED_PUT(htons(id), (uint16_t *)(buf));
 805aa37:	8b 45 f0             	mov    -0x10(%ebp),%eax
 805aa3a:	8b 75 14             	mov    0x14(%ebp),%esi
	*(buf + offset) = DNS_FLAGS1;		/* QR, Opcode, AA, TC and RD */
 805aa3d:	c7 42 02 01 00 00 01 	movl   $0x1000001,0x2(%edx)
	UNALIGNED_PUT(0, (uint32_t *)(buf + offset));
 805aa44:	c7 42 06 00 00 00 00 	movl   $0x0,0x6(%edx)
	UNALIGNED_PUT(htons(id), (uint16_t *)(buf));
 805aa4b:	86 e0                	xchg   %ah,%al
	UNALIGNED_PUT(0, (uint16_t *)(buf + offset));
 805aa4d:	66 c7 42 0a 00 00    	movw   $0x0,0xa(%edx)
	UNALIGNED_PUT(htons(id), (uint16_t *)(buf));
 805aa53:	66 89 02             	mov    %ax,(%edx)
	if (rc != 0) {
		return rc;
	}

	offset = DNS_MSG_HEADER_SIZE;
	memcpy(buf + offset, qname, qname_len);
 805aa56:	8d 42 0c             	lea    0xc(%edx),%eax
 805aa59:	89 c7                	mov    %eax,%edi

	offset += qname_len;
 805aa5b:	8d 43 0c             	lea    0xc(%ebx),%eax
 805aa5e:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)

	/* QType */
	UNALIGNED_PUT(htons(qtype), (uint16_t *)(buf + offset + 0));
 805aa60:	8b 4d 20             	mov    0x20(%ebp),%ecx
 805aa63:	0f b7 c0             	movzwl %ax,%eax
 805aa66:	86 e9                	xchg   %ch,%cl
 805aa68:	66 89 0c 02          	mov    %cx,(%edx,%eax,1)
	offset += DNS_QTYPE_LEN;
 805aa6c:	8d 43 0e             	lea    0xe(%ebx),%eax

	/* QClass */
	UNALIGNED_PUT(htons(DNS_CLASS_IN), (uint16_t *)(buf + offset));

	*len = offset + DNS_QCLASS_LEN;
 805aa6f:	83 c3 10             	add    $0x10,%ebx
	UNALIGNED_PUT(htons(DNS_CLASS_IN), (uint16_t *)(buf + offset));
 805aa72:	0f b7 c0             	movzwl %ax,%eax
 805aa75:	66 c7 04 02 00 01    	movw   $0x100,(%edx,%eax,1)
	*len = offset + DNS_QCLASS_LEN;
 805aa7b:	8b 45 0c             	mov    0xc(%ebp),%eax
 805aa7e:	66 89 18             	mov    %bx,(%eax)

	return 0;
 805aa81:	31 c0                	xor    %eax,%eax
}
 805aa83:	5a                   	pop    %edx
 805aa84:	59                   	pop    %ecx
 805aa85:	5b                   	pop    %ebx
 805aa86:	5e                   	pop    %esi
 805aa87:	5f                   	pop    %edi
 805aa88:	5d                   	pop    %ebp
 805aa89:	c3                   	ret    

0805aa8a <dns_unpack_response_query>:

	return -ENOMEM;
}

int dns_unpack_response_query(struct dns_msg_t *dns_msg)
{
 805aa8a:	55                   	push   %ebp
	*qname_size = 0;
 805aa8b:	31 c0                	xor    %eax,%eax
{
 805aa8d:	89 e5                	mov    %esp,%ebp
 805aa8f:	57                   	push   %edi
 805aa90:	56                   	push   %esi
 805aa91:	53                   	push   %ebx
 805aa92:	51                   	push   %ecx
 805aa93:	8b 75 08             	mov    0x8(%ebp),%esi
	int offset;
	int rc;

	dns_msg->query_offset = DNS_MSG_HEADER_SIZE;
	dns_query = dns_msg->msg + dns_msg->query_offset;
	remaining_size = dns_msg->msg_size - dns_msg->query_offset;
 805aa96:	0f b7 4e 10          	movzwl 0x10(%esi),%ecx
	dns_query = dns_msg->msg + dns_msg->query_offset;
 805aa9a:	8b 3e                	mov    (%esi),%edi
	dns_msg->query_offset = DNS_MSG_HEADER_SIZE;
 805aa9c:	66 c7 46 0c 0c 00    	movw   $0xc,0xc(%esi)

	rc = dns_find_null(&qname_size, dns_query, remaining_size);
 805aaa2:	8d 51 f4             	lea    -0xc(%ecx),%edx
	while (*qname_size < size) {
 805aaa5:	0f b7 d2             	movzwl %dx,%edx
 805aaa8:	39 c2                	cmp    %eax,%edx
 805aaaa:	7e 0e                	jle    805aaba <dns_unpack_response_query+0x30>
		if (buf[(*qname_size)++] == 0x00) {
 805aaac:	80 7c 07 0c 00       	cmpb   $0x0,0xc(%edi,%eax,1)
 805aab1:	8d 58 01             	lea    0x1(%eax),%ebx
 805aab4:	74 0b                	je     805aac1 <dns_unpack_response_query+0x37>
 805aab6:	89 d8                	mov    %ebx,%eax
 805aab8:	eb ee                	jmp    805aaa8 <dns_unpack_response_query+0x1e>
	return -ENOMEM;
 805aaba:	ba f4 ff ff ff       	mov    $0xfffffff4,%edx
 805aabf:	eb 40                	jmp    805ab01 <dns_unpack_response_query+0x77>

	/* header already parsed + qname size */
	offset = dns_msg->query_offset + qname_size;

	/* 4 bytes more due to qtype and qclass */
	offset += DNS_QTYPE_LEN + DNS_QCLASS_LEN;
 805aac1:	8d 50 11             	lea    0x11(%eax),%edx
 805aac4:	89 55 f0             	mov    %edx,-0x10(%ebp)
	return -ENOMEM;
 805aac7:	ba f4 ff ff ff       	mov    $0xfffffff4,%edx
	if (offset >= dns_msg->msg_size) {
 805aacc:	3b 4d f0             	cmp    -0x10(%ebp),%ecx
 805aacf:	7e 30                	jle    805ab01 <dns_unpack_response_query+0x77>
		return -ENOMEM;
	}

	buf = dns_query + qname_size;
 805aad1:	8d 4c 07 0d          	lea    0xd(%edi,%eax,1),%ecx
	return ntohs(UNALIGNED_GET((uint16_t *)(question + 0)));
 805aad5:	66 8b 01             	mov    (%ecx),%ax
 805aad8:	86 e0                	xchg   %ah,%al
 805aada:	0f b7 f8             	movzwl %ax,%edi
	if (dns_unpack_query_qtype(buf) != DNS_RR_TYPE_A &&
 805aadd:	66 83 f8 1c          	cmp    $0x1c,%ax
 805aae1:	74 08                	je     805aaeb <dns_unpack_response_query+0x61>
 805aae3:	4f                   	dec    %edi
	    dns_unpack_query_qtype(buf) != DNS_RR_TYPE_AAAA) {
		return -EINVAL;
 805aae4:	ba ea ff ff ff       	mov    $0xffffffea,%edx
	if (dns_unpack_query_qtype(buf) != DNS_RR_TYPE_A &&
 805aae9:	75 16                	jne    805ab01 <dns_unpack_response_query+0x77>
	}

	if (dns_unpack_query_qclass(buf) != DNS_CLASS_IN) {
 805aaeb:	66 81 79 02 00 01    	cmpw   $0x100,0x2(%ecx)
		return -EINVAL;
 805aaf1:	ba ea ff ff ff       	mov    $0xffffffea,%edx
	if (dns_unpack_query_qclass(buf) != DNS_CLASS_IN) {
 805aaf6:	75 09                	jne    805ab01 <dns_unpack_response_query+0x77>
		return -EINVAL;
	}

	dns_msg->answer_offset = dns_msg->query_offset + qname_size +
				 DNS_QTYPE_LEN + DNS_QCLASS_LEN;
 805aaf8:	83 c3 10             	add    $0x10,%ebx

	return 0;
 805aafb:	31 d2                	xor    %edx,%edx
				 DNS_QTYPE_LEN + DNS_QCLASS_LEN;
 805aafd:	66 89 5e 0e          	mov    %bx,0xe(%esi)
}
 805ab01:	89 d0                	mov    %edx,%eax
 805ab03:	5a                   	pop    %edx
 805ab04:	5b                   	pop    %ebx
 805ab05:	5e                   	pop    %esi
 805ab06:	5f                   	pop    %edi
 805ab07:	5d                   	pop    %ebp
 805ab08:	c3                   	ret    

0805ab09 <dns_copy_qname>:

int dns_copy_qname(uint8_t *buf, uint16_t *len, uint16_t size,
		   struct dns_msg_t *dns_msg, uint16_t pos)
{
 805ab09:	55                   	push   %ebp
 805ab0a:	89 e5                	mov    %esp,%ebp
 805ab0c:	57                   	push   %edi
 805ab0d:	56                   	push   %esi
 805ab0e:	53                   	push   %ebx
 805ab0f:	83 ec 10             	sub    $0x10,%esp
 805ab12:	8b 45 14             	mov    0x14(%ebp),%eax
 805ab15:	8b 5d 18             	mov    0x18(%ebp),%ebx
	uint16_t msg_size = dns_msg->msg_size;
 805ab18:	8b 70 10             	mov    0x10(%eax),%esi
	uint8_t *msg = dns_msg->msg;
 805ab1b:	8b 00                	mov    (%eax),%eax
 805ab1d:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint16_t lb_size;
	int rc = -EINVAL;

	*len = 0U;
 805ab20:	8b 45 0c             	mov    0xc(%ebp),%eax
	uint16_t msg_size = dns_msg->msg_size;
 805ab23:	66 89 75 f2          	mov    %si,-0xe(%ebp)
	*len = 0U;
 805ab27:	66 c7 00 00 00       	movw   $0x0,(%eax)
		}

		/* validate that the label (i.e. size + elements),
		 * fits the current msg buffer
		 */
		if (DNS_LABEL_LEN_SIZE + lb_size > size - *len) {
 805ab2c:	0f b7 45 10          	movzwl 0x10(%ebp),%eax
 805ab30:	89 45 e8             	mov    %eax,-0x18(%ebp)
			if (pos + 1 >= msg_size) {
 805ab33:	0f b7 c6             	movzwl %si,%eax
 805ab36:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		if (pos >= msg_size) {
 805ab39:	66 3b 5d f2          	cmp    -0xe(%ebp),%bx
 805ab3d:	73 62                	jae    805aba1 <dns_copy_qname+0x98>
		lb_size = msg[pos];
 805ab3f:	8b 55 ec             	mov    -0x14(%ebp),%edx
 805ab42:	0f b7 c3             	movzwl %bx,%eax
 805ab45:	8d 34 02             	lea    (%edx,%eax,1),%esi
 805ab48:	0f b6 16             	movzbl (%esi),%edx
 805ab4b:	89 d1                	mov    %edx,%ecx
		if (lb_size > DNS_LABEL_MAX_SIZE) {
 805ab4d:	80 fa 3f             	cmp    $0x3f,%dl
 805ab50:	76 1b                	jbe    805ab6d <dns_copy_qname+0x64>
			if (pos + 1 >= msg_size) {
 805ab52:	8d 50 01             	lea    0x1(%eax),%edx
 805ab55:	3b 55 e4             	cmp    -0x1c(%ebp),%edx
 805ab58:	7d 47                	jge    805aba1 <dns_copy_qname+0x98>
			pos = ((msg[pos] & mask) << 8) + msg[pos + 1];
 805ab5a:	8b 75 ec             	mov    -0x14(%ebp),%esi
 805ab5d:	83 e1 3f             	and    $0x3f,%ecx
 805ab60:	c1 e1 08             	shl    $0x8,%ecx
 805ab63:	0f b6 44 06 01       	movzbl 0x1(%esi,%eax,1),%eax
 805ab68:	8d 1c 08             	lea    (%eax,%ecx,1),%ebx
			continue;
 805ab6b:	eb cc                	jmp    805ab39 <dns_copy_qname+0x30>
		if (DNS_LABEL_LEN_SIZE + lb_size > size - *len) {
 805ab6d:	8b 45 0c             	mov    0xc(%ebp),%eax
 805ab70:	8b 7d e8             	mov    -0x18(%ebp),%edi
 805ab73:	0f b7 00             	movzwl (%eax),%eax
 805ab76:	29 c7                	sub    %eax,%edi
 805ab78:	39 fa                	cmp    %edi,%edx
 805ab7a:	7d 25                	jge    805aba1 <dns_copy_qname+0x98>
			rc = -ENOMEM;
			break;
		}

		/* copy the lb_size value and label elements */
		memcpy(buf + *len, msg + pos, DNS_LABEL_LEN_SIZE + lb_size);
 805ab7c:	03 45 08             	add    0x8(%ebp),%eax
 805ab7f:	41                   	inc    %ecx
		/* update destination buffer len */
		*len += DNS_LABEL_LEN_SIZE + lb_size;
		/* update msg ptr position */
		pos += DNS_LABEL_LEN_SIZE + lb_size;
 805ab80:	8d 5c 1a 01          	lea    0x1(%edx,%ebx,1),%ebx
 805ab84:	89 c7                	mov    %eax,%edi
		*len += DNS_LABEL_LEN_SIZE + lb_size;
 805ab86:	8b 45 0c             	mov    0xc(%ebp),%eax
 805ab89:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
 805ab8b:	8b 7d 0c             	mov    0xc(%ebp),%edi
 805ab8e:	66 8b 00             	mov    (%eax),%ax
 805ab91:	8d 44 02 01          	lea    0x1(%edx,%eax,1),%eax
 805ab95:	66 89 07             	mov    %ax,(%edi)

		/* The domain name terminates with the zero length octet
		 * for the null label of the root
		 */
		if (lb_size == 0U) {
 805ab98:	66 85 d2             	test   %dx,%dx
 805ab9b:	75 9c                	jne    805ab39 <dns_copy_qname+0x30>
			rc = 0;
 805ab9d:	31 c0                	xor    %eax,%eax
 805ab9f:	eb 05                	jmp    805aba6 <dns_copy_qname+0x9d>
			rc = -ENOMEM;
 805aba1:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
			break;
		}
	}

	return rc;
}
 805aba6:	83 c4 10             	add    $0x10,%esp
 805aba9:	5b                   	pop    %ebx
 805abaa:	5e                   	pop    %esi
 805abab:	5f                   	pop    %edi
 805abac:	5d                   	pop    %ebp
 805abad:	c3                   	ret    

0805abae <net_ipv4_is_addr_mcast>:
	return (ntohl(UNALIGNED_GET(&addr->s_addr)) & 0xF0000000) == 0xE0000000;
 805abae:	8b 00                	mov    (%eax),%eax
 805abb0:	25 f0 00 00 00       	and    $0xf0,%eax
 805abb5:	3d e0 00 00 00       	cmp    $0xe0,%eax
 805abba:	0f 94 c0             	sete   %al
}
 805abbd:	c3                   	ret    

0805abbe <invoke_query_callback>:
					 struct dns_pending_query *pending_query)
{
	/* Only notify if the slot is neither released nor in the process of
	 * being released.
	 */
	if (pending_query->query != NULL && pending_query->cb != NULL)  {
 805abbe:	83 79 3c 00          	cmpl   $0x0,0x3c(%ecx)
 805abc2:	74 1e                	je     805abe2 <invoke_query_callback+0x24>
{
 805abc4:	55                   	push   %ebp
 805abc5:	89 e5                	mov    %esp,%ebp
 805abc7:	53                   	push   %ebx
 805abc8:	53                   	push   %ebx
	if (pending_query->query != NULL && pending_query->cb != NULL)  {
 805abc9:	8b 59 2c             	mov    0x2c(%ecx),%ebx
 805abcc:	85 db                	test   %ebx,%ebx
 805abce:	74 0d                	je     805abdd <invoke_query_callback+0x1f>
		pending_query->cb(status, info, pending_query->user_data);
 805abd0:	83 ec 04             	sub    $0x4,%esp
 805abd3:	ff 71 30             	push   0x30(%ecx)
 805abd6:	52                   	push   %edx
 805abd7:	50                   	push   %eax
 805abd8:	ff d3                	call   *%ebx
 805abda:	83 c4 10             	add    $0x10,%esp
	}
}
 805abdd:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 805abe0:	c9                   	leave  
 805abe1:	c3                   	ret    
 805abe2:	c3                   	ret    

0805abe3 <k_mutex_lock>:
{
 805abe3:	55                   	push   %ebp
 805abe4:	89 e5                	mov    %esp,%ebp
 805abe6:	53                   	push   %ebx
 805abe7:	83 ec 08             	sub    $0x8,%esp
	return z_impl_k_mutex_lock(mutex, timeout);
 805abea:	51                   	push   %ecx
 805abeb:	52                   	push   %edx
 805abec:	50                   	push   %eax
 805abed:	e8 a6 45 00 00       	call   805f198 <z_impl_k_mutex_lock>
}
 805abf2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
	return z_impl_k_mutex_lock(mutex, timeout);
 805abf5:	83 c4 10             	add    $0x10,%esp
}
 805abf8:	c9                   	leave  
 805abf9:	c3                   	ret    

0805abfa <get_slot_by_id>:
				 uint16_t query_hash)
{
	int i;

	for (i = 0; i < CONFIG_DNS_NUM_CONCUR_QUERIES; i++) {
		if (check_query_active(&ctx->queries[i], false) &&
 805abfa:	83 78 68 00          	cmpl   $0x0,0x68(%eax)
 805abfe:	74 2d                	je     805ac2d <get_slot_by_id+0x33>
{
 805ac00:	55                   	push   %ebp
 805ac01:	89 e5                	mov    %esp,%ebp
 805ac03:	53                   	push   %ebx
 805ac04:	89 c3                	mov    %eax,%ebx
		     ctx->queries[i].query_hash == query_hash)) {
			return i;
		}
	}

	return -ENOENT;
 805ac06:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
		if (check_query_active(&ctx->queries[i], false) &&
 805ac0b:	66 39 93 80 00 00 00 	cmp    %dx,0x80(%ebx)
 805ac12:	75 1f                	jne    805ac33 <get_slot_by_id+0x39>
 805ac14:	31 c0                	xor    %eax,%eax
		    ctx->queries[i].id == dns_id &&
 805ac16:	66 85 c9             	test   %cx,%cx
 805ac19:	74 18                	je     805ac33 <get_slot_by_id+0x39>
		    (query_hash == 0 ||
 805ac1b:	31 c0                	xor    %eax,%eax
 805ac1d:	66 39 8b 82 00 00 00 	cmp    %cx,0x82(%ebx)
 805ac24:	0f 94 c0             	sete   %al
 805ac27:	8d 44 00 fe          	lea    -0x2(%eax,%eax,1),%eax
 805ac2b:	eb 06                	jmp    805ac33 <get_slot_by_id+0x39>
	return -ENOENT;
 805ac2d:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
}
 805ac32:	c3                   	ret    
 805ac33:	5b                   	pop    %ebx
 805ac34:	5d                   	pop    %ebp
 805ac35:	c3                   	ret    

0805ac36 <release_query>:
{
 805ac36:	55                   	push   %ebp
 805ac37:	89 e5                	mov    %esp,%ebp
 805ac39:	53                   	push   %ebx
 805ac3a:	89 c3                	mov    %eax,%ebx
 805ac3c:	83 ec 10             	sub    $0x10,%esp
	int busy = k_work_cancel_delayable(&pending_query->timer);
 805ac3f:	50                   	push   %eax
 805ac40:	e8 b9 50 00 00       	call   805fcfe <k_work_cancel_delayable>
 805ac45:	83 c4 10             	add    $0x10,%esp
	if (busy == 0) {
 805ac48:	85 c0                	test   %eax,%eax
 805ac4a:	75 09                	jne    805ac55 <release_query+0x1f>
		pending_query->cb = NULL;
 805ac4c:	c7 43 2c 00 00 00 00 	movl   $0x0,0x2c(%ebx)
 805ac53:	eb 07                	jmp    805ac5c <release_query+0x26>
		pending_query->query = NULL;
 805ac55:	c7 43 3c 00 00 00 00 	movl   $0x0,0x3c(%ebx)
}
 805ac5c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 805ac5f:	c9                   	leave  
 805ac60:	c3                   	ret    

0805ac61 <k_mutex_unlock>:
{
 805ac61:	55                   	push   %ebp
 805ac62:	89 e5                	mov    %esp,%ebp
 805ac64:	83 ec 14             	sub    $0x14,%esp
	return z_impl_k_mutex_unlock(mutex);
 805ac67:	50                   	push   %eax
 805ac68:	e8 39 46 00 00       	call   805f2a6 <z_impl_k_mutex_unlock>
 805ac6d:	83 c4 10             	add    $0x10,%esp
}
 805ac70:	c9                   	leave  
 805ac71:	c3                   	ret    

0805ac72 <dns_server_exists>:
	return ret;
}

static bool dns_server_exists(struct dns_resolve_context *ctx,
			      const struct sockaddr *addr)
{
 805ac72:	55                   	push   %ebp
				return true;
			}
		}
	}

	return false;
 805ac73:	31 c9                	xor    %ecx,%ecx
{
 805ac75:	89 e5                	mov    %esp,%ebp
 805ac77:	53                   	push   %ebx
 805ac78:	53                   	push   %ebx
		if (IS_ENABLED(CONFIG_NET_IPV4) && (addr->sa_family == AF_INET) &&
 805ac79:	66 8b 1a             	mov    (%edx),%bx
 805ac7c:	66 83 fb 01          	cmp    $0x1,%bx
 805ac80:	75 0e                	jne    805ac90 <dns_server_exists+0x1e>
 805ac82:	66 83 38 01          	cmpw   $0x1,(%eax)
 805ac86:	75 2c                	jne    805acb4 <dns_server_exists+0x42>
			if (net_ipv4_addr_cmp(&net_sin(addr)->sin_addr,
 805ac88:	8b 5a 04             	mov    0x4(%edx),%ebx
 805ac8b:	39 58 04             	cmp    %ebx,0x4(%eax)
 805ac8e:	eb 21                	jmp    805acb1 <dns_server_exists+0x3f>
		if (IS_ENABLED(CONFIG_NET_IPV6) && (addr->sa_family == AF_INET6) &&
 805ac90:	66 83 fb 02          	cmp    $0x2,%bx
 805ac94:	75 1e                	jne    805acb4 <dns_server_exists+0x42>
 805ac96:	66 83 38 02          	cmpw   $0x2,(%eax)
 805ac9a:	75 18                	jne    805acb4 <dns_server_exists+0x42>
	return !memcmp(addr1, addr2, sizeof(struct in6_addr));
 805ac9c:	83 c0 04             	add    $0x4,%eax
 805ac9f:	83 c2 04             	add    $0x4,%edx
 805aca2:	51                   	push   %ecx
 805aca3:	6a 10                	push   $0x10
 805aca5:	50                   	push   %eax
 805aca6:	52                   	push   %edx
 805aca7:	e8 c4 e3 fe ff       	call   8049070 <memcmp@plt>
 805acac:	83 c4 10             	add    $0x10,%esp
			if (net_ipv6_addr_cmp(&net_sin6(addr)->sin6_addr,
 805acaf:	85 c0                	test   %eax,%eax
 805acb1:	0f 94 c1             	sete   %cl
}
 805acb4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 805acb7:	89 c8                	mov    %ecx,%eax
 805acb9:	c9                   	leave  
 805acba:	c3                   	ret    

0805acbb <dns_resolve_cancel_with_hash.constprop.0>:
static int dns_resolve_cancel_with_hash(struct dns_resolve_context *ctx,
 805acbb:	55                   	push   %ebp
 805acbc:	89 e5                	mov    %esp,%ebp
 805acbe:	57                   	push   %edi
 805acbf:	89 cf                	mov    %ecx,%edi
 805acc1:	56                   	push   %esi
 805acc2:	89 d6                	mov    %edx,%esi
	k_mutex_lock(&ctx->lock, K_FOREVER);
 805acc4:	83 ca ff             	or     $0xffffffff,%edx
static int dns_resolve_cancel_with_hash(struct dns_resolve_context *ctx,
 805acc7:	53                   	push   %ebx
	k_mutex_lock(&ctx->lock, K_FOREVER);
 805acc8:	89 d1                	mov    %edx,%ecx
static int dns_resolve_cancel_with_hash(struct dns_resolve_context *ctx,
 805acca:	89 c3                	mov    %eax,%ebx
	k_mutex_lock(&ctx->lock, K_FOREVER);
 805accc:	83 c0 20             	add    $0x20,%eax
static int dns_resolve_cancel_with_hash(struct dns_resolve_context *ctx,
 805accf:	83 ec 1c             	sub    $0x1c,%esp
	k_mutex_lock(&ctx->lock, K_FOREVER);
 805acd2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 805acd5:	e8 09 ff ff ff       	call   805abe3 <k_mutex_lock>
	if (ctx->state == DNS_RESOLVE_CONTEXT_DEACTIVATING) {
 805acda:	83 bb 84 00 00 00 01 	cmpl   $0x1,0x84(%ebx)
 805ace1:	74 32                	je     805ad15 <dns_resolve_cancel_with_hash.constprop.0+0x5a>
	i = get_slot_by_id(ctx, dns_id, query_hash);
 805ace3:	0f b7 d6             	movzwl %si,%edx
 805ace6:	0f b7 cf             	movzwl %di,%ecx
 805ace9:	89 d8                	mov    %ebx,%eax
		ret = -ENOENT;
 805aceb:	be fe ff ff ff       	mov    $0xfffffffe,%esi
	i = get_slot_by_id(ctx, dns_id, query_hash);
 805acf0:	e8 05 ff ff ff       	call   805abfa <get_slot_by_id>
	if (i < 0) {
 805acf5:	85 c0                	test   %eax,%eax
 805acf7:	78 1e                	js     805ad17 <dns_resolve_cancel_with_hash.constprop.0+0x5c>
	invoke_query_callback(DNS_EAI_CANCELED, NULL, &ctx->queries[slot]);
 805acf9:	6b c0 48             	imul   $0x48,%eax,%eax
 805acfc:	31 d2                	xor    %edx,%edx
 805acfe:	8d 5c 03 3c          	lea    0x3c(%ebx,%eax,1),%ebx
 805ad02:	b8 9b ff ff ff       	mov    $0xffffff9b,%eax
 805ad07:	89 d9                	mov    %ebx,%ecx
 805ad09:	e8 b0 fe ff ff       	call   805abbe <invoke_query_callback>
	release_query(&ctx->queries[slot]);
 805ad0e:	89 d8                	mov    %ebx,%eax
 805ad10:	e8 21 ff ff ff       	call   805ac36 <release_query>
	int ret = 0;
 805ad15:	31 f6                	xor    %esi,%esi
	k_mutex_unlock(&ctx->lock);
 805ad17:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 805ad1a:	e8 42 ff ff ff       	call   805ac61 <k_mutex_unlock>
}
 805ad1f:	83 c4 1c             	add    $0x1c,%esp
 805ad22:	89 f0                	mov    %esi,%eax
 805ad24:	5b                   	pop    %ebx
 805ad25:	5e                   	pop    %esi
 805ad26:	5f                   	pop    %edi
 805ad27:	5d                   	pop    %ebp
 805ad28:	c3                   	ret    

0805ad29 <query_timeout>:
{
 805ad29:	55                   	push   %ebp
	ret = k_mutex_lock(&pending_query->ctx->lock, K_NO_WAIT);
 805ad2a:	31 c9                	xor    %ecx,%ecx
{
 805ad2c:	89 e5                	mov    %esp,%ebp
 805ad2e:	53                   	push   %ebx
 805ad2f:	52                   	push   %edx
 805ad30:	8b 5d 08             	mov    0x8(%ebp),%ebx
	ret = k_mutex_lock(&pending_query->ctx->lock, K_NO_WAIT);
 805ad33:	31 d2                	xor    %edx,%edx
 805ad35:	8b 43 28             	mov    0x28(%ebx),%eax
 805ad38:	83 c0 20             	add    $0x20,%eax
 805ad3b:	e8 a3 fe ff ff       	call   805abe3 <k_mutex_lock>
	if (ret != 0) {
 805ad40:	85 c0                	test   %eax,%eax
 805ad42:	74 13                	je     805ad57 <query_timeout+0x2e>
		k_work_reschedule(dwork, K_MSEC(10));
 805ad44:	50                   	push   %eax
 805ad45:	6a 00                	push   $0x0
 805ad47:	6a 01                	push   $0x1
 805ad49:	53                   	push   %ebx
 805ad4a:	e8 91 4f 00 00       	call   805fce0 <k_work_reschedule>
}
 805ad4f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
		k_work_reschedule(dwork, K_MSEC(10));
 805ad52:	83 c4 10             	add    $0x10,%esp
}
 805ad55:	c9                   	leave  
 805ad56:	c3                   	ret    
	(void)dns_resolve_cancel_with_hash(pending_query->ctx,
 805ad57:	0f b7 4b 46          	movzwl 0x46(%ebx),%ecx
 805ad5b:	0f b7 53 44          	movzwl 0x44(%ebx),%edx
 805ad5f:	8b 43 28             	mov    0x28(%ebx),%eax
 805ad62:	e8 54 ff ff ff       	call   805acbb <dns_resolve_cancel_with_hash.constprop.0>
	k_mutex_unlock(&pending_query->ctx->lock);
 805ad67:	8b 43 28             	mov    0x28(%ebx),%eax
}
 805ad6a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 805ad6d:	c9                   	leave  
	k_mutex_unlock(&pending_query->ctx->lock);
 805ad6e:	83 c0 20             	add    $0x20,%eax
 805ad71:	e9 eb fe ff ff       	jmp    805ac61 <k_mutex_unlock>

0805ad76 <dns_resolve_close_locked>:
	if (ctx->state != DNS_RESOLVE_CONTEXT_ACTIVE) {
 805ad76:	83 b8 84 00 00 00 00 	cmpl   $0x0,0x84(%eax)
 805ad7d:	75 64                	jne    805ade3 <dns_resolve_close_locked+0x6d>
{
 805ad7f:	55                   	push   %ebp
 805ad80:	89 e5                	mov    %esp,%ebp
 805ad82:	56                   	push   %esi
	k_mutex_unlock(&ctx->lock);
 805ad83:	8d 70 20             	lea    0x20(%eax),%esi
{
 805ad86:	53                   	push   %ebx
 805ad87:	89 c3                	mov    %eax,%ebx
	ctx->state = DNS_RESOLVE_CONTEXT_DEACTIVATING;
 805ad89:	c7 80 84 00 00 00 01 	movl   $0x1,0x84(%eax)
 805ad90:	00 00 00 
	k_mutex_unlock(&ctx->lock);
 805ad93:	89 f0                	mov    %esi,%eax
 805ad95:	e8 c7 fe ff ff       	call   805ac61 <k_mutex_unlock>
		if (ctx->servers[i].net_ctx) {
 805ad9a:	8b 43 18             	mov    0x18(%ebx),%eax
 805ad9d:	85 c0                	test   %eax,%eax
 805ad9f:	74 23                	je     805adc4 <dns_resolve_close_locked+0x4e>
 805ada1:	0f be 80 9a 00 00 00 	movsbl 0x9a(%eax),%eax
 805ada8:	83 ec 0c             	sub    $0xc,%esp
 805adab:	50                   	push   %eax
 805adac:	e8 49 62 ff ff       	call   8050ffa <z_impl_net_if_get_by_index>
 805adb1:	58                   	pop    %eax
			net_context_put(ctx->servers[i].net_ctx);
 805adb2:	ff 73 18             	push   0x18(%ebx)
 805adb5:	e8 0b 8e ff ff       	call   8053bc5 <net_context_put>
			ctx->servers[i].net_ctx = NULL;
 805adba:	c7 43 18 00 00 00 00 	movl   $0x0,0x18(%ebx)
			net_context_put(ctx->servers[i].net_ctx);
 805adc1:	83 c4 10             	add    $0x10,%esp
	k_mutex_lock(&ctx->lock, K_FOREVER);
 805adc4:	83 ca ff             	or     $0xffffffff,%edx
 805adc7:	89 f0                	mov    %esi,%eax
 805adc9:	89 d1                	mov    %edx,%ecx
 805adcb:	e8 13 fe ff ff       	call   805abe3 <k_mutex_lock>
	return 0;
 805add0:	31 c0                	xor    %eax,%eax
	ctx->state = DNS_RESOLVE_CONTEXT_INACTIVE;
 805add2:	c7 83 84 00 00 00 02 	movl   $0x2,0x84(%ebx)
 805add9:	00 00 00 
}
 805addc:	8d 65 f8             	lea    -0x8(%ebp),%esp
 805addf:	5b                   	pop    %ebx
 805ade0:	5e                   	pop    %esi
 805ade1:	5d                   	pop    %ebp
 805ade2:	c3                   	ret    
		return -ENOENT;
 805ade3:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
}
 805ade8:	c3                   	ret    

0805ade9 <dns_postprocess_server>:
{
 805ade9:	55                   	push   %ebp
 805adea:	89 d1                	mov    %edx,%ecx
	struct sockaddr *addr = &ctx->servers[idx].dns_server;
 805adec:	c1 e2 05             	shl    $0x5,%edx
 805adef:	01 c2                	add    %eax,%edx
{
 805adf1:	89 e5                	mov    %esp,%ebp
 805adf3:	56                   	push   %esi
 805adf4:	53                   	push   %ebx
	if (addr->sa_family == AF_INET) {
 805adf5:	66 83 3a 01          	cmpw   $0x1,(%edx)
{
 805adf9:	89 c3                	mov    %eax,%ebx
	if (addr->sa_family == AF_INET) {
 805adfb:	75 49                	jne    805ae46 <dns_postprocess_server+0x5d>
		if (net_ipv4_is_addr_mcast(&net_sin(addr)->sin_addr) &&
 805adfd:	8d 72 04             	lea    0x4(%edx),%esi
 805ae00:	89 f0                	mov    %esi,%eax
 805ae02:	e8 a7 fd ff ff       	call   805abae <net_ipv4_is_addr_mcast>
 805ae07:	84 c0                	test   %al,%al
 805ae09:	74 06                	je     805ae11 <dns_postprocess_server+0x28>
 805ae0b:	80 7a 07 fb          	cmpb   $0xfb,0x7(%edx)
 805ae0f:	74 5c                	je     805ae6d <dns_postprocess_server+0x84>
		ctx->servers[idx].is_mdns = server_is_mdns(AF_INET, addr);
 805ae11:	89 c8                	mov    %ecx,%eax
 805ae13:	c1 e0 05             	shl    $0x5,%eax
 805ae16:	80 64 03 1c fe       	andb   $0xfe,0x1c(%ebx,%eax,1)
		if (net_ipv4_is_addr_mcast(&net_sin(addr)->sin_addr) &&
 805ae1b:	89 f0                	mov    %esi,%eax
 805ae1d:	e8 8c fd ff ff       	call   805abae <net_ipv4_is_addr_mcast>
 805ae22:	84 c0                	test   %al,%al
 805ae24:	74 07                	je     805ae2d <dns_postprocess_server+0x44>
 805ae26:	80 7a 07 fc          	cmpb   $0xfc,0x7(%edx)
 805ae2a:	0f 94 c0             	sete   %al
			ctx->servers[idx].is_llmnr =
 805ae2d:	c1 e1 05             	shl    $0x5,%ecx
 805ae30:	83 e0 01             	and    $0x1,%eax
 805ae33:	8d 4c 0b 10          	lea    0x10(%ebx,%ecx,1),%ecx
 805ae37:	01 c0                	add    %eax,%eax
 805ae39:	8a 59 0c             	mov    0xc(%ecx),%bl
 805ae3c:	83 e3 fd             	and    $0xfffffffd,%ebx
 805ae3f:	09 d8                	or     %ebx,%eax
 805ae41:	88 41 0c             	mov    %al,0xc(%ecx)
		if (net_sin(addr)->sin_port == 0U) {
 805ae44:	eb 42                	jmp    805ae88 <dns_postprocess_server+0x9f>
		if (net_ipv6_is_addr_mcast(&net_sin6(addr)->sin6_addr) &&
 805ae46:	80 7a 04 ff          	cmpb   $0xff,0x4(%edx)
 805ae4a:	75 06                	jne    805ae52 <dns_postprocess_server+0x69>
 805ae4c:	80 7a 13 fb          	cmpb   $0xfb,0x13(%edx)
 805ae50:	74 1b                	je     805ae6d <dns_postprocess_server+0x84>
		ctx->servers[idx].is_mdns = server_is_mdns(AF_INET6, addr);
 805ae52:	89 c8                	mov    %ecx,%eax
 805ae54:	c1 e0 05             	shl    $0x5,%eax
 805ae57:	80 64 03 1c fe       	andb   $0xfe,0x1c(%ebx,%eax,1)
		return false;
 805ae5c:	31 c0                	xor    %eax,%eax
		if (net_ipv6_is_addr_mcast(&net_sin6(addr)->sin6_addr) &&
 805ae5e:	80 7a 04 ff          	cmpb   $0xff,0x4(%edx)
 805ae62:	75 0f                	jne    805ae73 <dns_postprocess_server+0x8a>
 805ae64:	80 7a 13 03          	cmpb   $0x3,0x13(%edx)
 805ae68:	0f 94 c0             	sete   %al
 805ae6b:	eb 06                	jmp    805ae73 <dns_postprocess_server+0x8a>
		ctx->servers[idx].is_mdns = server_is_mdns(AF_INET6, addr);
 805ae6d:	80 4a 1c 01          	orb    $0x1,0x1c(%edx)
		if (!ctx->servers[idx].is_mdns) {
 805ae71:	eb 15                	jmp    805ae88 <dns_postprocess_server+0x9f>
			ctx->servers[idx].is_llmnr =
 805ae73:	c1 e1 05             	shl    $0x5,%ecx
 805ae76:	8d 5c 0b 10          	lea    0x10(%ebx,%ecx,1),%ebx
 805ae7a:	8d 0c 00             	lea    (%eax,%eax,1),%ecx
 805ae7d:	8a 43 0c             	mov    0xc(%ebx),%al
 805ae80:	83 e0 fd             	and    $0xfffffffd,%eax
 805ae83:	09 c8                	or     %ecx,%eax
 805ae85:	88 43 0c             	mov    %al,0xc(%ebx)
		if (net_sin6(addr)->sin6_port == 0U) {
 805ae88:	66 83 7a 02 00       	cmpw   $0x0,0x2(%edx)
 805ae8d:	75 06                	jne    805ae95 <dns_postprocess_server+0xac>
				net_sin6(addr)->sin6_port = htons(53);
 805ae8f:	66 c7 42 02 00 35    	movw   $0x3500,0x2(%edx)
}
 805ae95:	5b                   	pop    %ebx
 805ae96:	5e                   	pop    %esi
 805ae97:	5d                   	pop    %ebp
 805ae98:	c3                   	ret    

0805ae99 <dns_resolve_init_locked>:
{
 805ae99:	55                   	push   %ebp
	struct sockaddr_in6 local_addr6 = {
 805ae9a:	b9 06 00 00 00       	mov    $0x6,%ecx
{
 805ae9f:	89 e5                	mov    %esp,%ebp
 805aea1:	57                   	push   %edi
 805aea2:	56                   	push   %esi
	struct sockaddr_in6 local_addr6 = {
 805aea3:	8d 7d cc             	lea    -0x34(%ebp),%edi
{
 805aea6:	53                   	push   %ebx
 805aea7:	83 ec 4c             	sub    $0x4c,%esp
 805aeaa:	8b 5d 08             	mov    0x8(%ebp),%ebx
 805aead:	8b 55 0c             	mov    0xc(%ebp),%edx
 805aeb0:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 805aeb6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 805aeb9:	31 c0                	xor    %eax,%eax
 805aebb:	8b 75 10             	mov    0x10(%ebp),%esi
	struct sockaddr_in local_addr4 = {
 805aebe:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
 805aec5:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
 805aecc:	66 c7 45 c4 01 00    	movw   $0x1,-0x3c(%ebp)
	struct sockaddr_in6 local_addr6 = {
 805aed2:	f3 ab                	rep stos %eax,%es:(%edi)
 805aed4:	66 c7 45 cc 02 00    	movw   $0x2,-0x34(%ebp)
		return -ENOENT;
 805aeda:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
	if (!ctx) {
 805aedf:	85 db                	test   %ebx,%ebx
 805aee1:	0f 84 f1 00 00 00    	je     805afd8 <dns_resolve_init_locked+0x13f>
	if (ctx->state != DNS_RESOLVE_CONTEXT_INACTIVE) {
 805aee7:	83 bb 84 00 00 00 02 	cmpl   $0x2,0x84(%ebx)
		ret = -ENOTEMPTY;
 805aeee:	b8 d9 ff ff ff       	mov    $0xffffffd9,%eax
	if (ctx->state != DNS_RESOLVE_CONTEXT_INACTIVE) {
 805aef3:	0f 85 df 00 00 00    	jne    805afd8 <dns_resolve_init_locked+0x13f>
	if (servers) {
 805aef9:	85 d2                	test   %edx,%edx
 805aefb:	74 38                	je     805af35 <dns_resolve_init_locked+0x9c>
		for (i = 0; idx < SERVER_COUNT && servers[i]; i++) {
 805aefd:	83 3a 00             	cmpl   $0x0,(%edx)
 805af00:	74 33                	je     805af35 <dns_resolve_init_locked+0x9c>
  return __builtin___memset_chk (__dest, __ch, __len,
 805af02:	31 c0                	xor    %eax,%eax
 805af04:	b9 06 00 00 00       	mov    $0x6,%ecx
 805af09:	89 df                	mov    %ebx,%edi
			ret = net_ipaddr_parse(servers[i], strlen(servers[i]),
 805af0b:	83 ec 0c             	sub    $0xc,%esp
 805af0e:	f3 ab                	rep stos %eax,%es:(%edi)
 805af10:	89 55 b4             	mov    %edx,-0x4c(%ebp)
 805af13:	8b 3a                	mov    (%edx),%edi
 805af15:	57                   	push   %edi
 805af16:	e8 25 e3 fe ff       	call   8049240 <strlen@plt>
 805af1b:	83 c4 0c             	add    $0xc,%esp
 805af1e:	53                   	push   %ebx
 805af1f:	50                   	push   %eax
 805af20:	57                   	push   %edi
 805af21:	e8 a2 87 ff ff       	call   80536c8 <net_ipaddr_parse>
			if (!ret) {
 805af26:	8b 55 b4             	mov    -0x4c(%ebp),%edx
			ret = net_ipaddr_parse(servers[i], strlen(servers[i]),
 805af29:	83 c4 10             	add    $0x10,%esp
			if (!ret) {
 805af2c:	83 c2 04             	add    $0x4,%edx
 805af2f:	84 c0                	test   %al,%al
 805af31:	74 ca                	je     805aefd <dns_resolve_init_locked+0x64>
 805af33:	eb 13                	jmp    805af48 <dns_resolve_init_locked+0xaf>
	if (servers_sa) {
 805af35:	85 f6                	test   %esi,%esi
 805af37:	74 18                	je     805af51 <dns_resolve_init_locked+0xb8>
		for (i = 0; idx < SERVER_COUNT && servers_sa[i]; i++) {
 805af39:	8b 36                	mov    (%esi),%esi
 805af3b:	85 f6                	test   %esi,%esi
 805af3d:	74 12                	je     805af51 <dns_resolve_init_locked+0xb8>
  return __builtin___memcpy_chk (__dest, __src, __len,
 805af3f:	b9 06 00 00 00       	mov    $0x6,%ecx
 805af44:	89 df                	mov    %ebx,%edi
 805af46:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
			dns_postprocess_server(ctx, idx);
 805af48:	31 d2                	xor    %edx,%edx
 805af4a:	89 d8                	mov    %ebx,%eax
 805af4c:	e8 98 fe ff ff       	call   805ade9 <dns_postprocess_server>
	     i < SERVER_COUNT && ctx->servers[i].dns_server.sa_family; i++) {
 805af51:	0f b7 13             	movzwl (%ebx),%edx
		ret = -EINVAL;
 805af54:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
	     i < SERVER_COUNT && ctx->servers[i].dns_server.sa_family; i++) {
 805af59:	66 85 d2             	test   %dx,%dx
 805af5c:	74 7a                	je     805afd8 <dns_resolve_init_locked+0x13f>
		if (ctx->servers[i].dns_server.sa_family == AF_INET6) {
 805af5e:	66 83 fa 02          	cmp    $0x2,%dx
 805af62:	75 61                	jne    805afc5 <dns_resolve_init_locked+0x12c>
			local_addr = (struct sockaddr *)&local_addr6;
 805af64:	8d 7d cc             	lea    -0x34(%ebp),%edi
			addr_len = sizeof(struct sockaddr_in6);
 805af67:	be 18 00 00 00       	mov    $0x18,%esi
		ret = net_context_get(ctx->servers[i].dns_server.sa_family,
 805af6c:	8d 43 18             	lea    0x18(%ebx),%eax
 805af6f:	50                   	push   %eax
 805af70:	6a 11                	push   $0x11
 805af72:	6a 02                	push   $0x2
 805af74:	52                   	push   %edx
 805af75:	e8 03 8a ff ff       	call   805397d <net_context_get>
 805af7a:	83 c4 10             	add    $0x10,%esp
		if (ret < 0) {
 805af7d:	85 c0                	test   %eax,%eax
 805af7f:	78 57                	js     805afd8 <dns_resolve_init_locked+0x13f>
		ret = net_context_bind(ctx->servers[i].net_ctx,
 805af81:	50                   	push   %eax
 805af82:	56                   	push   %esi
 805af83:	57                   	push   %edi
 805af84:	ff 73 18             	push   0x18(%ebx)
 805af87:	e8 9a 8c ff ff       	call   8053c26 <net_context_bind>
 805af8c:	83 c4 10             	add    $0x10,%esp
		if (ret < 0) {
 805af8f:	85 c0                	test   %eax,%eax
 805af91:	78 45                	js     805afd8 <dns_resolve_init_locked+0x13f>
 805af93:	8b 43 18             	mov    0x18(%ebx),%eax
 805af96:	0f be 80 9a 00 00 00 	movsbl 0x9a(%eax),%eax
 805af9d:	83 ec 0c             	sub    $0xc,%esp
 805afa0:	50                   	push   %eax
 805afa1:	e8 54 60 ff ff       	call   8050ffa <z_impl_net_if_get_by_index>
	ctx->buf_timeout = DNS_BUF_TIMEOUT;
 805afa6:	c7 43 34 32 00 00 00 	movl   $0x32,0x34(%ebx)
 805afad:	83 c4 10             	add    $0x10,%esp
	ret = 0;
 805afb0:	31 c0                	xor    %eax,%eax
	ctx->state = DNS_RESOLVE_CONTEXT_ACTIVE;
 805afb2:	c7 83 84 00 00 00 00 	movl   $0x0,0x84(%ebx)
 805afb9:	00 00 00 
	ctx->buf_timeout = DNS_BUF_TIMEOUT;
 805afbc:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)
	ret = 0;
 805afc3:	eb 13                	jmp    805afd8 <dns_resolve_init_locked+0x13f>
			local_addr = (struct sockaddr *)&local_addr4;
 805afc5:	8d 7d c4             	lea    -0x3c(%ebp),%edi
			addr_len = sizeof(struct sockaddr_in);
 805afc8:	be 08 00 00 00       	mov    $0x8,%esi
			ret = -EAFNOSUPPORT;
 805afcd:	b8 9f ff ff ff       	mov    $0xffffff9f,%eax
		if (ctx->servers[i].dns_server.sa_family == AF_INET) {
 805afd2:	66 83 fa 01          	cmp    $0x1,%dx
 805afd6:	74 94                	je     805af6c <dns_resolve_init_locked+0xd3>
}
 805afd8:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 805afdb:	65 2b 15 14 00 00 00 	sub    %gs:0x14,%edx
 805afe2:	74 05                	je     805afe9 <dns_resolve_init_locked+0x150>
 805afe4:	e8 17 e3 fe ff       	call   8049300 <__stack_chk_fail@plt>
 805afe9:	8d 65 f4             	lea    -0xc(%ebp),%esp
 805afec:	5b                   	pop    %ebx
 805afed:	5e                   	pop    %esi
 805afee:	5f                   	pop    %edi
 805afef:	5d                   	pop    %ebp
 805aff0:	c3                   	ret    

0805aff1 <dns_write.constprop.0>:
static int dns_write(struct dns_resolve_context *ctx,
 805aff1:	55                   	push   %ebp
 805aff2:	89 e5                	mov    %esp,%ebp
 805aff4:	57                   	push   %edi
	query_type = ctx->queries[query_idx].query_type;
 805aff5:	6b fa 48             	imul   $0x48,%edx,%edi
static int dns_write(struct dns_resolve_context *ctx,
 805aff8:	56                   	push   %esi
 805aff9:	89 ce                	mov    %ecx,%esi
 805affb:	53                   	push   %ebx
 805affc:	89 c3                	mov    %eax,%ebx
	query_type = ctx->queries[query_idx].query_type;
 805affe:	01 df                	add    %ebx,%edi
static int dns_write(struct dns_resolve_context *ctx,
 805b000:	83 ec 20             	sub    $0x20,%esp
	net_ctx = ctx->servers[server_idx].net_ctx;
 805b003:	8b 40 18             	mov    0x18(%eax),%eax
static int dns_write(struct dns_resolve_context *ctx,
 805b006:	8b 4d 08             	mov    0x8(%ebp),%ecx
	ret = dns_msg_pack_query(dns_data->data, &dns_data->len, dns_data->size,
 805b009:	ff 77 7c             	push   0x7c(%edi)
static int dns_write(struct dns_resolve_context *ctx,
 805b00c:	89 55 e0             	mov    %edx,-0x20(%ebp)
	net_ctx = ctx->servers[server_idx].net_ctx;
 805b00f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	ret = dns_msg_pack_query(dns_data->data, &dns_data->len, dns_data->size,
 805b012:	0f b7 87 80 00 00 00 	movzwl 0x80(%edi),%eax
 805b019:	50                   	push   %eax
 805b01a:	0f b7 41 10          	movzwl 0x10(%ecx),%eax
 805b01e:	50                   	push   %eax
 805b01f:	0f b7 46 12          	movzwl 0x12(%esi),%eax
 805b023:	ff 71 0c             	push   0xc(%ecx)
 805b026:	50                   	push   %eax
 805b027:	8d 46 10             	lea    0x10(%esi),%eax
 805b02a:	50                   	push   %eax
 805b02b:	ff 76 0c             	push   0xc(%esi)
 805b02e:	e8 d0 f9 ff ff       	call   805aa03 <dns_msg_pack_query>
 805b033:	83 c4 20             	add    $0x20,%esp
	if (ret < 0) {
 805b036:	85 c0                	test   %eax,%eax
 805b038:	0f 88 c8 00 00 00    	js     805b106 <dns_write.constprop.0+0x115>
			   dns_qname->len + 2);
 805b03e:	8b 4d 08             	mov    0x8(%ebp),%ecx
 805b041:	0f b7 41 10          	movzwl 0x10(%ecx),%eax
 805b045:	83 c0 02             	add    $0x2,%eax
 *
 * @return The computed CRC16 value
 */
static inline uint16_t crc16_ansi(const uint8_t *src, size_t len)
{
	return crc16_reflect(0xA001, 0xffff, src, len);
 805b048:	50                   	push   %eax
		crc16_ansi(dns_data->data + DNS_MSG_HEADER_SIZE,
 805b049:	8b 46 0c             	mov    0xc(%esi),%eax
 805b04c:	83 c0 0c             	add    $0xc,%eax
 805b04f:	50                   	push   %eax
 805b050:	68 ff ff 00 00       	push   $0xffff
 805b055:	68 01 a0 00 00       	push   $0xa001
 805b05a:	e8 11 f4 fe ff       	call   804a470 <crc16_reflect>
 805b05f:	83 c4 10             	add    $0x10,%esp
	ctx->queries[query_idx].query_hash =
 805b062:	66 89 87 82 00 00 00 	mov    %ax,0x82(%edi)
	return ((context->flags & NET_CONTEXT_FAMILY) >> 3);
 805b069:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 805b06c:	0f b7 80 98 00 00 00 	movzwl 0x98(%eax),%eax
 805b073:	c1 e8 03             	shr    $0x3,%eax
 805b076:	83 e0 07             	and    $0x7,%eax
	if (IS_ENABLED(CONFIG_NET_IPV6) &&
 805b079:	66 83 f8 02          	cmp    $0x2,%ax
 805b07d:	74 04                	je     805b083 <dns_write.constprop.0+0x92>
	} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
 805b07f:	66 48                	dec    %ax
 805b081:	75 0a                	jne    805b08d <dns_write.constprop.0+0x9c>
	context->ipv4_ttl = ttl;
 805b083:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 805b086:	c6 80 9b 00 00 00 00 	movb   $0x0,0x9b(%eax)
	ret = net_context_recv(net_ctx, cb_recv, K_NO_WAIT, ctx);
 805b08d:	83 ec 0c             	sub    $0xc,%esp
 805b090:	53                   	push   %ebx
 805b091:	6a 00                	push   $0x0
 805b093:	6a 00                	push   $0x0
 805b095:	68 99 b2 05 08       	push   $0x805b299
 805b09a:	ff 75 e4             	push   -0x1c(%ebp)
 805b09d:	e8 b8 96 ff ff       	call   805475a <net_context_recv>
 805b0a2:	83 c4 20             	add    $0x20,%esp
	if (ret < 0 && ret != -EALREADY) {
 805b0a5:	85 c0                	test   %eax,%eax
 805b0a7:	79 05                	jns    805b0ae <dns_write.constprop.0+0xbd>
 805b0a9:	83 f8 8e             	cmp    $0xffffff8e,%eax
 805b0ac:	75 5d                	jne    805b10b <dns_write.constprop.0+0x11a>
		server_addr_len = sizeof(struct sockaddr_in6);
 805b0ae:	66 83 3b 01          	cmpw   $0x1,(%ebx)
 805b0b2:	b8 18 00 00 00       	mov    $0x18,%eax
 805b0b7:	bf 08 00 00 00       	mov    $0x8,%edi
 805b0bc:	0f 45 f8             	cmovne %eax,%edi
	ret = k_work_reschedule(&ctx->queries[query_idx].timer,
 805b0bf:	50                   	push   %eax
 805b0c0:	6b 45 e0 48          	imul   $0x48,-0x20(%ebp),%eax
 805b0c4:	ff 74 03 74          	push   0x74(%ebx,%eax,1)
 805b0c8:	ff 74 03 70          	push   0x70(%ebx,%eax,1)
 805b0cc:	8d 44 03 3c          	lea    0x3c(%ebx,%eax,1),%eax
 805b0d0:	50                   	push   %eax
 805b0d1:	e8 0a 4c 00 00       	call   805fce0 <k_work_reschedule>
 805b0d6:	83 c4 10             	add    $0x10,%esp
	if (ret < 0) {
 805b0d9:	85 c0                	test   %eax,%eax
 805b0db:	78 2e                	js     805b10b <dns_write.constprop.0+0x11a>
	ret = net_context_sendto(net_ctx, dns_data->data, dns_data->len,
 805b0dd:	0f b7 46 10          	movzwl 0x10(%esi),%eax
 805b0e1:	83 ec 0c             	sub    $0xc,%esp
 805b0e4:	6a 00                	push   $0x0
 805b0e6:	6a 00                	push   $0x0
 805b0e8:	6a 00                	push   $0x0
 805b0ea:	6a 00                	push   $0x0
 805b0ec:	57                   	push   %edi
 805b0ed:	53                   	push   %ebx
 805b0ee:	50                   	push   %eax
 805b0ef:	ff 76 0c             	push   0xc(%esi)
 805b0f2:	ff 75 e4             	push   -0x1c(%ebp)
 805b0f5:	e8 16 96 ff ff       	call   8054710 <net_context_sendto>
	if (ret < 0) {
 805b0fa:	31 d2                	xor    %edx,%edx
	ret = net_context_sendto(net_ctx, dns_data->data, dns_data->len,
 805b0fc:	83 c4 30             	add    $0x30,%esp
 805b0ff:	85 c0                	test   %eax,%eax
 805b101:	0f 4f c2             	cmovg  %edx,%eax
 805b104:	eb 05                	jmp    805b10b <dns_write.constprop.0+0x11a>
		return -EINVAL;
 805b106:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
}
 805b10b:	8d 65 f4             	lea    -0xc(%ebp),%esp
 805b10e:	5b                   	pop    %ebx
 805b10f:	5e                   	pop    %esi
 805b110:	5f                   	pop    %edi
 805b111:	5d                   	pop    %ebp
 805b112:	c3                   	ret    

0805b113 <dns_resolve_init>:
{
 805b113:	55                   	push   %ebp
 805b114:	89 e5                	mov    %esp,%ebp
 805b116:	57                   	push   %edi
 805b117:	56                   	push   %esi
 805b118:	53                   	push   %ebx
 805b119:	83 ec 1c             	sub    $0x1c,%esp
 805b11c:	8b 55 10             	mov    0x10(%ebp),%edx
 805b11f:	8b 5d 08             	mov    0x8(%ebp),%ebx
 805b122:	8b 75 0c             	mov    0xc(%ebp),%esi
 805b125:	89 55 e4             	mov    %edx,-0x1c(%ebp)
	if (!ctx) {
 805b128:	85 db                	test   %ebx,%ebx
 805b12a:	74 3c                	je     805b168 <dns_resolve_init+0x55>
  return __builtin___memset_chk (__dest, __ch, __len,
 805b12c:	31 c0                	xor    %eax,%eax
 805b12e:	89 df                	mov    %ebx,%edi
 805b130:	b9 22 00 00 00       	mov    $0x22,%ecx
 805b135:	f3 ab                	rep stos %eax,%es:(%edi)
	return z_impl_k_mutex_init(mutex);
 805b137:	83 ec 0c             	sub    $0xc,%esp
	(void)k_mutex_init(&ctx->lock);
 805b13a:	8d 43 20             	lea    0x20(%ebx),%eax
 805b13d:	50                   	push   %eax
 805b13e:	e8 38 40 00 00       	call   805f17b <z_impl_k_mutex_init>
	return dns_resolve_init_locked(ctx, servers, servers_sa);
 805b143:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 805b146:	83 c4 10             	add    $0x10,%esp
	ctx->state = DNS_RESOLVE_CONTEXT_INACTIVE;
 805b149:	c7 83 84 00 00 00 02 	movl   $0x2,0x84(%ebx)
 805b150:	00 00 00 
	return dns_resolve_init_locked(ctx, servers, servers_sa);
 805b153:	89 75 0c             	mov    %esi,0xc(%ebp)
 805b156:	89 5d 08             	mov    %ebx,0x8(%ebp)
 805b159:	89 55 10             	mov    %edx,0x10(%ebp)
}
 805b15c:	8d 65 f4             	lea    -0xc(%ebp),%esp
 805b15f:	5b                   	pop    %ebx
 805b160:	5e                   	pop    %esi
 805b161:	5f                   	pop    %edi
 805b162:	5d                   	pop    %ebp
	return dns_resolve_init_locked(ctx, servers, servers_sa);
 805b163:	e9 31 fd ff ff       	jmp    805ae99 <dns_resolve_init_locked>
}
 805b168:	8d 65 f4             	lea    -0xc(%ebp),%esp
 805b16b:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
 805b170:	5b                   	pop    %ebx
 805b171:	5e                   	pop    %esi
 805b172:	5f                   	pop    %edi
 805b173:	5d                   	pop    %ebp
 805b174:	c3                   	ret    

0805b175 <dns_resolve_cancel_with_name>:
{
 805b175:	55                   	push   %ebp
 805b176:	89 e5                	mov    %esp,%ebp
 805b178:	57                   	push   %edi
 805b179:	56                   	push   %esi
 805b17a:	53                   	push   %ebx
 805b17b:	83 ec 2c             	sub    $0x2c,%esp
 805b17e:	8b 45 0c             	mov    0xc(%ebp),%eax
 805b181:	8b 75 10             	mov    0x10(%ebp),%esi
 805b184:	8b 7d 08             	mov    0x8(%ebp),%edi
 805b187:	89 45 d4             	mov    %eax,-0x2c(%ebp)
 805b18a:	8b 45 14             	mov    0x14(%ebp),%eax
 805b18d:	89 45 d0             	mov    %eax,-0x30(%ebp)
 805b190:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 805b196:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 805b199:	31 c0                	xor    %eax,%eax
	if (query_name) {
 805b19b:	85 f6                	test   %esi,%esi
 805b19d:	0f 84 b8 00 00 00    	je     805b25b <dns_resolve_cancel_with_name+0xe6>
	return net_buf_alloc_fixed(pool, timeout);
 805b1a3:	51                   	push   %ecx
 805b1a4:	ff 77 38             	push   0x38(%edi)
 805b1a7:	ff 77 34             	push   0x34(%edi)
 805b1aa:	68 00 76 06 08       	push   $0x8067600
 805b1af:	e8 ac 3f ff ff       	call   804f160 <net_buf_alloc_fixed>
 805b1b4:	83 c4 10             	add    $0x10,%esp
 805b1b7:	89 c3                	mov    %eax,%ebx
		if (!buf) {
 805b1b9:	85 c0                	test   %eax,%eax
 805b1bb:	0f 84 93 00 00 00    	je     805b254 <dns_resolve_cancel_with_name+0xdf>
		ret = dns_msg_pack_qname(&len, buf->data, buf->size,
 805b1c1:	56                   	push   %esi
 805b1c2:	0f b7 40 12          	movzwl 0x12(%eax),%eax
 805b1c6:	50                   	push   %eax
 805b1c7:	8d 45 e2             	lea    -0x1e(%ebp),%eax
 805b1ca:	ff 73 0c             	push   0xc(%ebx)
 805b1cd:	50                   	push   %eax
 805b1ce:	e8 55 f6 ff ff       	call   805a828 <dns_msg_pack_qname>
 805b1d3:	83 c4 10             	add    $0x10,%esp
 805b1d6:	89 c6                	mov    %eax,%esi
		if (ret >= 0) {
 805b1d8:	85 c0                	test   %eax,%eax
 805b1da:	78 5e                	js     805b23a <dns_resolve_cancel_with_name+0xc5>
			if ((len + 2) > buf->size) {
 805b1dc:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
 805b1e0:	0f b7 53 12          	movzwl 0x12(%ebx),%edx
 805b1e4:	8d 48 01             	lea    0x1(%eax),%ecx
 805b1e7:	39 d1                	cmp    %edx,%ecx
 805b1e9:	7c 0e                	jl     805b1f9 <dns_resolve_cancel_with_name+0x84>
				net_buf_unref(buf);
 805b1eb:	83 ec 0c             	sub    $0xc,%esp
 805b1ee:	53                   	push   %ebx
 805b1ef:	e8 8e 3f ff ff       	call   804f182 <net_buf_unref>
 805b1f4:	83 c4 10             	add    $0x10,%esp
				return -ENOMEM;
 805b1f7:	eb 5b                	jmp    805b254 <dns_resolve_cancel_with_name+0xdf>
	return net_buf_simple_add(&buf->b, len);
 805b1f9:	8d 53 0c             	lea    0xc(%ebx),%edx
 805b1fc:	51                   	push   %ecx
 805b1fd:	51                   	push   %ecx
 805b1fe:	50                   	push   %eax
 805b1ff:	52                   	push   %edx
 805b200:	89 55 cc             	mov    %edx,-0x34(%ebp)
 805b203:	e8 35 40 ff ff       	call   804f23d <net_buf_simple_add>
 805b208:	58                   	pop    %eax
			net_buf_add_be16(buf, query_type);
 805b209:	0f b7 45 d0          	movzwl -0x30(%ebp),%eax
 805b20d:	5a                   	pop    %edx
	net_buf_simple_add_be16(&buf->b, val);
 805b20e:	8b 55 cc             	mov    -0x34(%ebp),%edx
 805b211:	50                   	push   %eax
 805b212:	52                   	push   %edx
 805b213:	e8 3c 40 ff ff       	call   804f254 <net_buf_simple_add_be16>
			query_hash = crc16_ansi(buf->data, len + 2);
 805b218:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
 805b21c:	83 c4 10             	add    $0x10,%esp
 805b21f:	83 c0 02             	add    $0x2,%eax
 805b222:	50                   	push   %eax
 805b223:	ff 73 0c             	push   0xc(%ebx)
 805b226:	68 ff ff 00 00       	push   $0xffff
 805b22b:	68 01 a0 00 00       	push   $0xa001
 805b230:	e8 3b f2 fe ff       	call   804a470 <crc16_reflect>
 805b235:	83 c4 10             	add    $0x10,%esp
 805b238:	eb 02                	jmp    805b23c <dns_resolve_cancel_with_name+0xc7>
	uint16_t query_hash = 0;
 805b23a:	31 c0                	xor    %eax,%eax
		net_buf_unref(buf);
 805b23c:	83 ec 0c             	sub    $0xc,%esp
 805b23f:	89 45 d0             	mov    %eax,-0x30(%ebp)
 805b242:	53                   	push   %ebx
 805b243:	e8 3a 3f ff ff       	call   804f182 <net_buf_unref>
 805b248:	83 c4 10             	add    $0x10,%esp
		if (ret < 0) {
 805b24b:	85 f6                	test   %esi,%esi
 805b24d:	8b 45 d0             	mov    -0x30(%ebp),%eax
 805b250:	79 0b                	jns    805b25d <dns_resolve_cancel_with_name+0xe8>
 805b252:	eb 2a                	jmp    805b27e <dns_resolve_cancel_with_name+0x109>
			return -ENOMEM;
 805b254:	be f4 ff ff ff       	mov    $0xfffffff4,%esi
 805b259:	eb 23                	jmp    805b27e <dns_resolve_cancel_with_name+0x109>
	uint16_t query_hash = 0;
 805b25b:	31 c0                	xor    %eax,%eax
	return dns_resolve_cancel_with_hash(ctx, dns_id, query_hash,
 805b25d:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 805b260:	65 2b 15 14 00 00 00 	sub    %gs:0x14,%edx
 805b267:	75 21                	jne    805b28a <dns_resolve_cancel_with_name+0x115>
 805b269:	0f b7 55 d4          	movzwl -0x2c(%ebp),%edx
}
 805b26d:	8d 65 f4             	lea    -0xc(%ebp),%esp
	return dns_resolve_cancel_with_hash(ctx, dns_id, query_hash,
 805b270:	0f b7 c8             	movzwl %ax,%ecx
 805b273:	89 f8                	mov    %edi,%eax
}
 805b275:	5b                   	pop    %ebx
 805b276:	5e                   	pop    %esi
 805b277:	5f                   	pop    %edi
 805b278:	5d                   	pop    %ebp
	return dns_resolve_cancel_with_hash(ctx, dns_id, query_hash,
 805b279:	e9 3d fa ff ff       	jmp    805acbb <dns_resolve_cancel_with_hash.constprop.0>
}
 805b27e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 805b281:	65 2b 05 14 00 00 00 	sub    %gs:0x14,%eax
 805b288:	74 05                	je     805b28f <dns_resolve_cancel_with_name+0x11a>
 805b28a:	e8 71 e0 fe ff       	call   8049300 <__stack_chk_fail@plt>
 805b28f:	8d 65 f4             	lea    -0xc(%ebp),%esp
 805b292:	89 f0                	mov    %esi,%eax
 805b294:	5b                   	pop    %ebx
 805b295:	5e                   	pop    %esi
 805b296:	5f                   	pop    %edi
 805b297:	5d                   	pop    %ebp
 805b298:	c3                   	ret    

0805b299 <cb_recv>:
{
 805b299:	55                   	push   %ebp
	k_mutex_lock(&ctx->lock, K_FOREVER);
 805b29a:	83 ca ff             	or     $0xffffffff,%edx
 805b29d:	89 d1                	mov    %edx,%ecx
{
 805b29f:	89 e5                	mov    %esp,%ebp
 805b2a1:	57                   	push   %edi
 805b2a2:	56                   	push   %esi
 805b2a3:	53                   	push   %ebx
 805b2a4:	81 ec 9c 00 00 00    	sub    $0x9c,%esp
 805b2aa:	8b 45 0c             	mov    0xc(%ebp),%eax
 805b2ad:	8b 5d 18             	mov    0x18(%ebp),%ebx
 805b2b0:	89 85 6c ff ff ff    	mov    %eax,-0x94(%ebp)
 805b2b6:	8b 45 1c             	mov    0x1c(%ebp),%eax
 805b2b9:	89 45 84             	mov    %eax,-0x7c(%ebp)
	k_mutex_lock(&ctx->lock, K_FOREVER);
 805b2bc:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 805b2c2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 805b2c5:	8b 45 84             	mov    -0x7c(%ebp),%eax
 805b2c8:	83 c0 20             	add    $0x20,%eax
 805b2cb:	89 85 68 ff ff ff    	mov    %eax,-0x98(%ebp)
 805b2d1:	e8 0d f9 ff ff       	call   805abe3 <k_mutex_lock>
	if (ctx->state != DNS_RESOLVE_CONTEXT_ACTIVE) {
 805b2d6:	8b 45 84             	mov    -0x7c(%ebp),%eax
 805b2d9:	83 b8 84 00 00 00 00 	cmpl   $0x0,0x84(%eax)
 805b2e0:	0f 85 89 04 00 00    	jne    805b76f <cb_recv+0x4d6>
	if (status) {
 805b2e6:	85 db                	test   %ebx,%ebx
 805b2e8:	0f 85 db 03 00 00    	jne    805b6c9 <cb_recv+0x430>
	return net_buf_alloc_fixed(pool, timeout);
 805b2ee:	57                   	push   %edi
 805b2ef:	ff 70 38             	push   0x38(%eax)
 805b2f2:	ff 70 34             	push   0x34(%eax)
 805b2f5:	68 00 76 06 08       	push   $0x8067600
 805b2fa:	e8 61 3e ff ff       	call   804f160 <net_buf_alloc_fixed>
 805b2ff:	83 c4 10             	add    $0x10,%esp
 805b302:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
	if (!dns_data) {
 805b308:	85 c0                	test   %eax,%eax
 805b30a:	0f 84 e0 03 00 00    	je     805b6f0 <cb_recv+0x457>
 805b310:	8b 45 84             	mov    -0x7c(%ebp),%eax
 805b313:	56                   	push   %esi
 805b314:	ff 70 38             	push   0x38(%eax)
 805b317:	ff 70 34             	push   0x34(%eax)
 805b31a:	68 2c 76 06 08       	push   $0x806762c
 805b31f:	e8 3c 3e ff ff       	call   804f160 <net_buf_alloc_fixed>
 805b324:	83 c4 10             	add    $0x10,%esp
 805b327:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
	if (!dns_cname) {
 805b32d:	85 c0                	test   %eax,%eax
 805b32f:	0f 84 c5 03 00 00    	je     805b6fa <cb_recv+0x461>
	data_len = MIN(net_pkt_remaining_data(pkt), DNS_RESOLVER_MAX_BUF_SIZE);
 805b335:	83 ec 0c             	sub    $0xc,%esp
 805b338:	ff b5 6c ff ff ff    	push   -0x94(%ebp)
 805b33e:	be 00 02 00 00       	mov    $0x200,%esi
 805b343:	e8 3c a3 ff ff       	call   8055684 <net_pkt_remaining_data>
 805b348:	83 c4 10             	add    $0x10,%esp
 805b34b:	3d ff 01 00 00       	cmp    $0x1ff,%eax
 805b350:	77 13                	ja     805b365 <cb_recv+0xcc>
 805b352:	83 ec 0c             	sub    $0xc,%esp
 805b355:	ff b5 6c ff ff ff    	push   -0x94(%ebp)
 805b35b:	e8 24 a3 ff ff       	call   8055684 <net_pkt_remaining_data>
 805b360:	83 c4 10             	add    $0x10,%esp
 805b363:	89 c6                	mov    %eax,%esi
	ret = net_pkt_read(pkt, dns_data->data, data_len);
 805b365:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
 805b36b:	51                   	push   %ecx
 805b36c:	56                   	push   %esi
 805b36d:	ff 70 0c             	push   0xc(%eax)
 805b370:	ff b5 6c ff ff ff    	push   -0x94(%ebp)
 805b376:	e8 9f a1 ff ff       	call   805551a <net_pkt_read>
 805b37b:	83 c4 10             	add    $0x10,%esp
	if (ret < 0) {
 805b37e:	85 c0                	test   %eax,%eax
 805b380:	0f 88 f8 02 00 00    	js     805b67e <cb_recv+0x3e5>
	dns_msg.msg = dns_data->data;
 805b386:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
	struct dns_addrinfo info = { 0 };
 805b38c:	8d 7d b0             	lea    -0x50(%ebp),%edi
 805b38f:	b9 0d 00 00 00       	mov    $0xd,%ecx
	dns_msg.msg = dns_data->data;
 805b394:	8b 50 0c             	mov    0xc(%eax),%edx
	struct dns_addrinfo info = { 0 };
 805b397:	31 c0                	xor    %eax,%eax
	dns_msg.msg_size = data_len;
 805b399:	66 89 75 ac          	mov    %si,-0x54(%ebp)
	struct dns_addrinfo info = { 0 };
 805b39d:	f3 ab                	rep stos %eax,%es:(%edi)
	dns_msg.msg = dns_data->data;
 805b39f:	89 55 9c             	mov    %edx,-0x64(%ebp)
	if (dns_msg->msg_size < (sizeof(*dns_id) + sizeof(uint16_t))) {
 805b3a2:	66 83 fe 03          	cmp    $0x3,%si
 805b3a6:	0f 86 4a 04 00 00    	jbe    805b7f6 <cb_recv+0x55d>
	return ntohs(UNALIGNED_GET((uint16_t *)(header)));
 805b3ac:	66 8b 02             	mov    (%edx),%ax
 805b3af:	86 e0                	xchg   %ah,%al
 805b3b1:	66 89 45 80          	mov    %ax,-0x80(%ebp)
	if (dns_header_rcode(dns_msg->msg) == DNS_HEADER_REFUSED) {
 805b3b5:	8a 42 03             	mov    0x3(%edx),%al
 805b3b8:	83 e0 0f             	and    $0xf,%eax
 805b3bb:	3c 05                	cmp    $0x5,%al
 805b3bd:	0f 84 39 04 00 00    	je     805b7fc <cb_recv+0x563>
	return ((*(header + 2)) & 0x80) ? 1 : 0;
 805b3c3:	8a 42 02             	mov    0x2(%edx),%al
	uint16_t query_hash = 0U;
 805b3c6:	66 c7 45 82 00 00    	movw   $0x0,-0x7e(%ebp)
	if (dns_header_qr(dns_msg->msg) == DNS_QUERY) {
 805b3cc:	c0 e8 07             	shr    $0x7,%al
 805b3cf:	88 85 5f ff ff ff    	mov    %al,-0xa1(%ebp)
 805b3d5:	0f 84 b4 02 00 00    	je     805b68f <cb_recv+0x3f6>
	return ntohs(UNALIGNED_GET((uint16_t *)(header)));
 805b3db:	0f b7 45 80          	movzwl -0x80(%ebp),%eax
	ret = dns_unpack_response_header(dns_msg, *dns_id);
 805b3df:	52                   	push   %edx
 805b3e0:	52                   	push   %edx
 805b3e1:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
 805b3e7:	50                   	push   %eax
 805b3e8:	8d 45 9c             	lea    -0x64(%ebp),%eax
 805b3eb:	50                   	push   %eax
 805b3ec:	e8 a4 f5 ff ff       	call   805a995 <dns_unpack_response_header>
 805b3f1:	83 c4 10             	add    $0x10,%esp
	if (ret < 0) {
 805b3f4:	85 c0                	test   %eax,%eax
 805b3f6:	0f 88 06 04 00 00    	js     805b802 <cb_recv+0x569>
		if (*dns_id > 0) {
 805b3fc:	8b 45 9c             	mov    -0x64(%ebp),%eax
 805b3ff:	66 81 78 04 00 01    	cmpw   $0x100,0x4(%eax)
 805b405:	74 0b                	je     805b412 <cb_recv+0x179>
 805b407:	66 83 7d 80 00       	cmpw   $0x0,-0x80(%ebp)
 805b40c:	0f 85 f0 03 00 00    	jne    805b802 <cb_recv+0x569>
	ret = dns_unpack_response_query(dns_msg);
 805b412:	83 ec 0c             	sub    $0xc,%esp
 805b415:	8d 45 9c             	lea    -0x64(%ebp),%eax
 805b418:	50                   	push   %eax
 805b419:	e8 6c f6 ff ff       	call   805aa8a <dns_unpack_response_query>
 805b41e:	83 c4 10             	add    $0x10,%esp
	if (ret < 0) {
 805b421:	85 c0                	test   %eax,%eax
 805b423:	79 12                	jns    805b437 <cb_recv+0x19e>
		if (*dns_id > 0) {
 805b425:	66 83 7d 80 00       	cmpw   $0x0,-0x80(%ebp)
 805b42a:	0f 85 cc 03 00 00    	jne    805b7fc <cb_recv+0x563>
		dns_msg->answer_offset = dns_msg->query_offset;
 805b430:	8b 45 a8             	mov    -0x58(%ebp),%eax
 805b433:	66 89 45 aa          	mov    %ax,-0x56(%ebp)
	enum dns_rr_type answer_type = DNS_RR_TYPE_INVALID;
 805b437:	c7 45 98 00 00 00 00 	movl   $0x0,-0x68(%ebp)
	server_idx = 0;
 805b43e:	c7 85 60 ff ff ff 00 	movl   $0x0,-0xa0(%ebp)
 805b445:	00 00 00 
	int query_idx = -1;
 805b448:	c7 85 78 ff ff ff ff 	movl   $0xffffffff,-0x88(%ebp)
 805b44f:	ff ff ff 
	uint16_t query_hash = 0U;
 805b452:	66 c7 45 82 00 00    	movw   $0x0,-0x7e(%ebp)
	answer_ptr = DNS_QUERY_POS;
 805b458:	c7 85 64 ff ff ff 0c 	movl   $0xc,-0x9c(%ebp)
 805b45f:	00 00 00 
	while (server_idx < dns_header_ancount(dns_msg->msg)) {
 805b462:	8b 75 9c             	mov    -0x64(%ebp),%esi
	return htons(UNALIGNED_GET((uint16_t *)(header + 6)));
 805b465:	66 8b 46 06          	mov    0x6(%esi),%ax
 805b469:	86 e0                	xchg   %ah,%al
 805b46b:	0f b7 c0             	movzwl %ax,%eax
 805b46e:	39 85 60 ff ff ff    	cmp    %eax,-0xa0(%ebp)
 805b474:	0f 8d 5b 01 00 00    	jge    805b5d5 <cb_recv+0x33c>
		ret = dns_unpack_answer(dns_msg, answer_ptr, &ttl,
 805b47a:	8d 45 98             	lea    -0x68(%ebp),%eax
 805b47d:	50                   	push   %eax
 805b47e:	8d 45 94             	lea    -0x6c(%ebp),%eax
 805b481:	50                   	push   %eax
 805b482:	8d 45 9c             	lea    -0x64(%ebp),%eax
 805b485:	ff b5 64 ff ff ff    	push   -0x9c(%ebp)
 805b48b:	50                   	push   %eax
 805b48c:	e8 36 f4 ff ff       	call   805a8c7 <dns_unpack_answer>
 805b491:	83 c4 10             	add    $0x10,%esp
		if (ret < 0) {
 805b494:	85 c0                	test   %eax,%eax
 805b496:	0f 88 66 03 00 00    	js     805b802 <cb_recv+0x569>
		switch (dns_msg->response_type) {
 805b49c:	8b 45 a0             	mov    -0x60(%ebp),%eax
 805b49f:	83 f8 eb             	cmp    $0xffffffeb,%eax
 805b4a2:	74 18                	je     805b4bc <cb_recv+0x223>
 805b4a4:	83 f8 ed             	cmp    $0xffffffed,%eax
 805b4a7:	0f 85 55 03 00 00    	jne    805b802 <cb_recv+0x569>
			answer_ptr = dns_msg->response_position;
 805b4ad:	0f b7 45 a4          	movzwl -0x5c(%ebp),%eax
 805b4b1:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%ebp)
			break;
 805b4b7:	e9 03 01 00 00       	jmp    805b5bf <cb_recv+0x326>
			if (*query_idx >= 0) {
 805b4bc:	83 bd 78 ff ff ff ff 	cmpl   $0xffffffff,-0x88(%ebp)
 805b4c3:	75 4d                	jne    805b512 <cb_recv+0x279>
						 strlen(query_name) + 1 + 2);
 805b4c5:	83 ec 0c             	sub    $0xc,%esp
			query_name = dns_msg->msg + dns_msg->query_offset;
 805b4c8:	0f b7 75 a8          	movzwl -0x58(%ebp),%esi
 805b4cc:	03 75 9c             	add    -0x64(%ebp),%esi
						 strlen(query_name) + 1 + 2);
 805b4cf:	56                   	push   %esi
 805b4d0:	e8 6b dd fe ff       	call   8049240 <strlen@plt>
 805b4d5:	83 c4 10             	add    $0x10,%esp
			*query_hash = crc16_ansi(query_name,
 805b4d8:	83 c0 03             	add    $0x3,%eax
 805b4db:	50                   	push   %eax
 805b4dc:	56                   	push   %esi
 805b4dd:	68 ff ff 00 00       	push   $0xffff
 805b4e2:	68 01 a0 00 00       	push   $0xa001
 805b4e7:	e8 84 ef fe ff       	call   804a470 <crc16_reflect>
			*query_idx = get_slot_by_id(ctx, *dns_id, *query_hash);
 805b4ec:	8b 95 70 ff ff ff    	mov    -0x90(%ebp),%edx
 805b4f2:	83 c4 10             	add    $0x10,%esp
 805b4f5:	66 89 45 82          	mov    %ax,-0x7e(%ebp)
 805b4f9:	0f b7 c8             	movzwl %ax,%ecx
 805b4fc:	8b 45 84             	mov    -0x7c(%ebp),%eax
 805b4ff:	e8 f6 f6 ff ff       	call   805abfa <get_slot_by_id>
 805b504:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
			if (*query_idx < 0) {
 805b50a:	85 c0                	test   %eax,%eax
 805b50c:	0f 88 0e 03 00 00    	js     805b820 <cb_recv+0x587>
			if (ctx->queries[*query_idx].query_type ==
 805b512:	6b 85 78 ff ff ff 48 	imul   $0x48,-0x88(%ebp),%eax
 805b519:	8b 7d 84             	mov    -0x7c(%ebp),%edi
 805b51c:	8b 44 07 7c          	mov    0x7c(%edi,%eax,1),%eax
 805b520:	83 f8 01             	cmp    $0x1,%eax
 805b523:	75 22                	jne    805b547 <cb_recv+0x2ae>
				if (answer_type != DNS_RR_TYPE_A) {
 805b525:	83 7d 98 01          	cmpl   $0x1,-0x68(%ebp)
 805b529:	0f 85 e7 02 00 00    	jne    805b816 <cb_recv+0x57d>
 805b52f:	ba 01 00 00 00       	mov    $0x1,%edx
 805b534:	bf 08 00 00 00       	mov    $0x8,%edi
				address_size = DNS_IPV4_LEN;
 805b539:	b9 04 00 00 00       	mov    $0x4,%ecx
 805b53e:	0f b6 b5 5f ff ff ff 	movzbl -0xa1(%ebp),%esi
 805b545:	eb 27                	jmp    805b56e <cb_recv+0x2d5>
			} else if (ctx->queries[*query_idx].query_type ==
 805b547:	83 f8 1c             	cmp    $0x1c,%eax
 805b54a:	0f 85 bc 02 00 00    	jne    805b80c <cb_recv+0x573>
				if (answer_type != DNS_RR_TYPE_AAAA) {
 805b550:	83 7d 98 1c          	cmpl   $0x1c,-0x68(%ebp)
 805b554:	0f 85 bc 02 00 00    	jne    805b816 <cb_recv+0x57d>
 805b55a:	be 02 00 00 00       	mov    $0x2,%esi
 805b55f:	ba 02 00 00 00       	mov    $0x2,%edx
 805b564:	bf 18 00 00 00       	mov    $0x18,%edi
				address_size = DNS_IPV6_LEN;
 805b569:	b9 10 00 00 00       	mov    $0x10,%ecx
				info.ai_family = AF_INET;
 805b56e:	89 f0                	mov    %esi,%eax
				info.ai_addr.sa_family = AF_INET;
 805b570:	66 89 55 b0          	mov    %dx,-0x50(%ebp)
				info.ai_family = AF_INET;
 805b574:	88 45 cc             	mov    %al,-0x34(%ebp)
			if (dns_msg->response_length < address_size) {
 805b577:	0f b7 45 a6          	movzwl -0x5a(%ebp),%eax
				info.ai_addrlen = sizeof(struct sockaddr_in);
 805b57b:	89 7d c8             	mov    %edi,-0x38(%ebp)
			if (dns_msg->response_length < address_size) {
 805b57e:	39 c8                	cmp    %ecx,%eax
 805b580:	0f 8c 7c 02 00 00    	jl     805b802 <cb_recv+0x569>
			if ((dns_msg->response_position + address_size) >
 805b586:	0f b7 75 a4          	movzwl -0x5c(%ebp),%esi
			    dns_msg->msg_size) {
 805b58a:	0f b7 45 ac          	movzwl -0x54(%ebp),%eax
			if ((dns_msg->response_position + address_size) >
 805b58e:	8d 14 0e             	lea    (%esi,%ecx,1),%edx
 805b591:	39 c2                	cmp    %eax,%edx
 805b593:	0f 8f 69 02 00 00    	jg     805b802 <cb_recv+0x569>
  return __builtin___memcpy_chk (__dest, __src, __len,
 805b599:	8d 45 b4             	lea    -0x4c(%ebp),%eax
			src = dns_msg->msg + dns_msg->response_position;
 805b59c:	03 75 9c             	add    -0x64(%ebp),%esi
			invoke_query_callback(DNS_EAI_INPROGRESS, &info,
 805b59f:	8d 55 b0             	lea    -0x50(%ebp),%edx
			items++;
 805b5a2:	43                   	inc    %ebx
 805b5a3:	89 c7                	mov    %eax,%edi
			invoke_query_callback(DNS_EAI_INPROGRESS, &info,
 805b5a5:	6b 85 78 ff ff ff 48 	imul   $0x48,-0x88(%ebp),%eax
 805b5ac:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
 805b5ae:	8b 7d 84             	mov    -0x7c(%ebp),%edi
 805b5b1:	8d 4c 07 3c          	lea    0x3c(%edi,%eax,1),%ecx
 805b5b5:	b8 9c ff ff ff       	mov    $0xffffff9c,%eax
 805b5ba:	e8 ff f5 ff ff       	call   805abbe <invoke_query_callback>
		dns_msg->answer_offset += dns_msg->response_length;
 805b5bf:	66 8b 45 a6          	mov    -0x5a(%ebp),%ax
 805b5c3:	03 45 a4             	add    -0x5c(%ebp),%eax
		server_idx++;
 805b5c6:	ff 85 60 ff ff ff    	incl   -0xa0(%ebp)
		dns_msg->answer_offset += dns_msg->response_length;
 805b5cc:	66 89 45 aa          	mov    %ax,-0x56(%ebp)
		server_idx++;
 805b5d0:	e9 8d fe ff ff       	jmp    805b462 <cb_recv+0x1c9>
	if (*query_idx < 0) {
 805b5d5:	83 bd 78 ff ff ff ff 	cmpl   $0xffffffff,-0x88(%ebp)
 805b5dc:	75 4c                	jne    805b62a <cb_recv+0x391>
		query_name = dns_msg->msg + dns_msg->query_offset;
 805b5de:	0f b7 45 a8          	movzwl -0x58(%ebp),%eax
					 strlen(query_name) + 1 + 2);
 805b5e2:	83 ec 0c             	sub    $0xc,%esp
		query_name = dns_msg->msg + dns_msg->query_offset;
 805b5e5:	01 c6                	add    %eax,%esi
					 strlen(query_name) + 1 + 2);
 805b5e7:	56                   	push   %esi
 805b5e8:	e8 53 dc fe ff       	call   8049240 <strlen@plt>
 805b5ed:	83 c4 10             	add    $0x10,%esp
		*query_hash = crc16_ansi(query_name,
 805b5f0:	83 c0 03             	add    $0x3,%eax
 805b5f3:	50                   	push   %eax
 805b5f4:	56                   	push   %esi
 805b5f5:	68 ff ff 00 00       	push   $0xffff
 805b5fa:	68 01 a0 00 00       	push   $0xa001
 805b5ff:	e8 6c ee fe ff       	call   804a470 <crc16_reflect>
		*query_idx = get_slot_by_id(ctx, *dns_id, *query_hash);
 805b604:	8b 95 70 ff ff ff    	mov    -0x90(%ebp),%edx
 805b60a:	83 c4 10             	add    $0x10,%esp
 805b60d:	66 89 45 82          	mov    %ax,-0x7e(%ebp)
 805b611:	0f b7 c8             	movzwl %ax,%ecx
 805b614:	8b 45 84             	mov    -0x7c(%ebp),%eax
 805b617:	e8 de f5 ff ff       	call   805abfa <get_slot_by_id>
 805b61c:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
		if (*query_idx < 0) {
 805b622:	85 c0                	test   %eax,%eax
 805b624:	0f 88 f6 01 00 00    	js     805b820 <cb_recv+0x587>
	if (items == 0) {
 805b62a:	85 db                	test   %ebx,%ebx
 805b62c:	0f 85 f8 01 00 00    	jne    805b82a <cb_recv+0x591>
		if (dns_msg->response_type == DNS_RESPONSE_CNAME_NO_IP) {
 805b632:	83 7d a0 ed          	cmpl   $0xffffffed,-0x60(%ebp)
		ret = DNS_EAI_NODATA;
 805b636:	bb fb ff ff ff       	mov    $0xfffffffb,%ebx
		if (dns_msg->response_type == DNS_RESPONSE_CNAME_NO_IP) {
 805b63b:	75 52                	jne    805b68f <cb_recv+0x3f6>
				ret = dns_copy_qname(dns_cname->data,
 805b63d:	0f b7 45 a4          	movzwl -0x5c(%ebp),%eax
 805b641:	83 ec 0c             	sub    $0xc,%esp
					ret = DNS_EAI_SYSTEM;
 805b644:	bb f5 ff ff ff       	mov    $0xfffffff5,%ebx
				ret = dns_copy_qname(dns_cname->data,
 805b649:	50                   	push   %eax
 805b64a:	8d 45 9c             	lea    -0x64(%ebp),%eax
 805b64d:	50                   	push   %eax
 805b64e:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
 805b654:	0f b7 40 12          	movzwl 0x12(%eax),%eax
 805b658:	50                   	push   %eax
 805b659:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
 805b65f:	83 c0 10             	add    $0x10,%eax
 805b662:	50                   	push   %eax
 805b663:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
 805b669:	ff 70 0c             	push   0xc(%eax)
 805b66c:	e8 98 f4 ff ff       	call   805ab09 <dns_copy_qname>
 805b671:	83 c4 20             	add    $0x20,%esp
				if (ret < 0) {
 805b674:	85 c0                	test   %eax,%eax
 805b676:	0f 89 16 01 00 00    	jns    805b792 <cb_recv+0x4f9>
 805b67c:	eb 11                	jmp    805b68f <cb_recv+0x3f6>
	uint16_t dns_id = 0U;
 805b67e:	66 c7 45 80 00 00    	movw   $0x0,-0x80(%ebp)
		ret = DNS_EAI_MEMORY;
 805b684:	bb f6 ff ff ff       	mov    $0xfffffff6,%ebx
	uint16_t query_hash = 0U;
 805b689:	66 c7 45 82 00 00    	movw   $0x0,-0x7e(%ebp)
	net_pkt_unref(pkt);
 805b68f:	83 ec 0c             	sub    $0xc,%esp
 805b692:	ff b5 6c ff ff ff    	push   -0x94(%ebp)
 805b698:	e8 4b 97 ff ff       	call   8054de8 <net_pkt_unref>
 805b69d:	83 c4 10             	add    $0x10,%esp
	if (!ret) {
 805b6a0:	85 db                	test   %ebx,%ebx
 805b6a2:	0f 84 9c 00 00 00    	je     805b744 <cb_recv+0x4ab>
		i = get_slot_by_id(ctx, dns_id, query_hash);
 805b6a8:	0f b7 55 80          	movzwl -0x80(%ebp),%edx
 805b6ac:	0f b7 4d 82          	movzwl -0x7e(%ebp),%ecx
 805b6b0:	8b 45 84             	mov    -0x7c(%ebp),%eax
 805b6b3:	e8 42 f5 ff ff       	call   805abfa <get_slot_by_id>
 805b6b8:	89 c2                	mov    %eax,%edx
	if (ret == DNS_EAI_AGAIN) {
 805b6ba:	83 fb fd             	cmp    $0xfffffffd,%ebx
 805b6bd:	75 4c                	jne    805b70b <cb_recv+0x472>
		if (i < 0) {
 805b6bf:	85 c0                	test   %eax,%eax
 805b6c1:	0f 89 f6 00 00 00    	jns    805b7bd <cb_recv+0x524>
 805b6c7:	eb 7b                	jmp    805b744 <cb_recv+0x4ab>
	uint16_t dns_id = 0U;
 805b6c9:	66 c7 45 80 00 00    	movw   $0x0,-0x80(%ebp)
		ret = DNS_EAI_SYSTEM;
 805b6cf:	bb f5 ff ff ff       	mov    $0xfffffff5,%ebx
	uint16_t query_hash = 0U;
 805b6d4:	66 c7 45 82 00 00    	movw   $0x0,-0x7e(%ebp)
	struct net_buf *dns_data = NULL;
 805b6da:	c7 85 74 ff ff ff 00 	movl   $0x0,-0x8c(%ebp)
 805b6e1:	00 00 00 
	struct net_buf *dns_cname = NULL;
 805b6e4:	c7 85 7c ff ff ff 00 	movl   $0x0,-0x84(%ebp)
 805b6eb:	00 00 00 
 805b6ee:	eb 1b                	jmp    805b70b <cb_recv+0x472>
 805b6f0:	c7 85 7c ff ff ff 00 	movl   $0x0,-0x84(%ebp)
 805b6f7:	00 00 00 
	uint16_t dns_id = 0U;
 805b6fa:	66 c7 45 80 00 00    	movw   $0x0,-0x80(%ebp)
		ret = DNS_EAI_MEMORY;
 805b700:	bb f6 ff ff ff       	mov    $0xfffffff6,%ebx
	uint16_t query_hash = 0U;
 805b705:	66 c7 45 82 00 00    	movw   $0x0,-0x7e(%ebp)
	i = get_slot_by_id(ctx, dns_id, query_hash);
 805b70b:	0f b7 4d 82          	movzwl -0x7e(%ebp),%ecx
 805b70f:	0f b7 55 80          	movzwl -0x80(%ebp),%edx
 805b713:	8b 45 84             	mov    -0x7c(%ebp),%eax
 805b716:	e8 df f4 ff ff       	call   805abfa <get_slot_by_id>
	if (i < 0) {
 805b71b:	85 c0                	test   %eax,%eax
 805b71d:	78 1c                	js     805b73b <cb_recv+0x4a2>
	invoke_query_callback(ret, NULL, &ctx->queries[i]);
 805b71f:	6b c0 48             	imul   $0x48,%eax,%eax
 805b722:	8b 7d 84             	mov    -0x7c(%ebp),%edi
 805b725:	31 d2                	xor    %edx,%edx
 805b727:	8d 74 07 3c          	lea    0x3c(%edi,%eax,1),%esi
 805b72b:	89 d8                	mov    %ebx,%eax
 805b72d:	89 f1                	mov    %esi,%ecx
 805b72f:	e8 8a f4 ff ff       	call   805abbe <invoke_query_callback>
	release_query(&ctx->queries[i]);
 805b734:	89 f0                	mov    %esi,%eax
 805b736:	e8 fb f4 ff ff       	call   805ac36 <release_query>
	if (dns_data) {
 805b73b:	83 bd 74 ff ff ff 00 	cmpl   $0x0,-0x8c(%ebp)
 805b742:	74 11                	je     805b755 <cb_recv+0x4bc>
		net_buf_unref(dns_data);
 805b744:	83 ec 0c             	sub    $0xc,%esp
 805b747:	ff b5 74 ff ff ff    	push   -0x8c(%ebp)
 805b74d:	e8 30 3a ff ff       	call   804f182 <net_buf_unref>
 805b752:	83 c4 10             	add    $0x10,%esp
	if (dns_cname) {
 805b755:	83 bd 7c ff ff ff 00 	cmpl   $0x0,-0x84(%ebp)
 805b75c:	74 11                	je     805b76f <cb_recv+0x4d6>
		net_buf_unref(dns_cname);
 805b75e:	83 ec 0c             	sub    $0xc,%esp
 805b761:	ff b5 7c ff ff ff    	push   -0x84(%ebp)
 805b767:	e8 16 3a ff ff       	call   804f182 <net_buf_unref>
 805b76c:	83 c4 10             	add    $0x10,%esp
	k_mutex_unlock(&ctx->lock);
 805b76f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 805b772:	65 2b 05 14 00 00 00 	sub    %gs:0x14,%eax
 805b779:	74 05                	je     805b780 <cb_recv+0x4e7>
 805b77b:	e8 80 db fe ff       	call   8049300 <__stack_chk_fail@plt>
 805b780:	8b 85 68 ff ff ff    	mov    -0x98(%ebp),%eax
}
 805b786:	8d 65 f4             	lea    -0xc(%ebp),%esp
 805b789:	5b                   	pop    %ebx
 805b78a:	5e                   	pop    %esi
 805b78b:	5f                   	pop    %edi
 805b78c:	5d                   	pop    %ebp
	k_mutex_unlock(&ctx->lock);
 805b78d:	e9 cf f4 ff ff       	jmp    805ac61 <k_mutex_unlock>
	dns_resolve_cancel_with_name(ctx, *dns_id,
 805b792:	6b 85 78 ff ff ff 48 	imul   $0x48,-0x88(%ebp),%eax
 805b799:	03 45 84             	add    -0x7c(%ebp),%eax
	ret = dns_validate_msg(ctx, &dns_msg, dns_id, &query_idx,
 805b79c:	bb fd ff ff ff       	mov    $0xfffffffd,%ebx
	dns_resolve_cancel_with_name(ctx, *dns_id,
 805b7a1:	ff 70 7c             	push   0x7c(%eax)
 805b7a4:	ff 70 78             	push   0x78(%eax)
 805b7a7:	ff b5 70 ff ff ff    	push   -0x90(%ebp)
 805b7ad:	ff 75 84             	push   -0x7c(%ebp)
 805b7b0:	e8 c0 f9 ff ff       	call   805b175 <dns_resolve_cancel_with_name>
 805b7b5:	83 c4 10             	add    $0x10,%esp
 805b7b8:	e9 d2 fe ff ff       	jmp    805b68f <cb_recv+0x3f6>
			if (!ctx->servers[j].net_ctx) {
 805b7bd:	8b 45 84             	mov    -0x7c(%ebp),%eax
 805b7c0:	83 78 18 00          	cmpl   $0x0,0x18(%eax)
 805b7c4:	0f 84 7a ff ff ff    	je     805b744 <cb_recv+0x4ab>
			ret = dns_write(ctx, j, i, dns_data, dns_cname, 0);
 805b7ca:	83 ec 0c             	sub    $0xc,%esp
 805b7cd:	ff b5 7c ff ff ff    	push   -0x84(%ebp)
 805b7d3:	8b 8d 74 ff ff ff    	mov    -0x8c(%ebp),%ecx
				ret = DNS_EAI_SYSTEM;
 805b7d9:	bb f5 ff ff ff       	mov    $0xfffffff5,%ebx
			ret = dns_write(ctx, j, i, dns_data, dns_cname, 0);
 805b7de:	8b 45 84             	mov    -0x7c(%ebp),%eax
 805b7e1:	e8 0b f8 ff ff       	call   805aff1 <dns_write.constprop.0>
 805b7e6:	83 c4 10             	add    $0x10,%esp
			if (ret < 0) {
 805b7e9:	85 c0                	test   %eax,%eax
 805b7eb:	0f 89 53 ff ff ff    	jns    805b744 <cb_recv+0x4ab>
 805b7f1:	e9 15 ff ff ff       	jmp    805b70b <cb_recv+0x472>
	uint16_t dns_id = 0U;
 805b7f6:	66 c7 45 80 00 00    	movw   $0x0,-0x80(%ebp)
	uint16_t query_hash = 0U;
 805b7fc:	66 c7 45 82 00 00    	movw   $0x0,-0x7e(%ebp)
		ret = DNS_EAI_FAIL;
 805b802:	bb fc ff ff ff       	mov    $0xfffffffc,%ebx
 805b807:	e9 83 fe ff ff       	jmp    805b68f <cb_recv+0x3f6>
				ret = DNS_EAI_FAMILY;
 805b80c:	bb fa ff ff ff       	mov    $0xfffffffa,%ebx
 805b811:	e9 79 fe ff ff       	jmp    805b68f <cb_recv+0x3f6>
					ret = DNS_EAI_ADDRFAMILY;
 805b816:	bb f7 ff ff ff       	mov    $0xfffffff7,%ebx
 805b81b:	e9 6f fe ff ff       	jmp    805b68f <cb_recv+0x3f6>
			ret = DNS_EAI_SYSTEM;
 805b820:	bb f5 ff ff ff       	mov    $0xfffffff5,%ebx
 805b825:	e9 65 fe ff ff       	jmp    805b68f <cb_recv+0x3f6>
		ret = DNS_EAI_ALLDONE;
 805b82a:	bb 99 ff ff ff       	mov    $0xffffff99,%ebx
 805b82f:	e9 5b fe ff ff       	jmp    805b68f <cb_recv+0x3f6>

0805b834 <dns_resolve_cancel>:
{
 805b834:	55                   	push   %ebp
	return dns_resolve_cancel_with_hash(ctx, dns_id, query_hash,
 805b835:	31 c9                	xor    %ecx,%ecx
{
 805b837:	89 e5                	mov    %esp,%ebp
	return dns_resolve_cancel_with_name(ctx, dns_id, NULL, 0);
 805b839:	0f b7 55 0c          	movzwl 0xc(%ebp),%edx
	return dns_resolve_cancel_with_hash(ctx, dns_id, query_hash,
 805b83d:	8b 45 08             	mov    0x8(%ebp),%eax
}
 805b840:	5d                   	pop    %ebp
	return dns_resolve_cancel_with_hash(ctx, dns_id, query_hash,
 805b841:	e9 75 f4 ff ff       	jmp    805acbb <dns_resolve_cancel_with_hash.constprop.0>

0805b846 <dns_resolve_name>:
{
 805b846:	55                   	push   %ebp
 805b847:	89 e5                	mov    %esp,%ebp
 805b849:	57                   	push   %edi
 805b84a:	56                   	push   %esi
 805b84b:	53                   	push   %ebx
 805b84c:	83 ec 7c             	sub    $0x7c,%esp
 805b84f:	8b 45 0c             	mov    0xc(%ebp),%eax
 805b852:	8b 5d 08             	mov    0x8(%ebp),%ebx
 805b855:	89 45 94             	mov    %eax,-0x6c(%ebp)
 805b858:	8b 45 14             	mov    0x14(%ebp),%eax
 805b85b:	89 45 90             	mov    %eax,-0x70(%ebp)
 805b85e:	8b 45 18             	mov    0x18(%ebp),%eax
 805b861:	89 45 8c             	mov    %eax,-0x74(%ebp)
 805b864:	8b 45 1c             	mov    0x1c(%ebp),%eax
 805b867:	89 45 84             	mov    %eax,-0x7c(%ebp)
 805b86a:	8b 45 20             	mov    0x20(%ebp),%eax
 805b86d:	65 8b 15 14 00 00 00 	mov    %gs:0x14,%edx
 805b874:	89 55 e4             	mov    %edx,-0x1c(%ebp)
 805b877:	31 d2                	xor    %edx,%edx
	if (!ctx || !query || !cb) {
 805b879:	85 db                	test   %ebx,%ebx
 805b87b:	0f 94 c2             	sete   %dl
 805b87e:	83 7d 8c 00          	cmpl   $0x0,-0x74(%ebp)
 805b882:	0f 94 c1             	sete   %cl
 805b885:	08 ca                	or     %cl,%dl
 805b887:	0f 85 3d 02 00 00    	jne    805baca <dns_resolve_name+0x284>
 805b88d:	83 7d 94 00          	cmpl   $0x0,-0x6c(%ebp)
 805b891:	0f 84 33 02 00 00    	je     805baca <dns_resolve_name+0x284>
	tout = SYS_TIMEOUT_MS(timeout);
 805b897:	83 f8 ff             	cmp    $0xffffffff,%eax
 805b89a:	74 3f                	je     805b8db <dns_resolve_name+0x95>
 805b89c:	31 d2                	xor    %edx,%edx
 805b89e:	85 c0                	test   %eax,%eax
 805b8a0:	6a 00                	push   $0x0
 805b8a2:	0f 48 c2             	cmovs  %edx,%eax
 805b8a5:	6a 0a                	push   $0xa
 805b8a7:	99                   	cltd   
		t += off;
 805b8a8:	83 c0 09             	add    $0x9,%eax
 805b8ab:	83 d2 00             	adc    $0x0,%edx
 805b8ae:	89 c6                	mov    %eax,%esi
			return t / ((uint64_t)from_hz / to_hz);
 805b8b0:	52                   	push   %edx
		t += off;
 805b8b1:	89 d7                	mov    %edx,%edi
			return t / ((uint64_t)from_hz / to_hz);
 805b8b3:	50                   	push   %eax
 805b8b4:	e8 97 dc fe ff       	call   8049550 <__udivdi3>
 805b8b9:	83 c4 10             	add    $0x10,%esp
 805b8bc:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
	if (K_TIMEOUT_EQ(tout, K_NO_WAIT)) {
 805b8c2:	89 f0                	mov    %esi,%eax
 805b8c4:	83 f0 09             	xor    $0x9,%eax
 805b8c7:	89 95 7c ff ff ff    	mov    %edx,-0x84(%ebp)
		return -EINVAL;
 805b8cd:	ba ea ff ff ff       	mov    $0xffffffea,%edx
	if (K_TIMEOUT_EQ(tout, K_NO_WAIT)) {
 805b8d2:	09 f8                	or     %edi,%eax
 805b8d4:	75 19                	jne    805b8ef <dns_resolve_name+0xa9>
 805b8d6:	e9 f4 01 00 00       	jmp    805bacf <dns_resolve_name+0x289>
	tout = SYS_TIMEOUT_MS(timeout);
 805b8db:	c7 85 78 ff ff ff ff 	movl   $0xffffffff,-0x88(%ebp)
 805b8e2:	ff ff ff 
 805b8e5:	c7 85 7c ff ff ff ff 	movl   $0xffffffff,-0x84(%ebp)
 805b8ec:	ff ff ff 
	ret = net_ipaddr_parse(query, strlen(query), &addr);
 805b8ef:	83 ec 0c             	sub    $0xc,%esp
 805b8f2:	ff 75 94             	push   -0x6c(%ebp)
 805b8f5:	8d 75 98             	lea    -0x68(%ebp),%esi
 805b8f8:	e8 43 d9 fe ff       	call   8049240 <strlen@plt>
 805b8fd:	83 c4 0c             	add    $0xc,%esp
 805b900:	56                   	push   %esi
 805b901:	50                   	push   %eax
 805b902:	ff 75 94             	push   -0x6c(%ebp)
 805b905:	e8 be 7d ff ff       	call   80536c8 <net_ipaddr_parse>
 805b90a:	83 c4 10             	add    $0x10,%esp
	if (ret) {
 805b90d:	84 c0                	test   %al,%al
 805b90f:	0f 84 99 00 00 00    	je     805b9ae <dns_resolve_name+0x168>
		struct dns_addrinfo info = { 0 };
 805b915:	31 c0                	xor    %eax,%eax
 805b917:	8d 7d b0             	lea    -0x50(%ebp),%edi
 805b91a:	b9 0d 00 00 00       	mov    $0xd,%ecx
		if (type == DNS_QUERY_TYPE_A) {
 805b91f:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
		struct dns_addrinfo info = { 0 };
 805b923:	f3 ab                	rep stos %eax,%es:(%edi)
		if (type == DNS_QUERY_TYPE_A) {
 805b925:	8d 45 b0             	lea    -0x50(%ebp),%eax
 805b928:	75 2a                	jne    805b954 <dns_resolve_name+0x10e>
			if (net_sin(&addr)->sin_family == AF_INET6) {
 805b92a:	66 83 7d 98 02       	cmpw   $0x2,-0x68(%ebp)
				return -EPFNOSUPPORT;
 805b92f:	ba a0 ff ff ff       	mov    $0xffffffa0,%edx
			if (net_sin(&addr)->sin_family == AF_INET6) {
 805b934:	0f 84 95 01 00 00    	je     805bacf <dns_resolve_name+0x289>
			memcpy(net_sin(&info.ai_addr), net_sin(&addr),
 805b93a:	8b 4d 98             	mov    -0x68(%ebp),%ecx
 805b93d:	8b 5d 9c             	mov    -0x64(%ebp),%ebx
 805b940:	ba 08 00 00 00       	mov    $0x8,%edx
 805b945:	89 4d b0             	mov    %ecx,-0x50(%ebp)
 805b948:	b9 01 00 00 00       	mov    $0x1,%ecx
 805b94d:	89 5d b4             	mov    %ebx,-0x4c(%ebp)
			info.ai_addrlen = sizeof(struct sockaddr_in);
 805b950:	b3 01                	mov    $0x1,%bl
 805b952:	eb 2b                	jmp    805b97f <dns_resolve_name+0x139>
		} else if (type == DNS_QUERY_TYPE_AAAA) {
 805b954:	83 7d 10 1c          	cmpl   $0x1c,0x10(%ebp)
 805b958:	75 54                	jne    805b9ae <dns_resolve_name+0x168>
			if (net_sin(&addr)->sin_family == AF_INET) {
 805b95a:	66 83 7d 98 01       	cmpw   $0x1,-0x68(%ebp)
				return -EPFNOSUPPORT;
 805b95f:	ba a0 ff ff ff       	mov    $0xffffffa0,%edx
			if (net_sin(&addr)->sin_family == AF_INET) {
 805b964:	0f 84 65 01 00 00    	je     805bacf <dns_resolve_name+0x289>
			memcpy(net_sin6(&info.ai_addr), net_sin6(&addr),
 805b96a:	b9 06 00 00 00       	mov    $0x6,%ecx
 805b96f:	89 c7                	mov    %eax,%edi
 805b971:	b3 02                	mov    $0x2,%bl
 805b973:	ba 18 00 00 00       	mov    $0x18,%edx
 805b978:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
			info.ai_addrlen = sizeof(struct sockaddr_in6);
 805b97a:	b9 02 00 00 00       	mov    $0x2,%ecx
			info.ai_addr.sa_family = AF_INET;
 805b97f:	66 89 4d b0          	mov    %cx,-0x50(%ebp)
		cb(DNS_EAI_INPROGRESS, &info, user_data);
 805b983:	51                   	push   %ecx
 805b984:	ff 75 84             	push   -0x7c(%ebp)
 805b987:	50                   	push   %eax
 805b988:	6a 9c                	push   $0xffffff9c
 805b98a:	8b 45 8c             	mov    -0x74(%ebp),%eax
			info.ai_addrlen = sizeof(struct sockaddr_in);
 805b98d:	89 55 c8             	mov    %edx,-0x38(%ebp)
			info.ai_family = AF_INET;
 805b990:	88 5d cc             	mov    %bl,-0x34(%ebp)
		cb(DNS_EAI_INPROGRESS, &info, user_data);
 805b993:	ff d0                	call   *%eax
 805b995:	83 c4 0c             	add    $0xc,%esp
		cb(DNS_EAI_ALLDONE, NULL, user_data);
 805b998:	ff 75 84             	push   -0x7c(%ebp)
 805b99b:	8b 45 8c             	mov    -0x74(%ebp),%eax
 805b99e:	6a 00                	push   $0x0
 805b9a0:	6a 99                	push   $0xffffff99
 805b9a2:	ff d0                	call   *%eax
		return 0;
 805b9a4:	31 d2                	xor    %edx,%edx
		cb(DNS_EAI_ALLDONE, NULL, user_data);
 805b9a6:	83 c4 10             	add    $0x10,%esp
		return 0;
 805b9a9:	e9 21 01 00 00       	jmp    805bacf <dns_resolve_name+0x289>
	k_mutex_lock(&ctx->lock, K_FOREVER);
 805b9ae:	83 ca ff             	or     $0xffffffff,%edx
 805b9b1:	8d 43 20             	lea    0x20(%ebx),%eax
 805b9b4:	89 d1                	mov    %edx,%ecx
 805b9b6:	89 45 80             	mov    %eax,-0x80(%ebp)
 805b9b9:	e8 25 f2 ff ff       	call   805abe3 <k_mutex_lock>
	if (ctx->state != DNS_RESOLVE_CONTEXT_ACTIVE) {
 805b9be:	83 bb 84 00 00 00 00 	cmpl   $0x0,0x84(%ebx)
		ret = -EINVAL;
 805b9c5:	ba ea ff ff ff       	mov    $0xffffffea,%edx
	if (ctx->state != DNS_RESOLVE_CONTEXT_ACTIVE) {
 805b9ca:	0f 85 ea 00 00 00    	jne    805baba <dns_resolve_name+0x274>
		if (!check_query_active(&ctx->queries[i], true)) {
 805b9d0:	8d 43 3c             	lea    0x3c(%ebx),%eax
	if (pending_query->cb != NULL) {
 805b9d3:	83 7b 68 00          	cmpl   $0x0,0x68(%ebx)
		if (!check_query_active(&ctx->queries[i], true)) {
 805b9d7:	89 45 88             	mov    %eax,-0x78(%ebp)
	if (pending_query->cb != NULL) {
 805b9da:	74 22                	je     805b9fe <dns_resolve_name+0x1b8>
		    && pending_query->query == NULL
 805b9dc:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
 805b9e0:	74 0a                	je     805b9ec <dns_resolve_name+0x1a6>
		ret = -EAGAIN;
 805b9e2:	ba f5 ff ff ff       	mov    $0xfffffff5,%edx
 805b9e7:	e9 ce 00 00 00       	jmp    805baba <dns_resolve_name+0x274>
		    && k_work_delayable_busy_get(&pending_query->timer) == 0) {
 805b9ec:	83 ec 0c             	sub    $0xc,%esp
 805b9ef:	ff 75 88             	push   -0x78(%ebp)
 805b9f2:	e8 70 42 00 00       	call   805fc67 <k_work_delayable_busy_get>
 805b9f7:	83 c4 10             	add    $0x10,%esp
 805b9fa:	85 c0                	test   %eax,%eax
 805b9fc:	75 e4                	jne    805b9e2 <dns_resolve_name+0x19c>
	ctx->queries[i].cb = cb;
 805b9fe:	8b 45 8c             	mov    -0x74(%ebp),%eax
	ctx->queries[i].timeout = tout;
 805ba01:	8b 95 7c ff ff ff    	mov    -0x84(%ebp),%edx
	ctx->queries[i].ctx = ctx;
 805ba07:	89 5b 64             	mov    %ebx,0x64(%ebx)
	ctx->queries[i].query_hash = 0;
 805ba0a:	66 c7 83 82 00 00 00 	movw   $0x0,0x82(%ebx)
 805ba11:	00 00 
	ctx->queries[i].cb = cb;
 805ba13:	89 43 68             	mov    %eax,0x68(%ebx)
	ctx->queries[i].timeout = tout;
 805ba16:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
 805ba1c:	89 53 74             	mov    %edx,0x74(%ebx)
 805ba1f:	89 43 70             	mov    %eax,0x70(%ebx)
	ctx->queries[i].query = query;
 805ba22:	8b 45 94             	mov    -0x6c(%ebp),%eax
 805ba25:	89 43 78             	mov    %eax,0x78(%ebx)
	ctx->queries[i].query_type = type;
 805ba28:	8b 45 10             	mov    0x10(%ebp),%eax
 805ba2b:	89 43 7c             	mov    %eax,0x7c(%ebx)
	ctx->queries[i].user_data = user_data;
 805ba2e:	8b 45 84             	mov    -0x7c(%ebp),%eax
 805ba31:	89 43 6c             	mov    %eax,0x6c(%ebx)
	k_work_init_delayable(&ctx->queries[i].timer, query_timeout);
 805ba34:	50                   	push   %eax
 805ba35:	50                   	push   %eax
 805ba36:	68 29 ad 05 08       	push   $0x805ad29
 805ba3b:	ff 75 88             	push   -0x78(%ebp)
 805ba3e:	e8 02 42 00 00       	call   805fc45 <k_work_init_delayable>
 805ba43:	83 c4 0c             	add    $0xc,%esp
 805ba46:	ff 73 38             	push   0x38(%ebx)
 805ba49:	ff 73 34             	push   0x34(%ebx)
 805ba4c:	68 00 76 06 08       	push   $0x8067600
 805ba51:	e8 0a 37 ff ff       	call   804f160 <net_buf_alloc_fixed>
 805ba56:	83 c4 10             	add    $0x10,%esp
 805ba59:	89 c7                	mov    %eax,%edi
	if (!dns_data) {
 805ba5b:	85 c0                	test   %eax,%eax
 805ba5d:	74 1a                	je     805ba79 <dns_resolve_name+0x233>
 805ba5f:	52                   	push   %edx
 805ba60:	ff 73 38             	push   0x38(%ebx)
 805ba63:	ff 73 34             	push   0x34(%ebx)
 805ba66:	68 2c 76 06 08       	push   $0x806762c
 805ba6b:	e8 f0 36 ff ff       	call   804f160 <net_buf_alloc_fixed>
 805ba70:	83 c4 10             	add    $0x10,%esp
 805ba73:	89 c6                	mov    %eax,%esi
	if (!dns_qname) {
 805ba75:	85 c0                	test   %eax,%eax
 805ba77:	75 67                	jne    805bae0 <dns_resolve_name+0x29a>
	dns_qname = net_buf_alloc(&dns_qname_pool, ctx->buf_timeout);
 805ba79:	31 f6                	xor    %esi,%esi
		ret = -ENOMEM;
 805ba7b:	ba f4 ff ff ff       	mov    $0xfffffff4,%edx
			release_query(&ctx->queries[i]);
 805ba80:	8b 45 88             	mov    -0x78(%ebp),%eax
 805ba83:	89 55 94             	mov    %edx,-0x6c(%ebp)
 805ba86:	e8 ab f1 ff ff       	call   805ac36 <release_query>
		if (dns_id) {
 805ba8b:	83 7d 90 00          	cmpl   $0x0,-0x70(%ebp)
 805ba8f:	8b 55 94             	mov    -0x6c(%ebp),%edx
 805ba92:	74 08                	je     805ba9c <dns_resolve_name+0x256>
			*dns_id = 0U;
 805ba94:	8b 45 90             	mov    -0x70(%ebp),%eax
 805ba97:	66 c7 00 00 00       	movw   $0x0,(%eax)
	if (dns_data) {
 805ba9c:	85 ff                	test   %edi,%edi
 805ba9e:	0f 85 99 00 00 00    	jne    805bb3d <dns_resolve_name+0x2f7>
	if (dns_qname) {
 805baa4:	85 f6                	test   %esi,%esi
 805baa6:	74 12                	je     805baba <dns_resolve_name+0x274>
		net_buf_unref(dns_qname);
 805baa8:	83 ec 0c             	sub    $0xc,%esp
 805baab:	89 55 94             	mov    %edx,-0x6c(%ebp)
 805baae:	56                   	push   %esi
 805baaf:	e8 ce 36 ff ff       	call   804f182 <net_buf_unref>
 805bab4:	8b 55 94             	mov    -0x6c(%ebp),%edx
 805bab7:	83 c4 10             	add    $0x10,%esp
	k_mutex_unlock(&ctx->lock);
 805baba:	8b 45 80             	mov    -0x80(%ebp),%eax
 805babd:	89 55 94             	mov    %edx,-0x6c(%ebp)
 805bac0:	e8 9c f1 ff ff       	call   805ac61 <k_mutex_unlock>
	return ret;
 805bac5:	8b 55 94             	mov    -0x6c(%ebp),%edx
 805bac8:	eb 05                	jmp    805bacf <dns_resolve_name+0x289>
		return -EINVAL;
 805baca:	ba ea ff ff ff       	mov    $0xffffffea,%edx
}
 805bacf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 805bad2:	65 2b 05 14 00 00 00 	sub    %gs:0x14,%eax
 805bad9:	74 79                	je     805bb54 <dns_resolve_name+0x30e>
 805badb:	e8 20 d8 fe ff       	call   8049300 <__stack_chk_fail@plt>
	ret = dns_msg_pack_qname(&dns_qname->len, dns_qname->data,
 805bae0:	ff 73 78             	push   0x78(%ebx)
 805bae3:	8d 40 10             	lea    0x10(%eax),%eax
 805bae6:	68 ff 00 00 00       	push   $0xff
 805baeb:	ff 70 fc             	push   -0x4(%eax)
 805baee:	50                   	push   %eax
 805baef:	e8 34 ed ff ff       	call   805a828 <dns_msg_pack_qname>
 805baf4:	83 c4 10             	add    $0x10,%esp
 805baf7:	89 c2                	mov    %eax,%edx
	if (ret < 0) {
 805baf9:	85 c0                	test   %eax,%eax
 805bafb:	78 83                	js     805ba80 <dns_resolve_name+0x23a>
 805bafd:	e8 1e 34 ff ff       	call   804ef20 <z_impl_sys_rand32_get>
	if (dns_id) {
 805bb02:	83 7d 90 00          	cmpl   $0x0,-0x70(%ebp)
	ctx->queries[i].id = sys_rand32_get();
 805bb06:	66 89 83 80 00 00 00 	mov    %ax,0x80(%ebx)
	if (dns_id) {
 805bb0d:	74 06                	je     805bb15 <dns_resolve_name+0x2cf>
		*dns_id = ctx->queries[i].id;
 805bb0f:	8b 4d 90             	mov    -0x70(%ebp),%ecx
 805bb12:	66 89 01             	mov    %ax,(%ecx)
		if (!ctx->servers[j].net_ctx) {
 805bb15:	83 7b 18 00          	cmpl   $0x0,0x18(%ebx)
 805bb19:	74 20                	je     805bb3b <dns_resolve_name+0x2f5>
		ret = dns_write(ctx, j, i, dns_data, dns_qname, hop_limit);
 805bb1b:	83 ec 0c             	sub    $0xc,%esp
 805bb1e:	89 f9                	mov    %edi,%ecx
 805bb20:	31 d2                	xor    %edx,%edx
 805bb22:	89 d8                	mov    %ebx,%eax
 805bb24:	56                   	push   %esi
 805bb25:	e8 c7 f4 ff ff       	call   805aff1 <dns_write.constprop.0>
 805bb2a:	83 c4 10             	add    $0x10,%esp
		if (ret < 0) {
 805bb2d:	85 c0                	test   %eax,%eax
 805bb2f:	79 0a                	jns    805bb3b <dns_resolve_name+0x2f5>
			ret = -ENOENT;
 805bb31:	ba fe ff ff ff       	mov    $0xfffffffe,%edx
 805bb36:	e9 45 ff ff ff       	jmp    805ba80 <dns_resolve_name+0x23a>
 805bb3b:	31 d2                	xor    %edx,%edx
		net_buf_unref(dns_data);
 805bb3d:	83 ec 0c             	sub    $0xc,%esp
 805bb40:	89 55 94             	mov    %edx,-0x6c(%ebp)
 805bb43:	57                   	push   %edi
 805bb44:	e8 39 36 ff ff       	call   804f182 <net_buf_unref>
 805bb49:	8b 55 94             	mov    -0x6c(%ebp),%edx
 805bb4c:	83 c4 10             	add    $0x10,%esp
 805bb4f:	e9 50 ff ff ff       	jmp    805baa4 <dns_resolve_name+0x25e>
}
 805bb54:	8d 65 f4             	lea    -0xc(%ebp),%esp
 805bb57:	89 d0                	mov    %edx,%eax
 805bb59:	5b                   	pop    %ebx
 805bb5a:	5e                   	pop    %esi
 805bb5b:	5f                   	pop    %edi
 805bb5c:	5d                   	pop    %ebp
 805bb5d:	c3                   	ret    

0805bb5e <dns_resolve_reconfigure>:
}

int dns_resolve_reconfigure(struct dns_resolve_context *ctx,
			    const char *servers[],
			    const struct sockaddr *servers_sa[])
{
 805bb5e:	55                   	push   %ebp
 805bb5f:	ba fe ff ff ff       	mov    $0xfffffffe,%edx
 805bb64:	89 e5                	mov    %esp,%ebp
 805bb66:	57                   	push   %edi
 805bb67:	56                   	push   %esi
 805bb68:	53                   	push   %ebx
 805bb69:	83 ec 3c             	sub    $0x3c,%esp
 805bb6c:	8b 5d 08             	mov    0x8(%ebp),%ebx
 805bb6f:	8b 75 0c             	mov    0xc(%ebp),%esi
 805bb72:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 805bb78:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 805bb7b:	31 c0                	xor    %eax,%eax
 805bb7d:	8b 7d 10             	mov    0x10(%ebp),%edi
	int err;

	if (!ctx) {
 805bb80:	85 db                	test   %ebx,%ebx
 805bb82:	0f 84 c9 00 00 00    	je     805bc51 <dns_resolve_reconfigure+0xf3>
		return -ENOENT;
	}

	k_mutex_lock(&ctx->lock, K_FOREVER);
 805bb88:	83 ca ff             	or     $0xffffffff,%edx
 805bb8b:	8d 43 20             	lea    0x20(%ebx),%eax
 805bb8e:	89 d1                	mov    %edx,%ecx
 805bb90:	89 45 c4             	mov    %eax,-0x3c(%ebp)
 805bb93:	e8 4b f0 ff ff       	call   805abe3 <k_mutex_lock>
	if (servers) {
 805bb98:	85 f6                	test   %esi,%esi
 805bb9a:	74 38                	je     805bbd4 <dns_resolve_reconfigure+0x76>
		for (int i = 0; i < SERVER_COUNT && servers[i]; i++) {
 805bb9c:	8b 0e                	mov    (%esi),%ecx
 805bb9e:	85 c9                	test   %ecx,%ecx
 805bba0:	74 32                	je     805bbd4 <dns_resolve_reconfigure+0x76>
			if (!net_ipaddr_parse(servers[i], strlen(servers[i]), &addr)) {
 805bba2:	83 ec 0c             	sub    $0xc,%esp
 805bba5:	89 4d c0             	mov    %ecx,-0x40(%ebp)
 805bba8:	51                   	push   %ecx
 805bba9:	e8 92 d6 fe ff       	call   8049240 <strlen@plt>
 805bbae:	8b 4d c0             	mov    -0x40(%ebp),%ecx
 805bbb1:	83 c4 0c             	add    $0xc,%esp
 805bbb4:	8d 55 cc             	lea    -0x34(%ebp),%edx
 805bbb7:	52                   	push   %edx
 805bbb8:	50                   	push   %eax
 805bbb9:	51                   	push   %ecx
 805bbba:	e8 09 7b ff ff       	call   80536c8 <net_ipaddr_parse>
 805bbbf:	83 c4 10             	add    $0x10,%esp
 805bbc2:	84 c0                	test   %al,%al
 805bbc4:	74 0e                	je     805bbd4 <dns_resolve_reconfigure+0x76>
			if (!dns_server_exists(ctx, &addr)) {
 805bbc6:	8d 55 cc             	lea    -0x34(%ebp),%edx
 805bbc9:	89 d8                	mov    %ebx,%eax
 805bbcb:	e8 a2 f0 ff ff       	call   805ac72 <dns_server_exists>
 805bbd0:	84 c0                	test   %al,%al
 805bbd2:	74 19                	je     805bbed <dns_resolve_reconfigure+0x8f>

	if (dns_servers_exists(ctx, servers, servers_sa)) {
		/* DNS servers did not change. */
		err = 0;
 805bbd4:	31 d2                	xor    %edx,%edx
	if (servers_sa) {
 805bbd6:	85 ff                	test   %edi,%edi
 805bbd8:	74 69                	je     805bc43 <dns_resolve_reconfigure+0xe5>
		for (int i = 0; i < SERVER_COUNT && servers_sa[i]; i++) {
 805bbda:	8b 17                	mov    (%edi),%edx
 805bbdc:	85 d2                	test   %edx,%edx
 805bbde:	74 63                	je     805bc43 <dns_resolve_reconfigure+0xe5>
			if (!dns_server_exists(ctx, servers_sa[i])) {
 805bbe0:	89 d8                	mov    %ebx,%eax
 805bbe2:	e8 8b f0 ff ff       	call   805ac72 <dns_server_exists>
		err = 0;
 805bbe7:	31 d2                	xor    %edx,%edx
			if (!dns_server_exists(ctx, servers_sa[i])) {
 805bbe9:	84 c0                	test   %al,%al
 805bbeb:	75 56                	jne    805bc43 <dns_resolve_reconfigure+0xe5>
		goto unlock;
	}

	if (ctx->state == DNS_RESOLVE_CONTEXT_DEACTIVATING) {
 805bbed:	8b 83 84 00 00 00    	mov    0x84(%ebx),%eax
		err = -EBUSY;
 805bbf3:	ba f0 ff ff ff       	mov    $0xfffffff0,%edx
	if (ctx->state == DNS_RESOLVE_CONTEXT_DEACTIVATING) {
 805bbf8:	83 f8 01             	cmp    $0x1,%eax
 805bbfb:	74 46                	je     805bc43 <dns_resolve_reconfigure+0xe5>
		goto unlock;
	}

	if (ctx->state == DNS_RESOLVE_CONTEXT_ACTIVE) {
 805bbfd:	85 c0                	test   %eax,%eax
 805bbff:	74 10                	je     805bc11 <dns_resolve_reconfigure+0xb3>
		if (err) {
			goto unlock;
		}
	}

	err = dns_resolve_init_locked(ctx, servers, servers_sa);
 805bc01:	50                   	push   %eax
 805bc02:	57                   	push   %edi
 805bc03:	56                   	push   %esi
 805bc04:	53                   	push   %ebx
 805bc05:	e8 8f f2 ff ff       	call   805ae99 <dns_resolve_init_locked>
 805bc0a:	83 c4 10             	add    $0x10,%esp
 805bc0d:	89 c2                	mov    %eax,%edx
 805bc0f:	eb 32                	jmp    805bc43 <dns_resolve_reconfigure+0xe5>
		if (ctx->queries[i].cb && ctx->queries[i].query) {
 805bc11:	83 7b 68 00          	cmpl   $0x0,0x68(%ebx)
 805bc15:	74 1f                	je     805bc36 <dns_resolve_reconfigure+0xd8>
 805bc17:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
 805bc1b:	74 19                	je     805bc36 <dns_resolve_reconfigure+0xd8>
	invoke_query_callback(DNS_EAI_CANCELED, NULL, &ctx->queries[slot]);
 805bc1d:	8d 43 3c             	lea    0x3c(%ebx),%eax
 805bc20:	31 d2                	xor    %edx,%edx
 805bc22:	89 c1                	mov    %eax,%ecx
 805bc24:	b8 9b ff ff ff       	mov    $0xffffff9b,%eax
 805bc29:	e8 90 ef ff ff       	call   805abbe <invoke_query_callback>
	release_query(&ctx->queries[slot]);
 805bc2e:	8d 43 3c             	lea    0x3c(%ebx),%eax
 805bc31:	e8 00 f0 ff ff       	call   805ac36 <release_query>
		err = dns_resolve_close_locked(ctx);
 805bc36:	89 d8                	mov    %ebx,%eax
 805bc38:	e8 39 f1 ff ff       	call   805ad76 <dns_resolve_close_locked>
 805bc3d:	89 c2                	mov    %eax,%edx
		if (err) {
 805bc3f:	85 c0                	test   %eax,%eax
 805bc41:	74 be                	je     805bc01 <dns_resolve_reconfigure+0xa3>

unlock:
	k_mutex_unlock(&ctx->lock);
 805bc43:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 805bc46:	89 55 c0             	mov    %edx,-0x40(%ebp)
 805bc49:	e8 13 f0 ff ff       	call   805ac61 <k_mutex_unlock>
 805bc4e:	8b 55 c0             	mov    -0x40(%ebp),%edx

	return err;
}
 805bc51:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 805bc54:	65 2b 05 14 00 00 00 	sub    %gs:0x14,%eax
 805bc5b:	74 05                	je     805bc62 <dns_resolve_reconfigure+0x104>
 805bc5d:	e8 9e d6 fe ff       	call   8049300 <__stack_chk_fail@plt>
 805bc62:	8d 65 f4             	lea    -0xc(%ebp),%esp
 805bc65:	89 d0                	mov    %edx,%eax
 805bc67:	5b                   	pop    %ebx
 805bc68:	5e                   	pop    %esi
 805bc69:	5f                   	pop    %edi
 805bc6a:	5d                   	pop    %ebp
 805bc6b:	c3                   	ret    

0805bc6c <dns_resolve_get_default>:

struct dns_resolve_context *dns_resolve_get_default(void)
{
	return &dns_default_ctx;
}
 805bc6c:	b8 20 86 06 08       	mov    $0x8068620,%eax
 805bc71:	c3                   	ret    

0805bc72 <dns_init_resolver>:

void dns_init_resolver(void)
{
 805bc72:	55                   	push   %ebp
 805bc73:	89 e5                	mov    %esp,%ebp
 805bc75:	83 ec 0c             	sub    $0xc,%esp
	}
#else
	/* We must always call init even if there are no servers configured so
	 * that DNS mutex gets initialized properly.
	 */
	(void)dns_resolve_init(dns_resolve_get_default(), NULL, NULL);
 805bc78:	6a 00                	push   $0x0
 805bc7a:	6a 00                	push   $0x0
 805bc7c:	68 20 86 06 08       	push   $0x8068620
 805bc81:	e8 8d f4 ff ff       	call   805b113 <dns_resolve_init>
 805bc86:	83 c4 10             	add    $0x10,%esp
#endif
}
 805bc89:	c9                   	leave  
 805bc8a:	c3                   	ret    

0805bc8b <cb_notify>:
int cb_notify(struct http_parser *parser, enum state *current_state, http_cb cb,
	      int cb_error, size_t *parsed, size_t already_parsed)
{
	__ASSERT_NO_MSG(HTTP_PARSER_ERRNO(parser) == HPE_OK);

	if (cb == NULL) {
 805bc8b:	85 c9                	test   %ecx,%ecx
 805bc8d:	74 63                	je     805bcf2 <cb_notify+0x67>
{
 805bc8f:	55                   	push   %ebp
 805bc90:	89 e5                	mov    %esp,%ebp
 805bc92:	56                   	push   %esi
 805bc93:	89 d6                	mov    %edx,%esi
 805bc95:	53                   	push   %ebx
		return 0;
	}

	parser->state = *current_state;
 805bc96:	8b 12                	mov    (%edx),%edx
 805bc98:	89 c3                	mov    %eax,%ebx
 805bc9a:	8b 00                	mov    (%eax),%eax
 805bc9c:	83 e2 7f             	and    $0x7f,%edx
 805bc9f:	c1 e2 0a             	shl    $0xa,%edx
 805bca2:	25 ff 03 fe ff       	and    $0xfffe03ff,%eax
	if (UNLIKELY(cb(parser) != 0)) {
 805bca7:	83 ec 0c             	sub    $0xc,%esp
	parser->state = *current_state;
 805bcaa:	09 d0                	or     %edx,%eax
 805bcac:	89 03                	mov    %eax,(%ebx)
	if (UNLIKELY(cb(parser) != 0)) {
 805bcae:	53                   	push   %ebx
 805bcaf:	ff d1                	call   *%ecx
 805bcb1:	83 c4 10             	add    $0x10,%esp
 805bcb4:	85 c0                	test   %eax,%eax
 805bcb6:	74 11                	je     805bcc9 <cb_notify+0x3e>
		SET_ERRNO(cb_error);
 805bcb8:	8a 55 08             	mov    0x8(%ebp),%dl
 805bcbb:	8a 43 17             	mov    0x17(%ebx),%al
 805bcbe:	83 e2 7f             	and    $0x7f,%edx
 805bcc1:	83 e0 80             	and    $0xffffff80,%eax
 805bcc4:	09 d0                	or     %edx,%eax
 805bcc6:	88 43 17             	mov    %al,0x17(%ebx)
	}
	*current_state = parser->state;
 805bcc9:	8b 03                	mov    (%ebx),%eax
 805bccb:	c1 e8 0a             	shr    $0xa,%eax
 805bcce:	83 e0 7f             	and    $0x7f,%eax
 805bcd1:	89 06                	mov    %eax,(%esi)
		return 0;
 805bcd3:	31 c0                	xor    %eax,%eax
	/* We either errored above or got paused; get out */
	if (UNLIKELY(HTTP_PARSER_ERRNO(parser) != HPE_OK)) {
 805bcd5:	f6 43 17 7f          	testb  $0x7f,0x17(%ebx)
 805bcd9:	74 10                	je     805bceb <cb_notify+0x60>
		*parsed = already_parsed;
 805bcdb:	8b 45 0c             	mov    0xc(%ebp),%eax
 805bcde:	8b 55 10             	mov    0x10(%ebp),%edx
 805bce1:	89 10                	mov    %edx,(%eax)
		return -HTTP_PARSER_ERRNO(parser);
 805bce3:	8a 43 17             	mov    0x17(%ebx),%al
 805bce6:	83 e0 7f             	and    $0x7f,%eax
 805bce9:	f7 d8                	neg    %eax
	}

	return 0;
}
 805bceb:	8d 65 f8             	lea    -0x8(%ebp),%esp
 805bcee:	5b                   	pop    %ebx
 805bcef:	5e                   	pop    %esi
 805bcf0:	5d                   	pop    %ebp
 805bcf1:	c3                   	ret    
		return 0;
 805bcf2:	31 c0                	xor    %eax,%eax
}
 805bcf4:	c3                   	ret    

0805bcf5 <cb_data>:

static inline
int cb_data(struct http_parser *parser, http_data_cb cb, int cb_error,
	    enum state *current_state, size_t *parsed, size_t already_parsed,
	    const char **mark, size_t len)
{
 805bcf5:	55                   	push   %ebp
 805bcf6:	89 e5                	mov    %esp,%ebp
 805bcf8:	57                   	push   %edi
 805bcf9:	56                   	push   %esi
 805bcfa:	53                   	push   %ebx
 805bcfb:	83 ec 1c             	sub    $0x1c,%esp
 805bcfe:	8b 7d 14             	mov    0x14(%ebp),%edi
	int rc;

	__ASSERT_NO_MSG(HTTP_PARSER_ERRNO(parser) == HPE_OK);
	if (*mark == NULL) {
 805bd01:	83 3f 00             	cmpl   $0x0,(%edi)
 805bd04:	74 71                	je     805bd77 <cb_data+0x82>
 805bd06:	89 c3                	mov    %eax,%ebx
 805bd08:	89 d0                	mov    %edx,%eax
		return 0;
	}
	if (cb == NULL) {
 805bd0a:	85 d2                	test   %edx,%edx
 805bd0c:	74 63                	je     805bd71 <cb_data+0x7c>
		goto lb_end;
	}

	parser->state = *current_state;
 805bd0e:	8b 55 08             	mov    0x8(%ebp),%edx
 805bd11:	89 ce                	mov    %ecx,%esi
 805bd13:	8b 12                	mov    (%edx),%edx
 805bd15:	89 d1                	mov    %edx,%ecx
 805bd17:	89 55 e4             	mov    %edx,-0x1c(%ebp)
 805bd1a:	83 e1 7f             	and    $0x7f,%ecx
 805bd1d:	89 ca                	mov    %ecx,%edx
 805bd1f:	8b 0b                	mov    (%ebx),%ecx
 805bd21:	c1 e2 0a             	shl    $0xa,%edx
 805bd24:	81 e1 ff 03 fe ff    	and    $0xfffe03ff,%ecx
 805bd2a:	09 d1                	or     %edx,%ecx
 805bd2c:	89 0b                	mov    %ecx,(%ebx)
	rc = cb(parser, *mark, len);
 805bd2e:	52                   	push   %edx
 805bd2f:	ff 75 18             	push   0x18(%ebp)
 805bd32:	ff 37                	push   (%edi)
 805bd34:	53                   	push   %ebx
 805bd35:	ff d0                	call   *%eax
 805bd37:	83 c4 10             	add    $0x10,%esp
	if (UNLIKELY(rc != 0)) {
 805bd3a:	85 c0                	test   %eax,%eax
 805bd3c:	74 0e                	je     805bd4c <cb_data+0x57>
		SET_ERRNO(cb_error);
 805bd3e:	8a 43 17             	mov    0x17(%ebx),%al
 805bd41:	83 e6 7f             	and    $0x7f,%esi
 805bd44:	83 e0 80             	and    $0xffffff80,%eax
 805bd47:	09 f0                	or     %esi,%eax
 805bd49:	88 43 17             	mov    %al,0x17(%ebx)
	}
	*current_state = parser->state;
 805bd4c:	8b 03                	mov    (%ebx),%eax
 805bd4e:	8b 75 08             	mov    0x8(%ebp),%esi
 805bd51:	c1 e8 0a             	shr    $0xa,%eax
 805bd54:	83 e0 7f             	and    $0x7f,%eax
 805bd57:	89 06                	mov    %eax,(%esi)
	/* We either errored above or got paused; get out */
	if (UNLIKELY(HTTP_PARSER_ERRNO(parser) != HPE_OK)) {
 805bd59:	f6 43 17 7f          	testb  $0x7f,0x17(%ebx)
 805bd5d:	74 12                	je     805bd71 <cb_data+0x7c>
		*parsed = already_parsed;
 805bd5f:	8b 45 0c             	mov    0xc(%ebp),%eax
 805bd62:	8b 55 10             	mov    0x10(%ebp),%edx
 805bd65:	89 10                	mov    %edx,(%eax)
		return -HTTP_PARSER_ERRNO(parser);
 805bd67:	8a 43 17             	mov    0x17(%ebx),%al
 805bd6a:	83 e0 7f             	and    $0x7f,%eax
 805bd6d:	f7 d8                	neg    %eax
 805bd6f:	eb 08                	jmp    805bd79 <cb_data+0x84>
	}
lb_end:
	*mark = NULL;
 805bd71:	c7 07 00 00 00 00    	movl   $0x0,(%edi)
		return 0;
 805bd77:	31 c0                	xor    %eax,%eax

	return 0;
}
 805bd79:	8d 65 f4             	lea    -0xc(%ebp),%esp
 805bd7c:	5b                   	pop    %ebx
 805bd7d:	5e                   	pop    %esi
 805bd7e:	5f                   	pop    %edi
 805bd7f:	5d                   	pop    %ebp
 805bd80:	c3                   	ret    

0805bd81 <http_message_needs_eof>:
	return parsed;
}

/* Does the parser need to see an EOF to find the end of the message? */
int http_message_needs_eof(const struct http_parser *parser)
{
 805bd81:	55                   	push   %ebp
		return 0;
	}

	if ((parser->flags & F_CHUNKED) ||
			parser->content_length != ULLONG_MAX) {
		return 0;
 805bd82:	31 d2                	xor    %edx,%edx
{
 805bd84:	89 e5                	mov    %esp,%ebp
 805bd86:	53                   	push   %ebx
 805bd87:	8b 45 08             	mov    0x8(%ebp),%eax
	if (parser->type == HTTP_REQUEST) {
 805bd8a:	f6 00 03             	testb  $0x3,(%eax)
 805bd8d:	74 3f                	je     805bdce <http_message_needs_eof+0x4d>
	if (parser->status_code / 100 == 1U || /* 1xx e.g. Continue */
 805bd8f:	8b 50 14             	mov    0x14(%eax),%edx
 805bd92:	66 81 fa cc 00       	cmp    $0xcc,%dx
 805bd97:	0f 94 c1             	sete   %cl
			parser->status_code == 204U ||     /* No Content */
 805bd9a:	66 81 fa 30 01       	cmp    $0x130,%dx
 805bd9f:	0f 94 c3             	sete   %bl
 805bda2:	08 d9                	or     %bl,%cl
 805bda4:	75 26                	jne    805bdcc <http_message_needs_eof+0x4b>
	if (parser->status_code / 100 == 1U || /* 1xx e.g. Continue */
 805bda6:	83 ea 64             	sub    $0x64,%edx
			parser->status_code == 204U ||     /* No Content */
 805bda9:	66 83 fa 63          	cmp    $0x63,%dx
 805bdad:	76 1d                	jbe    805bdcc <http_message_needs_eof+0x4b>
			parser->flags & F_SKIPBODY) {     /* response to a HEAD
 805bdaf:	8b 08                	mov    (%eax),%ecx
		return 0;
 805bdb1:	31 d2                	xor    %edx,%edx
			parser->flags & F_SKIPBODY) {     /* response to a HEAD
 805bdb3:	66 c1 e9 02          	shr    $0x2,%cx
	if ((parser->flags & F_CHUNKED) ||
 805bdb7:	80 e1 41             	and    $0x41,%cl
 805bdba:	75 12                	jne    805bdce <http_message_needs_eof+0x4d>
 805bdbc:	8b 50 08             	mov    0x8(%eax),%edx
 805bdbf:	23 50 0c             	and    0xc(%eax),%edx
 805bdc2:	89 d0                	mov    %edx,%eax
 805bdc4:	31 d2                	xor    %edx,%edx
 805bdc6:	40                   	inc    %eax
 805bdc7:	0f 94 c2             	sete   %dl
 805bdca:	eb 02                	jmp    805bdce <http_message_needs_eof+0x4d>
		return 0;
 805bdcc:	31 d2                	xor    %edx,%edx
	}

	return 1;
}
 805bdce:	89 d0                	mov    %edx,%eax
 805bdd0:	5b                   	pop    %ebx
 805bdd1:	5d                   	pop    %ebp
 805bdd2:	c3                   	ret    

0805bdd3 <http_parser_execute>:
{
 805bdd3:	55                   	push   %ebp
 805bdd4:	89 e5                	mov    %esp,%ebp
 805bdd6:	57                   	push   %edi
 805bdd7:	56                   	push   %esi
 805bdd8:	53                   	push   %ebx
 805bdd9:	83 ec 7c             	sub    $0x7c,%esp
 805bddc:	8b 45 0c             	mov    0xc(%ebp),%eax
 805bddf:	8b 75 08             	mov    0x8(%ebp),%esi
 805bde2:	89 45 a4             	mov    %eax,-0x5c(%ebp)
 805bde5:	8b 45 10             	mov    0x10(%ebp),%eax
 805bde8:	89 45 b0             	mov    %eax,-0x50(%ebp)
 805bdeb:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 805bdf1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 805bdf4:	31 c0                	xor    %eax,%eax
	const unsigned int lenient = parser->lenient_http_headers;
 805bdf6:	8a 46 03             	mov    0x3(%esi),%al
	const char *header_field_mark = 0;
 805bdf9:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
	const char *header_value_mark = 0;
 805be00:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
	const unsigned int lenient = parser->lenient_http_headers;
 805be07:	c0 e8 07             	shr    $0x7,%al
	const char *url_mark = 0;
 805be0a:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
	const unsigned int lenient = parser->lenient_http_headers;
 805be11:	88 45 87             	mov    %al,-0x79(%ebp)
	enum state p_state = (enum state) parser->state;
 805be14:	8b 06                	mov    (%esi),%eax
	const char *body_mark = 0;
 805be16:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	enum state p_state = (enum state) parser->state;
 805be1d:	c1 e8 0a             	shr    $0xa,%eax
	const char *status_mark = 0;
 805be20:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	enum state p_state = (enum state) parser->state;
 805be27:	89 c1                	mov    %eax,%ecx
 805be29:	83 e0 7f             	and    $0x7f,%eax
	*parsed = 0;
 805be2c:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
	enum state p_state = (enum state) parser->state;
 805be33:	89 45 c8             	mov    %eax,-0x38(%ebp)
 805be36:	83 e1 7f             	and    $0x7f,%ecx
	if (HTTP_PARSER_ERRNO(parser) != HPE_OK) {
 805be39:	f6 46 17 7f          	testb  $0x7f,0x17(%esi)
 805be3d:	0f 85 e1 17 00 00    	jne    805d624 <http_parser_execute+0x1851>
	if (len == 0) {
 805be43:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
 805be47:	75 50                	jne    805be99 <http_parser_execute+0xc6>
		switch (CURRENT_STATE()) {
 805be49:	80 f9 12             	cmp    $0x12,%cl
 805be4c:	77 14                	ja     805be62 <http_parser_execute+0x8f>
 805be4e:	84 c9                	test   %cl,%cl
 805be50:	74 36                	je     805be88 <http_parser_execute+0xb5>
 805be52:	b8 16 00 04 00       	mov    $0x40016,%eax
 805be57:	d3 e8                	shr    %cl,%eax
 805be59:	a8 01                	test   $0x1,%al
 805be5b:	74 2b                	je     805be88 <http_parser_execute+0xb5>
 805be5d:	e9 c2 17 00 00       	jmp    805d624 <http_parser_execute+0x1851>
 805be62:	80 f9 3d             	cmp    $0x3d,%cl
 805be65:	75 21                	jne    805be88 <http_parser_execute+0xb5>
			cb_notify(parser, &p_state,
 805be67:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 805be6a:	8d 55 c8             	lea    -0x38(%ebp),%edx
 805be6d:	8b 48 1c             	mov    0x1c(%eax),%ecx
 805be70:	50                   	push   %eax
 805be71:	8d 45 c4             	lea    -0x3c(%ebp),%eax
 805be74:	6a 00                	push   $0x0
 805be76:	50                   	push   %eax
 805be77:	89 f0                	mov    %esi,%eax
 805be79:	6a 07                	push   $0x7
 805be7b:	e8 0b fe ff ff       	call   805bc8b <cb_notify>
 805be80:	83 c4 10             	add    $0x10,%esp
			return 0;
 805be83:	e9 9c 17 00 00       	jmp    805d624 <http_parser_execute+0x1851>
			SET_ERRNO(HPE_INVALID_EOF_STATE);
 805be88:	8a 46 17             	mov    0x17(%esi),%al
 805be8b:	83 e0 80             	and    $0xffffff80,%eax
 805be8e:	83 c8 0b             	or     $0xb,%eax
 805be91:	88 46 17             	mov    %al,0x17(%esi)
			return 1;
 805be94:	e9 8b 17 00 00       	jmp    805d624 <http_parser_execute+0x1851>
	if (CURRENT_STATE() == s_header_field) {
 805be99:	83 f8 2b             	cmp    $0x2b,%eax
 805be9c:	75 08                	jne    805bea6 <http_parser_execute+0xd3>
		header_field_mark = data;
 805be9e:	8b 45 b0             	mov    -0x50(%ebp),%eax
 805bea1:	89 45 cc             	mov    %eax,-0x34(%ebp)
	switch (CURRENT_STATE()) {
 805bea4:	eb 2b                	jmp    805bed1 <http_parser_execute+0xfe>
	if (CURRENT_STATE() == s_header_value) {
 805bea6:	83 f8 30             	cmp    $0x30,%eax
 805bea9:	74 18                	je     805bec3 <http_parser_execute+0xf0>
	switch (CURRENT_STATE()) {
 805beab:	80 f9 10             	cmp    $0x10,%cl
 805beae:	74 1b                	je     805becb <http_parser_execute+0xf8>
 805beb0:	83 c1 6b             	add    $0x6b,%ecx
 805beb3:	83 e1 7f             	and    $0x7f,%ecx
 805beb6:	80 f9 0a             	cmp    $0xa,%cl
 805beb9:	77 16                	ja     805bed1 <http_parser_execute+0xfe>
		url_mark = data;
 805bebb:	8b 45 b0             	mov    -0x50(%ebp),%eax
 805bebe:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		break;
 805bec1:	eb 0e                	jmp    805bed1 <http_parser_execute+0xfe>
		header_value_mark = data;
 805bec3:	8b 45 b0             	mov    -0x50(%ebp),%eax
 805bec6:	89 45 d0             	mov    %eax,-0x30(%ebp)
	switch (CURRENT_STATE()) {
 805bec9:	eb 06                	jmp    805bed1 <http_parser_execute+0xfe>
		status_mark = data;
 805becb:	8b 45 b0             	mov    -0x50(%ebp),%eax
 805bece:	89 45 dc             	mov    %eax,-0x24(%ebp)
		break;
 805bed1:	8b 45 b0             	mov    -0x50(%ebp),%eax
 805bed4:	89 45 b4             	mov    %eax,-0x4c(%ebp)
	for (p = data; p != data + len; p++) {
 805bed7:	8b 7d b4             	mov    -0x4c(%ebp),%edi
 805beda:	8b 45 b0             	mov    -0x50(%ebp),%eax
 805bedd:	03 45 14             	add    0x14(%ebp),%eax
 805bee0:	89 45 9c             	mov    %eax,-0x64(%ebp)
 805bee3:	39 f8                	cmp    %edi,%eax
 805bee5:	0f 84 00 16 00 00    	je     805d4eb <http_parser_execute+0x1718>
		ch = *p;
 805beeb:	8b 45 b4             	mov    -0x4c(%ebp),%eax
		if (PARSING_HEADER(CURRENT_STATE())) {
 805beee:	83 7d c8 38          	cmpl   $0x38,-0x38(%ebp)
		ch = *p;
 805bef2:	8a 18                	mov    (%eax),%bl
		if (PARSING_HEADER(CURRENT_STATE())) {
 805bef4:	77 26                	ja     805bf1c <http_parser_execute+0x149>
	parser->nread += bytes;
 805bef6:	8b 46 04             	mov    0x4(%esi),%eax
 805bef9:	40                   	inc    %eax
 805befa:	89 46 04             	mov    %eax,0x4(%esi)
	if (UNLIKELY(parser->nread > (HTTP_MAX_HEADER_SIZE))) {
 805befd:	3d 00 40 01 00       	cmp    $0x14000,%eax
 805bf02:	76 18                	jbe    805bf1c <http_parser_execute+0x149>
		parser->http_errno = HPE_HEADER_OVERFLOW;
 805bf04:	8a 46 17             	mov    0x17(%esi),%al
 805bf07:	83 e0 80             	and    $0xffffff80,%eax
 805bf0a:	83 c8 0c             	or     $0xc,%eax
 805bf0d:	e9 b9 15 00 00       	jmp    805d4cb <http_parser_execute+0x16f8>
				parser->type = HTTP_REQUEST;
 805bf12:	80 26 fc             	andb   $0xfc,(%esi)
				UPDATE_STATE(s_start_req);
 805bf15:	c7 45 c8 12 00 00 00 	movl   $0x12,-0x38(%ebp)
		switch (CURRENT_STATE()) {
 805bf1c:	8b 45 c8             	mov    -0x38(%ebp),%eax
 805bf1f:	8d 50 ff             	lea    -0x1(%eax),%edx
 805bf22:	83 fa 3d             	cmp    $0x3d,%edx
 805bf25:	0f 87 97 15 00 00    	ja     805d4c2 <http_parser_execute+0x16ef>
 805bf2b:	ff 24 95 d4 24 06 08 	jmp    *0x80624d4(,%edx,4)
			if (LIKELY(ch == CR || ch == LF)) {
 805bf32:	80 fb 0d             	cmp    $0xd,%bl
 805bf35:	0f 84 a8 15 00 00    	je     805d4e3 <http_parser_execute+0x1710>
 805bf3b:	80 fb 0a             	cmp    $0xa,%bl
 805bf3e:	0f 84 9f 15 00 00    	je     805d4e3 <http_parser_execute+0x1710>
			SET_ERRNO(HPE_CLOSED_CONNECTION);
 805bf44:	8a 46 17             	mov    0x17(%esi),%al
 805bf47:	83 e0 80             	and    $0xffffff80,%eax
 805bf4a:	83 c8 0d             	or     $0xd,%eax
 805bf4d:	e9 79 15 00 00       	jmp    805d4cb <http_parser_execute+0x16f8>
			if (ch == CR || ch == LF) {
 805bf52:	80 fb 0d             	cmp    $0xd,%bl
 805bf55:	0f 84 88 15 00 00    	je     805d4e3 <http_parser_execute+0x1710>
 805bf5b:	80 fb 0a             	cmp    $0xa,%bl
 805bf5e:	0f 84 7f 15 00 00    	je     805d4e3 <http_parser_execute+0x1710>
			parser->flags = 0U;
 805bf64:	66 81 26 03 fc       	andw   $0xfc03,(%esi)
			parser->content_length = ULLONG_MAX;
 805bf69:	c7 46 08 ff ff ff ff 	movl   $0xffffffff,0x8(%esi)
 805bf70:	c7 46 0c ff ff ff ff 	movl   $0xffffffff,0xc(%esi)
			if (ch == 'H') {
 805bf77:	80 fb 48             	cmp    $0x48,%bl
 805bf7a:	75 96                	jne    805bf12 <http_parser_execute+0x13f>
				UPDATE_STATE(s_res_or_resp_H);
 805bf7c:	c7 45 c8 03 00 00 00 	movl   $0x3,-0x38(%ebp)
				rc = cb_notify(parser, &p_state,
 805bf83:	e9 55 03 00 00       	jmp    805c2dd <http_parser_execute+0x50a>
			if (ch == 'T') {
 805bf88:	80 fb 54             	cmp    $0x54,%bl
 805bf8b:	75 0c                	jne    805bf99 <http_parser_execute+0x1c6>
				parser->type = HTTP_RESPONSE;
 805bf8d:	8a 06                	mov    (%esi),%al
 805bf8f:	83 e0 fc             	and    $0xfffffffc,%eax
 805bf92:	83 c8 01             	or     $0x1,%eax
 805bf95:	88 06                	mov    %al,(%esi)
				UPDATE_STATE(s_res_HT);
 805bf97:	eb 62                	jmp    805bffb <http_parser_execute+0x228>
				if (UNLIKELY(ch != 'E')) {
 805bf99:	80 fb 45             	cmp    $0x45,%bl
 805bf9c:	0f 85 0f 06 00 00    	jne    805c5b1 <http_parser_execute+0x7de>
				parser->type = HTTP_REQUEST;
 805bfa2:	8b 06                	mov    (%esi),%eax
				parser->method = HTTP_HEAD;
 805bfa4:	c6 46 16 02          	movb   $0x2,0x16(%esi)
				UPDATE_STATE(s_req_method);
 805bfa8:	c7 45 c8 13 00 00 00 	movl   $0x13,-0x38(%ebp)
				parser->type = HTTP_REQUEST;
 805bfaf:	25 fc ff ff 80       	and    $0x80fffffc,%eax
 805bfb4:	0d 00 00 00 02       	or     $0x2000000,%eax
 805bfb9:	89 06                	mov    %eax,(%esi)
				UPDATE_STATE(s_req_method);
 805bfbb:	e9 23 15 00 00       	jmp    805d4e3 <http_parser_execute+0x1710>
			parser->flags = 0U;
 805bfc0:	66 81 26 03 fc       	andw   $0xfc03,(%esi)
			parser->content_length = ULLONG_MAX;
 805bfc5:	c7 46 08 ff ff ff ff 	movl   $0xffffffff,0x8(%esi)
 805bfcc:	c7 46 0c ff ff ff ff 	movl   $0xffffffff,0xc(%esi)
			switch (ch) {
 805bfd3:	80 fb 0d             	cmp    $0xd,%bl
 805bfd6:	0f 84 01 03 00 00    	je     805c2dd <http_parser_execute+0x50a>
 805bfdc:	80 fb 48             	cmp    $0x48,%bl
 805bfdf:	74 0e                	je     805bfef <http_parser_execute+0x21c>
 805bfe1:	80 fb 0a             	cmp    $0xa,%bl
 805bfe4:	0f 85 c7 05 00 00    	jne    805c5b1 <http_parser_execute+0x7de>
 805bfea:	e9 ee 02 00 00       	jmp    805c2dd <http_parser_execute+0x50a>
				UPDATE_STATE(s_res_H);
 805bfef:	c7 45 c8 05 00 00 00 	movl   $0x5,-0x38(%ebp)
				break;
 805bff6:	e9 e2 02 00 00       	jmp    805c2dd <http_parser_execute+0x50a>
			UPDATE_STATE(s_res_HT);
 805bffb:	c7 45 c8 06 00 00 00 	movl   $0x6,-0x38(%ebp)
			break;
 805c002:	e9 dc 14 00 00       	jmp    805d4e3 <http_parser_execute+0x1710>
			UPDATE_STATE(s_res_HTT);
 805c007:	c7 45 c8 07 00 00 00 	movl   $0x7,-0x38(%ebp)
			break;
 805c00e:	e9 d0 14 00 00       	jmp    805d4e3 <http_parser_execute+0x1710>
			UPDATE_STATE(s_res_HTTP);
 805c013:	c7 45 c8 08 00 00 00 	movl   $0x8,-0x38(%ebp)
			break;
 805c01a:	e9 c4 14 00 00       	jmp    805d4e3 <http_parser_execute+0x1710>
			UPDATE_STATE(s_res_first_http_major);
 805c01f:	c7 45 c8 09 00 00 00 	movl   $0x9,-0x38(%ebp)
			break;
 805c026:	e9 b8 14 00 00       	jmp    805d4e3 <http_parser_execute+0x1710>
			if (UNLIKELY(ch < '0' || ch > '9')) {
 805c02b:	8d 43 d0             	lea    -0x30(%ebx),%eax
 805c02e:	3c 09                	cmp    $0x9,%al
 805c030:	0f 87 5c 06 00 00    	ja     805c692 <http_parser_execute+0x8bf>
			parser->http_major = ch - '0';
 805c036:	66 0f be c3          	movsbw %bl,%ax
			UPDATE_STATE(s_res_http_major);
 805c03a:	c7 45 c8 0a 00 00 00 	movl   $0xa,-0x38(%ebp)
			parser->http_major = ch - '0';
 805c041:	83 e8 30             	sub    $0x30,%eax
 805c044:	66 89 46 10          	mov    %ax,0x10(%esi)
			break;
 805c048:	e9 96 14 00 00       	jmp    805d4e3 <http_parser_execute+0x1710>
			if (ch == '.') {
 805c04d:	80 fb 2e             	cmp    $0x2e,%bl
 805c050:	0f 85 cc 05 00 00    	jne    805c622 <http_parser_execute+0x84f>
				UPDATE_STATE(s_res_first_http_minor);
 805c056:	c7 45 c8 0b 00 00 00 	movl   $0xb,-0x38(%ebp)
				break;
 805c05d:	e9 81 14 00 00       	jmp    805d4e3 <http_parser_execute+0x1710>
			if (UNLIKELY(!IS_NUM(ch))) {
 805c062:	8d 43 d0             	lea    -0x30(%ebx),%eax
 805c065:	3c 09                	cmp    $0x9,%al
 805c067:	0f 87 25 06 00 00    	ja     805c692 <http_parser_execute+0x8bf>
			parser->http_minor = ch - '0';
 805c06d:	66 0f be c3          	movsbw %bl,%ax
			UPDATE_STATE(s_res_http_minor);
 805c071:	c7 45 c8 0c 00 00 00 	movl   $0xc,-0x38(%ebp)
			parser->http_minor = ch - '0';
 805c078:	83 e8 30             	sub    $0x30,%eax
 805c07b:	66 89 46 12          	mov    %ax,0x12(%esi)
			break;
 805c07f:	e9 5f 14 00 00       	jmp    805d4e3 <http_parser_execute+0x1710>
			if (ch == ' ') {
 805c084:	80 fb 20             	cmp    $0x20,%bl
 805c087:	0f 85 e3 05 00 00    	jne    805c670 <http_parser_execute+0x89d>
				UPDATE_STATE(s_res_first_status_code);
 805c08d:	c7 45 c8 0d 00 00 00 	movl   $0xd,-0x38(%ebp)
				break;
 805c094:	e9 4a 14 00 00       	jmp    805d4e3 <http_parser_execute+0x1710>
			if (!IS_NUM(ch)) {
 805c099:	8d 43 d0             	lea    -0x30(%ebx),%eax
 805c09c:	3c 09                	cmp    $0x9,%al
 805c09e:	76 0e                	jbe    805c0ae <http_parser_execute+0x2db>
				if (ch == ' ') {
 805c0a0:	80 fb 20             	cmp    $0x20,%bl
 805c0a3:	0f 84 3a 14 00 00    	je     805d4e3 <http_parser_execute+0x1710>
 805c0a9:	e9 92 00 00 00       	jmp    805c140 <http_parser_execute+0x36d>
			parser->status_code = ch - '0';
 805c0ae:	66 0f be c3          	movsbw %bl,%ax
			UPDATE_STATE(s_res_status_code);
 805c0b2:	c7 45 c8 0e 00 00 00 	movl   $0xe,-0x38(%ebp)
			parser->status_code = ch - '0';
 805c0b9:	83 e8 30             	sub    $0x30,%eax
 805c0bc:	66 89 46 14          	mov    %ax,0x14(%esi)
			break;
 805c0c0:	e9 1e 14 00 00       	jmp    805d4e3 <http_parser_execute+0x1710>
			if (!IS_NUM(ch)) {
 805c0c5:	8d 43 d0             	lea    -0x30(%ebx),%eax
 805c0c8:	3c 09                	cmp    $0x9,%al
 805c0ca:	76 59                	jbe    805c125 <http_parser_execute+0x352>
				if ((ch == CR) || (ch == LF)) {
 805c0cc:	80 fb 0d             	cmp    $0xd,%bl
 805c0cf:	74 09                	je     805c0da <http_parser_execute+0x307>
 805c0d1:	80 fb 0a             	cmp    $0xa,%bl
 805c0d4:	0f 85 f9 13 00 00    	jne    805d4d3 <http_parser_execute+0x1700>
					rc = cb_data(parser,
 805c0da:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 805c0dd:	83 ec 0c             	sub    $0xc,%esp
 805c0e0:	b9 08 00 00 00       	mov    $0x8,%ecx
					const char *no_status_txt = "";
 805c0e5:	c7 45 e0 b0 34 06 08 	movl   $0x80634b0,-0x20(%ebp)
					rc = cb_data(parser,
 805c0ec:	8b 50 08             	mov    0x8(%eax),%edx
 805c0ef:	8d 45 e0             	lea    -0x20(%ebp),%eax
 805c0f2:	6a 00                	push   $0x0
 805c0f4:	50                   	push   %eax
					     p - data + 1, &no_status_txt, 0);
 805c0f5:	8b 45 b4             	mov    -0x4c(%ebp),%eax
 805c0f8:	2b 45 b0             	sub    -0x50(%ebp),%eax
 805c0fb:	40                   	inc    %eax
					rc = cb_data(parser,
 805c0fc:	50                   	push   %eax
 805c0fd:	8d 45 c4             	lea    -0x3c(%ebp),%eax
 805c100:	50                   	push   %eax
 805c101:	8d 45 c8             	lea    -0x38(%ebp),%eax
 805c104:	50                   	push   %eax
 805c105:	89 f0                	mov    %esi,%eax
 805c107:	e8 e9 fb ff ff       	call   805bcf5 <cb_data>
 805c10c:	83 c4 20             	add    $0x20,%esp
					if (rc != 0) {
 805c10f:	85 c0                	test   %eax,%eax
 805c111:	0f 85 0d 15 00 00    	jne    805d624 <http_parser_execute+0x1851>
				switch (ch) {
 805c117:	80 fb 0d             	cmp    $0xd,%bl
 805c11a:	0f 84 8b 00 00 00    	je     805c1ab <http_parser_execute+0x3d8>
 805c120:	e9 85 05 00 00       	jmp    805c6aa <http_parser_execute+0x8d7>
			parser->status_code *= 10U;
 805c125:	66 6b 46 14 0a       	imul   $0xa,0x14(%esi),%ax
			parser->status_code += ch - '0';
 805c12a:	66 0f be d3          	movsbw %bl,%dx
 805c12e:	8d 44 10 d0          	lea    -0x30(%eax,%edx,1),%eax
 805c132:	66 89 46 14          	mov    %ax,0x14(%esi)
			if (UNLIKELY(parser->status_code > 999)) {
 805c136:	66 3d e7 03          	cmp    $0x3e7,%ax
 805c13a:	0f 86 a3 13 00 00    	jbe    805d4e3 <http_parser_execute+0x1710>
				SET_ERRNO(HPE_INVALID_STATUS);
 805c140:	8a 46 17             	mov    0x17(%esi),%al
 805c143:	83 e0 80             	and    $0xffffff80,%eax
 805c146:	83 c8 0f             	or     $0xf,%eax
 805c149:	e9 7d 13 00 00       	jmp    805d4cb <http_parser_execute+0x16f8>
			if (!status_mark && ((ch == CR) || (ch == LF))) {
 805c14e:	8b 45 dc             	mov    -0x24(%ebp),%eax
 805c151:	89 c7                	mov    %eax,%edi
 805c153:	85 c0                	test   %eax,%eax
 805c155:	75 4f                	jne    805c1a6 <http_parser_execute+0x3d3>
 805c157:	80 fb 0d             	cmp    $0xd,%bl
 805c15a:	74 0d                	je     805c169 <http_parser_execute+0x396>
 805c15c:	80 fb 0a             	cmp    $0xa,%bl
 805c15f:	74 08                	je     805c169 <http_parser_execute+0x396>
			MARK(status);
 805c161:	8b 45 b4             	mov    -0x4c(%ebp),%eax
 805c164:	89 45 dc             	mov    %eax,-0x24(%ebp)
 805c167:	eb 5b                	jmp    805c1c4 <http_parser_execute+0x3f1>
				rc = cb_data(parser,
 805c169:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 805c16c:	83 ec 0c             	sub    $0xc,%esp
 805c16f:	b9 08 00 00 00       	mov    $0x8,%ecx
				const char *no_status_txt = "";
 805c174:	c7 45 e0 b0 34 06 08 	movl   $0x80634b0,-0x20(%ebp)
				rc = cb_data(parser,
 805c17b:	8b 50 08             	mov    0x8(%eax),%edx
 805c17e:	8d 45 e0             	lea    -0x20(%ebp),%eax
 805c181:	6a 00                	push   $0x0
 805c183:	50                   	push   %eax
					p - data + 1, &no_status_txt, 0);
 805c184:	8b 45 b4             	mov    -0x4c(%ebp),%eax
 805c187:	2b 45 b0             	sub    -0x50(%ebp),%eax
 805c18a:	40                   	inc    %eax
				rc = cb_data(parser,
 805c18b:	50                   	push   %eax
 805c18c:	8d 45 c4             	lea    -0x3c(%ebp),%eax
 805c18f:	50                   	push   %eax
 805c190:	8d 45 c8             	lea    -0x38(%ebp),%eax
 805c193:	50                   	push   %eax
 805c194:	89 f0                	mov    %esi,%eax
 805c196:	e8 5a fb ff ff       	call   805bcf5 <cb_data>
 805c19b:	83 c4 20             	add    $0x20,%esp
				if (rc != 0) {
 805c19e:	85 c0                	test   %eax,%eax
 805c1a0:	0f 85 7e 14 00 00    	jne    805d624 <http_parser_execute+0x1851>
			if (ch == CR) {
 805c1a6:	80 fb 0d             	cmp    $0xd,%bl
 805c1a9:	75 0c                	jne    805c1b7 <http_parser_execute+0x3e4>
				UPDATE_STATE(s_res_line_almost_done);
 805c1ab:	c7 45 c8 11 00 00 00 	movl   $0x11,-0x38(%ebp)
				break;
 805c1b2:	e9 2c 13 00 00       	jmp    805d4e3 <http_parser_execute+0x1710>
			if (ch == LF) {
 805c1b7:	80 fb 0a             	cmp    $0xa,%bl
 805c1ba:	0f 84 f3 04 00 00    	je     805c6b3 <http_parser_execute+0x8e0>
			MARK(status);
 805c1c0:	85 ff                	test   %edi,%edi
 805c1c2:	74 9d                	je     805c161 <http_parser_execute+0x38e>
			parser->index = 0U;
 805c1c4:	80 66 03 80          	andb   $0x80,0x3(%esi)
			UPDATE_STATE(s_res_status);
 805c1c8:	c7 45 c8 10 00 00 00 	movl   $0x10,-0x38(%ebp)
			break;
 805c1cf:	e9 0f 13 00 00       	jmp    805d4e3 <http_parser_execute+0x1710>
			if (ch == CR) {
 805c1d4:	80 fb 0d             	cmp    $0xd,%bl
 805c1d7:	75 09                	jne    805c1e2 <http_parser_execute+0x40f>
				UPDATE_STATE(s_res_line_almost_done);
 805c1d9:	c7 45 c8 11 00 00 00 	movl   $0x11,-0x38(%ebp)
				rc = cb_data(parser, settings->on_status,
 805c1e0:	eb 10                	jmp    805c1f2 <http_parser_execute+0x41f>
			if (ch == LF) {
 805c1e2:	80 fb 0a             	cmp    $0xa,%bl
 805c1e5:	0f 85 f8 12 00 00    	jne    805d4e3 <http_parser_execute+0x1710>
				UPDATE_STATE(s_header_field_start);
 805c1eb:	c7 45 c8 2a 00 00 00 	movl   $0x2a,-0x38(%ebp)
				rc = cb_data(parser, settings->on_status,
 805c1f2:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 805c1f5:	83 ec 0c             	sub    $0xc,%esp
 805c1f8:	b9 08 00 00 00       	mov    $0x8,%ecx
 805c1fd:	8b 50 08             	mov    0x8(%eax),%edx
					     p - status_mark);
 805c200:	8b 45 b4             	mov    -0x4c(%ebp),%eax
 805c203:	2b 45 dc             	sub    -0x24(%ebp),%eax
				rc = cb_data(parser, settings->on_status,
 805c206:	50                   	push   %eax
 805c207:	8d 45 dc             	lea    -0x24(%ebp),%eax
 805c20a:	50                   	push   %eax
					     p - data + 1, &status_mark,
 805c20b:	8b 45 b4             	mov    -0x4c(%ebp),%eax
 805c20e:	2b 45 b0             	sub    -0x50(%ebp),%eax
 805c211:	40                   	inc    %eax
				rc = cb_data(parser, settings->on_status,
 805c212:	50                   	push   %eax
 805c213:	8d 45 c4             	lea    -0x3c(%ebp),%eax
 805c216:	50                   	push   %eax
 805c217:	8d 45 c8             	lea    -0x38(%ebp),%eax
 805c21a:	50                   	push   %eax
 805c21b:	89 f0                	mov    %esi,%eax
 805c21d:	e8 d3 fa ff ff       	call   805bcf5 <cb_data>
 805c222:	83 c4 20             	add    $0x20,%esp
 805c225:	e9 8f 12 00 00       	jmp    805d4b9 <http_parser_execute+0x16e6>
			if (ch == CR || ch == LF) {
 805c22a:	80 fb 0d             	cmp    $0xd,%bl
 805c22d:	0f 84 b0 12 00 00    	je     805d4e3 <http_parser_execute+0x1710>
 805c233:	80 fb 0a             	cmp    $0xa,%bl
 805c236:	0f 84 a7 12 00 00    	je     805d4e3 <http_parser_execute+0x1710>
			if (UNLIKELY(!IS_ALPHA(ch))) {
 805c23c:	89 d8                	mov    %ebx,%eax
			parser->flags = 0U;
 805c23e:	66 81 26 03 fc       	andw   $0xfc03,(%esi)
			if (UNLIKELY(!IS_ALPHA(ch))) {
 805c243:	83 c8 20             	or     $0x20,%eax
			parser->content_length = ULLONG_MAX;
 805c246:	c7 46 08 ff ff ff ff 	movl   $0xffffffff,0x8(%esi)
			if (UNLIKELY(!IS_ALPHA(ch))) {
 805c24d:	83 e8 61             	sub    $0x61,%eax
			parser->content_length = ULLONG_MAX;
 805c250:	c7 46 0c ff ff ff ff 	movl   $0xffffffff,0xc(%esi)
			if (UNLIKELY(!IS_ALPHA(ch))) {
 805c257:	3c 19                	cmp    $0x19,%al
 805c259:	0f 87 47 02 00 00    	ja     805c4a6 <http_parser_execute+0x6d3>
			parser->index = 1U;
 805c25f:	8a 46 03             	mov    0x3(%esi),%al
			parser->method = (enum http_method) 0;
 805c262:	c6 46 16 00          	movb   $0x0,0x16(%esi)
			parser->index = 1U;
 805c266:	83 e0 80             	and    $0xffffff80,%eax
 805c269:	83 c8 01             	or     $0x1,%eax
 805c26c:	88 46 03             	mov    %al,0x3(%esi)
			switch (ch) {
 805c26f:	8d 43 bf             	lea    -0x41(%ebx),%eax
 805c272:	3c 14                	cmp    $0x14,%al
 805c274:	0f 87 2c 02 00 00    	ja     805c4a6 <http_parser_execute+0x6d3>
 805c27a:	0f b6 c0             	movzbl %al,%eax
 805c27d:	ff 24 85 cc 25 06 08 	jmp    *0x80625cc(,%eax,4)
				parser->method = HTTP_ACL;
 805c284:	c6 46 16 13          	movb   $0x13,0x16(%esi)
				break;
 805c288:	eb 4c                	jmp    805c2d6 <http_parser_execute+0x503>
				parser->method = HTTP_BIND;
 805c28a:	c6 46 16 10          	movb   $0x10,0x16(%esi)
				break;
 805c28e:	eb 46                	jmp    805c2d6 <http_parser_execute+0x503>
				parser->method = HTTP_CONNECT;
 805c290:	c6 46 16 05          	movb   $0x5,0x16(%esi)
				break;
 805c294:	eb 40                	jmp    805c2d6 <http_parser_execute+0x503>
				parser->method = HTTP_GET;
 805c296:	c6 46 16 01          	movb   $0x1,0x16(%esi)
				break;
 805c29a:	eb 3a                	jmp    805c2d6 <http_parser_execute+0x503>
				parser->method = HTTP_HEAD;
 805c29c:	c6 46 16 02          	movb   $0x2,0x16(%esi)
				break;
 805c2a0:	eb 34                	jmp    805c2d6 <http_parser_execute+0x503>
				parser->method = HTTP_LOCK; /* or LINK */
 805c2a2:	c6 46 16 09          	movb   $0x9,0x16(%esi)
				break;
 805c2a6:	eb 2e                	jmp    805c2d6 <http_parser_execute+0x503>
				parser->method =
 805c2a8:	c6 46 16 0a          	movb   $0xa,0x16(%esi)
				break;
 805c2ac:	eb 28                	jmp    805c2d6 <http_parser_execute+0x503>
				parser->method = HTTP_NOTIFY;
 805c2ae:	c6 46 16 19          	movb   $0x19,0x16(%esi)
				break;
 805c2b2:	eb 22                	jmp    805c2d6 <http_parser_execute+0x503>
				parser->method = HTTP_OPTIONS;
 805c2b4:	c6 46 16 06          	movb   $0x6,0x16(%esi)
				break;
 805c2b8:	eb 1c                	jmp    805c2d6 <http_parser_execute+0x503>
				parser->method = HTTP_POST;
 805c2ba:	c6 46 16 03          	movb   $0x3,0x16(%esi)
				break;
 805c2be:	eb 16                	jmp    805c2d6 <http_parser_execute+0x503>
				parser->method = HTTP_REPORT; /* or REBIND */
 805c2c0:	c6 46 16 14          	movb   $0x14,0x16(%esi)
				break;
 805c2c4:	eb 10                	jmp    805c2d6 <http_parser_execute+0x503>
				parser->method = HTTP_SUBSCRIBE; /* or SEARCH */
 805c2c6:	c6 46 16 1a          	movb   $0x1a,0x16(%esi)
				break;
 805c2ca:	eb 0a                	jmp    805c2d6 <http_parser_execute+0x503>
				parser->method = HTTP_TRACE;
 805c2cc:	c6 46 16 07          	movb   $0x7,0x16(%esi)
				break;
 805c2d0:	eb 04                	jmp    805c2d6 <http_parser_execute+0x503>
				parser->method = HTTP_UNLOCK;
 805c2d2:	c6 46 16 0f          	movb   $0xf,0x16(%esi)
			UPDATE_STATE(s_req_method);
 805c2d6:	c7 45 c8 13 00 00 00 	movl   $0x13,-0x38(%ebp)
			rc = cb_notify(parser, &p_state,
 805c2dd:	50                   	push   %eax
				       p - data + 1);
 805c2de:	8b 45 b4             	mov    -0x4c(%ebp),%eax
 805c2e1:	2b 45 b0             	sub    -0x50(%ebp),%eax
 805c2e4:	40                   	inc    %eax
			rc = cb_notify(parser, &p_state,
 805c2e5:	50                   	push   %eax
 805c2e6:	8d 45 c4             	lea    -0x3c(%ebp),%eax
 805c2e9:	50                   	push   %eax
 805c2ea:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 805c2ed:	6a 01                	push   $0x1
 805c2ef:	8b 08                	mov    (%eax),%ecx
 805c2f1:	e9 b6 11 00 00       	jmp    805d4ac <http_parser_execute+0x16d9>
			if (UNLIKELY(ch == '\0')) {
 805c2f6:	84 db                	test   %bl,%bl
 805c2f8:	0f 84 a8 01 00 00    	je     805c4a6 <http_parser_execute+0x6d3>
			if (ch == ' ' && matcher[parser->index] == '\0') {
 805c2fe:	8a 56 03             	mov    0x3(%esi),%dl
			matcher = method_strings[parser->method];
 805c301:	0f b6 7e 16          	movzbl 0x16(%esi),%edi
			if (ch == ' ' && matcher[parser->index] == '\0') {
 805c305:	89 d0                	mov    %edx,%eax
			matcher = method_strings[parser->method];
 805c307:	89 f9                	mov    %edi,%ecx
			if (ch == ' ' && matcher[parser->index] == '\0') {
 805c309:	83 e0 7f             	and    $0x7f,%eax
 805c30c:	88 45 a8             	mov    %al,-0x58(%ebp)
 805c30f:	89 d0                	mov    %edx,%eax
 805c311:	8b 14 bd 40 22 06 08 	mov    0x8062240(,%edi,4),%edx
 805c318:	83 e0 7f             	and    $0x7f,%eax
 805c31b:	89 45 a0             	mov    %eax,-0x60(%ebp)
 805c31e:	8a 14 02             	mov    (%edx,%eax,1),%dl
 805c321:	80 fb 20             	cmp    $0x20,%bl
 805c324:	75 14                	jne    805c33a <http_parser_execute+0x567>
 805c326:	84 d2                	test   %dl,%dl
 805c328:	0f 85 73 01 00 00    	jne    805c4a1 <http_parser_execute+0x6ce>
				UPDATE_STATE(s_req_spaces_before_url);
 805c32e:	c7 45 c8 14 00 00 00 	movl   $0x14,-0x38(%ebp)
 805c335:	e9 7a 01 00 00       	jmp    805c4b4 <http_parser_execute+0x6e1>
			} else if (ch == matcher[parser->index]) {
 805c33a:	38 d3                	cmp    %dl,%bl
 805c33c:	0f 84 72 01 00 00    	je     805c4b4 <http_parser_execute+0x6e1>
			} else if (IS_ALPHA(ch)) {
 805c342:	89 da                	mov    %ebx,%edx
 805c344:	83 ca 20             	or     $0x20,%edx
 805c347:	83 ea 61             	sub    $0x61,%edx
 805c34a:	80 fa 19             	cmp    $0x19,%dl
 805c34d:	0f 87 38 01 00 00    	ja     805c48b <http_parser_execute+0x6b8>
						     parser->index << 8 | ch;
 805c353:	8b 55 a0             	mov    -0x60(%ebp),%edx
				uint64_t sw_option = parser->method << 16 |
 805c356:	89 f8                	mov    %edi,%eax
 805c358:	c1 e0 10             	shl    $0x10,%eax
						     parser->index << 8 | ch;
 805c35b:	c1 e2 08             	shl    $0x8,%edx
				uint64_t sw_option = parser->method << 16 |
 805c35e:	09 d0                	or     %edx,%eax
						     parser->index << 8 | ch;
 805c360:	0f be d3             	movsbl %bl,%edx
 805c363:	09 d0                	or     %edx,%eax
				switch (sw_option) {
 805c365:	3d 4f 01 0a 00       	cmp    $0xa014f,%eax
 805c36a:	0f 84 eb 00 00 00    	je     805c45b <http_parser_execute+0x688>
 805c370:	7f 77                	jg     805c3e9 <http_parser_execute+0x616>
 805c372:	3d 48 01 05 00       	cmp    $0x50148,%eax
 805c377:	0f 84 d8 00 00 00    	je     805c455 <http_parser_execute+0x682>
 805c37d:	7f 40                	jg     805c3bf <http_parser_execute+0x5ec>
 805c37f:	3d 55 01 03 00       	cmp    $0x30155,%eax
 805c384:	0f 84 bf 00 00 00    	je     805c449 <http_parser_execute+0x676>
 805c38a:	7f 1f                	jg     805c3ab <http_parser_execute+0x5d8>
 805c38c:	3d 41 01 03 00       	cmp    $0x30141,%eax
 805c391:	0f 84 b8 00 00 00    	je     805c44f <http_parser_execute+0x67c>
 805c397:	3d 52 01 03 00       	cmp    $0x30152,%eax
 805c39c:	0f 85 04 01 00 00    	jne    805c4a6 <http_parser_execute+0x6d3>
					parser->method = HTTP_PROPFIND;
 805c3a2:	c6 46 16 0c          	movb   $0xc,0x16(%esi)
					break;
 805c3a6:	e9 09 01 00 00       	jmp    805c4b4 <http_parser_execute+0x6e1>
 805c3ab:	3d 52 02 04 00       	cmp    $0x40252,%eax
 805c3b0:	0f 85 f0 00 00 00    	jne    805c4a6 <http_parser_execute+0x6d3>
					parser->method = HTTP_PURGE;
 805c3b6:	c6 46 16 1d          	movb   $0x1d,0x16(%esi)
					break;
 805c3ba:	e9 f5 00 00 00       	jmp    805c4b4 <http_parser_execute+0x6e1>
 805c3bf:	3d 49 01 09 00       	cmp    $0x90149,%eax
 805c3c4:	0f 84 b5 00 00 00    	je     805c47f <http_parser_execute+0x6ac>
 805c3ca:	3d 45 01 0a 00       	cmp    $0xa0145,%eax
 805c3cf:	0f 84 8c 00 00 00    	je     805c461 <http_parser_execute+0x68e>
 805c3d5:	3d 50 02 05 00       	cmp    $0x50250,%eax
 805c3da:	0f 85 c6 00 00 00    	jne    805c4a6 <http_parser_execute+0x6d3>
					parser->method = HTTP_COPY;
 805c3e0:	c6 46 16 08          	movb   $0x8,0x16(%esi)
					break;
 805c3e4:	e9 cb 00 00 00       	jmp    805c4b4 <http_parser_execute+0x6e1>
 805c3e9:	3d 53 02 0f 00       	cmp    $0xf0253,%eax
 805c3ee:	0f 84 91 00 00 00    	je     805c485 <http_parser_execute+0x6b2>
 805c3f4:	7f 38                	jg     805c42e <http_parser_execute+0x65b>
 805c3f6:	3d 50 04 0c 00       	cmp    $0xc0450,%eax
 805c3fb:	74 7c                	je     805c479 <http_parser_execute+0x6a6>
 805c3fd:	7f 1b                	jg     805c41a <http_parser_execute+0x647>
 805c3ff:	3d 41 02 0a 00       	cmp    $0xa0241,%eax
 805c404:	74 61                	je     805c467 <http_parser_execute+0x694>
 805c406:	3d 41 03 0a 00       	cmp    $0xa0341,%eax
 805c40b:	0f 85 95 00 00 00    	jne    805c4a6 <http_parser_execute+0x6d3>
					parser->method = HTTP_MKCALENDAR;
 805c411:	c6 46 16 1e          	movb   $0x1e,0x16(%esi)
					break;
 805c415:	e9 9a 00 00 00       	jmp    805c4b4 <http_parser_execute+0x6e1>
 805c41a:	3d 42 02 0f 00       	cmp    $0xf0242,%eax
 805c41f:	0f 85 81 00 00 00    	jne    805c4a6 <http_parser_execute+0x6d3>
					parser->method = HTTP_UNBIND;
 805c425:	c6 46 16 12          	movb   $0x12,0x16(%esi)
					break;
 805c429:	e9 86 00 00 00       	jmp    805c4b4 <http_parser_execute+0x6e1>
 805c42e:	3d 42 02 14 00       	cmp    $0x140242,%eax
 805c433:	74 3e                	je     805c473 <http_parser_execute+0x6a0>
 805c435:	3d 45 01 1a 00       	cmp    $0x1a0145,%eax
 805c43a:	74 31                	je     805c46d <http_parser_execute+0x69a>
 805c43c:	3d 49 03 0f 00       	cmp    $0xf0349,%eax
 805c441:	75 63                	jne    805c4a6 <http_parser_execute+0x6d3>
					parser->method = HTTP_UNLINK;
 805c443:	c6 46 16 20          	movb   $0x20,0x16(%esi)
					break;
 805c447:	eb 6b                	jmp    805c4b4 <http_parser_execute+0x6e1>
					parser->method = HTTP_PUT;
 805c449:	c6 46 16 04          	movb   $0x4,0x16(%esi)
					break;
 805c44d:	eb 65                	jmp    805c4b4 <http_parser_execute+0x6e1>
					parser->method = HTTP_PATCH;
 805c44f:	c6 46 16 1c          	movb   $0x1c,0x16(%esi)
					break;
 805c453:	eb 5f                	jmp    805c4b4 <http_parser_execute+0x6e1>
					parser->method = HTTP_CHECKOUT;
 805c455:	c6 46 16 16          	movb   $0x16,0x16(%esi)
					break;
 805c459:	eb 59                	jmp    805c4b4 <http_parser_execute+0x6e1>
					parser->method = HTTP_MOVE;
 805c45b:	c6 46 16 0b          	movb   $0xb,0x16(%esi)
					break;
 805c45f:	eb 53                	jmp    805c4b4 <http_parser_execute+0x6e1>
					parser->method = HTTP_MERGE;
 805c461:	c6 46 16 17          	movb   $0x17,0x16(%esi)
					break;
 805c465:	eb 4d                	jmp    805c4b4 <http_parser_execute+0x6e1>
					parser->method = HTTP_MKACTIVITY;
 805c467:	c6 46 16 15          	movb   $0x15,0x16(%esi)
					break;
 805c46b:	eb 47                	jmp    805c4b4 <http_parser_execute+0x6e1>
					parser->method = HTTP_SEARCH;
 805c46d:	c6 46 16 0e          	movb   $0xe,0x16(%esi)
					break;
 805c471:	eb 41                	jmp    805c4b4 <http_parser_execute+0x6e1>
					parser->method = HTTP_REBIND;
 805c473:	c6 46 16 11          	movb   $0x11,0x16(%esi)
					break;
 805c477:	eb 3b                	jmp    805c4b4 <http_parser_execute+0x6e1>
					parser->method = HTTP_PROPPATCH;
 805c479:	c6 46 16 0d          	movb   $0xd,0x16(%esi)
					break;
 805c47d:	eb 35                	jmp    805c4b4 <http_parser_execute+0x6e1>
					parser->method = HTTP_LINK;
 805c47f:	c6 46 16 1f          	movb   $0x1f,0x16(%esi)
					break;
 805c483:	eb 2f                	jmp    805c4b4 <http_parser_execute+0x6e1>
					parser->method = HTTP_UNSUBSCRIBE;
 805c485:	c6 46 16 1b          	movb   $0x1b,0x16(%esi)
					break;
 805c489:	eb 29                	jmp    805c4b4 <http_parser_execute+0x6e1>
			} else if (ch == '-' &&
 805c48b:	80 fb 2d             	cmp    $0x2d,%bl
 805c48e:	75 16                	jne    805c4a6 <http_parser_execute+0x6d3>
					parser->index == 1U &&
 805c490:	80 7d a8 01          	cmpb   $0x1,-0x58(%ebp)
 805c494:	75 10                	jne    805c4a6 <http_parser_execute+0x6d3>
 805c496:	80 f9 0a             	cmp    $0xa,%cl
 805c499:	75 0b                	jne    805c4a6 <http_parser_execute+0x6d3>
				parser->method = HTTP_MSEARCH;
 805c49b:	c6 46 16 18          	movb   $0x18,0x16(%esi)
 805c49f:	eb 13                	jmp    805c4b4 <http_parser_execute+0x6e1>
			} else if (ch == matcher[parser->index]) {
 805c4a1:	80 fa 20             	cmp    $0x20,%dl
 805c4a4:	74 0e                	je     805c4b4 <http_parser_execute+0x6e1>
				SET_ERRNO(HPE_INVALID_METHOD);
 805c4a6:	8a 46 17             	mov    0x17(%esi),%al
 805c4a9:	83 e0 80             	and    $0xffffff80,%eax
 805c4ac:	83 c8 10             	or     $0x10,%eax
 805c4af:	e9 17 10 00 00       	jmp    805d4cb <http_parser_execute+0x16f8>
			++parser->index;
 805c4b4:	8a 55 a8             	mov    -0x58(%ebp),%dl
 805c4b7:	8a 46 03             	mov    0x3(%esi),%al
 805c4ba:	42                   	inc    %edx
 805c4bb:	83 e0 80             	and    $0xffffff80,%eax
 805c4be:	83 e2 7f             	and    $0x7f,%edx
 805c4c1:	09 d0                	or     %edx,%eax
 805c4c3:	88 46 03             	mov    %al,0x3(%esi)
			break;
 805c4c6:	e9 18 10 00 00       	jmp    805d4e3 <http_parser_execute+0x1710>
			if (ch == ' ') {
 805c4cb:	80 fb 20             	cmp    $0x20,%bl
 805c4ce:	0f 84 0f 10 00 00    	je     805d4e3 <http_parser_execute+0x1710>
			MARK(url);
 805c4d4:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
 805c4d8:	75 06                	jne    805c4e0 <http_parser_execute+0x70d>
 805c4da:	8b 45 b4             	mov    -0x4c(%ebp),%eax
 805c4dd:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			if (parser->method == HTTP_CONNECT) {
 805c4e0:	80 7e 16 05          	cmpb   $0x5,0x16(%esi)
 805c4e4:	75 07                	jne    805c4ed <http_parser_execute+0x71a>
				UPDATE_STATE(s_req_server_start);
 805c4e6:	c7 45 c8 18 00 00 00 	movl   $0x18,-0x38(%ebp)
			UPDATE_STATE(parse_url_char(CURRENT_STATE(), ch));
 805c4ed:	0f be c3             	movsbl %bl,%eax
 805c4f0:	57                   	push   %edi
 805c4f1:	57                   	push   %edi
 805c4f2:	50                   	push   %eax
 805c4f3:	ff 75 c8             	push   -0x38(%ebp)
 805c4f6:	eb 7f                	jmp    805c577 <http_parser_execute+0x7a4>
			switch (ch) {
 805c4f8:	8d 4b f6             	lea    -0xa(%ebx),%ecx
 805c4fb:	0f be d3             	movsbl %bl,%edx
 805c4fe:	80 f9 16             	cmp    $0x16,%cl
 805c501:	77 0c                	ja     805c50f <http_parser_execute+0x73c>
 805c503:	bb 09 00 40 00       	mov    $0x400009,%ebx
 805c508:	d3 eb                	shr    %cl,%ebx
 805c50a:	80 e3 01             	and    $0x1,%bl
 805c50d:	75 7a                	jne    805c589 <http_parser_execute+0x7b6>
				UPDATE_STATE
 805c50f:	51                   	push   %ecx
 805c510:	51                   	push   %ecx
 805c511:	eb 62                	jmp    805c575 <http_parser_execute+0x7a2>
			switch (ch) {
 805c513:	80 fb 0d             	cmp    $0xd,%bl
 805c516:	74 15                	je     805c52d <http_parser_execute+0x75a>
 805c518:	80 fb 20             	cmp    $0x20,%bl
 805c51b:	74 07                	je     805c524 <http_parser_execute+0x751>
 805c51d:	80 fb 0a             	cmp    $0xa,%bl
 805c520:	75 4e                	jne    805c570 <http_parser_execute+0x79d>
 805c522:	eb 09                	jmp    805c52d <http_parser_execute+0x75a>
				UPDATE_STATE(s_req_http_start);
 805c524:	c7 45 c8 20 00 00 00 	movl   $0x20,-0x38(%ebp)
				rc = cb_data(parser, settings->on_url,
 805c52b:	eb 15                	jmp    805c542 <http_parser_execute+0x76f>
				UPDATE_STATE((ch == CR) ?
 805c52d:	31 c0                	xor    %eax,%eax
 805c52f:	80 fb 0d             	cmp    $0xd,%bl
				parser->http_major = 0U;
 805c532:	c7 46 10 00 00 09 00 	movl   $0x90000,0x10(%esi)
				UPDATE_STATE((ch == CR) ?
 805c539:	0f 95 c0             	setne  %al
 805c53c:	83 c0 29             	add    $0x29,%eax
 805c53f:	89 45 c8             	mov    %eax,-0x38(%ebp)
				rc = cb_data(parser, settings->on_url,
 805c542:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 805c545:	83 ec 0c             	sub    $0xc,%esp
 805c548:	b9 02 00 00 00       	mov    $0x2,%ecx
 805c54d:	8b 50 04             	mov    0x4(%eax),%edx
					     p - url_mark);
 805c550:	8b 45 b4             	mov    -0x4c(%ebp),%eax
 805c553:	2b 45 d4             	sub    -0x2c(%ebp),%eax
				rc = cb_data(parser, settings->on_url,
 805c556:	50                   	push   %eax
 805c557:	8d 45 d4             	lea    -0x2c(%ebp),%eax
 805c55a:	50                   	push   %eax
					     p - data + 1, &url_mark,
 805c55b:	8b 45 b4             	mov    -0x4c(%ebp),%eax
 805c55e:	2b 45 b0             	sub    -0x50(%ebp),%eax
 805c561:	40                   	inc    %eax
				rc = cb_data(parser, settings->on_url,
 805c562:	50                   	push   %eax
 805c563:	8d 45 c4             	lea    -0x3c(%ebp),%eax
 805c566:	50                   	push   %eax
 805c567:	8d 45 c8             	lea    -0x38(%ebp),%eax
 805c56a:	50                   	push   %eax
 805c56b:	e9 ab fc ff ff       	jmp    805c21b <http_parser_execute+0x448>
				UPDATE_STATE
 805c570:	57                   	push   %edi
			switch (ch) {
 805c571:	0f be d3             	movsbl %bl,%edx
				UPDATE_STATE
 805c574:	57                   	push   %edi
 805c575:	52                   	push   %edx
 805c576:	50                   	push   %eax
 805c577:	e8 59 11 00 00       	call   805d6d5 <parse_url_char>
 805c57c:	83 c4 10             	add    $0x10,%esp
 805c57f:	89 45 c8             	mov    %eax,-0x38(%ebp)
				if (UNLIKELY(CURRENT_STATE() == s_dead)) {
 805c582:	48                   	dec    %eax
 805c583:	0f 85 5a 0f 00 00    	jne    805d4e3 <http_parser_execute+0x1710>
					SET_ERRNO(HPE_INVALID_URL);
 805c589:	8a 46 17             	mov    0x17(%esi),%al
 805c58c:	83 e0 80             	and    $0xffffff80,%eax
 805c58f:	83 c8 11             	or     $0x11,%eax
 805c592:	e9 34 0f 00 00       	jmp    805d4cb <http_parser_execute+0x16f8>
			switch (ch) {
 805c597:	80 fb 20             	cmp    $0x20,%bl
 805c59a:	0f 84 43 0f 00 00    	je     805d4e3 <http_parser_execute+0x1710>
 805c5a0:	80 fb 48             	cmp    $0x48,%bl
 805c5a3:	75 0c                	jne    805c5b1 <http_parser_execute+0x7de>
				UPDATE_STATE(s_req_http_H);
 805c5a5:	c7 45 c8 21 00 00 00 	movl   $0x21,-0x38(%ebp)
				break;
 805c5ac:	e9 32 0f 00 00       	jmp    805d4e3 <http_parser_execute+0x1710>
				SET_ERRNO(HPE_INVALID_CONSTANT);
 805c5b1:	8a 46 17             	mov    0x17(%esi),%al
 805c5b4:	83 e0 80             	and    $0xffffff80,%eax
 805c5b7:	83 c8 1c             	or     $0x1c,%eax
 805c5ba:	e9 0c 0f 00 00       	jmp    805d4cb <http_parser_execute+0x16f8>
			UPDATE_STATE(s_req_http_HT);
 805c5bf:	c7 45 c8 22 00 00 00 	movl   $0x22,-0x38(%ebp)
			break;
 805c5c6:	e9 18 0f 00 00       	jmp    805d4e3 <http_parser_execute+0x1710>
			UPDATE_STATE(s_req_http_HTT);
 805c5cb:	c7 45 c8 23 00 00 00 	movl   $0x23,-0x38(%ebp)
			break;
 805c5d2:	e9 0c 0f 00 00       	jmp    805d4e3 <http_parser_execute+0x1710>
			UPDATE_STATE(s_req_http_HTTP);
 805c5d7:	c7 45 c8 24 00 00 00 	movl   $0x24,-0x38(%ebp)
			break;
 805c5de:	e9 00 0f 00 00       	jmp    805d4e3 <http_parser_execute+0x1710>
			UPDATE_STATE(s_req_first_http_major);
 805c5e3:	c7 45 c8 25 00 00 00 	movl   $0x25,-0x38(%ebp)
			break;
 805c5ea:	e9 f4 0e 00 00       	jmp    805d4e3 <http_parser_execute+0x1710>
			if (UNLIKELY(ch < '1' || ch > '9')) {
 805c5ef:	8d 43 cf             	lea    -0x31(%ebx),%eax
 805c5f2:	3c 08                	cmp    $0x8,%al
 805c5f4:	0f 87 98 00 00 00    	ja     805c692 <http_parser_execute+0x8bf>
			parser->http_major = ch - '0';
 805c5fa:	66 0f be c3          	movsbw %bl,%ax
			UPDATE_STATE(s_req_http_major);
 805c5fe:	c7 45 c8 26 00 00 00 	movl   $0x26,-0x38(%ebp)
			parser->http_major = ch - '0';
 805c605:	83 e8 30             	sub    $0x30,%eax
 805c608:	66 89 46 10          	mov    %ax,0x10(%esi)
			break;
 805c60c:	e9 d2 0e 00 00       	jmp    805d4e3 <http_parser_execute+0x1710>
			if (ch == '.') {
 805c611:	80 fb 2e             	cmp    $0x2e,%bl
 805c614:	75 0c                	jne    805c622 <http_parser_execute+0x84f>
				UPDATE_STATE(s_req_first_http_minor);
 805c616:	c7 45 c8 27 00 00 00 	movl   $0x27,-0x38(%ebp)
				break;
 805c61d:	e9 c1 0e 00 00       	jmp    805d4e3 <http_parser_execute+0x1710>
			if (UNLIKELY(!IS_NUM(ch))) {
 805c622:	8d 43 d0             	lea    -0x30(%ebx),%eax
 805c625:	3c 09                	cmp    $0x9,%al
 805c627:	77 69                	ja     805c692 <http_parser_execute+0x8bf>
			parser->http_major *= 10U;
 805c629:	66 6b 46 10 0a       	imul   $0xa,0x10(%esi),%ax
			parser->http_major += ch - '0';
 805c62e:	66 0f be d3          	movsbw %bl,%dx
 805c632:	8d 44 10 d0          	lea    -0x30(%eax,%edx,1),%eax
 805c636:	66 89 46 10          	mov    %ax,0x10(%esi)
			if (UNLIKELY(parser->http_major > 999)) {
 805c63a:	eb 4c                	jmp    805c688 <http_parser_execute+0x8b5>
			if (UNLIKELY(!IS_NUM(ch))) {
 805c63c:	8d 43 d0             	lea    -0x30(%ebx),%eax
 805c63f:	3c 09                	cmp    $0x9,%al
 805c641:	77 4f                	ja     805c692 <http_parser_execute+0x8bf>
			parser->http_minor = ch - '0';
 805c643:	66 0f be c3          	movsbw %bl,%ax
			UPDATE_STATE(s_req_http_minor);
 805c647:	c7 45 c8 28 00 00 00 	movl   $0x28,-0x38(%ebp)
			parser->http_minor = ch - '0';
 805c64e:	83 e8 30             	sub    $0x30,%eax
 805c651:	66 89 46 12          	mov    %ax,0x12(%esi)
			break;
 805c655:	e9 89 0e 00 00       	jmp    805d4e3 <http_parser_execute+0x1710>
			if (ch == CR) {
 805c65a:	80 fb 0d             	cmp    $0xd,%bl
 805c65d:	75 0c                	jne    805c66b <http_parser_execute+0x898>
				UPDATE_STATE(s_req_line_almost_done);
 805c65f:	c7 45 c8 29 00 00 00 	movl   $0x29,-0x38(%ebp)
				break;
 805c666:	e9 78 0e 00 00       	jmp    805d4e3 <http_parser_execute+0x1710>
			if (ch == LF) {
 805c66b:	80 fb 0a             	cmp    $0xa,%bl
 805c66e:	74 43                	je     805c6b3 <http_parser_execute+0x8e0>
			if (UNLIKELY(!IS_NUM(ch))) {
 805c670:	8d 43 d0             	lea    -0x30(%ebx),%eax
 805c673:	3c 09                	cmp    $0x9,%al
 805c675:	77 1b                	ja     805c692 <http_parser_execute+0x8bf>
			parser->http_minor *= 10U;
 805c677:	66 6b 46 12 0a       	imul   $0xa,0x12(%esi),%ax
			parser->http_minor += ch - '0';
 805c67c:	66 0f be d3          	movsbw %bl,%dx
 805c680:	8d 44 10 d0          	lea    -0x30(%eax,%edx,1),%eax
 805c684:	66 89 46 12          	mov    %ax,0x12(%esi)
			if (UNLIKELY(parser->http_minor > 999)) {
 805c688:	66 3d e7 03          	cmp    $0x3e7,%ax
 805c68c:	0f 86 51 0e 00 00    	jbe    805d4e3 <http_parser_execute+0x1710>
				SET_ERRNO(HPE_INVALID_VERSION);
 805c692:	8a 46 17             	mov    0x17(%esi),%al
 805c695:	83 e0 80             	and    $0xffffff80,%eax
 805c698:	83 c8 0e             	or     $0xe,%eax
 805c69b:	e9 2b 0e 00 00       	jmp    805d4cb <http_parser_execute+0x16f8>
			if (UNLIKELY(ch != LF)) {
 805c6a0:	80 fb 0a             	cmp    $0xa,%bl
 805c6a3:	74 0e                	je     805c6b3 <http_parser_execute+0x8e0>
 805c6a5:	e9 30 08 00 00       	jmp    805ceda <http_parser_execute+0x1107>
 805c6aa:	80 fb 20             	cmp    $0x20,%bl
 805c6ad:	0f 84 29 0e 00 00    	je     805d4dc <http_parser_execute+0x1709>
			UPDATE_STATE(s_header_field_start);
 805c6b3:	c7 45 c8 2a 00 00 00 	movl   $0x2a,-0x38(%ebp)
			break;
 805c6ba:	e9 24 0e 00 00       	jmp    805d4e3 <http_parser_execute+0x1710>
			if (ch == CR) {
 805c6bf:	80 fb 0d             	cmp    $0xd,%bl
 805c6c2:	75 0c                	jne    805c6d0 <http_parser_execute+0x8fd>
				UPDATE_STATE(s_headers_almost_done);
 805c6c4:	c7 45 c8 37 00 00 00 	movl   $0x37,-0x38(%ebp)
				break;
 805c6cb:	e9 13 0e 00 00       	jmp    805d4e3 <http_parser_execute+0x1710>
			if (ch == LF) {
 805c6d0:	80 fb 0a             	cmp    $0xa,%bl
 805c6d3:	75 0c                	jne    805c6e1 <http_parser_execute+0x90e>
				UPDATE_STATE(s_headers_almost_done);
 805c6d5:	c7 45 c8 37 00 00 00 	movl   $0x37,-0x38(%ebp)
				goto reexecute;
 805c6dc:	e9 3b f8 ff ff       	jmp    805bf1c <http_parser_execute+0x149>
			c = TOKEN(ch);
 805c6e1:	80 fb 20             	cmp    $0x20,%bl
 805c6e4:	74 1b                	je     805c701 <http_parser_execute+0x92e>
 805c6e6:	0f b6 c3             	movzbl %bl,%eax
 805c6e9:	8a 98 40 21 06 08    	mov    0x8062140(%eax),%bl
			if (UNLIKELY(!c)) {
 805c6ef:	84 db                	test   %bl,%bl
 805c6f1:	75 0e                	jne    805c701 <http_parser_execute+0x92e>
				SET_ERRNO(HPE_INVALID_HEADER_TOKEN);
 805c6f3:	8a 46 17             	mov    0x17(%esi),%al
 805c6f6:	83 e0 80             	and    $0xffffff80,%eax
 805c6f9:	83 c8 18             	or     $0x18,%eax
 805c6fc:	e9 ca 0d 00 00       	jmp    805d4cb <http_parser_execute+0x16f8>
			MARK(header_field);
 805c701:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
 805c705:	75 06                	jne    805c70d <http_parser_execute+0x93a>
 805c707:	8b 45 b4             	mov    -0x4c(%ebp),%eax
 805c70a:	89 45 cc             	mov    %eax,-0x34(%ebp)
			parser->index = 0U;
 805c70d:	80 66 03 80          	andb   $0x80,0x3(%esi)
			UPDATE_STATE(s_header_field);
 805c711:	80 fb 74             	cmp    $0x74,%bl
 805c714:	8a 46 02             	mov    0x2(%esi),%al
 805c717:	c7 45 c8 2b 00 00 00 	movl   $0x2b,-0x38(%ebp)
			switch (c) {
 805c71e:	74 29                	je     805c749 <http_parser_execute+0x976>
 805c720:	7f 12                	jg     805c734 <http_parser_execute+0x961>
 805c722:	80 fb 63             	cmp    $0x63,%bl
 805c725:	74 1a                	je     805c741 <http_parser_execute+0x96e>
 805c727:	80 fb 70             	cmp    $0x70,%bl
 805c72a:	75 2b                	jne    805c757 <http_parser_execute+0x984>
				parser->header_state =
 805c72c:	83 e0 01             	and    $0x1,%eax
 805c72f:	83 c8 0a             	or     $0xa,%eax
 805c732:	eb 1b                	jmp    805c74f <http_parser_execute+0x97c>
 805c734:	80 fb 75             	cmp    $0x75,%bl
 805c737:	75 1e                	jne    805c757 <http_parser_execute+0x984>
				parser->header_state = h_matching_upgrade;
 805c739:	83 e0 01             	and    $0x1,%eax
 805c73c:	83 c8 10             	or     $0x10,%eax
 805c73f:	eb 0e                	jmp    805c74f <http_parser_execute+0x97c>
				parser->header_state = h_C;
 805c741:	83 e0 01             	and    $0x1,%eax
 805c744:	83 c8 02             	or     $0x2,%eax
 805c747:	eb 06                	jmp    805c74f <http_parser_execute+0x97c>
				parser->header_state =
 805c749:	83 e0 01             	and    $0x1,%eax
 805c74c:	83 c8 0e             	or     $0xe,%eax
				parser->header_state =
 805c74f:	88 46 02             	mov    %al,0x2(%esi)
				break;
 805c752:	e9 8c 0d 00 00       	jmp    805d4e3 <http_parser_execute+0x1710>
				parser->header_state = h_general;
 805c757:	83 e0 01             	and    $0x1,%eax
 805c75a:	eb f3                	jmp    805c74f <http_parser_execute+0x97c>
		switch (CURRENT_STATE()) {
 805c75c:	8b 45 b4             	mov    -0x4c(%ebp),%eax
 805c75f:	89 45 a8             	mov    %eax,-0x58(%ebp)
			for (; p != data + len; p++) {
 805c762:	8b 7d a8             	mov    -0x58(%ebp),%edi
 805c765:	39 7d 9c             	cmp    %edi,-0x64(%ebp)
 805c768:	0f 84 f8 01 00 00    	je     805c966 <http_parser_execute+0xb93>
				ch = *p;
 805c76e:	8b 45 a8             	mov    -0x58(%ebp),%eax
 805c771:	8a 18                	mov    (%eax),%bl
				c = TOKEN(ch);
 805c773:	80 fb 20             	cmp    $0x20,%bl
 805c776:	74 12                	je     805c78a <http_parser_execute+0x9b7>
 805c778:	0f b6 c3             	movzbl %bl,%eax
 805c77b:	8a 80 40 21 06 08    	mov    0x8062140(%eax),%al
				if (!c) {
 805c781:	84 c0                	test   %al,%al
 805c783:	75 07                	jne    805c78c <http_parser_execute+0x9b9>
 805c785:	e9 dc 01 00 00       	jmp    805c966 <http_parser_execute+0xb93>
				c = TOKEN(ch);
 805c78a:	b0 20                	mov    $0x20,%al
	switch (parser->header_state) {
 805c78c:	8a 56 02             	mov    0x2(%esi),%dl
 805c78f:	d0 ea                	shr    %dl
 805c791:	83 c2 7f             	add    $0x7f,%edx
 805c794:	83 e2 7f             	and    $0x7f,%edx
 805c797:	80 fa 0b             	cmp    $0xb,%dl
 805c79a:	0f 87 be 01 00 00    	ja     805c95e <http_parser_execute+0xb8b>
 805c7a0:	0f b6 d2             	movzbl %dl,%edx
 805c7a3:	ff 24 95 20 26 06 08 	jmp    *0x8062620(,%edx,4)
		parser->index++;
 805c7aa:	0f b6 7e 03          	movzbl 0x3(%esi),%edi
 805c7ae:	8d 57 01             	lea    0x1(%edi),%edx
		parser->header_state = (c == 'o' ? h_CO : h_general);
 805c7b1:	83 e2 7f             	and    $0x7f,%edx
 805c7b4:	c1 e2 08             	shl    $0x8,%edx
 805c7b7:	3c 6f                	cmp    $0x6f,%al
 805c7b9:	0f 94 c0             	sete   %al
 805c7bc:	0f b6 c0             	movzbl %al,%eax
 805c7bf:	c1 e0 02             	shl    $0x2,%eax
 805c7c2:	09 d0                	or     %edx,%eax
 805c7c4:	66 8b 56 02          	mov    0x2(%esi),%dx
 805c7c8:	66 81 e2 01 80       	and    $0x8001,%dx
 805c7cd:	09 d0                	or     %edx,%eax
 805c7cf:	66 89 46 02          	mov    %ax,0x2(%esi)
		break;
 805c7d3:	e9 86 01 00 00       	jmp    805c95e <http_parser_execute+0xb8b>
		parser->index++;
 805c7d8:	8a 56 03             	mov    0x3(%esi),%dl
 805c7db:	8d 4a 01             	lea    0x1(%edx),%ecx
 805c7de:	83 e2 80             	and    $0xffffff80,%edx
 805c7e1:	83 e1 7f             	and    $0x7f,%ecx
 805c7e4:	09 ca                	or     %ecx,%edx
		parser->header_state = (c == 'n' ? h_CON : h_general);
 805c7e6:	3c 6e                	cmp    $0x6e,%al
 805c7e8:	0f 94 c0             	sete   %al
		parser->index++;
 805c7eb:	88 56 03             	mov    %dl,0x3(%esi)
		parser->header_state = (c == 'n' ? h_CON : h_general);
 805c7ee:	8a 56 02             	mov    0x2(%esi),%dl
 805c7f1:	8d 04 40             	lea    (%eax,%eax,2),%eax
 805c7f4:	01 c0                	add    %eax,%eax
 805c7f6:	83 e2 01             	and    $0x1,%edx
 805c7f9:	09 d0                	or     %edx,%eax
 805c7fb:	e9 d5 00 00 00       	jmp    805c8d5 <http_parser_execute+0xb02>
		parser->index++;
 805c800:	8a 56 03             	mov    0x3(%esi),%dl
 805c803:	8d 4a 01             	lea    0x1(%edx),%ecx
 805c806:	83 e2 80             	and    $0xffffff80,%edx
 805c809:	83 e1 7f             	and    $0x7f,%ecx
 805c80c:	09 ca                	or     %ecx,%edx
 805c80e:	3c 6e                	cmp    $0x6e,%al
 805c810:	88 56 03             	mov    %dl,0x3(%esi)
		switch (c) {
 805c813:	8a 56 02             	mov    0x2(%esi),%dl
 805c816:	74 0f                	je     805c827 <http_parser_execute+0xa54>
			parser->header_state = h_general;
 805c818:	83 e2 01             	and    $0x1,%edx
 805c81b:	89 d1                	mov    %edx,%ecx
 805c81d:	83 c9 0c             	or     $0xc,%ecx
 805c820:	3c 74                	cmp    $0x74,%al
 805c822:	0f 44 d1             	cmove  %ecx,%edx
 805c825:	eb 06                	jmp    805c82d <http_parser_execute+0xa5a>
			parser->header_state = h_matching_connection;
 805c827:	83 e2 01             	and    $0x1,%edx
 805c82a:	83 ca 08             	or     $0x8,%edx
 805c82d:	88 56 02             	mov    %dl,0x2(%esi)
			break;
 805c830:	e9 29 01 00 00       	jmp    805c95e <http_parser_execute+0xb8b>
		parser->index++;
 805c835:	8a 4e 03             	mov    0x3(%esi),%cl
 805c838:	8d 51 01             	lea    0x1(%ecx),%edx
 805c83b:	83 e1 80             	and    $0xffffff80,%ecx
 805c83e:	83 e2 7f             	and    $0x7f,%edx
 805c841:	09 d1                	or     %edx,%ecx
 805c843:	88 4e 03             	mov    %cl,0x3(%esi)
		if (cond1 || c != CONNECTION[parser->index]) {
 805c846:	80 fa 0a             	cmp    $0xa,%dl
 805c849:	77 0b                	ja     805c856 <http_parser_execute+0xa83>
 805c84b:	0f b6 d2             	movzbl %dl,%edx
 805c84e:	3a 82 ee 36 06 08    	cmp    0x80636ee(%edx),%al
 805c854:	74 09                	je     805c85f <http_parser_execute+0xa8c>
			parser->header_state = h_general;
 805c856:	80 66 02 01          	andb   $0x1,0x2(%esi)
 805c85a:	e9 ff 00 00 00       	jmp    805c95e <http_parser_execute+0xb8b>
		} else if (parser->index == sizeof(CONNECTION) - 2) {
 805c85f:	83 e1 7f             	and    $0x7f,%ecx
 805c862:	80 f9 09             	cmp    $0x9,%cl
 805c865:	0f 85 f3 00 00 00    	jne    805c95e <http_parser_execute+0xb8b>
			parser->header_state = h_connection;
 805c86b:	8a 46 02             	mov    0x2(%esi),%al
 805c86e:	83 e0 01             	and    $0x1,%eax
 805c871:	83 c8 12             	or     $0x12,%eax
 805c874:	eb 5f                	jmp    805c8d5 <http_parser_execute+0xb02>
		parser->index++;
 805c876:	8a 4e 03             	mov    0x3(%esi),%cl
 805c879:	8d 51 01             	lea    0x1(%ecx),%edx
 805c87c:	83 e1 80             	and    $0xffffff80,%ecx
 805c87f:	83 e2 7f             	and    $0x7f,%edx
 805c882:	09 d1                	or     %edx,%ecx
 805c884:	88 4e 03             	mov    %cl,0x3(%esi)
		if (cond1 || c != PROXY_CONNECTION[parser->index]) {
 805c887:	80 fa 10             	cmp    $0x10,%dl
 805c88a:	77 ca                	ja     805c856 <http_parser_execute+0xa83>
 805c88c:	0f b6 d2             	movzbl %dl,%edx
 805c88f:	3a 82 e8 36 06 08    	cmp    0x80636e8(%edx),%al
 805c895:	75 bf                	jne    805c856 <http_parser_execute+0xa83>
		} else if (parser->index == sizeof(PROXY_CONNECTION) - 2) {
 805c897:	83 e1 7f             	and    $0x7f,%ecx
 805c89a:	80 f9 0f             	cmp    $0xf,%cl
 805c89d:	eb c6                	jmp    805c865 <http_parser_execute+0xa92>
		parser->index++;
 805c89f:	8a 4e 03             	mov    0x3(%esi),%cl
 805c8a2:	8d 51 01             	lea    0x1(%ecx),%edx
 805c8a5:	83 e1 80             	and    $0xffffff80,%ecx
 805c8a8:	83 e2 7f             	and    $0x7f,%edx
 805c8ab:	09 d1                	or     %edx,%ecx
 805c8ad:	88 4e 03             	mov    %cl,0x3(%esi)
		if (cond1 || c != CONTENT_LENGTH[parser->index]) {
 805c8b0:	80 fa 0e             	cmp    $0xe,%dl
 805c8b3:	77 a1                	ja     805c856 <http_parser_execute+0xa83>
 805c8b5:	0f b6 d2             	movzbl %dl,%edx
 805c8b8:	3a 82 f9 36 06 08    	cmp    0x80636f9(%edx),%al
 805c8be:	75 96                	jne    805c856 <http_parser_execute+0xa83>
		} else if (parser->index == sizeof(CONTENT_LENGTH) - 2) {
 805c8c0:	83 e1 7f             	and    $0x7f,%ecx
 805c8c3:	80 f9 0d             	cmp    $0xd,%cl
 805c8c6:	0f 85 92 00 00 00    	jne    805c95e <http_parser_execute+0xb8b>
			parser->header_state = h_content_length;
 805c8cc:	8a 46 02             	mov    0x2(%esi),%al
 805c8cf:	83 e0 01             	and    $0x1,%eax
 805c8d2:	83 c8 14             	or     $0x14,%eax
 805c8d5:	88 46 02             	mov    %al,0x2(%esi)
 805c8d8:	e9 81 00 00 00       	jmp    805c95e <http_parser_execute+0xb8b>
		parser->index++;
 805c8dd:	8a 4e 03             	mov    0x3(%esi),%cl
 805c8e0:	8d 51 01             	lea    0x1(%ecx),%edx
 805c8e3:	83 e1 80             	and    $0xffffff80,%ecx
 805c8e6:	83 e2 7f             	and    $0x7f,%edx
 805c8e9:	09 d1                	or     %edx,%ecx
 805c8eb:	88 4e 03             	mov    %cl,0x3(%esi)
		if (cond1 || c != TRANSFER_ENCODING[parser->index]) {
 805c8ee:	80 fa 11             	cmp    $0x11,%dl
 805c8f1:	0f 87 5f ff ff ff    	ja     805c856 <http_parser_execute+0xa83>
 805c8f7:	0f b6 d2             	movzbl %dl,%edx
 805c8fa:	3a 82 08 37 06 08    	cmp    0x8063708(%edx),%al
 805c900:	0f 85 50 ff ff ff    	jne    805c856 <http_parser_execute+0xa83>
		} else if (parser->index == sizeof(TRANSFER_ENCODING) - 2) {
 805c906:	83 e1 7f             	and    $0x7f,%ecx
 805c909:	80 f9 10             	cmp    $0x10,%cl
 805c90c:	75 50                	jne    805c95e <http_parser_execute+0xb8b>
			parser->header_state = h_transfer_encoding;
 805c90e:	8a 46 02             	mov    0x2(%esi),%al
 805c911:	83 e0 01             	and    $0x1,%eax
 805c914:	83 c8 16             	or     $0x16,%eax
 805c917:	eb bc                	jmp    805c8d5 <http_parser_execute+0xb02>
		parser->index++;
 805c919:	8a 4e 03             	mov    0x3(%esi),%cl
 805c91c:	8d 51 01             	lea    0x1(%ecx),%edx
 805c91f:	83 e1 80             	and    $0xffffff80,%ecx
 805c922:	83 e2 7f             	and    $0x7f,%edx
 805c925:	09 d1                	or     %edx,%ecx
 805c927:	88 4e 03             	mov    %cl,0x3(%esi)
		if (cond1 || c != UPGRADE[parser->index]) {
 805c92a:	80 fa 07             	cmp    $0x7,%dl
 805c92d:	0f 87 23 ff ff ff    	ja     805c856 <http_parser_execute+0xa83>
 805c933:	0f b6 d2             	movzbl %dl,%edx
 805c936:	3a 82 1a 37 06 08    	cmp    0x806371a(%edx),%al
 805c93c:	0f 85 14 ff ff ff    	jne    805c856 <http_parser_execute+0xa83>
		} else if (parser->index == sizeof(UPGRADE) - 2) {
 805c942:	83 e1 7f             	and    $0x7f,%ecx
 805c945:	80 f9 06             	cmp    $0x6,%cl
 805c948:	75 14                	jne    805c95e <http_parser_execute+0xb8b>
			parser->header_state = h_upgrade;
 805c94a:	8a 46 02             	mov    0x2(%esi),%al
 805c94d:	83 e0 01             	and    $0x1,%eax
 805c950:	83 c8 18             	or     $0x18,%eax
 805c953:	eb 80                	jmp    805c8d5 <http_parser_execute+0xb02>
		if (ch != ' ') {
 805c955:	80 fb 20             	cmp    $0x20,%bl
 805c958:	0f 85 f8 fe ff ff    	jne    805c856 <http_parser_execute+0xa83>
			for (; p != data + len; p++) {
 805c95e:	ff 45 a8             	incl   -0x58(%ebp)
 805c961:	e9 fc fd ff ff       	jmp    805c762 <http_parser_execute+0x98f>
			rc = count_header_size(parser, p - start);
 805c966:	8b 45 a8             	mov    -0x58(%ebp),%eax
 805c969:	2b 45 b4             	sub    -0x4c(%ebp),%eax
	parser->nread += bytes;
 805c96c:	03 46 04             	add    0x4(%esi),%eax
 805c96f:	89 46 04             	mov    %eax,0x4(%esi)
	if (UNLIKELY(parser->nread > (HTTP_MAX_HEADER_SIZE))) {
 805c972:	3d 00 40 01 00       	cmp    $0x14000,%eax
 805c977:	76 0b                	jbe    805c984 <http_parser_execute+0xbb1>
		parser->http_errno = HPE_HEADER_OVERFLOW;
 805c979:	8a 46 17             	mov    0x17(%esi),%al
 805c97c:	83 e0 80             	and    $0xffffff80,%eax
 805c97f:	83 c8 0c             	or     $0xc,%eax
 805c982:	eb 6c                	jmp    805c9f0 <http_parser_execute+0xc1d>
			if (p == data + len) {
 805c984:	8b 7d a8             	mov    -0x58(%ebp),%edi
 805c987:	39 7d 9c             	cmp    %edi,-0x64(%ebp)
 805c98a:	75 0c                	jne    805c998 <http_parser_execute+0xbc5>
				--p;
 805c98c:	8b 7d 9c             	mov    -0x64(%ebp),%edi
 805c98f:	4f                   	dec    %edi
 805c990:	89 7d b4             	mov    %edi,-0x4c(%ebp)
				break;
 805c993:	e9 4b 0b 00 00       	jmp    805d4e3 <http_parser_execute+0x1710>
					     parsed, p - data + 1,
 805c998:	8b 45 a8             	mov    -0x58(%ebp),%eax
 805c99b:	2b 45 b0             	sub    -0x50(%ebp),%eax
			if (ch == ':') {
 805c99e:	80 fb 3a             	cmp    $0x3a,%bl
 805c9a1:	75 44                	jne    805c9e7 <http_parser_execute+0xc14>
				rc = cb_data(parser, settings->on_header_field,
 805c9a3:	8b 7d a4             	mov    -0x5c(%ebp),%edi
 805c9a6:	83 ec 0c             	sub    $0xc,%esp
					     p - header_field_mark);
 805c9a9:	8b 4d a8             	mov    -0x58(%ebp),%ecx
					     parsed, p - data + 1,
 805c9ac:	40                   	inc    %eax
					     p - header_field_mark);
 805c9ad:	2b 4d cc             	sub    -0x34(%ebp),%ecx
				UPDATE_STATE(s_header_value_discard_ws);
 805c9b0:	c7 45 c8 2c 00 00 00 	movl   $0x2c,-0x38(%ebp)
				rc = cb_data(parser, settings->on_header_field,
 805c9b7:	8b 57 0c             	mov    0xc(%edi),%edx
 805c9ba:	51                   	push   %ecx
 805c9bb:	8d 4d cc             	lea    -0x34(%ebp),%ecx
 805c9be:	51                   	push   %ecx
 805c9bf:	b9 03 00 00 00       	mov    $0x3,%ecx
 805c9c4:	50                   	push   %eax
 805c9c5:	8d 45 c4             	lea    -0x3c(%ebp),%eax
 805c9c8:	50                   	push   %eax
 805c9c9:	8d 45 c8             	lea    -0x38(%ebp),%eax
 805c9cc:	50                   	push   %eax
 805c9cd:	89 f0                	mov    %esi,%eax
 805c9cf:	e8 21 f3 ff ff       	call   805bcf5 <cb_data>
 805c9d4:	83 c4 20             	add    $0x20,%esp
				if (rc != 0) {
 805c9d7:	85 c0                	test   %eax,%eax
 805c9d9:	0f 85 45 0c 00 00    	jne    805d624 <http_parser_execute+0x1851>
 805c9df:	8b 45 a8             	mov    -0x58(%ebp),%eax
 805c9e2:	e9 c1 08 00 00       	jmp    805d2a8 <http_parser_execute+0x14d5>
			SET_ERRNO(HPE_INVALID_HEADER_TOKEN);
 805c9e7:	8a 46 17             	mov    0x17(%esi),%al
 805c9ea:	83 e0 80             	and    $0xffffff80,%eax
 805c9ed:	83 c8 18             	or     $0x18,%eax
 805c9f0:	88 46 17             	mov    %al,0x17(%esi)
			goto error;
 805c9f3:	8b 45 a8             	mov    -0x58(%ebp),%eax
 805c9f6:	e9 bb 04 00 00       	jmp    805ceb6 <http_parser_execute+0x10e3>
			if (ch == ' ' || ch == '\t') {
 805c9fb:	80 fb 20             	cmp    $0x20,%bl
 805c9fe:	0f 84 df 0a 00 00    	je     805d4e3 <http_parser_execute+0x1710>
 805ca04:	80 fb 09             	cmp    $0x9,%bl
 805ca07:	0f 84 d6 0a 00 00    	je     805d4e3 <http_parser_execute+0x1710>
			if (ch == CR) {
 805ca0d:	80 fb 0d             	cmp    $0xd,%bl
 805ca10:	75 0c                	jne    805ca1e <http_parser_execute+0xc4b>
				UPDATE_STATE
 805ca12:	c7 45 c8 2d 00 00 00 	movl   $0x2d,-0x38(%ebp)
				break;
 805ca19:	e9 c5 0a 00 00       	jmp    805d4e3 <http_parser_execute+0x1710>
			if (ch == LF) {
 805ca1e:	80 fb 0a             	cmp    $0xa,%bl
 805ca21:	0f 84 1c 05 00 00    	je     805cf43 <http_parser_execute+0x1170>
			MARK(header_value);
 805ca27:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
 805ca2b:	75 06                	jne    805ca33 <http_parser_execute+0xc60>
 805ca2d:	8b 45 b4             	mov    -0x4c(%ebp),%eax
 805ca30:	89 45 d0             	mov    %eax,-0x30(%ebp)
			switch (parser->header_state) {
 805ca33:	8a 46 02             	mov    0x2(%esi),%al
			c = LOWER(ch);
 805ca36:	89 da                	mov    %ebx,%edx
			parser->index = 0U;
 805ca38:	80 66 03 80          	andb   $0x80,0x3(%esi)
			UPDATE_STATE(s_header_value);
 805ca3c:	c7 45 c8 30 00 00 00 	movl   $0x30,-0x38(%ebp)
			c = LOWER(ch);
 805ca43:	83 ca 20             	or     $0x20,%edx
			switch (parser->header_state) {
 805ca46:	d0 e8                	shr    %al
 805ca48:	83 c0 77             	add    $0x77,%eax
 805ca4b:	83 e0 7f             	and    $0x7f,%eax
 805ca4e:	3c 05                	cmp    $0x5,%al
 805ca50:	0f 87 a0 00 00 00    	ja     805caf6 <http_parser_execute+0xd23>
 805ca56:	0f b6 c0             	movzbl %al,%eax
 805ca59:	ff 24 85 50 26 06 08 	jmp    *0x8062650(,%eax,4)
				parser->flags |= F_UPGRADE;
 805ca60:	66 81 0e 80 00       	orw    $0x80,(%esi)
				parser->header_state = h_general;
 805ca65:	e9 8c 00 00 00       	jmp    805caf6 <http_parser_execute+0xd23>
					parser->header_state =
 805ca6a:	8a 46 02             	mov    0x2(%esi),%al
 805ca6d:	83 e0 01             	and    $0x1,%eax
 805ca70:	89 c1                	mov    %eax,%ecx
 805ca72:	83 c9 1a             	or     $0x1a,%ecx
 805ca75:	80 fa 63             	cmp    $0x63,%dl
 805ca78:	0f 44 c1             	cmove  %ecx,%eax
 805ca7b:	e9 cf fc ff ff       	jmp    805c74f <http_parser_execute+0x97c>
				if (UNLIKELY(!IS_NUM(ch))) {
 805ca80:	8d 4b d0             	lea    -0x30(%ebx),%ecx
 805ca83:	80 f9 09             	cmp    $0x9,%cl
 805ca86:	0f 87 04 09 00 00    	ja     805d390 <http_parser_execute+0x15bd>
				if (parser->flags & F_CONTENTLENGTH) {
 805ca8c:	8b 16                	mov    (%esi),%edx
 805ca8e:	89 d0                	mov    %edx,%eax
 805ca90:	66 c1 e8 02          	shr    $0x2,%ax
 805ca94:	84 c0                	test   %al,%al
 805ca96:	0f 88 78 05 00 00    	js     805d014 <http_parser_execute+0x1241>
				parser->flags |= F_CONTENTLENGTH;
 805ca9c:	83 c8 80             	or     $0xffffff80,%eax
				parser->content_length = ch - '0';
 805ca9f:	0f be c9             	movsbl %cl,%ecx
				parser->flags |= F_CONTENTLENGTH;
 805caa2:	66 81 e2 03 fc       	and    $0xfc03,%dx
 805caa7:	0f b6 c0             	movzbl %al,%eax
				parser->content_length = ch - '0';
 805caaa:	89 4e 08             	mov    %ecx,0x8(%esi)
 805caad:	c1 f9 1f             	sar    $0x1f,%ecx
				parser->flags |= F_CONTENTLENGTH;
 805cab0:	c1 e0 02             	shl    $0x2,%eax
				parser->content_length = ch - '0';
 805cab3:	89 4e 0c             	mov    %ecx,0xc(%esi)
				parser->flags |= F_CONTENTLENGTH;
 805cab6:	09 c2                	or     %eax,%edx
 805cab8:	66 89 16             	mov    %dx,(%esi)
				break;
 805cabb:	e9 23 0a 00 00       	jmp    805d4e3 <http_parser_execute+0x1710>
				if (c == 'k') {
 805cac0:	80 fa 6b             	cmp    $0x6b,%dl
 805cac3:	8a 46 02             	mov    0x2(%esi),%al
 805cac6:	75 0b                	jne    805cad3 <http_parser_execute+0xd00>
					parser->header_state =
 805cac8:	83 e0 01             	and    $0x1,%eax
 805cacb:	83 c8 1e             	or     $0x1e,%eax
 805cace:	e9 7c fc ff ff       	jmp    805c74f <http_parser_execute+0x97c>
					parser->header_state =
 805cad3:	83 e0 01             	and    $0x1,%eax
				} else if (c == 'c') {
 805cad6:	80 fa 63             	cmp    $0x63,%dl
 805cad9:	75 08                	jne    805cae3 <http_parser_execute+0xd10>
					parser->header_state =
 805cadb:	83 c8 20             	or     $0x20,%eax
 805cade:	e9 6c fc ff ff       	jmp    805c74f <http_parser_execute+0x97c>
					parser->header_state =
 805cae3:	89 c1                	mov    %eax,%ecx
 805cae5:	83 c8 22             	or     $0x22,%eax
 805cae8:	83 c9 24             	or     $0x24,%ecx
 805caeb:	80 fa 75             	cmp    $0x75,%dl
 805caee:	0f 45 c1             	cmovne %ecx,%eax
 805caf1:	e9 59 fc ff ff       	jmp    805c74f <http_parser_execute+0x97c>
				parser->header_state = h_general;
 805caf6:	80 66 02 01          	andb   $0x1,0x2(%esi)
				break;
 805cafa:	e9 e4 09 00 00       	jmp    805d4e3 <http_parser_execute+0x1710>
				(enum header_states)parser->header_state;
 805caff:	8a 46 02             	mov    0x2(%esi),%al
 805cb02:	d0 e8                	shr    %al
 805cb04:	0f b6 c0             	movzbl %al,%eax
 805cb07:	89 45 a8             	mov    %eax,-0x58(%ebp)
			for (; p != data + len; p++) {
 805cb0a:	8b 45 b4             	mov    -0x4c(%ebp),%eax
 805cb0d:	89 45 a0             	mov    %eax,-0x60(%ebp)
				if (!lenient && !IS_HEADER_CHAR(ch)) {
 805cb10:	8a 45 87             	mov    -0x79(%ebp),%al
 805cb13:	83 f0 01             	xor    $0x1,%eax
 805cb16:	88 45 86             	mov    %al,-0x7a(%ebp)
			for (; p != data + len; p++) {
 805cb19:	8b 7d a0             	mov    -0x60(%ebp),%edi
 805cb1c:	39 7d 9c             	cmp    %edi,-0x64(%ebp)
 805cb1f:	74 5d                	je     805cb7e <http_parser_execute+0xdab>
				ch = *p;
 805cb21:	8b 45 a0             	mov    -0x60(%ebp),%eax
 805cb24:	8a 18                	mov    (%eax),%bl
				if (ch == CR) {
 805cb26:	80 fb 0d             	cmp    $0xd,%bl
 805cb29:	75 7f                	jne    805cbaa <http_parser_execute+0xdd7>
					parser->header_state = h_state;
 805cb2b:	8a 45 a8             	mov    -0x58(%ebp),%al
					rc = cb_data(parser,
 805cb2e:	83 ec 0c             	sub    $0xc,%esp
 805cb31:	b9 04 00 00 00       	mov    $0x4,%ecx
					UPDATE_STATE(s_header_almost_done);
 805cb36:	c7 45 c8 32 00 00 00 	movl   $0x32,-0x38(%ebp)
					parser->header_state = h_state;
 805cb3d:	8d 14 00             	lea    (%eax,%eax,1),%edx
 805cb40:	8a 46 02             	mov    0x2(%esi),%al
 805cb43:	83 e0 01             	and    $0x1,%eax
 805cb46:	09 d0                	or     %edx,%eax
 805cb48:	88 46 02             	mov    %al,0x2(%esi)
					rc = cb_data(parser,
 805cb4b:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 805cb4e:	8b 50 10             	mov    0x10(%eax),%edx
						     p - header_value_mark);
 805cb51:	8b 45 a0             	mov    -0x60(%ebp),%eax
 805cb54:	2b 45 d0             	sub    -0x30(%ebp),%eax
					rc = cb_data(parser,
 805cb57:	50                   	push   %eax
 805cb58:	8d 45 d0             	lea    -0x30(%ebp),%eax
 805cb5b:	50                   	push   %eax
						     p - data + 1,
 805cb5c:	8b 45 a0             	mov    -0x60(%ebp),%eax
 805cb5f:	2b 45 b0             	sub    -0x50(%ebp),%eax
 805cb62:	40                   	inc    %eax
					rc = cb_data(parser,
 805cb63:	50                   	push   %eax
 805cb64:	8d 45 c4             	lea    -0x3c(%ebp),%eax
 805cb67:	50                   	push   %eax
 805cb68:	8d 45 c8             	lea    -0x38(%ebp),%eax
 805cb6b:	50                   	push   %eax
 805cb6c:	89 f0                	mov    %esi,%eax
 805cb6e:	e8 82 f1 ff ff       	call   805bcf5 <cb_data>
 805cb73:	83 c4 20             	add    $0x20,%esp
					if (rc != 0) {
 805cb76:	85 c0                	test   %eax,%eax
 805cb78:	0f 85 a6 0a 00 00    	jne    805d624 <http_parser_execute+0x1851>
			parser->header_state = h_state;
 805cb7e:	8a 46 02             	mov    0x2(%esi),%al
 805cb81:	8a 55 a8             	mov    -0x58(%ebp),%dl
 805cb84:	83 e0 01             	and    $0x1,%eax
 805cb87:	01 d2                	add    %edx,%edx
 805cb89:	09 d0                	or     %edx,%eax
 805cb8b:	88 46 02             	mov    %al,0x2(%esi)
			rc = count_header_size(parser, p - start);
 805cb8e:	8b 45 a0             	mov    -0x60(%ebp),%eax
 805cb91:	2b 45 b4             	sub    -0x4c(%ebp),%eax
	parser->nread += bytes;
 805cb94:	03 46 04             	add    0x4(%esi),%eax
 805cb97:	89 46 04             	mov    %eax,0x4(%esi)
	if (UNLIKELY(parser->nread > (HTTP_MAX_HEADER_SIZE))) {
 805cb9a:	3d 00 40 01 00       	cmp    $0x14000,%eax
 805cb9f:	0f 86 19 03 00 00    	jbe    805cebe <http_parser_execute+0x10eb>
 805cba5:	e9 fd 02 00 00       	jmp    805cea7 <http_parser_execute+0x10d4>
				if (ch == LF) {
 805cbaa:	80 fb 0a             	cmp    $0xa,%bl
 805cbad:	75 73                	jne    805cc22 <http_parser_execute+0xe4f>
					rc = count_header_size(parser,
 805cbaf:	8b 45 a0             	mov    -0x60(%ebp),%eax
 805cbb2:	2b 45 b4             	sub    -0x4c(%ebp),%eax
					UPDATE_STATE(s_header_almost_done);
 805cbb5:	c7 45 c8 32 00 00 00 	movl   $0x32,-0x38(%ebp)
	parser->nread += bytes;
 805cbbc:	03 46 04             	add    0x4(%esi),%eax
						     p - data + 1,
 805cbbf:	8b 4d a0             	mov    -0x60(%ebp),%ecx
	parser->nread += bytes;
 805cbc2:	89 46 04             	mov    %eax,0x4(%esi)
						     p - data + 1,
 805cbc5:	2b 4d b0             	sub    -0x50(%ebp),%ecx
	if (UNLIKELY(parser->nread > (HTTP_MAX_HEADER_SIZE))) {
 805cbc8:	3d 00 40 01 00       	cmp    $0x14000,%eax
 805cbcd:	0f 87 d4 02 00 00    	ja     805cea7 <http_parser_execute+0x10d4>
					parser->header_state = h_state;
 805cbd3:	8a 46 02             	mov    0x2(%esi),%al
 805cbd6:	8a 55 a8             	mov    -0x58(%ebp),%dl
					rc = cb_data(parser,
 805cbd9:	83 ec 0c             	sub    $0xc,%esp
					parser->header_state = h_state;
 805cbdc:	01 d2                	add    %edx,%edx
 805cbde:	83 e0 01             	and    $0x1,%eax
 805cbe1:	09 d0                	or     %edx,%eax
 805cbe3:	88 46 02             	mov    %al,0x2(%esi)
					rc = cb_data(parser,
 805cbe6:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 805cbe9:	8b 50 10             	mov    0x10(%eax),%edx
						     p - header_value_mark);
 805cbec:	8b 45 a0             	mov    -0x60(%ebp),%eax
 805cbef:	2b 45 d0             	sub    -0x30(%ebp),%eax
					rc = cb_data(parser,
 805cbf2:	50                   	push   %eax
 805cbf3:	8d 45 d0             	lea    -0x30(%ebp),%eax
 805cbf6:	50                   	push   %eax
 805cbf7:	8d 45 c4             	lea    -0x3c(%ebp),%eax
 805cbfa:	51                   	push   %ecx
 805cbfb:	b9 04 00 00 00       	mov    $0x4,%ecx
 805cc00:	50                   	push   %eax
 805cc01:	8d 45 c8             	lea    -0x38(%ebp),%eax
 805cc04:	50                   	push   %eax
 805cc05:	89 f0                	mov    %esi,%eax
 805cc07:	e8 e9 f0 ff ff       	call   805bcf5 <cb_data>
 805cc0c:	83 c4 20             	add    $0x20,%esp
					if (rc != 0) {
 805cc0f:	85 c0                	test   %eax,%eax
 805cc11:	0f 85 0d 0a 00 00    	jne    805d624 <http_parser_execute+0x1851>
 805cc17:	8b 45 a0             	mov    -0x60(%ebp),%eax
 805cc1a:	89 45 b4             	mov    %eax,-0x4c(%ebp)
 805cc1d:	e9 fa f2 ff ff       	jmp    805bf1c <http_parser_execute+0x149>
				if (!lenient && !IS_HEADER_CHAR(ch)) {
 805cc22:	80 7d 86 00          	cmpb   $0x0,-0x7a(%ebp)
 805cc26:	74 1d                	je     805cc45 <http_parser_execute+0xe72>
 805cc28:	80 fb 09             	cmp    $0x9,%bl
 805cc2b:	74 18                	je     805cc45 <http_parser_execute+0xe72>
 805cc2d:	80 fb 1f             	cmp    $0x1f,%bl
 805cc30:	76 05                	jbe    805cc37 <http_parser_execute+0xe64>
 805cc32:	80 fb 7f             	cmp    $0x7f,%bl
 805cc35:	75 0e                	jne    805cc45 <http_parser_execute+0xe72>
					SET_ERRNO(HPE_INVALID_HEADER_TOKEN);
 805cc37:	8a 46 17             	mov    0x17(%esi),%al
 805cc3a:	83 e0 80             	and    $0xffffff80,%eax
 805cc3d:	83 c8 18             	or     $0x18,%eax
 805cc40:	e9 6b 02 00 00       	jmp    805ceb0 <http_parser_execute+0x10dd>
				c = LOWER(ch);
 805cc45:	89 d8                	mov    %ebx,%eax
 805cc47:	83 c8 20             	or     $0x20,%eax
	switch (h_state) {
 805cc4a:	83 7d a8 16          	cmpl   $0x16,-0x58(%ebp)
 805cc4e:	0f 87 47 02 00 00    	ja     805ce9b <http_parser_execute+0x10c8>
 805cc54:	8b 7d a8             	mov    -0x58(%ebp),%edi
 805cc57:	ff 24 bd 68 26 06 08 	jmp    *0x8062668(,%edi,4)
		limit = MIN(limit, HTTP_MAX_HEADER_SIZE);
 805cc5e:	b8 00 40 01 00       	mov    $0x14000,%eax
		size_t limit = data + len - p;
 805cc63:	8b 55 9c             	mov    -0x64(%ebp),%edx
 805cc66:	2b 55 a0             	sub    -0x60(%ebp),%edx
		p_cr = (const char *)memchr(p, CR, limit);
 805cc69:	51                   	push   %ecx
		limit = MIN(limit, HTTP_MAX_HEADER_SIZE);
 805cc6a:	39 c2                	cmp    %eax,%edx
 805cc6c:	0f 47 d0             	cmova  %eax,%edx
		p_cr = (const char *)memchr(p, CR, limit);
 805cc6f:	52                   	push   %edx
 805cc70:	6a 0d                	push   $0xd
 805cc72:	ff 75 a0             	push   -0x60(%ebp)
 805cc75:	89 55 98             	mov    %edx,-0x68(%ebp)
 805cc78:	e8 d3 c6 fe ff       	call   8049350 <memchr@plt>
		p_lf = (const char *)memchr(p, LF, limit);
 805cc7d:	8b 55 98             	mov    -0x68(%ebp),%edx
		p_cr = (const char *)memchr(p, CR, limit);
 805cc80:	83 c4 0c             	add    $0xc,%esp
 805cc83:	89 c3                	mov    %eax,%ebx
		p_lf = (const char *)memchr(p, LF, limit);
 805cc85:	52                   	push   %edx
 805cc86:	6a 0a                	push   $0xa
 805cc88:	ff 75 a0             	push   -0x60(%ebp)
 805cc8b:	e8 c0 c6 fe ff       	call   8049350 <memchr@plt>
 805cc90:	83 c4 10             	add    $0x10,%esp
		if (p_cr != NULL) {
 805cc93:	85 db                	test   %ebx,%ebx
 805cc95:	74 0c                	je     805cca3 <http_parser_execute+0xed0>
			if (p_lf != NULL && p_cr >= p_lf) {
 805cc97:	85 c0                	test   %eax,%eax
 805cc99:	74 04                	je     805cc9f <http_parser_execute+0xecc>
 805cc9b:	39 d8                	cmp    %ebx,%eax
 805cc9d:	76 0a                	jbe    805cca9 <http_parser_execute+0xed6>
 805cc9f:	89 d8                	mov    %ebx,%eax
 805cca1:	eb 06                	jmp    805cca9 <http_parser_execute+0xed6>
		} else if (UNLIKELY(p_lf != NULL)) {
 805cca3:	85 c0                	test   %eax,%eax
 805cca5:	0f 44 45 9c          	cmove  -0x64(%ebp),%eax
		--p;
 805cca9:	48                   	dec    %eax
 805ccaa:	89 45 a0             	mov    %eax,-0x60(%ebp)
		break;
 805ccad:	e9 b1 09 00 00       	jmp    805d663 <http_parser_execute+0x1890>
		if (ch == ' ') {
 805ccb2:	80 fb 20             	cmp    $0x20,%bl
 805ccb5:	0f 84 a8 09 00 00    	je     805d663 <http_parser_execute+0x1890>
		if (UNLIKELY(!IS_NUM(ch))) {
 805ccbb:	8d 43 d0             	lea    -0x30(%ebx),%eax
 805ccbe:	88 45 98             	mov    %al,-0x68(%ebp)
 805ccc1:	3c 09                	cmp    $0x9,%al
 805ccc3:	77 2f                	ja     805ccf4 <http_parser_execute+0xf21>
		t *= 10U;
 805ccc5:	6b 46 0c 0a          	imul   $0xa,0xc(%esi),%eax
 805ccc9:	89 c7                	mov    %eax,%edi
 805cccb:	b8 0a 00 00 00       	mov    $0xa,%eax
 805ccd0:	f7 66 08             	mull   0x8(%esi)
 805ccd3:	89 c1                	mov    %eax,%ecx
		t += ch - '0';
 805ccd5:	0f be 45 98          	movsbl -0x68(%ebp),%eax
		t *= 10U;
 805ccd9:	89 d3                	mov    %edx,%ebx
 805ccdb:	01 fb                	add    %edi,%ebx
		t += ch - '0';
 805ccdd:	99                   	cltd   
 805ccde:	01 c8                	add    %ecx,%eax
		if (UNLIKELY(value < parser->content_length)) {
 805cce0:	b9 98 99 99 99       	mov    $0x99999998,%ecx
		t += ch - '0';
 805cce5:	11 da                	adc    %ebx,%edx
		if (UNLIKELY(value < parser->content_length)) {
 805cce7:	3b 4e 08             	cmp    0x8(%esi),%ecx
 805ccea:	b9 99 99 99 19       	mov    $0x19999999,%ecx
 805ccef:	1b 4e 0c             	sbb    0xc(%esi),%ecx
 805ccf2:	73 1d                	jae    805cd11 <http_parser_execute+0xf3e>
			SET_ERRNO(HPE_INVALID_CONTENT_LENGTH);
 805ccf4:	8a 46 17             	mov    0x17(%esi),%al
 805ccf7:	83 e0 80             	and    $0xffffff80,%eax
 805ccfa:	83 c8 19             	or     $0x19,%eax
 805ccfd:	88 46 17             	mov    %al,0x17(%esi)
			parser->header_state = h_state;
 805cd00:	8a 46 02             	mov    0x2(%esi),%al
 805cd03:	83 e0 01             	and    $0x1,%eax
 805cd06:	83 c8 14             	or     $0x14,%eax
 805cd09:	88 46 02             	mov    %al,0x2(%esi)
			return -1;
 805cd0c:	e9 a2 01 00 00       	jmp    805ceb3 <http_parser_execute+0x10e0>
		parser->content_length = t;
 805cd11:	89 46 08             	mov    %eax,0x8(%esi)
 805cd14:	89 56 0c             	mov    %edx,0xc(%esi)
		break;
 805cd17:	e9 47 09 00 00       	jmp    805d663 <http_parser_execute+0x1890>
		parser->index++;
 805cd1c:	8a 4e 03             	mov    0x3(%esi),%cl
 805cd1f:	8d 51 01             	lea    0x1(%ecx),%edx
 805cd22:	83 e1 80             	and    $0xffffff80,%ecx
 805cd25:	83 e2 7f             	and    $0x7f,%edx
 805cd28:	09 d1                	or     %edx,%ecx
 805cd2a:	88 4e 03             	mov    %cl,0x3(%esi)
		if (cond1 || c != CHUNKED[parser->index]) {
 805cd2d:	80 fa 07             	cmp    $0x7,%dl
 805cd30:	0f 87 02 09 00 00    	ja     805d638 <http_parser_execute+0x1865>
 805cd36:	0f b6 d2             	movzbl %dl,%edx
 805cd39:	3a 82 22 37 06 08    	cmp    0x8063722(%edx),%al
 805cd3f:	0f 85 f3 08 00 00    	jne    805d638 <http_parser_execute+0x1865>
		} else if (parser->index == sizeof(CHUNKED) - 2) {
 805cd45:	83 e1 7f             	and    $0x7f,%ecx
			h_state = h_transfer_encoding_chunked;
 805cd48:	b8 13 00 00 00       	mov    $0x13,%eax
 805cd4d:	80 f9 06             	cmp    $0x6,%cl
 805cd50:	e9 cf 00 00 00       	jmp    805ce24 <http_parser_execute+0x1051>
		if (c == 'k') {
 805cd55:	3c 6b                	cmp    $0x6b,%al
 805cd57:	0f 84 e4 08 00 00    	je     805d641 <http_parser_execute+0x186e>
		} else if (c == 'c') {
 805cd5d:	3c 63                	cmp    $0x63,%al
 805cd5f:	0f 84 e5 08 00 00    	je     805d64a <http_parser_execute+0x1877>
		} else if (c == 'u') {
 805cd65:	3c 75                	cmp    $0x75,%al
 805cd67:	0f 84 e6 08 00 00    	je     805d653 <http_parser_execute+0x1880>
		} else if (STRICT_TOKEN(c)) {
 805cd6d:	0f b6 d0             	movzbl %al,%edx
 805cd70:	80 ba 40 21 06 08 00 	cmpb   $0x0,0x8062140(%edx)
 805cd77:	0f 85 df 08 00 00    	jne    805d65c <http_parser_execute+0x1889>
			h_state = h_general;
 805cd7d:	3c 20                	cmp    $0x20,%al
 805cd7f:	e9 b8 00 00 00       	jmp    805ce3c <http_parser_execute+0x1069>
		parser->index++;
 805cd84:	8a 4e 03             	mov    0x3(%esi),%cl
 805cd87:	8d 51 01             	lea    0x1(%ecx),%edx
 805cd8a:	83 e1 80             	and    $0xffffff80,%ecx
 805cd8d:	83 e2 7f             	and    $0x7f,%edx
 805cd90:	09 d1                	or     %edx,%ecx
 805cd92:	88 4e 03             	mov    %cl,0x3(%esi)
		if (cond1 || c != KEEP_ALIVE[parser->index]) {
 805cd95:	80 fa 0a             	cmp    $0xa,%dl
 805cd98:	0f 87 be 08 00 00    	ja     805d65c <http_parser_execute+0x1889>
 805cd9e:	0f b6 d2             	movzbl %dl,%edx
 805cda1:	3a 82 2a 37 06 08    	cmp    0x806372a(%edx),%al
 805cda7:	0f 85 af 08 00 00    	jne    805d65c <http_parser_execute+0x1889>
		} else if (parser->index == sizeof(KEEP_ALIVE) - 2) {
 805cdad:	83 e1 7f             	and    $0x7f,%ecx
			h_state = h_connection_keep_alive;
 805cdb0:	b8 14 00 00 00       	mov    $0x14,%eax
 805cdb5:	80 f9 09             	cmp    $0x9,%cl
 805cdb8:	eb 6a                	jmp    805ce24 <http_parser_execute+0x1051>
		parser->index++;
 805cdba:	8a 4e 03             	mov    0x3(%esi),%cl
 805cdbd:	8d 51 01             	lea    0x1(%ecx),%edx
 805cdc0:	83 e1 80             	and    $0xffffff80,%ecx
 805cdc3:	83 e2 7f             	and    $0x7f,%edx
 805cdc6:	09 d1                	or     %edx,%ecx
 805cdc8:	88 4e 03             	mov    %cl,0x3(%esi)
		if (cond1 || c != CLOSE[parser->index]) {
 805cdcb:	80 fa 05             	cmp    $0x5,%dl
 805cdce:	0f 87 88 08 00 00    	ja     805d65c <http_parser_execute+0x1889>
 805cdd4:	0f b6 d2             	movzbl %dl,%edx
 805cdd7:	3a 82 35 37 06 08    	cmp    0x8063735(%edx),%al
 805cddd:	0f 85 79 08 00 00    	jne    805d65c <http_parser_execute+0x1889>
		} else if (parser->index == sizeof(CLOSE) - 2) {
 805cde3:	83 e1 7f             	and    $0x7f,%ecx
			h_state = h_connection_close;
 805cde6:	b8 15 00 00 00       	mov    $0x15,%eax
 805cdeb:	80 f9 04             	cmp    $0x4,%cl
 805cdee:	eb 34                	jmp    805ce24 <http_parser_execute+0x1051>
		parser->index++;
 805cdf0:	8a 4e 03             	mov    0x3(%esi),%cl
 805cdf3:	8d 51 01             	lea    0x1(%ecx),%edx
 805cdf6:	83 e1 80             	and    $0xffffff80,%ecx
 805cdf9:	83 e2 7f             	and    $0x7f,%edx
 805cdfc:	09 d1                	or     %edx,%ecx
 805cdfe:	88 4e 03             	mov    %cl,0x3(%esi)
		if (cond1 || c != UPGRADE[parser->index]) {
 805ce01:	80 fa 07             	cmp    $0x7,%dl
 805ce04:	0f 87 52 08 00 00    	ja     805d65c <http_parser_execute+0x1889>
 805ce0a:	0f b6 d2             	movzbl %dl,%edx
 805ce0d:	3a 82 1a 37 06 08    	cmp    0x806371a(%edx),%al
 805ce13:	0f 85 43 08 00 00    	jne    805d65c <http_parser_execute+0x1889>
		} else if (parser->index == sizeof(UPGRADE) - 2) {
 805ce19:	83 e1 7f             	and    $0x7f,%ecx
			h_state = h_connection_upgrade;
 805ce1c:	b8 16 00 00 00       	mov    $0x16,%eax
 805ce21:	80 f9 06             	cmp    $0x6,%cl
 805ce24:	0f 45 45 a8          	cmovne -0x58(%ebp),%eax
 805ce28:	eb 69                	jmp    805ce93 <http_parser_execute+0x10c0>
		if (ch == ',') {
 805ce2a:	80 fb 2c             	cmp    $0x2c,%bl
 805ce2d:	0f 85 30 08 00 00    	jne    805d663 <http_parser_execute+0x1890>
			parser->index = 0U;
 805ce33:	80 66 03 80          	andb   $0x80,0x3(%esi)
 805ce37:	eb 42                	jmp    805ce7b <http_parser_execute+0x10a8>
			h_state = h_general;
 805ce39:	80 fb 20             	cmp    $0x20,%bl
 805ce3c:	b8 00 00 00 00       	mov    $0x0,%eax
 805ce41:	eb 4c                	jmp    805ce8f <http_parser_execute+0x10bc>
		if (ch == ',') {
 805ce43:	80 fb 2c             	cmp    $0x2c,%bl
 805ce46:	75 3f                	jne    805ce87 <http_parser_execute+0x10b4>
				parser->flags |= F_CONNECTION_KEEP_ALIVE;
 805ce48:	8b 16                	mov    (%esi),%edx
 805ce4a:	66 c1 ea 02          	shr    $0x2,%dx
			if (h_state == h_connection_keep_alive) {
 805ce4e:	83 7d a8 14          	cmpl   $0x14,-0x58(%ebp)
				parser->flags |= F_CONNECTION_KEEP_ALIVE;
 805ce52:	89 d0                	mov    %edx,%eax
			if (h_state == h_connection_keep_alive) {
 805ce54:	75 05                	jne    805ce5b <http_parser_execute+0x1088>
				parser->flags |= F_CONNECTION_KEEP_ALIVE;
 805ce56:	83 c8 02             	or     $0x2,%eax
 805ce59:	eb 0e                	jmp    805ce69 <http_parser_execute+0x1096>
				parser->flags |= F_CONNECTION_UPGRADE;
 805ce5b:	83 c8 08             	or     $0x8,%eax
			} else if (h_state == h_connection_close) {
 805ce5e:	83 7d a8 15          	cmpl   $0x15,-0x58(%ebp)
 805ce62:	75 05                	jne    805ce69 <http_parser_execute+0x1096>
				parser->flags |= F_CONNECTION_CLOSE;
 805ce64:	89 d0                	mov    %edx,%eax
 805ce66:	83 c8 04             	or     $0x4,%eax
				parser->flags |= F_CONNECTION_KEEP_ALIVE;
 805ce69:	8b 16                	mov    (%esi),%edx
 805ce6b:	0f b6 c0             	movzbl %al,%eax
 805ce6e:	c1 e0 02             	shl    $0x2,%eax
 805ce71:	81 e2 03 fc ff 80    	and    $0x80fffc03,%edx
 805ce77:	09 c2                	or     %eax,%edx
 805ce79:	89 16                	mov    %edx,(%esi)
			h_state = h_matching_connection_token_start;
 805ce7b:	c7 45 a8 0e 00 00 00 	movl   $0xe,-0x58(%ebp)
 805ce82:	e9 dc 07 00 00       	jmp    805d663 <http_parser_execute+0x1890>
			h_state = h_matching_connection_token;
 805ce87:	80 fb 20             	cmp    $0x20,%bl
 805ce8a:	b8 12 00 00 00       	mov    $0x12,%eax
 805ce8f:	0f 44 45 a8          	cmove  -0x58(%ebp),%eax
 805ce93:	89 45 a8             	mov    %eax,-0x58(%ebp)
 805ce96:	e9 c8 07 00 00       	jmp    805d663 <http_parser_execute+0x1890>
		*p_state = s_header_value;
 805ce9b:	c7 45 c8 30 00 00 00 	movl   $0x30,-0x38(%ebp)
		break;
 805cea2:	e9 91 07 00 00       	jmp    805d638 <http_parser_execute+0x1865>
		parser->http_errno = HPE_HEADER_OVERFLOW;
 805cea7:	8a 46 17             	mov    0x17(%esi),%al
 805ceaa:	83 e0 80             	and    $0xffffff80,%eax
 805cead:	83 c8 0c             	or     $0xc,%eax
 805ceb0:	88 46 17             	mov    %al,0x17(%esi)
 805ceb3:	8b 45 a0             	mov    -0x60(%ebp),%eax
 805ceb6:	89 45 b4             	mov    %eax,-0x4c(%ebp)
 805ceb9:	e9 39 07 00 00       	jmp    805d5f7 <http_parser_execute+0x1824>
			if (p == data + len) {
 805cebe:	8b 45 a0             	mov    -0x60(%ebp),%eax
 805cec1:	89 45 b4             	mov    %eax,-0x4c(%ebp)
 805cec4:	39 45 9c             	cmp    %eax,-0x64(%ebp)
 805cec7:	0f 85 16 06 00 00    	jne    805d4e3 <http_parser_execute+0x1710>
				--p;
 805cecd:	ff 4d b4             	decl   -0x4c(%ebp)
 805ced0:	e9 0e 06 00 00       	jmp    805d4e3 <http_parser_execute+0x1710>
			if (UNLIKELY(ch != LF)) {
 805ced5:	80 fb 0a             	cmp    $0xa,%bl
 805ced8:	74 0e                	je     805cee8 <http_parser_execute+0x1115>
				SET_ERRNO(HPE_LF_EXPECTED);
 805ceda:	8a 46 17             	mov    0x17(%esi),%al
 805cedd:	83 e0 80             	and    $0xffffff80,%eax
 805cee0:	83 c8 17             	or     $0x17,%eax
 805cee3:	e9 e3 05 00 00       	jmp    805d4cb <http_parser_execute+0x16f8>
			UPDATE_STATE(s_header_value_lws);
 805cee8:	c7 45 c8 31 00 00 00 	movl   $0x31,-0x38(%ebp)
			break;
 805ceef:	e9 ef 05 00 00       	jmp    805d4e3 <http_parser_execute+0x1710>
			if (ch == ' ' || ch == '\t') {
 805cef4:	80 fb 20             	cmp    $0x20,%bl
 805cef7:	74 05                	je     805cefe <http_parser_execute+0x112b>
 805cef9:	80 fb 09             	cmp    $0x9,%bl
 805cefc:	75 0c                	jne    805cf0a <http_parser_execute+0x1137>
				UPDATE_STATE(s_header_value_start);
 805cefe:	c7 45 c8 2f 00 00 00 	movl   $0x2f,-0x38(%ebp)
				goto reexecute;
 805cf05:	e9 12 f0 ff ff       	jmp    805bf1c <http_parser_execute+0x149>
			switch (parser->header_state) {
 805cf0a:	8a 46 02             	mov    0x2(%esi),%al
 805cf0d:	d0 e8                	shr    %al
 805cf0f:	3c 15                	cmp    $0x15,%al
 805cf11:	74 1a                	je     805cf2d <http_parser_execute+0x115a>
 805cf13:	77 0e                	ja     805cf23 <http_parser_execute+0x1150>
 805cf15:	3c 13                	cmp    $0x13,%al
 805cf17:	74 1a                	je     805cf33 <http_parser_execute+0x1160>
 805cf19:	3c 14                	cmp    $0x14,%al
 805cf1b:	75 1a                	jne    805cf37 <http_parser_execute+0x1164>
				parser->flags |= F_CONNECTION_KEEP_ALIVE;
 805cf1d:	66 83 0e 08          	orw    $0x8,(%esi)
				break;
 805cf21:	eb 14                	jmp    805cf37 <http_parser_execute+0x1164>
 805cf23:	3c 16                	cmp    $0x16,%al
 805cf25:	75 10                	jne    805cf37 <http_parser_execute+0x1164>
				parser->flags |= F_CONNECTION_UPGRADE;
 805cf27:	66 83 0e 20          	orw    $0x20,(%esi)
				break;
 805cf2b:	eb 0a                	jmp    805cf37 <http_parser_execute+0x1164>
				parser->flags |= F_CONNECTION_CLOSE;
 805cf2d:	66 83 0e 10          	orw    $0x10,(%esi)
				break;
 805cf31:	eb 04                	jmp    805cf37 <http_parser_execute+0x1164>
				parser->flags |= F_CHUNKED;
 805cf33:	66 83 0e 04          	orw    $0x4,(%esi)
			UPDATE_STATE(s_header_field_start);
 805cf37:	c7 45 c8 2a 00 00 00 	movl   $0x2a,-0x38(%ebp)
			goto reexecute;
 805cf3e:	e9 d9 ef ff ff       	jmp    805bf1c <http_parser_execute+0x149>
			UPDATE_STATE(s_header_value_discard_lws);
 805cf43:	c7 45 c8 2e 00 00 00 	movl   $0x2e,-0x38(%ebp)
			break;
 805cf4a:	e9 94 05 00 00       	jmp    805d4e3 <http_parser_execute+0x1710>
			if (ch == ' ' || ch == '\t') {
 805cf4f:	80 fb 20             	cmp    $0x20,%bl
 805cf52:	74 05                	je     805cf59 <http_parser_execute+0x1186>
 805cf54:	80 fb 09             	cmp    $0x9,%bl
 805cf57:	75 0c                	jne    805cf65 <http_parser_execute+0x1192>
				UPDATE_STATE(s_header_value_discard_ws);
 805cf59:	c7 45 c8 2c 00 00 00 	movl   $0x2c,-0x38(%ebp)
				break;
 805cf60:	e9 7e 05 00 00       	jmp    805d4e3 <http_parser_execute+0x1710>
			switch (parser->header_state) {
 805cf65:	8a 46 02             	mov    0x2(%esi),%al
 805cf68:	d0 e8                	shr    %al
 805cf6a:	3c 15                	cmp    $0x15,%al
 805cf6c:	74 1a                	je     805cf88 <http_parser_execute+0x11b5>
 805cf6e:	77 0e                	ja     805cf7e <http_parser_execute+0x11ab>
 805cf70:	3c 13                	cmp    $0x13,%al
 805cf72:	74 1a                	je     805cf8e <http_parser_execute+0x11bb>
 805cf74:	3c 14                	cmp    $0x14,%al
 805cf76:	75 1a                	jne    805cf92 <http_parser_execute+0x11bf>
				parser->flags |=
 805cf78:	66 83 0e 08          	orw    $0x8,(%esi)
				break;
 805cf7c:	eb 14                	jmp    805cf92 <http_parser_execute+0x11bf>
 805cf7e:	3c 16                	cmp    $0x16,%al
 805cf80:	75 10                	jne    805cf92 <http_parser_execute+0x11bf>
				parser->flags |= F_CONNECTION_UPGRADE;
 805cf82:	66 83 0e 20          	orw    $0x20,(%esi)
				break;
 805cf86:	eb 0a                	jmp    805cf92 <http_parser_execute+0x11bf>
				parser->flags |= F_CONNECTION_CLOSE;
 805cf88:	66 83 0e 10          	orw    $0x10,(%esi)
				break;
 805cf8c:	eb 04                	jmp    805cf92 <http_parser_execute+0x11bf>
				parser->flags |= F_CHUNKED;
 805cf8e:	66 83 0e 04          	orw    $0x4,(%esi)
			MARK(header_value);
 805cf92:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
 805cf96:	75 06                	jne    805cf9e <http_parser_execute+0x11cb>
 805cf98:	8b 45 b4             	mov    -0x4c(%ebp),%eax
 805cf9b:	89 45 d0             	mov    %eax,-0x30(%ebp)
			rc = cb_data(parser, settings->on_header_value,
 805cf9e:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 805cfa1:	83 ec 0c             	sub    $0xc,%esp
 805cfa4:	b9 04 00 00 00       	mov    $0x4,%ecx
			UPDATE_STATE(s_header_field_start);
 805cfa9:	c7 45 c8 2a 00 00 00 	movl   $0x2a,-0x38(%ebp)
			rc = cb_data(parser, settings->on_header_value,
 805cfb0:	8b 50 10             	mov    0x10(%eax),%edx
				     p - header_value_mark);
 805cfb3:	8b 45 b4             	mov    -0x4c(%ebp),%eax
 805cfb6:	2b 45 d0             	sub    -0x30(%ebp),%eax
			rc = cb_data(parser, settings->on_header_value,
 805cfb9:	50                   	push   %eax
 805cfba:	8d 45 d0             	lea    -0x30(%ebp),%eax
 805cfbd:	50                   	push   %eax
				     p - data, &header_value_mark,
 805cfbe:	8b 45 b4             	mov    -0x4c(%ebp),%eax
 805cfc1:	2b 45 b0             	sub    -0x50(%ebp),%eax
			rc = cb_data(parser, settings->on_header_value,
 805cfc4:	50                   	push   %eax
 805cfc5:	8d 45 c4             	lea    -0x3c(%ebp),%eax
 805cfc8:	50                   	push   %eax
 805cfc9:	8d 45 c8             	lea    -0x38(%ebp),%eax
 805cfcc:	50                   	push   %eax
 805cfcd:	e9 a9 02 00 00       	jmp    805d27b <http_parser_execute+0x14a8>
			if (parser->flags & F_TRAILING) {
 805cfd2:	8b 16                	mov    (%esi),%edx
 805cfd4:	89 d0                	mov    %edx,%eax
 805cfd6:	66 c1 e8 02          	shr    $0x2,%ax
 805cfda:	80 e2 40             	and    $0x40,%dl
 805cfdd:	74 2d                	je     805d00c <http_parser_execute+0x1239>
				rc = cb_notify(parser, &p_state,
 805cfdf:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 805cfe2:	8d 55 c8             	lea    -0x38(%ebp),%edx
				UPDATE_STATE(s_message_done);
 805cfe5:	c7 45 c8 3e 00 00 00 	movl   $0x3e,-0x38(%ebp)
				rc = cb_notify(parser, &p_state,
 805cfec:	8b 48 24             	mov    0x24(%eax),%ecx
 805cfef:	50                   	push   %eax
					       p - data);
 805cff0:	8b 45 b4             	mov    -0x4c(%ebp),%eax
 805cff3:	2b 45 b0             	sub    -0x50(%ebp),%eax
				rc = cb_notify(parser, &p_state,
 805cff6:	50                   	push   %eax
 805cff7:	8d 45 c4             	lea    -0x3c(%ebp),%eax
 805cffa:	50                   	push   %eax
 805cffb:	89 f0                	mov    %esi,%eax
 805cffd:	6a 0a                	push   $0xa
 805cfff:	e8 87 ec ff ff       	call   805bc8b <cb_notify>
 805d004:	83 c4 10             	add    $0x10,%esp
 805d007:	e9 79 02 00 00       	jmp    805d285 <http_parser_execute+0x14b2>
			if ((parser->flags & F_CHUNKED) &&
 805d00c:	a8 01                	test   $0x1,%al
 805d00e:	74 12                	je     805d022 <http_parser_execute+0x124f>
 805d010:	84 c0                	test   %al,%al
 805d012:	79 0e                	jns    805d022 <http_parser_execute+0x124f>
				SET_ERRNO(HPE_UNEXPECTED_CONTENT_LENGTH);
 805d014:	8a 46 17             	mov    0x17(%esi),%al
 805d017:	83 e0 80             	and    $0xffffff80,%eax
 805d01a:	83 c8 1a             	or     $0x1a,%eax
 805d01d:	e9 a9 04 00 00       	jmp    805d4cb <http_parser_execute+0x16f8>
				((parser->flags & flags) == flags ||
 805d022:	83 e0 28             	and    $0x28,%eax
			UPDATE_STATE(s_headers_done);
 805d025:	c7 45 c8 38 00 00 00 	movl   $0x38,-0x38(%ebp)
				((parser->flags & flags) == flags ||
 805d02c:	ba 01 00 00 00       	mov    $0x1,%edx
 805d031:	3c 28                	cmp    $0x28,%al
 805d033:	74 09                	je     805d03e <http_parser_execute+0x126b>
 805d035:	31 d2                	xor    %edx,%edx
 805d037:	80 7e 16 05          	cmpb   $0x5,0x16(%esi)
 805d03b:	0f 94 c2             	sete   %dl
			parser->upgrade =
 805d03e:	8a 46 17             	mov    0x17(%esi),%al
 805d041:	c1 e2 07             	shl    $0x7,%edx
 805d044:	83 e0 7f             	and    $0x7f,%eax
 805d047:	09 d0                	or     %edx,%eax
 805d049:	88 46 17             	mov    %al,0x17(%esi)
			if (settings->on_headers_complete) {
 805d04c:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 805d04f:	8b 40 14             	mov    0x14(%eax),%eax
 805d052:	85 c0                	test   %eax,%eax
 805d054:	74 2e                	je     805d084 <http_parser_execute+0x12b1>
				switch (settings->on_headers_complete(parser)) {
 805d056:	83 ec 0c             	sub    $0xc,%esp
 805d059:	56                   	push   %esi
 805d05a:	ff d0                	call   *%eax
 805d05c:	83 c4 10             	add    $0x10,%esp
 805d05f:	83 f8 01             	cmp    $0x1,%eax
 805d062:	74 1b                	je     805d07f <http_parser_execute+0x12ac>
 805d064:	83 f8 02             	cmp    $0x2,%eax
 805d067:	74 12                	je     805d07b <http_parser_execute+0x12a8>
 805d069:	85 c0                	test   %eax,%eax
 805d06b:	74 17                	je     805d084 <http_parser_execute+0x12b1>
					SET_ERRNO(HPE_CB_headers_complete);
 805d06d:	8a 46 17             	mov    0x17(%esi),%al
 805d070:	83 e0 80             	and    $0xffffff80,%eax
 805d073:	83 c8 05             	or     $0x5,%eax
 805d076:	88 46 17             	mov    %al,0x17(%esi)
					parser->state = CURRENT_STATE();
 805d079:	eb 13                	jmp    805d08e <http_parser_execute+0x12bb>
					parser->upgrade = 1U;
 805d07b:	80 4e 17 80          	orb    $0x80,0x17(%esi)
					parser->flags |= F_SKIPBODY;
 805d07f:	66 81 0e 00 01       	orw    $0x100,(%esi)
			if (HTTP_PARSER_ERRNO(parser) != HPE_OK) {
 805d084:	f6 46 17 7f          	testb  $0x7f,0x17(%esi)
 805d088:	0f 84 8e ee ff ff    	je     805bf1c <http_parser_execute+0x149>
				parser->state = CURRENT_STATE();
 805d08e:	8b 06                	mov    (%esi),%eax
 805d090:	25 ff 03 fe ff       	and    $0xfffe03ff,%eax
 805d095:	80 cc e0             	or     $0xe0,%ah
 805d098:	e9 7c 05 00 00       	jmp    805d619 <http_parser_execute+0x1846>
			hasBody = parser->flags & F_CHUNKED ||
 805d09d:	8b 06                	mov    (%esi),%eax
			parser->nread = 0U;
 805d09f:	c7 46 04 00 00 00 00 	movl   $0x0,0x4(%esi)
			hasBody = parser->flags & F_CHUNKED ||
 805d0a6:	b9 01 00 00 00       	mov    $0x1,%ecx
 805d0ab:	66 c1 e8 02          	shr    $0x2,%ax
 805d0af:	89 c2                	mov    %eax,%edx
 805d0b1:	80 e2 01             	and    $0x1,%dl
 805d0b4:	75 28                	jne    805d0de <http_parser_execute+0x130b>
				  (parser->content_length > 0 &&
 805d0b6:	8b 4e 08             	mov    0x8(%esi),%ecx
 805d0b9:	8b 5e 0c             	mov    0xc(%esi),%ebx
			hasBody = parser->flags & F_CHUNKED ||
 805d0bc:	bf fd ff ff ff       	mov    $0xfffffffd,%edi
				  (parser->content_length > 0 &&
 805d0c1:	83 c1 ff             	add    $0xffffffff,%ecx
 805d0c4:	83 d3 ff             	adc    $0xffffffff,%ebx
 805d0c7:	89 4d a8             	mov    %ecx,-0x58(%ebp)
			hasBody = parser->flags & F_CHUNKED ||
 805d0ca:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
 805d0cf:	3b 7d a8             	cmp    -0x58(%ebp),%edi
				  (parser->content_length > 0 &&
 805d0d2:	89 5d ac             	mov    %ebx,-0x54(%ebp)
			hasBody = parser->flags & F_CHUNKED ||
 805d0d5:	1b 4d ac             	sbb    -0x54(%ebp),%ecx
 805d0d8:	0f 93 c1             	setae  %cl
 805d0db:	0f b6 c9             	movzbl %cl,%ecx
			if (parser->upgrade &&
 805d0de:	80 7e 17 00          	cmpb   $0x0,0x17(%esi)
 805d0e2:	79 51                	jns    805d135 <http_parser_execute+0x1362>
 805d0e4:	80 7e 16 05          	cmpb   $0x5,0x16(%esi)
 805d0e8:	74 08                	je     805d0f2 <http_parser_execute+0x131f>
				 (parser->flags & F_SKIPBODY) || !hasBody)) {
 805d0ea:	a8 40                	test   $0x40,%al
 805d0ec:	75 04                	jne    805d0f2 <http_parser_execute+0x131f>
 805d0ee:	85 c9                	test   %ecx,%ecx
 805d0f0:	75 73                	jne    805d165 <http_parser_execute+0x1392>
				UPDATE_STATE(NEW_MESSAGE());
 805d0f2:	8a 06                	mov    (%esi),%al
					       p - data + 1);
 805d0f4:	8b 7d b4             	mov    -0x4c(%ebp),%edi
				rc = cb_notify(parser, &p_state,
 805d0f7:	8d 55 c8             	lea    -0x38(%ebp),%edx
				UPDATE_STATE(NEW_MESSAGE());
 805d0fa:	83 e0 03             	and    $0x3,%eax
 805d0fd:	3c 01                	cmp    $0x1,%al
 805d0ff:	19 c0                	sbb    %eax,%eax
					       p - data + 1);
 805d101:	2b 7d b0             	sub    -0x50(%ebp),%edi
				UPDATE_STATE(NEW_MESSAGE());
 805d104:	83 e0 0e             	and    $0xe,%eax
					       p - data + 1);
 805d107:	89 fb                	mov    %edi,%ebx
				UPDATE_STATE(NEW_MESSAGE());
 805d109:	83 c0 04             	add    $0x4,%eax
					       p - data + 1);
 805d10c:	43                   	inc    %ebx
				UPDATE_STATE(NEW_MESSAGE());
 805d10d:	89 45 c8             	mov    %eax,-0x38(%ebp)
				rc = cb_notify(parser, &p_state,
 805d110:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 805d113:	8b 48 1c             	mov    0x1c(%eax),%ecx
 805d116:	50                   	push   %eax
 805d117:	8d 45 c4             	lea    -0x3c(%ebp),%eax
 805d11a:	53                   	push   %ebx
 805d11b:	50                   	push   %eax
 805d11c:	89 f0                	mov    %esi,%eax
 805d11e:	6a 07                	push   $0x7
 805d120:	e8 66 eb ff ff       	call   805bc8b <cb_notify>
 805d125:	83 c4 10             	add    $0x10,%esp
				if (rc != 0) {
 805d128:	85 c0                	test   %eax,%eax
 805d12a:	0f 85 f4 04 00 00    	jne    805d624 <http_parser_execute+0x1851>
 805d130:	e9 c1 01 00 00       	jmp    805d2f6 <http_parser_execute+0x1523>
			if (parser->flags & F_SKIPBODY) {
 805d135:	a8 40                	test   $0x40,%al
 805d137:	74 2c                	je     805d165 <http_parser_execute+0x1392>
				UPDATE_STATE(NEW_MESSAGE());
 805d139:	8a 06                	mov    (%esi),%al
 805d13b:	83 e0 03             	and    $0x3,%eax
 805d13e:	3c 01                	cmp    $0x1,%al
 805d140:	19 c0                	sbb    %eax,%eax
 805d142:	83 e0 0e             	and    $0xe,%eax
 805d145:	83 c0 04             	add    $0x4,%eax
 805d148:	89 45 c8             	mov    %eax,-0x38(%ebp)
				rc = cb_notify(parser, &p_state,
 805d14b:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 805d14e:	8b 48 1c             	mov    0x1c(%eax),%ecx
 805d151:	50                   	push   %eax
					       p - data + 1);
 805d152:	8b 45 b4             	mov    -0x4c(%ebp),%eax
 805d155:	2b 45 b0             	sub    -0x50(%ebp),%eax
 805d158:	40                   	inc    %eax
				rc = cb_notify(parser, &p_state,
 805d159:	50                   	push   %eax
 805d15a:	8d 45 c4             	lea    -0x3c(%ebp),%eax
 805d15d:	50                   	push   %eax
 805d15e:	6a 07                	push   $0x7
 805d160:	e9 47 03 00 00       	jmp    805d4ac <http_parser_execute+0x16d9>
			} else if (parser->flags & F_CHUNKED) {
 805d165:	84 d2                	test   %dl,%dl
 805d167:	74 0c                	je     805d175 <http_parser_execute+0x13a2>
				UPDATE_STATE(s_chunk_size_start);
 805d169:	c7 45 c8 33 00 00 00 	movl   $0x33,-0x38(%ebp)
 805d170:	e9 6e 03 00 00       	jmp    805d4e3 <http_parser_execute+0x1710>
	if (parser->content_length == 0U) {
 805d175:	8b 56 0c             	mov    0xc(%esi),%edx
 805d178:	8b 46 08             	mov    0x8(%esi),%eax
 805d17b:	89 d7                	mov    %edx,%edi
 805d17d:	09 c7                	or     %eax,%edi
 805d17f:	74 1f                	je     805d1a0 <http_parser_execute+0x13cd>
	} else if (parser->content_length != ULLONG_MAX) {
 805d181:	42                   	inc    %edx
 805d182:	75 03                	jne    805d187 <http_parser_execute+0x13b4>
 805d184:	40                   	inc    %eax
 805d185:	74 09                	je     805d190 <http_parser_execute+0x13bd>
		UPDATE_STATE(s_body_identity);
 805d187:	c7 45 e0 3c 00 00 00 	movl   $0x3c,-0x20(%ebp)
 805d18e:	eb 54                	jmp    805d1e4 <http_parser_execute+0x1411>
		if (!http_message_needs_eof(parser)) {
 805d190:	83 ec 0c             	sub    $0xc,%esp
 805d193:	56                   	push   %esi
 805d194:	e8 e8 eb ff ff       	call   805bd81 <http_message_needs_eof>
 805d199:	83 c4 10             	add    $0x10,%esp
 805d19c:	85 c0                	test   %eax,%eax
 805d19e:	75 3d                	jne    805d1dd <http_parser_execute+0x140a>
			UPDATE_STATE(NEW_MESSAGE());
 805d1a0:	8a 06                	mov    (%esi),%al
			rc = cb_notify(parser, &p_state,
 805d1a2:	8d 55 e0             	lea    -0x20(%ebp),%edx
			UPDATE_STATE(NEW_MESSAGE());
 805d1a5:	83 e0 03             	and    $0x3,%eax
 805d1a8:	3c 01                	cmp    $0x1,%al
 805d1aa:	19 c0                	sbb    %eax,%eax
 805d1ac:	83 e0 0e             	and    $0xe,%eax
 805d1af:	83 c0 04             	add    $0x4,%eax
 805d1b2:	89 45 e0             	mov    %eax,-0x20(%ebp)
			rc = cb_notify(parser, &p_state,
 805d1b5:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 805d1b8:	8b 48 1c             	mov    0x1c(%eax),%ecx
 805d1bb:	50                   	push   %eax
				       p - data + 1);
 805d1bc:	8b 45 b4             	mov    -0x4c(%ebp),%eax
 805d1bf:	2b 45 b0             	sub    -0x50(%ebp),%eax
 805d1c2:	40                   	inc    %eax
			rc = cb_notify(parser, &p_state,
 805d1c3:	50                   	push   %eax
 805d1c4:	8d 45 c4             	lea    -0x3c(%ebp),%eax
 805d1c7:	50                   	push   %eax
 805d1c8:	89 f0                	mov    %esi,%eax
 805d1ca:	6a 07                	push   $0x7
 805d1cc:	e8 ba ea ff ff       	call   805bc8b <cb_notify>
 805d1d1:	83 c4 10             	add    $0x10,%esp
			if (rc != 0) {
 805d1d4:	85 c0                	test   %eax,%eax
 805d1d6:	74 0c                	je     805d1e4 <http_parser_execute+0x1411>
 805d1d8:	e9 47 04 00 00       	jmp    805d624 <http_parser_execute+0x1851>
			UPDATE_STATE(s_body_identity_eof);
 805d1dd:	c7 45 e0 3d 00 00 00 	movl   $0x3d,-0x20(%ebp)
	*current_state = p_state;
 805d1e4:	8b 45 e0             	mov    -0x20(%ebp),%eax
 805d1e7:	89 45 c8             	mov    %eax,-0x38(%ebp)
				if (rc != 0) {
 805d1ea:	e9 f4 02 00 00       	jmp    805d4e3 <http_parser_execute+0x1710>
			uint64_t to_read = MIN(parser->content_length,
 805d1ef:	8b 46 08             	mov    0x8(%esi),%eax
 805d1f2:	8b 56 0c             	mov    0xc(%esi),%edx
 805d1f5:	89 45 a8             	mov    %eax,-0x58(%ebp)
 805d1f8:	8b 45 9c             	mov    -0x64(%ebp),%eax
 805d1fb:	2b 45 b4             	sub    -0x4c(%ebp),%eax
 805d1fe:	8b 4d a8             	mov    -0x58(%ebp),%ecx
 805d201:	89 55 ac             	mov    %edx,-0x54(%ebp)
 805d204:	8b 7d ac             	mov    -0x54(%ebp),%edi
 805d207:	99                   	cltd   
 805d208:	39 45 a8             	cmp    %eax,-0x58(%ebp)
 805d20b:	19 d7                	sbb    %edx,%edi
 805d20d:	0f 43 c8             	cmovae %eax,%ecx
 805d210:	89 d0                	mov    %edx,%eax
 805d212:	0f 42 45 ac          	cmovb  -0x54(%ebp),%eax
			MARK(body);
 805d216:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
			uint64_t to_read = MIN(parser->content_length,
 805d21a:	89 4d 90             	mov    %ecx,-0x70(%ebp)
 805d21d:	89 45 94             	mov    %eax,-0x6c(%ebp)
			MARK(body);
 805d220:	75 06                	jne    805d228 <http_parser_execute+0x1455>
 805d222:	8b 45 b4             	mov    -0x4c(%ebp),%eax
 805d225:	89 45 d8             	mov    %eax,-0x28(%ebp)
			p += to_read - 1;
 805d228:	8b 7d 90             	mov    -0x70(%ebp),%edi
			parser->content_length -= to_read;
 805d22b:	8b 45 a8             	mov    -0x58(%ebp),%eax
 805d22e:	8b 55 ac             	mov    -0x54(%ebp),%edx
 805d231:	2b 45 90             	sub    -0x70(%ebp),%eax
 805d234:	1b 55 94             	sbb    -0x6c(%ebp),%edx
 805d237:	89 46 08             	mov    %eax,0x8(%esi)
			p += to_read - 1;
 805d23a:	8d 4f ff             	lea    -0x1(%edi),%ecx
 805d23d:	01 4d b4             	add    %ecx,-0x4c(%ebp)
			if (parser->content_length == 0U) {
 805d240:	09 d0                	or     %edx,%eax
			parser->content_length -= to_read;
 805d242:	89 56 0c             	mov    %edx,0xc(%esi)
			if (parser->content_length == 0U) {
 805d245:	0f 85 98 02 00 00    	jne    805d4e3 <http_parser_execute+0x1710>
				rc = cb_data(parser, settings->on_body,
 805d24b:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 805d24e:	83 ec 0c             	sub    $0xc,%esp
 805d251:	b9 06 00 00 00       	mov    $0x6,%ecx
				UPDATE_STATE(s_message_done);
 805d256:	c7 45 c8 3e 00 00 00 	movl   $0x3e,-0x38(%ebp)
				rc = cb_data(parser, settings->on_body,
 805d25d:	8b 50 18             	mov    0x18(%eax),%edx
					     p - body_mark + 1);
 805d260:	8b 45 b4             	mov    -0x4c(%ebp),%eax
 805d263:	2b 45 d8             	sub    -0x28(%ebp),%eax
 805d266:	40                   	inc    %eax
				rc = cb_data(parser, settings->on_body,
 805d267:	50                   	push   %eax
 805d268:	8d 45 d8             	lea    -0x28(%ebp),%eax
 805d26b:	50                   	push   %eax
					     p - data, &body_mark,
 805d26c:	8b 45 b4             	mov    -0x4c(%ebp),%eax
 805d26f:	2b 45 b0             	sub    -0x50(%ebp),%eax
				rc = cb_data(parser, settings->on_body,
 805d272:	50                   	push   %eax
 805d273:	8d 45 c4             	lea    -0x3c(%ebp),%eax
 805d276:	50                   	push   %eax
 805d277:	8d 45 c8             	lea    -0x38(%ebp),%eax
 805d27a:	50                   	push   %eax
 805d27b:	89 f0                	mov    %esi,%eax
 805d27d:	e8 73 ea ff ff       	call   805bcf5 <cb_data>
 805d282:	83 c4 20             	add    $0x20,%esp
				if (rc != 0) {
 805d285:	85 c0                	test   %eax,%eax
 805d287:	0f 84 8f ec ff ff    	je     805bf1c <http_parser_execute+0x149>
 805d28d:	e9 92 03 00 00       	jmp    805d624 <http_parser_execute+0x1851>
			MARK(body);
 805d292:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
 805d296:	75 06                	jne    805d29e <http_parser_execute+0x14cb>
 805d298:	8b 45 b4             	mov    -0x4c(%ebp),%eax
 805d29b:	89 45 d8             	mov    %eax,-0x28(%ebp)
			p = data + len - 1;
 805d29e:	8b 45 b0             	mov    -0x50(%ebp),%eax
 805d2a1:	8b 7d 14             	mov    0x14(%ebp),%edi
 805d2a4:	8d 44 38 ff          	lea    -0x1(%eax,%edi,1),%eax
 805d2a8:	89 45 b4             	mov    %eax,-0x4c(%ebp)
			break;
 805d2ab:	e9 33 02 00 00       	jmp    805d4e3 <http_parser_execute+0x1710>
			UPDATE_STATE(NEW_MESSAGE());
 805d2b0:	8a 06                	mov    (%esi),%al
				       p - data + 1);
 805d2b2:	8b 5d b4             	mov    -0x4c(%ebp),%ebx
			rc = cb_notify(parser, &p_state,
 805d2b5:	8d 55 c8             	lea    -0x38(%ebp),%edx
			UPDATE_STATE(NEW_MESSAGE());
 805d2b8:	83 e0 03             	and    $0x3,%eax
 805d2bb:	3c 01                	cmp    $0x1,%al
 805d2bd:	19 c0                	sbb    %eax,%eax
				       p - data + 1);
 805d2bf:	2b 5d b0             	sub    -0x50(%ebp),%ebx
			UPDATE_STATE(NEW_MESSAGE());
 805d2c2:	83 e0 0e             	and    $0xe,%eax
				       p - data + 1);
 805d2c5:	43                   	inc    %ebx
			UPDATE_STATE(NEW_MESSAGE());
 805d2c6:	83 c0 04             	add    $0x4,%eax
 805d2c9:	89 45 c8             	mov    %eax,-0x38(%ebp)
			rc = cb_notify(parser, &p_state,
 805d2cc:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 805d2cf:	8b 48 1c             	mov    0x1c(%eax),%ecx
 805d2d2:	50                   	push   %eax
 805d2d3:	8d 45 c4             	lea    -0x3c(%ebp),%eax
 805d2d6:	53                   	push   %ebx
 805d2d7:	50                   	push   %eax
 805d2d8:	89 f0                	mov    %esi,%eax
 805d2da:	6a 07                	push   $0x7
 805d2dc:	e8 aa e9 ff ff       	call   805bc8b <cb_notify>
 805d2e1:	83 c4 10             	add    $0x10,%esp
			if (rc != 0) {
 805d2e4:	85 c0                	test   %eax,%eax
 805d2e6:	0f 85 38 03 00 00    	jne    805d624 <http_parser_execute+0x1851>
			if (parser->upgrade) {
 805d2ec:	80 7e 17 00          	cmpb   $0x0,0x17(%esi)
 805d2f0:	0f 89 ed 01 00 00    	jns    805d4e3 <http_parser_execute+0x1710>
				parser->state = CURRENT_STATE();
 805d2f6:	8b 55 c8             	mov    -0x38(%ebp),%edx
 805d2f9:	8b 06                	mov    (%esi),%eax
 805d2fb:	83 e2 7f             	and    $0x7f,%edx
 805d2fe:	25 ff 03 fe ff       	and    $0xfffe03ff,%eax
 805d303:	c1 e2 0a             	shl    $0xa,%edx
 805d306:	09 d0                	or     %edx,%eax
 805d308:	89 06                	mov    %eax,(%esi)
				*parsed = p - data + 1;
 805d30a:	89 5d c4             	mov    %ebx,-0x3c(%ebp)
				return 0;
 805d30d:	e9 12 03 00 00       	jmp    805d624 <http_parser_execute+0x1851>
			unhex_val = unhex[(unsigned char)ch];
 805d312:	0f b6 c3             	movzbl %bl,%eax
 805d315:	0f be 80 40 20 06 08 	movsbl 0x8062040(%eax),%eax
			if (UNLIKELY(unhex_val == -1)) {
 805d31c:	3c ff                	cmp    $0xff,%al
 805d31e:	74 3e                	je     805d35e <http_parser_execute+0x158b>
			parser->content_length = unhex_val;
 805d320:	89 46 08             	mov    %eax,0x8(%esi)
 805d323:	c1 f8 1f             	sar    $0x1f,%eax
 805d326:	89 46 0c             	mov    %eax,0xc(%esi)
			UPDATE_STATE(s_chunk_size);
 805d329:	c7 45 c8 34 00 00 00 	movl   $0x34,-0x38(%ebp)
			break;
 805d330:	e9 ae 01 00 00       	jmp    805d4e3 <http_parser_execute+0x1710>
			if (ch == CR) {
 805d335:	80 fb 0d             	cmp    $0xd,%bl
 805d338:	74 78                	je     805d3b2 <http_parser_execute+0x15df>
			unhex_val = unhex[(unsigned char)ch];
 805d33a:	0f b6 c3             	movzbl %bl,%eax
 805d33d:	0f be 80 40 20 06 08 	movsbl 0x8062040(%eax),%eax
			if (unhex_val == -1) {
 805d344:	3c ff                	cmp    $0xff,%al
 805d346:	75 24                	jne    805d36c <http_parser_execute+0x1599>
				if (ch == ';' || ch == ' ') {
 805d348:	80 fb 3b             	cmp    $0x3b,%bl
 805d34b:	74 05                	je     805d352 <http_parser_execute+0x157f>
 805d34d:	80 fb 20             	cmp    $0x20,%bl
 805d350:	75 0c                	jne    805d35e <http_parser_execute+0x158b>
					UPDATE_STATE(s_chunk_parameters);
 805d352:	c7 45 c8 35 00 00 00 	movl   $0x35,-0x38(%ebp)
					break;
 805d359:	e9 85 01 00 00       	jmp    805d4e3 <http_parser_execute+0x1710>
				SET_ERRNO(HPE_INVALID_CHUNK_SIZE);
 805d35e:	8a 46 17             	mov    0x17(%esi),%al
 805d361:	83 e0 80             	and    $0xffffff80,%eax
 805d364:	83 c8 1b             	or     $0x1b,%eax
 805d367:	e9 5f 01 00 00       	jmp    805d4cb <http_parser_execute+0x16f8>
			t *= 16U;
 805d36c:	8b 4e 08             	mov    0x8(%esi),%ecx
 805d36f:	8b 5e 0c             	mov    0xc(%esi),%ebx
			t += unhex_val;
 805d372:	99                   	cltd   
			t *= 16U;
 805d373:	0f a4 cb 04          	shld   $0x4,%ecx,%ebx
 805d377:	c1 e1 04             	shl    $0x4,%ecx
			t += unhex_val;
 805d37a:	01 c8                	add    %ecx,%eax
			if (UNLIKELY(ulong_value < parser->content_length)) {
 805d37c:	b9 fe ff ff ff       	mov    $0xfffffffe,%ecx
			t += unhex_val;
 805d381:	11 da                	adc    %ebx,%edx
			if (UNLIKELY(ulong_value < parser->content_length)) {
 805d383:	3b 4e 08             	cmp    0x8(%esi),%ecx
 805d386:	b9 ff ff ff 0f       	mov    $0xfffffff,%ecx
 805d38b:	1b 4e 0c             	sbb    0xc(%esi),%ecx
 805d38e:	73 0e                	jae    805d39e <http_parser_execute+0x15cb>
				SET_ERRNO(HPE_INVALID_CONTENT_LENGTH);
 805d390:	8a 46 17             	mov    0x17(%esi),%al
 805d393:	83 e0 80             	and    $0xffffff80,%eax
 805d396:	83 c8 19             	or     $0x19,%eax
 805d399:	e9 2d 01 00 00       	jmp    805d4cb <http_parser_execute+0x16f8>
			parser->content_length = t;
 805d39e:	89 46 08             	mov    %eax,0x8(%esi)
 805d3a1:	89 56 0c             	mov    %edx,0xc(%esi)
			break;
 805d3a4:	e9 3a 01 00 00       	jmp    805d4e3 <http_parser_execute+0x1710>
			if (ch == CR) {
 805d3a9:	80 fb 0d             	cmp    $0xd,%bl
 805d3ac:	0f 85 31 01 00 00    	jne    805d4e3 <http_parser_execute+0x1710>
				UPDATE_STATE(s_chunk_size_almost_done);
 805d3b2:	c7 45 c8 36 00 00 00 	movl   $0x36,-0x38(%ebp)
				break;
 805d3b9:	e9 25 01 00 00       	jmp    805d4e3 <http_parser_execute+0x1710>
			if (parser->content_length == 0U) {
 805d3be:	8b 56 0c             	mov    0xc(%esi),%edx
 805d3c1:	0b 56 08             	or     0x8(%esi),%edx
			parser->nread = 0U;
 805d3c4:	c7 46 04 00 00 00 00 	movl   $0x0,0x4(%esi)
			if (parser->content_length == 0U) {
 805d3cb:	b8 39 00 00 00       	mov    $0x39,%eax
 805d3d0:	75 09                	jne    805d3db <http_parser_execute+0x1608>
				parser->flags |= F_TRAILING;
 805d3d2:	66 83 0e 40          	orw    $0x40,(%esi)
				UPDATE_STATE(s_header_field_start);
 805d3d6:	b8 2a 00 00 00       	mov    $0x2a,%eax
 805d3db:	89 45 c8             	mov    %eax,-0x38(%ebp)
			rc = cb_notify(parser, &p_state,
 805d3de:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 805d3e1:	8b 48 20             	mov    0x20(%eax),%ecx
				       p - data + 1);
 805d3e4:	8b 45 b4             	mov    -0x4c(%ebp),%eax
			rc = cb_notify(parser, &p_state,
 805d3e7:	52                   	push   %edx
				       p - data + 1);
 805d3e8:	2b 45 b0             	sub    -0x50(%ebp),%eax
 805d3eb:	40                   	inc    %eax
			rc = cb_notify(parser, &p_state,
 805d3ec:	50                   	push   %eax
 805d3ed:	8d 45 c4             	lea    -0x3c(%ebp),%eax
 805d3f0:	50                   	push   %eax
 805d3f1:	6a 09                	push   $0x9
 805d3f3:	e9 b4 00 00 00       	jmp    805d4ac <http_parser_execute+0x16d9>
			uint64_t to_read = MIN(parser->content_length,
 805d3f8:	8b 4e 08             	mov    0x8(%esi),%ecx
 805d3fb:	8b 5e 0c             	mov    0xc(%esi),%ebx
 805d3fe:	8b 45 9c             	mov    -0x64(%ebp),%eax
 805d401:	2b 45 b4             	sub    -0x4c(%ebp),%eax
 805d404:	99                   	cltd   
 805d405:	89 df                	mov    %ebx,%edi
 805d407:	39 c1                	cmp    %eax,%ecx
 805d409:	19 d7                	sbb    %edx,%edi
 805d40b:	89 cf                	mov    %ecx,%edi
 805d40d:	0f 43 f8             	cmovae %eax,%edi
 805d410:	89 d0                	mov    %edx,%eax
 805d412:	0f 42 c3             	cmovb  %ebx,%eax
			MARK(body);
 805d415:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
			uint64_t to_read = MIN(parser->content_length,
 805d419:	89 7d 88             	mov    %edi,-0x78(%ebp)
 805d41c:	89 45 8c             	mov    %eax,-0x74(%ebp)
			MARK(body);
 805d41f:	75 06                	jne    805d427 <http_parser_execute+0x1654>
 805d421:	8b 45 b4             	mov    -0x4c(%ebp),%eax
 805d424:	89 45 d8             	mov    %eax,-0x28(%ebp)
			p += to_read - 1;
 805d427:	8b 7d 88             	mov    -0x78(%ebp),%edi
			parser->content_length -= to_read;
 805d42a:	89 c8                	mov    %ecx,%eax
 805d42c:	89 da                	mov    %ebx,%edx
 805d42e:	2b 45 88             	sub    -0x78(%ebp),%eax
 805d431:	1b 55 8c             	sbb    -0x74(%ebp),%edx
 805d434:	89 46 08             	mov    %eax,0x8(%esi)
			p += to_read - 1;
 805d437:	8d 4f ff             	lea    -0x1(%edi),%ecx
 805d43a:	01 4d b4             	add    %ecx,-0x4c(%ebp)
			if (parser->content_length == 0U) {
 805d43d:	09 d0                	or     %edx,%eax
			parser->content_length -= to_read;
 805d43f:	89 56 0c             	mov    %edx,0xc(%esi)
			if (parser->content_length == 0U) {
 805d442:	0f 85 9b 00 00 00    	jne    805d4e3 <http_parser_execute+0x1710>
				UPDATE_STATE(s_chunk_data_almost_done);
 805d448:	c7 45 c8 3a 00 00 00 	movl   $0x3a,-0x38(%ebp)
 805d44f:	e9 8f 00 00 00       	jmp    805d4e3 <http_parser_execute+0x1710>
			rc = cb_data(parser, settings->on_body, HPE_CB_body,
 805d454:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 805d457:	83 ec 0c             	sub    $0xc,%esp
 805d45a:	b9 06 00 00 00       	mov    $0x6,%ecx
			UPDATE_STATE(s_chunk_data_done);
 805d45f:	c7 45 c8 3b 00 00 00 	movl   $0x3b,-0x38(%ebp)
			rc = cb_data(parser, settings->on_body, HPE_CB_body,
 805d466:	8b 50 18             	mov    0x18(%eax),%edx
				     p - body_mark);
 805d469:	8b 45 b4             	mov    -0x4c(%ebp),%eax
 805d46c:	2b 45 d8             	sub    -0x28(%ebp),%eax
			rc = cb_data(parser, settings->on_body, HPE_CB_body,
 805d46f:	50                   	push   %eax
 805d470:	8d 45 d8             	lea    -0x28(%ebp),%eax
 805d473:	50                   	push   %eax
				     &p_state, parsed, p - data + 1, &body_mark,
 805d474:	8b 45 b4             	mov    -0x4c(%ebp),%eax
 805d477:	2b 45 b0             	sub    -0x50(%ebp),%eax
 805d47a:	40                   	inc    %eax
			rc = cb_data(parser, settings->on_body, HPE_CB_body,
 805d47b:	50                   	push   %eax
 805d47c:	8d 45 c4             	lea    -0x3c(%ebp),%eax
 805d47f:	50                   	push   %eax
 805d480:	8d 45 c8             	lea    -0x38(%ebp),%eax
 805d483:	50                   	push   %eax
 805d484:	e9 92 ed ff ff       	jmp    805c21b <http_parser_execute+0x448>
			rc = cb_notify(parser, &p_state,
 805d489:	8b 45 a4             	mov    -0x5c(%ebp),%eax
			parser->nread = 0U;
 805d48c:	c7 46 04 00 00 00 00 	movl   $0x0,0x4(%esi)
			UPDATE_STATE(s_chunk_size_start);
 805d493:	c7 45 c8 33 00 00 00 	movl   $0x33,-0x38(%ebp)
			rc = cb_notify(parser, &p_state,
 805d49a:	8b 48 24             	mov    0x24(%eax),%ecx
 805d49d:	50                   	push   %eax
				       p - data + 1);
 805d49e:	8b 45 b4             	mov    -0x4c(%ebp),%eax
 805d4a1:	2b 45 b0             	sub    -0x50(%ebp),%eax
 805d4a4:	40                   	inc    %eax
			rc = cb_notify(parser, &p_state,
 805d4a5:	50                   	push   %eax
 805d4a6:	8d 45 c4             	lea    -0x3c(%ebp),%eax
 805d4a9:	50                   	push   %eax
 805d4aa:	6a 0a                	push   $0xa
 805d4ac:	8d 55 c8             	lea    -0x38(%ebp),%edx
 805d4af:	89 f0                	mov    %esi,%eax
 805d4b1:	e8 d5 e7 ff ff       	call   805bc8b <cb_notify>
 805d4b6:	83 c4 10             	add    $0x10,%esp
			if (rc != 0) {
 805d4b9:	85 c0                	test   %eax,%eax
 805d4bb:	74 26                	je     805d4e3 <http_parser_execute+0x1710>
 805d4bd:	e9 62 01 00 00       	jmp    805d624 <http_parser_execute+0x1851>
			SET_ERRNO(HPE_INVALID_INTERNAL_STATE);
 805d4c2:	8a 46 17             	mov    0x17(%esi),%al
 805d4c5:	83 e0 80             	and    $0xffffff80,%eax
 805d4c8:	83 c8 1d             	or     $0x1d,%eax
 805d4cb:	88 46 17             	mov    %al,0x17(%esi)
			goto error;
 805d4ce:	e9 24 01 00 00       	jmp    805d5f7 <http_parser_execute+0x1824>
				switch (ch) {
 805d4d3:	80 fb 20             	cmp    $0x20,%bl
 805d4d6:	0f 85 64 ec ff ff    	jne    805c140 <http_parser_execute+0x36d>
					UPDATE_STATE(s_res_status_start);
 805d4dc:	c7 45 c8 0f 00 00 00 	movl   $0xf,-0x38(%ebp)
	for (p = data; p != data + len; p++) {
 805d4e3:	ff 45 b4             	incl   -0x4c(%ebp)
 805d4e6:	e9 ec e9 ff ff       	jmp    805bed7 <http_parser_execute+0x104>
	rc = cb_data(parser, settings->on_header_field, HPE_CB_header_field,
 805d4eb:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 805d4ee:	83 ec 0c             	sub    $0xc,%esp
		     &p_state, parsed, p - data, &header_field_mark,
 805d4f1:	2b 7d b0             	sub    -0x50(%ebp),%edi
	rc = cb_data(parser, settings->on_header_field, HPE_CB_header_field,
 805d4f4:	8d 5d c8             	lea    -0x38(%ebp),%ebx
 805d4f7:	b9 03 00 00 00       	mov    $0x3,%ecx
 805d4fc:	8b 50 0c             	mov    0xc(%eax),%edx
		     p - header_field_mark);
 805d4ff:	8b 45 b4             	mov    -0x4c(%ebp),%eax
 805d502:	2b 45 cc             	sub    -0x34(%ebp),%eax
	rc = cb_data(parser, settings->on_header_field, HPE_CB_header_field,
 805d505:	50                   	push   %eax
 805d506:	8d 45 cc             	lea    -0x34(%ebp),%eax
 805d509:	50                   	push   %eax
 805d50a:	8d 45 c4             	lea    -0x3c(%ebp),%eax
 805d50d:	57                   	push   %edi
 805d50e:	50                   	push   %eax
 805d50f:	89 f0                	mov    %esi,%eax
 805d511:	53                   	push   %ebx
 805d512:	e8 de e7 ff ff       	call   805bcf5 <cb_data>
 805d517:	83 c4 20             	add    $0x20,%esp
	if (rc != 0) {
 805d51a:	85 c0                	test   %eax,%eax
 805d51c:	0f 85 02 01 00 00    	jne    805d624 <http_parser_execute+0x1851>
	rc = cb_data(parser, settings->on_header_value, HPE_CB_header_value,
 805d522:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 805d525:	83 ec 0c             	sub    $0xc,%esp
 805d528:	b9 04 00 00 00       	mov    $0x4,%ecx
 805d52d:	8b 50 10             	mov    0x10(%eax),%edx
		     p - header_value_mark);
 805d530:	8b 45 b4             	mov    -0x4c(%ebp),%eax
 805d533:	2b 45 d0             	sub    -0x30(%ebp),%eax
	rc = cb_data(parser, settings->on_header_value, HPE_CB_header_value,
 805d536:	50                   	push   %eax
 805d537:	8d 45 d0             	lea    -0x30(%ebp),%eax
 805d53a:	50                   	push   %eax
 805d53b:	8d 45 c4             	lea    -0x3c(%ebp),%eax
 805d53e:	57                   	push   %edi
 805d53f:	50                   	push   %eax
 805d540:	89 f0                	mov    %esi,%eax
 805d542:	53                   	push   %ebx
 805d543:	e8 ad e7 ff ff       	call   805bcf5 <cb_data>
 805d548:	83 c4 20             	add    $0x20,%esp
	if (rc != 0) {
 805d54b:	85 c0                	test   %eax,%eax
 805d54d:	0f 85 d1 00 00 00    	jne    805d624 <http_parser_execute+0x1851>
	rc = cb_data(parser, settings->on_url, HPE_CB_url, &p_state, parsed,
 805d553:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 805d556:	83 ec 0c             	sub    $0xc,%esp
 805d559:	b9 02 00 00 00       	mov    $0x2,%ecx
 805d55e:	8b 50 04             	mov    0x4(%eax),%edx
		     p - data, &url_mark, p - url_mark);
 805d561:	8b 45 b4             	mov    -0x4c(%ebp),%eax
 805d564:	2b 45 d4             	sub    -0x2c(%ebp),%eax
	rc = cb_data(parser, settings->on_url, HPE_CB_url, &p_state, parsed,
 805d567:	50                   	push   %eax
 805d568:	8d 45 d4             	lea    -0x2c(%ebp),%eax
 805d56b:	50                   	push   %eax
 805d56c:	8d 45 c4             	lea    -0x3c(%ebp),%eax
 805d56f:	57                   	push   %edi
 805d570:	50                   	push   %eax
 805d571:	89 f0                	mov    %esi,%eax
 805d573:	53                   	push   %ebx
 805d574:	e8 7c e7 ff ff       	call   805bcf5 <cb_data>
 805d579:	83 c4 20             	add    $0x20,%esp
	if (rc != 0) {
 805d57c:	85 c0                	test   %eax,%eax
 805d57e:	0f 85 a0 00 00 00    	jne    805d624 <http_parser_execute+0x1851>
	rc = cb_data(parser, settings->on_body, HPE_CB_body, &p_state, parsed,
 805d584:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 805d587:	83 ec 0c             	sub    $0xc,%esp
 805d58a:	b9 06 00 00 00       	mov    $0x6,%ecx
 805d58f:	8b 50 18             	mov    0x18(%eax),%edx
		     p - data, &body_mark, p - body_mark);
 805d592:	8b 45 b4             	mov    -0x4c(%ebp),%eax
 805d595:	2b 45 d8             	sub    -0x28(%ebp),%eax
	rc = cb_data(parser, settings->on_body, HPE_CB_body, &p_state, parsed,
 805d598:	50                   	push   %eax
 805d599:	8d 45 d8             	lea    -0x28(%ebp),%eax
 805d59c:	50                   	push   %eax
 805d59d:	8d 45 c4             	lea    -0x3c(%ebp),%eax
 805d5a0:	57                   	push   %edi
 805d5a1:	50                   	push   %eax
 805d5a2:	89 f0                	mov    %esi,%eax
 805d5a4:	53                   	push   %ebx
 805d5a5:	e8 4b e7 ff ff       	call   805bcf5 <cb_data>
 805d5aa:	83 c4 20             	add    $0x20,%esp
	if (rc != 0) {
 805d5ad:	85 c0                	test   %eax,%eax
 805d5af:	75 73                	jne    805d624 <http_parser_execute+0x1851>
	rc = cb_data(parser, settings->on_status, HPE_CB_status, &p_state,
 805d5b1:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 805d5b4:	83 ec 0c             	sub    $0xc,%esp
 805d5b7:	b9 08 00 00 00       	mov    $0x8,%ecx
 805d5bc:	8b 50 08             	mov    0x8(%eax),%edx
		     parsed, p - data, &status_mark, p - status_mark);
 805d5bf:	8b 45 b4             	mov    -0x4c(%ebp),%eax
 805d5c2:	2b 45 dc             	sub    -0x24(%ebp),%eax
	rc = cb_data(parser, settings->on_status, HPE_CB_status, &p_state,
 805d5c5:	50                   	push   %eax
 805d5c6:	8d 45 dc             	lea    -0x24(%ebp),%eax
 805d5c9:	50                   	push   %eax
 805d5ca:	8d 45 c4             	lea    -0x3c(%ebp),%eax
 805d5cd:	57                   	push   %edi
 805d5ce:	50                   	push   %eax
 805d5cf:	89 f0                	mov    %esi,%eax
 805d5d1:	53                   	push   %ebx
 805d5d2:	e8 1e e7 ff ff       	call   805bcf5 <cb_data>
 805d5d7:	83 c4 20             	add    $0x20,%esp
	if (rc != 0) {
 805d5da:	85 c0                	test   %eax,%eax
 805d5dc:	75 46                	jne    805d624 <http_parser_execute+0x1851>
	parser->state = CURRENT_STATE();
 805d5de:	8b 55 c8             	mov    -0x38(%ebp),%edx
 805d5e1:	8b 06                	mov    (%esi),%eax
 805d5e3:	83 e2 7f             	and    $0x7f,%edx
 805d5e6:	25 ff 03 fe ff       	and    $0xfffe03ff,%eax
 805d5eb:	c1 e2 0a             	shl    $0xa,%edx
 805d5ee:	09 d0                	or     %edx,%eax
 805d5f0:	89 06                	mov    %eax,(%esi)
	*parsed = len;
 805d5f2:	8b 45 14             	mov    0x14(%ebp),%eax
 805d5f5:	eb 2a                	jmp    805d621 <http_parser_execute+0x184e>
	if (HTTP_PARSER_ERRNO(parser) == HPE_OK) {
 805d5f7:	8a 46 17             	mov    0x17(%esi),%al
 805d5fa:	a8 7f                	test   $0x7f,%al
 805d5fc:	75 09                	jne    805d607 <http_parser_execute+0x1834>
		SET_ERRNO(HPE_UNKNOWN);
 805d5fe:	83 e0 80             	and    $0xffffff80,%eax
 805d601:	83 c8 20             	or     $0x20,%eax
 805d604:	88 46 17             	mov    %al,0x17(%esi)
	parser->state = CURRENT_STATE();
 805d607:	8b 55 c8             	mov    -0x38(%ebp),%edx
 805d60a:	8b 06                	mov    (%esi),%eax
 805d60c:	83 e2 7f             	and    $0x7f,%edx
 805d60f:	25 ff 03 fe ff       	and    $0xfffe03ff,%eax
 805d614:	c1 e2 0a             	shl    $0xa,%edx
 805d617:	09 d0                	or     %edx,%eax
 805d619:	89 06                	mov    %eax,(%esi)
	*parsed = p - data; /* Error */
 805d61b:	8b 45 b4             	mov    -0x4c(%ebp),%eax
 805d61e:	2b 45 b0             	sub    -0x50(%ebp),%eax
 805d621:	89 45 c4             	mov    %eax,-0x3c(%ebp)
	return parsed;
 805d624:	8b 45 c4             	mov    -0x3c(%ebp),%eax
}
 805d627:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 805d62a:	65 2b 15 14 00 00 00 	sub    %gs:0x14,%edx
 805d631:	74 38                	je     805d66b <http_parser_execute+0x1898>
 805d633:	e8 c8 bc fe ff       	call   8049300 <__stack_chk_fail@plt>
			h_state = h_general;
 805d638:	c7 45 a8 00 00 00 00 	movl   $0x0,-0x58(%ebp)
 805d63f:	eb 22                	jmp    805d663 <http_parser_execute+0x1890>
			h_state = h_matching_connection_keep_alive;
 805d641:	c7 45 a8 0f 00 00 00 	movl   $0xf,-0x58(%ebp)
 805d648:	eb 19                	jmp    805d663 <http_parser_execute+0x1890>
			h_state = h_matching_connection_close;
 805d64a:	c7 45 a8 10 00 00 00 	movl   $0x10,-0x58(%ebp)
 805d651:	eb 10                	jmp    805d663 <http_parser_execute+0x1890>
			h_state = h_matching_connection_upgrade;
 805d653:	c7 45 a8 11 00 00 00 	movl   $0x11,-0x58(%ebp)
 805d65a:	eb 07                	jmp    805d663 <http_parser_execute+0x1890>
			h_state = h_matching_connection_token;
 805d65c:	c7 45 a8 12 00 00 00 	movl   $0x12,-0x58(%ebp)
			for (; p != data + len; p++) {
 805d663:	ff 45 a0             	incl   -0x60(%ebp)
 805d666:	e9 ae f4 ff ff       	jmp    805cb19 <http_parser_execute+0xd46>
}
 805d66b:	8d 65 f4             	lea    -0xc(%ebp),%esp
 805d66e:	5b                   	pop    %ebx
 805d66f:	5e                   	pop    %esi
 805d670:	5f                   	pop    %edi
 805d671:	5d                   	pop    %ebp
 805d672:	c3                   	ret    

0805d673 <http_method_str>:
	return !http_message_needs_eof(parser);
}


const char *http_method_str(enum http_method m)
{
 805d673:	55                   	push   %ebp
 805d674:	b8 17 36 06 08       	mov    $0x8063617,%eax
 805d679:	89 e5                	mov    %esp,%ebp
 805d67b:	8b 55 08             	mov    0x8(%ebp),%edx
	return ELEM_AT(method_strings, m, "<unknown>");
 805d67e:	83 fa 20             	cmp    $0x20,%edx
 805d681:	77 07                	ja     805d68a <http_method_str+0x17>
 805d683:	8b 04 95 40 22 06 08 	mov    0x8062240(,%edx,4),%eax
}
 805d68a:	5d                   	pop    %ebp
 805d68b:	c3                   	ret    

0805d68c <http_parser_init>:


void http_parser_init(struct http_parser *parser, enum http_parser_type t)
{
 805d68c:	55                   	push   %ebp
  return __builtin___memset_chk (__dest, __ch, __len,
 805d68d:	31 c0                	xor    %eax,%eax
 805d68f:	b9 08 00 00 00       	mov    $0x8,%ecx
 805d694:	89 e5                	mov    %esp,%ebp
 805d696:	57                   	push   %edi
 805d697:	8b 55 08             	mov    0x8(%ebp),%edx
 805d69a:	56                   	push   %esi
 805d69b:	53                   	push   %ebx
 805d69c:	8b 5d 0c             	mov    0xc(%ebp),%ebx
 805d69f:	89 d7                	mov    %edx,%edi
	void *data = parser->data; /* preserve application data */
 805d6a1:	8b 72 18             	mov    0x18(%edx),%esi
 805d6a4:	f3 ab                	rep stos %eax,%es:(%edi)

	(void)memset(parser, 0, sizeof(*parser));
	parser->data = data;
	parser->type = t;
 805d6a6:	89 d8                	mov    %ebx,%eax
 805d6a8:	83 e0 03             	and    $0x3,%eax
	parser->data = data;
 805d6ab:	89 72 18             	mov    %esi,0x18(%edx)
	parser->type = t;
 805d6ae:	88 02                	mov    %al,(%edx)
	parser->state =
 805d6b0:	b0 12                	mov    $0x12,%al
		(t == HTTP_REQUEST ? s_start_req :
 805d6b2:	85 db                	test   %ebx,%ebx
 805d6b4:	74 08                	je     805d6be <http_parser_init+0x32>
 805d6b6:	4b                   	dec    %ebx
 805d6b7:	0f 94 c0             	sete   %al
 805d6ba:	8d 44 00 02          	lea    0x2(%eax,%eax,1),%eax
	parser->state =
 805d6be:	8b 0a                	mov    (%edx),%ecx
 805d6c0:	0f b6 c0             	movzbl %al,%eax
 805d6c3:	c1 e0 0a             	shl    $0xa,%eax
 805d6c6:	81 e1 ff 03 fe ff    	and    $0xfffe03ff,%ecx
 805d6cc:	09 c8                	or     %ecx,%eax
 805d6ce:	89 02                	mov    %eax,(%edx)
		 (t == HTTP_RESPONSE ? s_start_res : s_start_req_or_res));
	parser->http_errno = HPE_OK;
}
 805d6d0:	5b                   	pop    %ebx
 805d6d1:	5e                   	pop    %esi
 805d6d2:	5f                   	pop    %edi
 805d6d3:	5d                   	pop    %ebp
 805d6d4:	c3                   	ret    

0805d6d5 <parse_url_char>:
 * This function should only be invoked with non-space characters. It is
 * assumed that the caller cares about (and can detect) the transition between
 * URL and non-URL states by looking for these.
 */
enum state parse_url_char(enum state s, const char ch)
{
 805d6d5:	55                   	push   %ebp
 805d6d6:	89 e5                	mov    %esp,%ebp
 805d6d8:	57                   	push   %edi
 805d6d9:	8b 55 0c             	mov    0xc(%ebp),%edx
 805d6dc:	8b 45 08             	mov    0x8(%ebp),%eax
 805d6df:	56                   	push   %esi
 805d6e0:	53                   	push   %ebx
 805d6e1:	8d 4a f6             	lea    -0xa(%edx),%ecx
 805d6e4:	80 f9 16             	cmp    $0x16,%cl
 805d6e7:	77 10                	ja     805d6f9 <parse_url_char+0x24>
 805d6e9:	bb 09 00 40 00       	mov    $0x400009,%ebx
 805d6ee:	d3 eb                	shr    %cl,%ebx
 805d6f0:	80 e3 01             	and    $0x1,%bl
 805d6f3:	0f 85 23 02 00 00    	jne    805d91c <parse_url_char+0x247>
	if (ch == '\t' || ch == '\f') {
		return s_dead;
	}
#endif

	switch (s) {
 805d6f9:	8d 48 ec             	lea    -0x14(%eax),%ecx
 805d6fc:	83 f9 0b             	cmp    $0xb,%ecx
 805d6ff:	0f 87 17 02 00 00    	ja     805d91c <parse_url_char+0x247>
 805d705:	ff 24 8d c4 26 06 08 	jmp    *0x80626c4(,%ecx,4)
		/* Proxied requests are followed by scheme of an absolute URI
		 * (alpha).
		 * All methods except CONNECT are followed by '/' or '*'.
		 */

		if (ch == '/' || ch == '*') {
 805d70c:	80 fa 2f             	cmp    $0x2f,%dl
 805d70f:	0f 84 0e 02 00 00    	je     805d923 <parse_url_char+0x24e>
 805d715:	80 fa 2a             	cmp    $0x2a,%dl
 805d718:	0f 84 05 02 00 00    	je     805d923 <parse_url_char+0x24e>
			return s_req_path;
		}

		if (IS_ALPHA(ch)) {
 805d71e:	83 ca 20             	or     $0x20,%edx
 805d721:	83 ea 61             	sub    $0x61,%edx
			return s_req_schema;
 805d724:	80 fa 1a             	cmp    $0x1a,%dl
 805d727:	19 c0                	sbb    %eax,%eax
 805d729:	83 e0 14             	and    $0x14,%eax
 805d72c:	40                   	inc    %eax
 805d72d:	e9 04 02 00 00       	jmp    805d936 <parse_url_char+0x261>
		}

		break;

	case s_req_schema:
		if (IS_ALPHA(ch)) {
 805d732:	89 d1                	mov    %edx,%ecx
 805d734:	83 c9 20             	or     $0x20,%ecx
 805d737:	83 e9 61             	sub    $0x61,%ecx
 805d73a:	80 f9 19             	cmp    $0x19,%cl
 805d73d:	0f 86 f3 01 00 00    	jbe    805d936 <parse_url_char+0x261>
			return s;
		}

		if (ch == ':') {
			return s_req_schema_slash;
 805d743:	80 fa 3a             	cmp    $0x3a,%dl
 805d746:	b8 01 00 00 00       	mov    $0x1,%eax
 805d74b:	ba 16 00 00 00       	mov    $0x16,%edx
 805d750:	e9 c9 00 00 00       	jmp    805d81e <parse_url_char+0x149>

		break;

	case s_req_schema_slash:
		if (ch == '/') {
			return s_req_schema_slash_slash;
 805d755:	80 fa 2f             	cmp    $0x2f,%dl
 805d758:	b8 01 00 00 00       	mov    $0x1,%eax
 805d75d:	ba 17 00 00 00       	mov    $0x17,%edx
 805d762:	e9 b7 00 00 00       	jmp    805d81e <parse_url_char+0x149>

		break;

	case s_req_schema_slash_slash:
		if (ch == '/') {
			return s_req_server_start;
 805d767:	80 fa 2f             	cmp    $0x2f,%dl
 805d76a:	b8 01 00 00 00       	mov    $0x1,%eax
 805d76f:	ba 18 00 00 00       	mov    $0x18,%edx
 805d774:	e9 a5 00 00 00       	jmp    805d81e <parse_url_char+0x149>

		break;

	case s_req_server_with_at:
		if (ch == '@') {
			return s_dead;
 805d779:	b8 01 00 00 00       	mov    $0x1,%eax
		if (ch == '@') {
 805d77e:	80 fa 40             	cmp    $0x40,%dl
 805d781:	0f 84 af 01 00 00    	je     805d936 <parse_url_char+0x261>
			return s_req_path;
 805d787:	b8 1b 00 00 00       	mov    $0x1b,%eax
		}

		__fallthrough;
	case s_req_server_start:
	case s_req_server:
		if (ch == '/') {
 805d78c:	80 fa 2f             	cmp    $0x2f,%dl
 805d78f:	0f 84 a1 01 00 00    	je     805d936 <parse_url_char+0x261>
			return s_req_path;
		}

		if (ch == '?') {
			return s_req_query_string_start;
 805d795:	b8 1c 00 00 00       	mov    $0x1c,%eax
		if (ch == '?') {
 805d79a:	80 fa 3f             	cmp    $0x3f,%dl
 805d79d:	0f 84 93 01 00 00    	je     805d936 <parse_url_char+0x261>
		}

		if (ch == '@') {
			return s_req_server_with_at;
 805d7a3:	b8 1a 00 00 00       	mov    $0x1a,%eax
		if (ch == '@') {
 805d7a8:	80 fa 40             	cmp    $0x40,%dl
 805d7ab:	0f 84 85 01 00 00    	je     805d936 <parse_url_char+0x261>
		}

		if (IS_USERINFO_CHAR(ch) || ch == '[' || ch == ']') {
 805d7b1:	89 d1                	mov    %edx,%ecx
			return s_req_server;
 805d7b3:	b8 19 00 00 00       	mov    $0x19,%eax
		if (IS_USERINFO_CHAR(ch) || ch == '[' || ch == ']') {
 805d7b8:	83 c9 20             	or     $0x20,%ecx
 805d7bb:	83 e9 61             	sub    $0x61,%ecx
 805d7be:	80 f9 19             	cmp    $0x19,%cl
 805d7c1:	0f 86 6f 01 00 00    	jbe    805d936 <parse_url_char+0x261>
 805d7c7:	8d 4a d0             	lea    -0x30(%edx),%ecx
 805d7ca:	80 f9 09             	cmp    $0x9,%cl
 805d7cd:	0f 86 63 01 00 00    	jbe    805d936 <parse_url_char+0x261>
 805d7d3:	80 fa 5f             	cmp    $0x5f,%dl
 805d7d6:	7f 39                	jg     805d811 <parse_url_char+0x13c>
 805d7d8:	80 fa 5a             	cmp    $0x5a,%dl
 805d7db:	7f 18                	jg     805d7f5 <parse_url_char+0x120>
 805d7dd:	8d 4a df             	lea    -0x21(%edx),%ecx
	}

	/* We should never fall out of the switch above unless there's
	 * an error
	 */
	return s_dead;
 805d7e0:	b8 01 00 00 00       	mov    $0x1,%eax
 805d7e5:	80 f9 1c             	cmp    $0x1c,%cl
 805d7e8:	0f 87 48 01 00 00    	ja     805d936 <parse_url_char+0x261>
 805d7ee:	b8 f9 3f 00 16       	mov    $0x16003ff9,%eax
 805d7f3:	eb 08                	jmp    805d7fd <parse_url_char+0x128>
 805d7f5:	8d 4a a5             	lea    -0x5b(%edx),%ecx
 805d7f8:	b8 15 00 00 00       	mov    $0x15,%eax
 805d7fd:	d3 e8                	shr    %cl,%eax
 805d7ff:	83 e0 01             	and    $0x1,%eax
		if (IS_USERINFO_CHAR(ch) || ch == '[' || ch == ']') {
 805d802:	3c 01                	cmp    $0x1,%al
 805d804:	19 c0                	sbb    %eax,%eax
 805d806:	83 e0 e8             	and    $0xffffffe8,%eax
 805d809:	83 c0 19             	add    $0x19,%eax
 805d80c:	e9 25 01 00 00       	jmp    805d936 <parse_url_char+0x261>
 805d811:	80 fa 7e             	cmp    $0x7e,%dl
 805d814:	b8 01 00 00 00       	mov    $0x1,%eax
 805d819:	ba 19 00 00 00       	mov    $0x19,%edx
 805d81e:	0f 44 c2             	cmove  %edx,%eax
 805d821:	e9 10 01 00 00       	jmp    805d936 <parse_url_char+0x261>
		if (IS_URL_CHAR(ch)) {
 805d826:	89 d1                	mov    %edx,%ecx
 805d828:	bb 01 00 00 00       	mov    $0x1,%ebx
 805d82d:	c0 e9 03             	shr    $0x3,%cl
 805d830:	89 df                	mov    %ebx,%edi
 805d832:	0f b6 c9             	movzbl %cl,%ecx
 805d835:	0f b6 b1 e0 22 06 08 	movzbl 0x80622e0(%ecx),%esi
 805d83c:	89 d1                	mov    %edx,%ecx
 805d83e:	83 e1 07             	and    $0x7,%ecx
 805d841:	d3 e7                	shl    %cl,%edi
 805d843:	85 fe                	test   %edi,%esi
 805d845:	0f 85 eb 00 00 00    	jne    805d936 <parse_url_char+0x261>
 805d84b:	84 d2                	test   %dl,%dl
 805d84d:	0f 88 e3 00 00 00    	js     805d936 <parse_url_char+0x261>
			return s_req_fragment_start;
 805d853:	b8 1e 00 00 00       	mov    $0x1e,%eax
 805d858:	80 fa 23             	cmp    $0x23,%dl
 805d85b:	0f 84 d5 00 00 00    	je     805d936 <parse_url_char+0x261>
 805d861:	80 fa 3f             	cmp    $0x3f,%dl
 805d864:	b8 1c 00 00 00       	mov    $0x1c,%eax
 805d869:	eb 43                	jmp    805d8ae <parse_url_char+0x1d9>
		if (IS_URL_CHAR(ch)) {
 805d86b:	89 d0                	mov    %edx,%eax
 805d86d:	89 d1                	mov    %edx,%ecx
 805d86f:	bb 01 00 00 00       	mov    $0x1,%ebx
 805d874:	c0 e8 03             	shr    $0x3,%al
 805d877:	83 e1 07             	and    $0x7,%ecx
 805d87a:	0f b6 c0             	movzbl %al,%eax
 805d87d:	0f b6 b0 e0 22 06 08 	movzbl 0x80622e0(%eax),%esi
 805d884:	89 d8                	mov    %ebx,%eax
 805d886:	d3 e0                	shl    %cl,%eax
 805d888:	85 c6                	test   %eax,%esi
 805d88a:	0f 85 9a 00 00 00    	jne    805d92a <parse_url_char+0x255>
 805d890:	84 d2                	test   %dl,%dl
 805d892:	0f 88 92 00 00 00    	js     805d92a <parse_url_char+0x255>
			return s_req_fragment_start;
 805d898:	b8 1e 00 00 00       	mov    $0x1e,%eax
 805d89d:	80 fa 23             	cmp    $0x23,%dl
 805d8a0:	0f 84 90 00 00 00    	je     805d936 <parse_url_char+0x261>
 805d8a6:	80 fa 3f             	cmp    $0x3f,%dl
 805d8a9:	b8 1d 00 00 00       	mov    $0x1d,%eax
 805d8ae:	0f 45 c3             	cmovne %ebx,%eax
 805d8b1:	e9 80 00 00 00       	jmp    805d936 <parse_url_char+0x261>
		if (IS_URL_CHAR(ch)) {
 805d8b6:	89 d1                	mov    %edx,%ecx
 805d8b8:	bb 01 00 00 00       	mov    $0x1,%ebx
 805d8bd:	c0 e9 03             	shr    $0x3,%cl
 805d8c0:	89 df                	mov    %ebx,%edi
 805d8c2:	0f b6 c9             	movzbl %cl,%ecx
 805d8c5:	0f b6 b1 e0 22 06 08 	movzbl 0x80622e0(%ecx),%esi
 805d8cc:	89 d1                	mov    %edx,%ecx
 805d8ce:	83 e1 07             	and    $0x7,%ecx
 805d8d1:	d3 e7                	shl    %cl,%edi
 805d8d3:	85 fe                	test   %edi,%esi
 805d8d5:	75 5a                	jne    805d931 <parse_url_char+0x25c>
 805d8d7:	84 d2                	test   %dl,%dl
 805d8d9:	78 56                	js     805d931 <parse_url_char+0x25c>
		switch (ch) {
 805d8db:	80 fa 23             	cmp    $0x23,%dl
 805d8de:	74 56                	je     805d936 <parse_url_char+0x261>
			return s_req_fragment;
 805d8e0:	80 fa 3f             	cmp    $0x3f,%dl
 805d8e3:	b8 1f 00 00 00       	mov    $0x1f,%eax
 805d8e8:	eb c4                	jmp    805d8ae <parse_url_char+0x1d9>
		if (IS_URL_CHAR(ch)) {
 805d8ea:	89 d1                	mov    %edx,%ecx
 805d8ec:	bb 01 00 00 00       	mov    $0x1,%ebx
 805d8f1:	c0 e9 03             	shr    $0x3,%cl
 805d8f4:	89 df                	mov    %ebx,%edi
 805d8f6:	0f b6 c9             	movzbl %cl,%ecx
 805d8f9:	0f b6 b1 e0 22 06 08 	movzbl 0x80622e0(%ecx),%esi
 805d900:	89 d1                	mov    %edx,%ecx
 805d902:	83 e1 07             	and    $0x7,%ecx
 805d905:	d3 e7                	shl    %cl,%edi
 805d907:	85 fe                	test   %edi,%esi
 805d909:	75 2b                	jne    805d936 <parse_url_char+0x261>
 805d90b:	84 d2                	test   %dl,%dl
 805d90d:	78 27                	js     805d936 <parse_url_char+0x261>
		switch (ch) {
 805d90f:	80 fa 23             	cmp    $0x23,%dl
 805d912:	74 22                	je     805d936 <parse_url_char+0x261>
 805d914:	80 fa 3f             	cmp    $0x3f,%dl
 805d917:	0f 45 c3             	cmovne %ebx,%eax
 805d91a:	eb 1a                	jmp    805d936 <parse_url_char+0x261>
	switch (s) {
 805d91c:	b8 01 00 00 00       	mov    $0x1,%eax
 805d921:	eb 13                	jmp    805d936 <parse_url_char+0x261>
			return s_req_path;
 805d923:	b8 1b 00 00 00       	mov    $0x1b,%eax
 805d928:	eb 0c                	jmp    805d936 <parse_url_char+0x261>
			return s_req_query_string;
 805d92a:	b8 1d 00 00 00       	mov    $0x1d,%eax
 805d92f:	eb 05                	jmp    805d936 <parse_url_char+0x261>
			return s_req_fragment;
 805d931:	b8 1f 00 00 00       	mov    $0x1f,%eax
}
 805d936:	5b                   	pop    %ebx
 805d937:	5e                   	pop    %esi
 805d938:	5f                   	pop    %edi
 805d939:	5d                   	pop    %ebp
 805d93a:	c3                   	ret    

0805d93b <on_url>:
		NET_DBG("[%zd] %s", len, output);
	}
}

static int on_url(struct http_parser *parser, const char *at, size_t length)
{
 805d93b:	55                   	push   %ebp
 805d93c:	89 e5                	mov    %esp,%ebp
 805d93e:	83 ec 08             	sub    $0x8,%esp
 805d941:	8b 55 08             	mov    0x8(%ebp),%edx
	struct http_request *req = CONTAINER_OF(parser,
						struct http_request,
						internal.parser);
	print_header_field(length, at);

	if (req->internal.response.http_cb &&
 805d944:	8b 42 48             	mov    0x48(%edx),%eax
 805d947:	85 c0                	test   %eax,%eax
 805d949:	74 14                	je     805d95f <on_url+0x24>
	    req->internal.response.http_cb->on_url) {
 805d94b:	8b 40 04             	mov    0x4(%eax),%eax
	if (req->internal.response.http_cb &&
 805d94e:	85 c0                	test   %eax,%eax
 805d950:	74 0d                	je     805d95f <on_url+0x24>
		req->internal.response.http_cb->on_url(parser, at, length);
 805d952:	51                   	push   %ecx
 805d953:	ff 75 10             	push   0x10(%ebp)
 805d956:	ff 75 0c             	push   0xc(%ebp)
 805d959:	52                   	push   %edx
 805d95a:	ff d0                	call   *%eax
 805d95c:	83 c4 10             	add    $0x10,%esp
	}

	return 0;
}
 805d95f:	c9                   	leave  
 805d960:	31 c0                	xor    %eax,%eax
 805d962:	c3                   	ret    

0805d963 <on_body>:

	return 0;
}

static int on_body(struct http_parser *parser, const char *at, size_t length)
{
 805d963:	55                   	push   %ebp
 805d964:	89 e5                	mov    %esp,%ebp
 805d966:	56                   	push   %esi
 805d967:	8b 55 10             	mov    0x10(%ebp),%edx
 805d96a:	8b 75 0c             	mov    0xc(%ebp),%esi
 805d96d:	53                   	push   %ebx
 805d96e:	8b 5d 08             	mov    0x8(%ebp),%ebx
	req->internal.response.processed += length;

	NET_DBG("Processed %zd length %zd", req->internal.response.processed,
		length);

	if (req->internal.response.http_cb &&
 805d971:	8b 43 48             	mov    0x48(%ebx),%eax
	req->internal.response.body_found = 1;
 805d974:	80 8b 8e 00 00 00 02 	orb    $0x2,0x8e(%ebx)
	req->internal.response.processed += length;
 805d97b:	01 53 68             	add    %edx,0x68(%ebx)
	if (req->internal.response.http_cb &&
 805d97e:	85 c0                	test   %eax,%eax
 805d980:	74 10                	je     805d992 <on_body+0x2f>
	    req->internal.response.http_cb->on_body) {
 805d982:	8b 40 18             	mov    0x18(%eax),%eax
	if (req->internal.response.http_cb &&
 805d985:	85 c0                	test   %eax,%eax
 805d987:	74 09                	je     805d992 <on_body+0x2f>
		req->internal.response.http_cb->on_body(parser, at, length);
 805d989:	51                   	push   %ecx
 805d98a:	52                   	push   %edx
 805d98b:	56                   	push   %esi
 805d98c:	53                   	push   %ebx
 805d98d:	ff d0                	call   *%eax
 805d98f:	83 c4 10             	add    $0x10,%esp
	}

	/* Reset the body_frag_start pointer for each fragment. */
	if (!req->internal.response.body_frag_start) {
 805d992:	83 7b 50 00          	cmpl   $0x0,0x50(%ebx)
 805d996:	75 03                	jne    805d99b <on_body+0x38>
		req->internal.response.body_frag_start = (uint8_t *)at;
 805d998:	89 73 50             	mov    %esi,0x50(%ebx)
	}

	/* Calculate the length of the body contained in the recv_buf */
	req->internal.response.body_frag_len = req->internal.response.data_len -
 805d99b:	8b 43 60             	mov    0x60(%ebx),%eax
		(req->internal.response.body_frag_start - req->internal.response.recv_buf);
 805d99e:	8b 53 50             	mov    0x50(%ebx),%edx
 805d9a1:	2b 53 58             	sub    0x58(%ebx),%edx
	req->internal.response.body_frag_len = req->internal.response.data_len -
 805d9a4:	29 d0                	sub    %edx,%eax
 805d9a6:	89 43 54             	mov    %eax,0x54(%ebx)

	return 0;
}
 805d9a9:	8d 65 f8             	lea    -0x8(%ebp),%esp
 805d9ac:	31 c0                	xor    %eax,%eax
 805d9ae:	5b                   	pop    %ebx
 805d9af:	5e                   	pop    %esi
 805d9b0:	5d                   	pop    %ebp
 805d9b1:	c3                   	ret    

0805d9b2 <on_message_begin>:

	return 0;
}

static int on_message_begin(struct http_parser *parser)
{
 805d9b2:	55                   	push   %ebp
 805d9b3:	89 e5                	mov    %esp,%ebp
 805d9b5:	83 ec 08             	sub    $0x8,%esp
 805d9b8:	8b 55 08             	mov    0x8(%ebp),%edx
	struct http_request *req = CONTAINER_OF(parser,
						struct http_request,
						internal.parser);

	if (req->internal.response.http_cb &&
 805d9bb:	8b 42 48             	mov    0x48(%edx),%eax
 805d9be:	85 c0                	test   %eax,%eax
 805d9c0:	74 0f                	je     805d9d1 <on_message_begin+0x1f>
	    req->internal.response.http_cb->on_message_begin) {
 805d9c2:	8b 00                	mov    (%eax),%eax
	if (req->internal.response.http_cb &&
 805d9c4:	85 c0                	test   %eax,%eax
 805d9c6:	74 09                	je     805d9d1 <on_message_begin+0x1f>
		req->internal.response.http_cb->on_message_begin(parser);
 805d9c8:	83 ec 0c             	sub    $0xc,%esp
 805d9cb:	52                   	push   %edx
 805d9cc:	ff d0                	call   *%eax
 805d9ce:	83 c4 10             	add    $0x10,%esp

	NET_DBG("-- HTTP %s response (headers) --",
		http_method_str(req->method));

	return 0;
}
 805d9d1:	c9                   	leave  
 805d9d2:	31 c0                	xor    %eax,%eax
 805d9d4:	c3                   	ret    

0805d9d5 <on_message_complete>:

static int on_message_complete(struct http_parser *parser)
{
 805d9d5:	55                   	push   %ebp
 805d9d6:	89 e5                	mov    %esp,%ebp
 805d9d8:	53                   	push   %ebx
 805d9d9:	50                   	push   %eax
 805d9da:	8b 5d 08             	mov    0x8(%ebp),%ebx
	struct http_request *req = CONTAINER_OF(parser,
						struct http_request,
						internal.parser);

	if (req->internal.response.http_cb &&
 805d9dd:	8b 43 48             	mov    0x48(%ebx),%eax
 805d9e0:	85 c0                	test   %eax,%eax
 805d9e2:	74 10                	je     805d9f4 <on_message_complete+0x1f>
	    req->internal.response.http_cb->on_message_complete) {
 805d9e4:	8b 40 1c             	mov    0x1c(%eax),%eax
	if (req->internal.response.http_cb &&
 805d9e7:	85 c0                	test   %eax,%eax
 805d9e9:	74 09                	je     805d9f4 <on_message_complete+0x1f>
		req->internal.response.http_cb->on_message_complete(parser);
 805d9eb:	83 ec 0c             	sub    $0xc,%esp
 805d9ee:	53                   	push   %ebx
 805d9ef:	ff d0                	call   *%eax
 805d9f1:	83 c4 10             	add    $0x10,%esp
	}

	NET_DBG("-- HTTP %s response (complete) --",
		http_method_str(req->method));

	req->internal.response.message_complete = 1;
 805d9f4:	80 8b 8e 00 00 00 04 	orb    $0x4,0x8e(%ebx)

	return 0;
}
 805d9fb:	31 c0                	xor    %eax,%eax
 805d9fd:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 805da00:	c9                   	leave  
 805da01:	c3                   	ret    

0805da02 <on_chunk_header>:

static int on_chunk_header(struct http_parser *parser)
{
 805da02:	55                   	push   %ebp
 805da03:	89 e5                	mov    %esp,%ebp
 805da05:	83 ec 08             	sub    $0x8,%esp
 805da08:	8b 55 08             	mov    0x8(%ebp),%edx
	struct http_request *req = CONTAINER_OF(parser,
						struct http_request,
						internal.parser);

	if (req->internal.response.http_cb &&
 805da0b:	8b 42 48             	mov    0x48(%edx),%eax
 805da0e:	85 c0                	test   %eax,%eax
 805da10:	74 10                	je     805da22 <on_chunk_header+0x20>
	    req->internal.response.http_cb->on_chunk_header) {
 805da12:	8b 40 20             	mov    0x20(%eax),%eax
	if (req->internal.response.http_cb &&
 805da15:	85 c0                	test   %eax,%eax
 805da17:	74 09                	je     805da22 <on_chunk_header+0x20>
		req->internal.response.http_cb->on_chunk_header(parser);
 805da19:	83 ec 0c             	sub    $0xc,%esp
 805da1c:	52                   	push   %edx
 805da1d:	ff d0                	call   *%eax
 805da1f:	83 c4 10             	add    $0x10,%esp
	}

	return 0;
}
 805da22:	c9                   	leave  
 805da23:	31 c0                	xor    %eax,%eax
 805da25:	c3                   	ret    

0805da26 <on_chunk_complete>:

static int on_chunk_complete(struct http_parser *parser)
{
 805da26:	55                   	push   %ebp
 805da27:	89 e5                	mov    %esp,%ebp
 805da29:	83 ec 08             	sub    $0x8,%esp
 805da2c:	8b 55 08             	mov    0x8(%ebp),%edx
	struct http_request *req = CONTAINER_OF(parser,
						struct http_request,
						internal.parser);

	if (req->internal.response.http_cb &&
 805da2f:	8b 42 48             	mov    0x48(%edx),%eax
 805da32:	85 c0                	test   %eax,%eax
 805da34:	74 10                	je     805da46 <on_chunk_complete+0x20>
	    req->internal.response.http_cb->on_chunk_complete) {
 805da36:	8b 40 24             	mov    0x24(%eax),%eax
	if (req->internal.response.http_cb &&
 805da39:	85 c0                	test   %eax,%eax
 805da3b:	74 09                	je     805da46 <on_chunk_complete+0x20>
		req->internal.response.http_cb->on_chunk_complete(parser);
 805da3d:	83 ec 0c             	sub    $0xc,%esp
 805da40:	52                   	push   %edx
 805da41:	ff d0                	call   *%eax
 805da43:	83 c4 10             	add    $0x10,%esp
	}

	return 0;
}
 805da46:	c9                   	leave  
 805da47:	31 c0                	xor    %eax,%eax
 805da49:	c3                   	ret    

0805da4a <on_status>:
{
 805da4a:	55                   	push   %ebp
	len = MIN(length, sizeof(req->internal.response.http_status) - 1);
 805da4b:	b8 1f 00 00 00       	mov    $0x1f,%eax
{
 805da50:	89 e5                	mov    %esp,%ebp
 805da52:	57                   	push   %edi
 805da53:	56                   	push   %esi
 805da54:	53                   	push   %ebx
 805da55:	83 ec 0c             	sub    $0xc,%esp
 805da58:	8b 55 08             	mov    0x8(%ebp),%edx
	len = MIN(length, sizeof(req->internal.response.http_status) - 1);
 805da5b:	39 45 10             	cmp    %eax,0x10(%ebp)
 805da5e:	0f 46 45 10          	cmovbe 0x10(%ebp),%eax
  return __builtin___memcpy_chk (__dest, __src, __len,
 805da62:	8b 75 0c             	mov    0xc(%ebp),%esi
 805da65:	89 c3                	mov    %eax,%ebx
 805da67:	8d 42 6c             	lea    0x6c(%edx),%eax
 805da6a:	89 c7                	mov    %eax,%edi
 805da6c:	89 d9                	mov    %ebx,%ecx
 805da6e:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
	req->internal.response.http_status[len] = 0;
 805da70:	c6 44 1a 6c 00       	movb   $0x0,0x6c(%edx,%ebx,1)
	req->internal.response.http_status_code =
 805da75:	8b 42 14             	mov    0x14(%edx),%eax
 805da78:	66 89 82 8c 00 00 00 	mov    %ax,0x8c(%edx)
	if (req->internal.response.http_cb &&
 805da7f:	8b 42 48             	mov    0x48(%edx),%eax
 805da82:	85 c0                	test   %eax,%eax
 805da84:	74 14                	je     805da9a <on_status+0x50>
	    req->internal.response.http_cb->on_status) {
 805da86:	8b 40 08             	mov    0x8(%eax),%eax
	if (req->internal.response.http_cb &&
 805da89:	85 c0                	test   %eax,%eax
 805da8b:	74 0d                	je     805da9a <on_status+0x50>
		req->internal.response.http_cb->on_status(parser, at, length);
 805da8d:	51                   	push   %ecx
 805da8e:	ff 75 10             	push   0x10(%ebp)
 805da91:	ff 75 0c             	push   0xc(%ebp)
 805da94:	52                   	push   %edx
 805da95:	ff d0                	call   *%eax
 805da97:	83 c4 10             	add    $0x10,%esp
}
 805da9a:	8d 65 f4             	lea    -0xc(%ebp),%esp
 805da9d:	31 c0                	xor    %eax,%eax
 805da9f:	5b                   	pop    %ebx
 805daa0:	5e                   	pop    %esi
 805daa1:	5f                   	pop    %edi
 805daa2:	5d                   	pop    %ebp
 805daa3:	c3                   	ret    

0805daa4 <on_header_value>:
{
 805daa4:	55                   	push   %ebp
 805daa5:	89 e5                	mov    %esp,%ebp
 805daa7:	57                   	push   %edi
 805daa8:	56                   	push   %esi
 805daa9:	53                   	push   %ebx
 805daaa:	83 ec 2c             	sub    $0x2c,%esp
 805daad:	8b 5d 08             	mov    0x8(%ebp),%ebx
 805dab0:	8b 7d 0c             	mov    0xc(%ebp),%edi
 805dab3:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 805dab9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 805dabc:	31 c0                	xor    %eax,%eax
 805dabe:	8b 75 10             	mov    0x10(%ebp),%esi
	if (req->internal.response.cl_present) {
 805dac1:	f6 83 8e 00 00 00 01 	testb  $0x1,0x8e(%ebx)
 805dac8:	74 46                	je     805db10 <on_header_value+0x6c>
		if (length <= MAX_NUM_DIGITS - 1) {
 805daca:	83 fe 0f             	cmp    $0xf,%esi
 805dacd:	77 3a                	ja     805db09 <on_header_value+0x65>
 805dacf:	8d 55 d4             	lea    -0x2c(%ebp),%edx
 805dad2:	6a 10                	push   $0x10
 805dad4:	56                   	push   %esi
 805dad5:	57                   	push   %edi
 805dad6:	52                   	push   %edx
 805dad7:	e8 64 b6 fe ff       	call   8049140 <__memcpy_chk@plt>
 805dadc:	83 c4 0c             	add    $0xc,%esp
			num = strtol(str, NULL, 10);
 805dadf:	8d 55 d4             	lea    -0x2c(%ebp),%edx
			str[length] = 0;
 805dae2:	c6 44 35 d4 00       	movb   $0x0,-0x2c(%ebp,%esi,1)
			num = strtol(str, NULL, 10);
 805dae7:	6a 0a                	push   $0xa
 805dae9:	6a 00                	push   $0x0
 805daeb:	52                   	push   %edx
 805daec:	e8 8f b6 fe ff       	call   8049180 <strtol@plt>
 805daf1:	83 c4 10             	add    $0x10,%esp
			if (num == LONG_MIN || num == LONG_MAX) {
 805daf4:	8d 88 ff ff ff 7f    	lea    0x7fffffff(%eax),%ecx
			num = strtol(str, NULL, 10);
 805dafa:	89 c2                	mov    %eax,%edx
				return -EINVAL;
 805dafc:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
			if (num == LONG_MIN || num == LONG_MAX) {
 805db01:	83 f9 fd             	cmp    $0xfffffffd,%ecx
 805db04:	77 25                	ja     805db2b <on_header_value+0x87>
			req->internal.response.content_length = num;
 805db06:	89 53 64             	mov    %edx,0x64(%ebx)
		req->internal.response.cl_present = false;
 805db09:	80 a3 8e 00 00 00 fe 	andb   $0xfe,0x8e(%ebx)
	if (req->internal.response.http_cb &&
 805db10:	8b 53 48             	mov    0x48(%ebx),%edx
	return 0;
 805db13:	31 c0                	xor    %eax,%eax
	if (req->internal.response.http_cb &&
 805db15:	85 d2                	test   %edx,%edx
 805db17:	74 12                	je     805db2b <on_header_value+0x87>
	    req->internal.response.http_cb->on_header_value) {
 805db19:	8b 52 10             	mov    0x10(%edx),%edx
	if (req->internal.response.http_cb &&
 805db1c:	85 d2                	test   %edx,%edx
 805db1e:	74 0b                	je     805db2b <on_header_value+0x87>
		req->internal.response.http_cb->on_header_value(parser, at,
 805db20:	50                   	push   %eax
 805db21:	56                   	push   %esi
 805db22:	57                   	push   %edi
 805db23:	53                   	push   %ebx
 805db24:	ff d2                	call   *%edx
	return 0;
 805db26:	31 c0                	xor    %eax,%eax
		req->internal.response.http_cb->on_header_value(parser, at,
 805db28:	83 c4 10             	add    $0x10,%esp
}
 805db2b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 805db2e:	65 2b 15 14 00 00 00 	sub    %gs:0x14,%edx
 805db35:	74 05                	je     805db3c <on_header_value+0x98>
 805db37:	e8 c4 b7 fe ff       	call   8049300 <__stack_chk_fail@plt>
 805db3c:	8d 65 f4             	lea    -0xc(%ebp),%esp
 805db3f:	5b                   	pop    %ebx
 805db40:	5e                   	pop    %esi
 805db41:	5f                   	pop    %edi
 805db42:	5d                   	pop    %ebp
 805db43:	c3                   	ret    

0805db44 <on_header_field>:
{
 805db44:	55                   	push   %ebp
 805db45:	89 e5                	mov    %esp,%ebp
 805db47:	57                   	push   %edi
 805db48:	56                   	push   %esi
 805db49:	53                   	push   %ebx
 805db4a:	83 ec 0c             	sub    $0xc,%esp
 805db4d:	8b 7d 10             	mov    0x10(%ebp),%edi
 805db50:	8b 5d 08             	mov    0x8(%ebp),%ebx
 805db53:	8b 75 0c             	mov    0xc(%ebp),%esi
	if (length >= len && strncasecmp(at, content_len, len) == 0) {
 805db56:	83 ff 0d             	cmp    $0xd,%edi
 805db59:	76 1c                	jbe    805db77 <on_header_field+0x33>
 805db5b:	51                   	push   %ecx
 805db5c:	6a 0e                	push   $0xe
 805db5e:	68 27 3e 06 08       	push   $0x8063e27
 805db63:	56                   	push   %esi
 805db64:	e8 d7 b7 fe ff       	call   8049340 <strncasecmp@plt>
 805db69:	83 c4 10             	add    $0x10,%esp
 805db6c:	85 c0                	test   %eax,%eax
 805db6e:	75 07                	jne    805db77 <on_header_field+0x33>
		req->internal.response.cl_present = true;
 805db70:	80 8b 8e 00 00 00 01 	orb    $0x1,0x8e(%ebx)
	if (req->internal.response.http_cb &&
 805db77:	8b 43 48             	mov    0x48(%ebx),%eax
 805db7a:	85 c0                	test   %eax,%eax
 805db7c:	74 10                	je     805db8e <on_header_field+0x4a>
	    req->internal.response.http_cb->on_header_field) {
 805db7e:	8b 40 0c             	mov    0xc(%eax),%eax
	if (req->internal.response.http_cb &&
 805db81:	85 c0                	test   %eax,%eax
 805db83:	74 09                	je     805db8e <on_header_field+0x4a>
		req->internal.response.http_cb->on_header_field(parser, at,
 805db85:	52                   	push   %edx
 805db86:	57                   	push   %edi
 805db87:	56                   	push   %esi
 805db88:	53                   	push   %ebx
 805db89:	ff d0                	call   *%eax
 805db8b:	83 c4 10             	add    $0x10,%esp
}
 805db8e:	8d 65 f4             	lea    -0xc(%ebp),%esp
 805db91:	31 c0                	xor    %eax,%eax
 805db93:	5b                   	pop    %ebx
 805db94:	5e                   	pop    %esi
 805db95:	5f                   	pop    %edi
 805db96:	5d                   	pop    %ebp
 805db97:	c3                   	ret    

0805db98 <on_headers_complete>:
{
 805db98:	55                   	push   %ebp
 805db99:	89 e5                	mov    %esp,%ebp
 805db9b:	53                   	push   %ebx
 805db9c:	50                   	push   %eax
 805db9d:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (req->internal.response.http_cb &&
 805dba0:	8b 43 48             	mov    0x48(%ebx),%eax
 805dba3:	85 c0                	test   %eax,%eax
 805dba5:	74 10                	je     805dbb7 <on_headers_complete+0x1f>
	    req->internal.response.http_cb->on_headers_complete) {
 805dba7:	8b 40 14             	mov    0x14(%eax),%eax
	if (req->internal.response.http_cb &&
 805dbaa:	85 c0                	test   %eax,%eax
 805dbac:	74 09                	je     805dbb7 <on_headers_complete+0x1f>
		req->internal.response.http_cb->on_headers_complete(parser);
 805dbae:	83 ec 0c             	sub    $0xc,%esp
 805dbb1:	53                   	push   %ebx
 805dbb2:	ff d0                	call   *%eax
 805dbb4:	83 c4 10             	add    $0x10,%esp
	if (parser->status_code >= 500 && parser->status_code < 600) {
 805dbb7:	8b 43 14             	mov    0x14(%ebx),%eax
 805dbba:	8d 90 0c fe ff ff    	lea    -0x1f4(%eax),%edx
		return 1;
 805dbc0:	b8 01 00 00 00       	mov    $0x1,%eax
	if (parser->status_code >= 500 && parser->status_code < 600) {
 805dbc5:	66 83 fa 63          	cmp    $0x63,%dx
 805dbc9:	76 19                	jbe    805dbe4 <on_headers_complete+0x4c>
	if ((req->method == HTTP_HEAD || req->method == HTTP_OPTIONS) &&
 805dbcb:	8b 93 98 00 00 00    	mov    0x98(%ebx),%edx
	return 0;
 805dbd1:	31 c0                	xor    %eax,%eax
	if ((req->method == HTTP_HEAD || req->method == HTTP_OPTIONS) &&
 805dbd3:	83 e2 fb             	and    $0xfffffffb,%edx
 805dbd6:	83 fa 02             	cmp    $0x2,%edx
 805dbd9:	75 09                	jne    805dbe4 <on_headers_complete+0x4c>
 805dbdb:	31 c0                	xor    %eax,%eax
 805dbdd:	83 7b 64 00          	cmpl   $0x0,0x64(%ebx)
 805dbe1:	0f 95 c0             	setne  %al
}
 805dbe4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 805dbe7:	c9                   	leave  
 805dbe8:	c3                   	ret    

0805dbe9 <sendall>:
{
 805dbe9:	55                   	push   %ebp
 805dbea:	89 e5                	mov    %esp,%ebp
 805dbec:	57                   	push   %edi
 805dbed:	89 d7                	mov    %edx,%edi
 805dbef:	56                   	push   %esi
 805dbf0:	89 c6                	mov    %eax,%esi
 805dbf2:	53                   	push   %ebx
 805dbf3:	89 cb                	mov    %ecx,%ebx
 805dbf5:	83 ec 0c             	sub    $0xc,%esp
	while (len) {
 805dbf8:	85 db                	test   %ebx,%ebx
 805dbfa:	74 28                	je     805dc24 <sendall+0x3b>
	return z_impl_zsock_sendto(sock, buf, len, flags, dest_addr, addrlen);
 805dbfc:	50                   	push   %eax
 805dbfd:	50                   	push   %eax
 805dbfe:	6a 00                	push   $0x0
 805dc00:	6a 00                	push   $0x0
 805dc02:	6a 00                	push   $0x0
 805dc04:	53                   	push   %ebx
 805dc05:	57                   	push   %edi
 805dc06:	56                   	push   %esi
 805dc07:	e8 16 e4 fe ff       	call   804c022 <z_impl_zsock_sendto>
 805dc0c:	83 c4 20             	add    $0x20,%esp
		if (out_len < 0) {
 805dc0f:	85 c0                	test   %eax,%eax
 805dc11:	79 0b                	jns    805dc1e <sendall+0x35>
			return -errno;
 805dc13:	e8 28 b4 fe ff       	call   8049040 <__errno_location@plt>
 805dc18:	8b 00                	mov    (%eax),%eax
 805dc1a:	f7 d8                	neg    %eax
 805dc1c:	eb 08                	jmp    805dc26 <sendall+0x3d>
		buf = (const char *)buf + out_len;
 805dc1e:	01 c7                	add    %eax,%edi
		len -= out_len;
 805dc20:	29 c3                	sub    %eax,%ebx
 805dc22:	eb d4                	jmp    805dbf8 <sendall+0xf>
	return 0;
 805dc24:	31 c0                	xor    %eax,%eax
}
 805dc26:	8d 65 f4             	lea    -0xc(%ebp),%esp
 805dc29:	5b                   	pop    %ebx
 805dc2a:	5e                   	pop    %esi
 805dc2b:	5f                   	pop    %edi
 805dc2c:	5d                   	pop    %ebp
 805dc2d:	c3                   	ret    

0805dc2e <http_send_data.constprop.0>:
static int http_send_data(int sock, char *send_buf,
 805dc2e:	55                   	push   %ebp
 805dc2f:	89 e5                	mov    %esp,%ebp
 805dc31:	57                   	push   %edi
 805dc32:	56                   	push   %esi
	data = va_arg(va, const char *);
 805dc33:	8d 7d 1c             	lea    0x1c(%ebp),%edi
static int http_send_data(int sock, char *send_buf,
 805dc36:	53                   	push   %ebx
 805dc37:	83 ec 1c             	sub    $0x1c,%esp
	int ret, end_of_send = *send_buf_pos;
 805dc3a:	8b 45 14             	mov    0x14(%ebp),%eax
	data = va_arg(va, const char *);
 805dc3d:	8b 75 18             	mov    0x18(%ebp),%esi
	int sent = 0;
 805dc40:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	int ret, end_of_send = *send_buf_pos;
 805dc47:	8b 18                	mov    (%eax),%ebx
	while (data) {
 805dc49:	85 f6                	test   %esi,%esi
 805dc4b:	0f 84 87 00 00 00    	je     805dcd8 <http_send_data.constprop.0+0xaa>
		end_of_data = 0;
 805dc51:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			remaining_len = strlen(data + end_of_data);
 805dc58:	8b 45 e0             	mov    -0x20(%ebp),%eax
 805dc5b:	83 ec 0c             	sub    $0xc,%esp
 805dc5e:	8d 0c 06             	lea    (%esi,%eax,1),%ecx
 805dc61:	51                   	push   %ecx
 805dc62:	89 4d d8             	mov    %ecx,-0x28(%ebp)
 805dc65:	e8 d6 b5 fe ff       	call   8049240 <strlen@plt>
 805dc6a:	83 c4 10             	add    $0x10,%esp
			if (remaining_len > to_be_copied) {
 805dc6d:	8b 4d d8             	mov    -0x28(%ebp),%ecx
			remaining_len = strlen(data + end_of_data);
 805dc70:	89 c2                	mov    %eax,%edx
			to_be_copied = send_buf_max_len - end_of_send;
 805dc72:	b8 c0 00 00 00       	mov    $0xc0,%eax
 805dc77:	29 d8                	sub    %ebx,%eax
 805dc79:	89 45 e4             	mov    %eax,-0x1c(%ebp)
				strncpy(send_buf + end_of_send,
 805dc7c:	8b 45 0c             	mov    0xc(%ebp),%eax
 805dc7f:	01 d8                	add    %ebx,%eax
			if (remaining_len > to_be_copied) {
 805dc81:	3b 55 e4             	cmp    -0x1c(%ebp),%edx
 805dc84:	7e 33                	jle    805dcb9 <http_send_data.constprop.0+0x8b>

__fortify_function char *
__NTH (strncpy (char *__restrict __dest, const char *__restrict __src,
		size_t __len))
{
  return __builtin___strncpy_chk (__dest, __src, __len,
 805dc86:	52                   	push   %edx
 805dc87:	ff 75 e4             	push   -0x1c(%ebp)
 805dc8a:	51                   	push   %ecx
 805dc8b:	50                   	push   %eax
 805dc8c:	e8 7f b4 fe ff       	call   8049110 <strncpy@plt>
				ret = sendall(sock, send_buf, end_of_send);
 805dc91:	8b 55 0c             	mov    0xc(%ebp),%edx
 805dc94:	8b 45 08             	mov    0x8(%ebp),%eax
 805dc97:	83 c4 10             	add    $0x10,%esp
 805dc9a:	b9 c0 00 00 00       	mov    $0xc0,%ecx
 805dc9f:	e8 45 ff ff ff       	call   805dbe9 <sendall>
				if (ret < 0) {
 805dca4:	85 c0                	test   %eax,%eax
 805dca6:	78 45                	js     805dced <http_send_data.constprop.0+0xbf>
				end_of_data += to_be_copied;
 805dca8:	8b 55 e4             	mov    -0x1c(%ebp),%edx
				sent += end_of_send;
 805dcab:	81 45 dc c0 00 00 00 	addl   $0xc0,-0x24(%ebp)
				end_of_send = 0;
 805dcb2:	31 db                	xor    %ebx,%ebx
				end_of_data += to_be_copied;
 805dcb4:	01 55 e0             	add    %edx,-0x20(%ebp)
 805dcb7:	eb 9f                	jmp    805dc58 <http_send_data.constprop.0+0x2a>
 805dcb9:	56                   	push   %esi
		data = va_arg(va, const char *);
 805dcba:	83 c7 04             	add    $0x4,%edi
 805dcbd:	52                   	push   %edx
 805dcbe:	51                   	push   %ecx
 805dcbf:	50                   	push   %eax
 805dcc0:	89 55 e4             	mov    %edx,-0x1c(%ebp)
 805dcc3:	e8 48 b4 fe ff       	call   8049110 <strncpy@plt>
				end_of_send += remaining_len;
 805dcc8:	8b 55 e4             	mov    -0x1c(%ebp),%edx
		data = va_arg(va, const char *);
 805dccb:	8b 77 fc             	mov    -0x4(%edi),%esi
 805dcce:	83 c4 10             	add    $0x10,%esp
				end_of_send += remaining_len;
 805dcd1:	01 d3                	add    %edx,%ebx
		data = va_arg(va, const char *);
 805dcd3:	e9 71 ff ff ff       	jmp    805dc49 <http_send_data.constprop.0+0x1b>
		return -EMSGSIZE;
 805dcd8:	b8 a6 ff ff ff       	mov    $0xffffffa6,%eax
	if (end_of_send > (int)send_buf_max_len) {
 805dcdd:	81 fb c0 00 00 00    	cmp    $0xc0,%ebx
 805dce3:	7f 08                	jg     805dced <http_send_data.constprop.0+0xbf>
	*send_buf_pos = end_of_send;
 805dce5:	8b 45 14             	mov    0x14(%ebp),%eax
 805dce8:	89 18                	mov    %ebx,(%eax)
	return sent;
 805dcea:	8b 45 dc             	mov    -0x24(%ebp),%eax
}
 805dced:	8d 65 f4             	lea    -0xc(%ebp),%esp
 805dcf0:	5b                   	pop    %ebx
 805dcf1:	5e                   	pop    %esi
 805dcf2:	5f                   	pop    %edi
 805dcf3:	5d                   	pop    %ebp
 805dcf4:	c3                   	ret    

0805dcf5 <http_client_req>:
	return ret;
}

int http_client_req(int sock, struct http_request *req,
		    int32_t timeout, void *user_data)
{
 805dcf5:	55                   	push   %ebp
 805dcf6:	89 e5                	mov    %esp,%ebp
 805dcf8:	57                   	push   %edi
 805dcf9:	56                   	push   %esi
 805dcfa:	53                   	push   %ebx
 805dcfb:	81 ec 0c 01 00 00    	sub    $0x10c,%esp
 805dd01:	8b 45 14             	mov    0x14(%ebp),%eax
 805dd04:	8b 5d 0c             	mov    0xc(%ebp),%ebx
 805dd07:	89 85 04 ff ff ff    	mov    %eax,-0xfc(%ebp)
 805dd0d:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 805dd13:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 805dd16:	31 c0                	xor    %eax,%eax
	size_t send_buf_pos = 0;
	int total_sent = 0;
	int ret, total_recv, i;
	const char *method;

	if (sock < 0 || req == NULL || req->response == NULL ||
 805dd18:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
	size_t send_buf_pos = 0;
 805dd1c:	c7 85 0c ff ff ff 00 	movl   $0x0,-0xf4(%ebp)
 805dd23:	00 00 00 
	if (sock < 0 || req == NULL || req->response == NULL ||
 805dd26:	0f 88 82 06 00 00    	js     805e3ae <http_client_req+0x6b9>
 805dd2c:	85 db                	test   %ebx,%ebx
 805dd2e:	0f 84 7a 06 00 00    	je     805e3ae <http_client_req+0x6b9>
 805dd34:	8b 83 9c 00 00 00    	mov    0x9c(%ebx),%eax
 805dd3a:	89 85 00 ff ff ff    	mov    %eax,-0x100(%ebp)
 805dd40:	83 bd 00 ff ff ff 00 	cmpl   $0x0,-0x100(%ebp)
	    req->recv_buf == NULL || req->recv_buf_len == 0) {
		return -EINVAL;
 805dd47:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
	if (sock < 0 || req == NULL || req->response == NULL ||
 805dd4c:	0f 84 61 06 00 00    	je     805e3b3 <http_client_req+0x6be>
	    req->recv_buf == NULL || req->recv_buf_len == 0) {
 805dd52:	8b b3 a4 00 00 00    	mov    0xa4(%ebx),%esi
	if (sock < 0 || req == NULL || req->response == NULL ||
 805dd58:	85 f6                	test   %esi,%esi
 805dd5a:	0f 84 53 06 00 00    	je     805e3b3 <http_client_req+0x6be>
	    req->recv_buf == NULL || req->recv_buf_len == 0) {
 805dd60:	8b 93 a8 00 00 00    	mov    0xa8(%ebx),%edx
 805dd66:	85 d2                	test   %edx,%edx
 805dd68:	0f 84 45 06 00 00    	je     805e3b3 <http_client_req+0x6be>
  return __builtin___memset_chk (__dest, __ch, __len,
 805dd6e:	8d 43 50             	lea    0x50(%ebx),%eax
 805dd71:	b9 10 00 00 00       	mov    $0x10,%ecx
	req->internal.response.recv_buf = req->recv_buf;
	req->internal.response.recv_buf_len = req->recv_buf_len;
	req->internal.user_data = user_data;
	req->internal.sock = sock;

	method = http_method_str(req->method);
 805dd76:	83 ec 0c             	sub    $0xc,%esp
 805dd79:	89 c7                	mov    %eax,%edi
 805dd7b:	31 c0                	xor    %eax,%eax
 805dd7d:	f3 ab                	rep stos %eax,%es:(%edi)
	req->internal.response.recv_buf = req->recv_buf;
 805dd7f:	89 73 58             	mov    %esi,0x58(%ebx)

	ret = http_send_data(sock, send_buf, send_buf_max_len, &send_buf_pos,
 805dd82:	8d bd 24 ff ff ff    	lea    -0xdc(%ebp),%edi
	req->internal.response.recv_buf_len = req->recv_buf_len;
 805dd88:	89 53 5c             	mov    %edx,0x5c(%ebx)
	req->internal.response.http_cb = req->http_cb;
 805dd8b:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
 805dd91:	89 43 48             	mov    %eax,0x48(%ebx)
	req->internal.response.cb = req->response;
 805dd94:	8b 85 00 ff ff ff    	mov    -0x100(%ebp),%eax
 805dd9a:	89 43 4c             	mov    %eax,0x4c(%ebx)
	req->internal.user_data = user_data;
 805dd9d:	8b 85 04 ff ff ff    	mov    -0xfc(%ebp),%eax
 805dda3:	89 83 90 00 00 00    	mov    %eax,0x90(%ebx)
	req->internal.sock = sock;
 805dda9:	8b 45 08             	mov    0x8(%ebp),%eax
 805ddac:	89 83 94 00 00 00    	mov    %eax,0x94(%ebx)
	method = http_method_str(req->method);
 805ddb2:	ff b3 98 00 00 00    	push   0x98(%ebx)
 805ddb8:	e8 b6 f8 ff ff       	call   805d673 <http_method_str>
 805ddbd:	83 c4 0c             	add    $0xc,%esp
	ret = http_send_data(sock, send_buf, send_buf_max_len, &send_buf_pos,
 805ddc0:	8d 95 0c ff ff ff    	lea    -0xf4(%ebp),%edx
 805ddc6:	6a 00                	push   $0x0
 805ddc8:	68 09 29 06 08       	push   $0x8062909
 805ddcd:	ff b3 b0 00 00 00    	push   0xb0(%ebx)
 805ddd3:	68 37 3e 06 08       	push   $0x8063e37
 805ddd8:	ff b3 ac 00 00 00    	push   0xac(%ebx)
 805ddde:	68 37 3e 06 08       	push   $0x8063e37
 805dde3:	50                   	push   %eax
 805dde4:	52                   	push   %edx
 805dde5:	68 c0 00 00 00       	push   $0xc0
 805ddea:	57                   	push   %edi
 805ddeb:	ff 75 08             	push   0x8(%ebp)
 805ddee:	e8 3b fe ff ff       	call   805dc2e <http_send_data.constprop.0>
 805ddf3:	83 c4 30             	add    $0x30,%esp
 805ddf6:	89 c6                	mov    %eax,%esi
			     method, " ", req->url, " ", req->protocol,
			     HTTP_CRLF, NULL);
	if (ret < 0) {
 805ddf8:	85 c0                	test   %eax,%eax
 805ddfa:	0f 88 b3 05 00 00    	js     805e3b3 <http_client_req+0x6be>
		goto out;
	}

	total_sent += ret;

	if (req->port) {
 805de00:	8b 8b c0 00 00 00    	mov    0xc0(%ebx),%ecx
		ret = http_send_data(sock, send_buf, send_buf_max_len,
 805de06:	8b 83 bc 00 00 00    	mov    0xbc(%ebx),%eax
	if (req->port) {
 805de0c:	8d 95 0c ff ff ff    	lea    -0xf4(%ebp),%edx
 805de12:	85 c9                	test   %ecx,%ecx
 805de14:	74 12                	je     805de28 <http_client_req+0x133>
		ret = http_send_data(sock, send_buf, send_buf_max_len,
 805de16:	83 ec 04             	sub    $0x4,%esp
 805de19:	6a 00                	push   $0x0
 805de1b:	68 09 29 06 08       	push   $0x8062909
 805de20:	51                   	push   %ecx
 805de21:	68 55 34 06 08       	push   $0x8063455
 805de26:	eb 0a                	jmp    805de32 <http_client_req+0x13d>
			goto out;
		}

		total_sent += ret;
	} else {
		ret = http_send_data(sock, send_buf, send_buf_max_len,
 805de28:	83 ec 0c             	sub    $0xc,%esp
 805de2b:	6a 00                	push   $0x0
 805de2d:	68 09 29 06 08       	push   $0x8062909
 805de32:	50                   	push   %eax
 805de33:	68 36 3e 06 08       	push   $0x8063e36
 805de38:	68 39 3e 06 08       	push   $0x8063e39
 805de3d:	52                   	push   %edx
 805de3e:	68 c0 00 00 00       	push   $0xc0
 805de43:	57                   	push   %edi
 805de44:	ff 75 08             	push   0x8(%ebp)
 805de47:	e8 e2 fd ff ff       	call   805dc2e <http_send_data.constprop.0>
 805de4c:	83 c4 30             	add    $0x30,%esp
				     &send_buf_pos, "Host", ": ", req->host,
				     HTTP_CRLF, NULL);

		if (ret < 0) {
 805de4f:	85 c0                	test   %eax,%eax
 805de51:	0f 88 5c 05 00 00    	js     805e3b3 <http_client_req+0x6be>
		}

		total_sent += ret;
	}

	if (req->optional_headers_cb) {
 805de57:	83 bb d0 00 00 00 00 	cmpl   $0x0,0xd0(%ebx)
		total_sent += ret;
 805de5e:	8d 3c 30             	lea    (%eax,%esi,1),%edi
	if (req->optional_headers_cb) {
 805de61:	74 57                	je     805deba <http_client_req+0x1c5>
		ret = http_flush_data(sock, send_buf, send_buf_pos);
 805de63:	8b b5 0c ff ff ff    	mov    -0xf4(%ebp),%esi
	ret = sendall(sock, send_buf, send_buf_len);
 805de69:	8b 45 08             	mov    0x8(%ebp),%eax
 805de6c:	8d 95 24 ff ff ff    	lea    -0xdc(%ebp),%edx
 805de72:	89 f1                	mov    %esi,%ecx
 805de74:	e8 70 fd ff ff       	call   805dbe9 <sendall>
	if (ret < 0) {
 805de79:	85 c0                	test   %eax,%eax
 805de7b:	0f 88 32 05 00 00    	js     805e3b3 <http_client_req+0x6be>
	return (int)send_buf_len;
 805de81:	89 f0                	mov    %esi,%eax
		if (ret < 0) {
 805de83:	85 f6                	test   %esi,%esi
 805de85:	0f 88 28 05 00 00    	js     805e3b3 <http_client_req+0x6be>
		}

		send_buf_pos = 0;
		total_sent += ret;

		ret = req->optional_headers_cb(sock, req, user_data);
 805de8b:	50                   	push   %eax
 805de8c:	ff b5 04 ff ff ff    	push   -0xfc(%ebp)
 805de92:	53                   	push   %ebx
 805de93:	ff 75 08             	push   0x8(%ebp)
		send_buf_pos = 0;
 805de96:	c7 85 0c ff ff ff 00 	movl   $0x0,-0xf4(%ebp)
 805de9d:	00 00 00 
		ret = req->optional_headers_cb(sock, req, user_data);
 805dea0:	ff 93 d0 00 00 00    	call   *0xd0(%ebx)
 805dea6:	83 c4 10             	add    $0x10,%esp
		if (ret < 0) {
 805dea9:	85 c0                	test   %eax,%eax
 805deab:	0f 88 02 05 00 00    	js     805e3b3 <http_client_req+0x6be>
		total_sent += ret;
 805deb1:	01 fe                	add    %edi,%esi
			goto out;
		}

		total_sent += ret;
 805deb3:	8d 3c 30             	lea    (%eax,%esi,1),%edi
 805deb6:	31 f6                	xor    %esi,%esi
 805deb8:	eb 7c                	jmp    805df36 <http_client_req+0x241>
 805deba:	31 f6                	xor    %esi,%esi
	} else {
		for (i = 0; req->optional_headers && req->optional_headers[i];
 805debc:	8b 83 d4 00 00 00    	mov    0xd4(%ebx),%eax
 805dec2:	85 c0                	test   %eax,%eax
 805dec4:	74 f0                	je     805deb6 <http_client_req+0x1c1>
 805dec6:	8b 04 30             	mov    (%eax,%esi,1),%eax
 805dec9:	85 c0                	test   %eax,%eax
 805decb:	74 e9                	je     805deb6 <http_client_req+0x1c1>
		     i++) {
			ret = http_send_data(sock, send_buf, send_buf_max_len,
 805decd:	51                   	push   %ecx
					     &send_buf_pos,
					     req->optional_headers[i], NULL);
			if (ret < 0) {
 805dece:	83 c6 04             	add    $0x4,%esi
			ret = http_send_data(sock, send_buf, send_buf_max_len,
 805ded1:	51                   	push   %ecx
 805ded2:	6a 00                	push   $0x0
 805ded4:	50                   	push   %eax
 805ded5:	8d 85 0c ff ff ff    	lea    -0xf4(%ebp),%eax
 805dedb:	50                   	push   %eax
 805dedc:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
 805dee2:	68 c0 00 00 00       	push   $0xc0
 805dee7:	50                   	push   %eax
 805dee8:	ff 75 08             	push   0x8(%ebp)
 805deeb:	e8 3e fd ff ff       	call   805dc2e <http_send_data.constprop.0>
 805def0:	83 c4 20             	add    $0x20,%esp
			if (ret < 0) {
 805def3:	85 c0                	test   %eax,%eax
 805def5:	0f 88 b8 04 00 00    	js     805e3b3 <http_client_req+0x6be>
				goto out;
			}

			total_sent += ret;
 805defb:	01 c7                	add    %eax,%edi
		     i++) {
 805defd:	eb bd                	jmp    805debc <http_client_req+0x1c7>
		}
	}

	for (i = 0; req->header_fields && req->header_fields[i]; i++) {
 805deff:	8b 04 30             	mov    (%eax,%esi,1),%eax
 805df02:	85 c0                	test   %eax,%eax
 805df04:	74 3a                	je     805df40 <http_client_req+0x24b>
		ret = http_send_data(sock, send_buf, send_buf_max_len,
 805df06:	52                   	push   %edx
				     &send_buf_pos, req->header_fields[i],
				     NULL);
		if (ret < 0) {
 805df07:	83 c6 04             	add    $0x4,%esi
		ret = http_send_data(sock, send_buf, send_buf_max_len,
 805df0a:	52                   	push   %edx
 805df0b:	6a 00                	push   $0x0
 805df0d:	50                   	push   %eax
 805df0e:	8d 85 0c ff ff ff    	lea    -0xf4(%ebp),%eax
 805df14:	50                   	push   %eax
 805df15:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
 805df1b:	68 c0 00 00 00       	push   $0xc0
 805df20:	50                   	push   %eax
 805df21:	ff 75 08             	push   0x8(%ebp)
 805df24:	e8 05 fd ff ff       	call   805dc2e <http_send_data.constprop.0>
 805df29:	83 c4 20             	add    $0x20,%esp
		if (ret < 0) {
 805df2c:	85 c0                	test   %eax,%eax
 805df2e:	0f 88 7f 04 00 00    	js     805e3b3 <http_client_req+0x6be>
			goto out;
		}

		total_sent += ret;
 805df34:	01 c7                	add    %eax,%edi
	for (i = 0; req->header_fields && req->header_fields[i]; i++) {
 805df36:	8b 83 b4 00 00 00    	mov    0xb4(%ebx),%eax
 805df3c:	85 c0                	test   %eax,%eax
 805df3e:	75 bf                	jne    805deff <http_client_req+0x20a>
	}

	if (req->content_type_value) {
 805df40:	8b 83 b8 00 00 00    	mov    0xb8(%ebx),%eax
 805df46:	85 c0                	test   %eax,%eax
 805df48:	74 3d                	je     805df87 <http_client_req+0x292>
		ret = http_send_data(sock, send_buf, send_buf_max_len,
 805df4a:	83 ec 0c             	sub    $0xc,%esp
 805df4d:	6a 00                	push   $0x0
 805df4f:	68 09 29 06 08       	push   $0x8062909
 805df54:	50                   	push   %eax
 805df55:	8d 85 0c ff ff ff    	lea    -0xf4(%ebp),%eax
 805df5b:	68 36 3e 06 08       	push   $0x8063e36
 805df60:	68 3e 3e 06 08       	push   $0x8063e3e
 805df65:	50                   	push   %eax
 805df66:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
 805df6c:	68 c0 00 00 00       	push   $0xc0
 805df71:	50                   	push   %eax
 805df72:	ff 75 08             	push   0x8(%ebp)
 805df75:	e8 b4 fc ff ff       	call   805dc2e <http_send_data.constprop.0>
 805df7a:	83 c4 30             	add    $0x30,%esp
				     &send_buf_pos, "Content-Type", ": ",
				     req->content_type_value, HTTP_CRLF, NULL);
		if (ret < 0) {
 805df7d:	85 c0                	test   %eax,%eax
 805df7f:	0f 88 2e 04 00 00    	js     805e3b3 <http_client_req+0x6be>
			goto out;
		}

		total_sent += ret;
 805df85:	01 c7                	add    %eax,%edi
	}

	if (req->payload || req->payload_cb) {
 805df87:	83 bb c8 00 00 00 00 	cmpl   $0x0,0xc8(%ebx)
 805df8e:	75 0d                	jne    805df9d <http_client_req+0x2a8>
 805df90:	83 bb c4 00 00 00 00 	cmpl   $0x0,0xc4(%ebx)
 805df97:	0f 84 42 01 00 00    	je     805e0df <http_client_req+0x3ea>
		if (req->payload_len) {
 805df9d:	8b 83 cc 00 00 00    	mov    0xcc(%ebx),%eax
 805dfa3:	85 c0                	test   %eax,%eax
 805dfa5:	74 60                	je     805e007 <http_client_req+0x312>
			char content_len_str[HTTP_CONTENT_LEN_SIZE];

			ret = snprintk(content_len_str, HTTP_CONTENT_LEN_SIZE,
 805dfa7:	8d b5 19 ff ff ff    	lea    -0xe7(%ebp),%esi
 805dfad:	50                   	push   %eax
 805dfae:	68 4b 3e 06 08       	push   $0x8063e4b
 805dfb3:	6a 0b                	push   $0xb
 805dfb5:	56                   	push   %esi
 805dfb6:	e8 7d bf fe ff       	call   8049f38 <snprintk>
 805dfbb:	83 c4 10             	add    $0x10,%esp
				       "%zd", req->payload_len);
			if (ret <= 0 || ret >= HTTP_CONTENT_LEN_SIZE) {
 805dfbe:	48                   	dec    %eax
 805dfbf:	83 f8 09             	cmp    $0x9,%eax
 805dfc2:	76 0a                	jbe    805dfce <http_client_req+0x2d9>
				ret = -ENOMEM;
 805dfc4:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
 805dfc9:	e9 e5 03 00 00       	jmp    805e3b3 <http_client_req+0x6be>
				goto out;
			}

			ret = http_send_data(sock, send_buf, send_buf_max_len,
 805dfce:	50                   	push   %eax
 805dfcf:	50                   	push   %eax
 805dfd0:	8d 85 0c ff ff ff    	lea    -0xf4(%ebp),%eax
 805dfd6:	6a 00                	push   $0x0
 805dfd8:	68 09 29 06 08       	push   $0x8062909
 805dfdd:	68 09 29 06 08       	push   $0x8062909
 805dfe2:	56                   	push   %esi
 805dfe3:	68 36 3e 06 08       	push   $0x8063e36
 805dfe8:	68 27 3e 06 08       	push   $0x8063e27
 805dfed:	50                   	push   %eax
 805dfee:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
 805dff4:	68 c0 00 00 00       	push   $0xc0
 805dff9:	50                   	push   %eax
 805dffa:	ff 75 08             	push   0x8(%ebp)
 805dffd:	e8 2c fc ff ff       	call   805dc2e <http_send_data.constprop.0>
 805e002:	83 c4 30             	add    $0x30,%esp
 805e005:	eb 27                	jmp    805e02e <http_client_req+0x339>
					     &send_buf_pos, "Content-Length", ": ",
					     content_len_str, HTTP_CRLF,
					     HTTP_CRLF, NULL);
		} else {
			ret = http_send_data(sock, send_buf, send_buf_max_len,
 805e007:	8d 85 0c ff ff ff    	lea    -0xf4(%ebp),%eax
 805e00d:	51                   	push   %ecx
 805e00e:	51                   	push   %ecx
 805e00f:	6a 00                	push   $0x0
 805e011:	68 09 29 06 08       	push   $0x8062909
 805e016:	50                   	push   %eax
 805e017:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
 805e01d:	68 c0 00 00 00       	push   $0xc0
 805e022:	50                   	push   %eax
 805e023:	ff 75 08             	push   0x8(%ebp)
 805e026:	e8 03 fc ff ff       	call   805dc2e <http_send_data.constprop.0>
 805e02b:	83 c4 20             	add    $0x20,%esp
 805e02e:	89 c6                	mov    %eax,%esi
				     &send_buf_pos, HTTP_CRLF, NULL);
		}

		if (ret < 0) {
 805e030:	85 c0                	test   %eax,%eax
 805e032:	0f 88 7b 03 00 00    	js     805e3b3 <http_client_req+0x6be>
			goto out;
		}

		total_sent += ret;

		ret = http_flush_data(sock, send_buf, send_buf_pos);
 805e038:	8b 8d 0c ff ff ff    	mov    -0xf4(%ebp),%ecx
	ret = sendall(sock, send_buf, send_buf_len);
 805e03e:	8b 45 08             	mov    0x8(%ebp),%eax
 805e041:	8d 95 24 ff ff ff    	lea    -0xdc(%ebp),%edx
 805e047:	89 8d 00 ff ff ff    	mov    %ecx,-0x100(%ebp)
 805e04d:	e8 97 fb ff ff       	call   805dbe9 <sendall>
	if (ret < 0) {
 805e052:	85 c0                	test   %eax,%eax
 805e054:	0f 88 59 03 00 00    	js     805e3b3 <http_client_req+0x6be>
	return (int)send_buf_len;
 805e05a:	8b 8d 00 ff ff ff    	mov    -0x100(%ebp),%ecx
 805e060:	89 c8                	mov    %ecx,%eax
		if (ret < 0) {
 805e062:	85 c9                	test   %ecx,%ecx
 805e064:	0f 88 49 03 00 00    	js     805e3b3 <http_client_req+0x6be>
		}

		send_buf_pos = 0;
		total_sent += ret;

		if (req->payload_cb) {
 805e06a:	8b 83 c4 00 00 00    	mov    0xc4(%ebx),%eax
		total_sent += ret;
 805e070:	01 fe                	add    %edi,%esi
		send_buf_pos = 0;
 805e072:	c7 85 0c ff ff ff 00 	movl   $0x0,-0xf4(%ebp)
 805e079:	00 00 00 
		total_sent += ret;
 805e07c:	01 ce                	add    %ecx,%esi
		if (req->payload_cb) {
 805e07e:	85 c0                	test   %eax,%eax
 805e080:	74 1c                	je     805e09e <http_client_req+0x3a9>
			ret = req->payload_cb(sock, req, user_data);
 805e082:	52                   	push   %edx
 805e083:	ff b5 04 ff ff ff    	push   -0xfc(%ebp)
 805e089:	53                   	push   %ebx
 805e08a:	ff 75 08             	push   0x8(%ebp)
 805e08d:	ff d0                	call   *%eax
 805e08f:	83 c4 10             	add    $0x10,%esp
			if (ret < 0) {
 805e092:	85 c0                	test   %eax,%eax
 805e094:	0f 88 19 03 00 00    	js     805e3b3 <http_client_req+0x6be>
				goto out;
			}

			total_sent += ret;
 805e09a:	01 f0                	add    %esi,%eax
 805e09c:	eb 72                	jmp    805e110 <http_client_req+0x41b>
		} else {
			uint32_t length;

			if (req->payload_len == 0) {
 805e09e:	8b bb cc 00 00 00    	mov    0xcc(%ebx),%edi
				length = strlen(req->payload);
 805e0a4:	8b 93 c8 00 00 00    	mov    0xc8(%ebx),%edx
			if (req->payload_len == 0) {
 805e0aa:	85 ff                	test   %edi,%edi
 805e0ac:	75 1a                	jne    805e0c8 <http_client_req+0x3d3>
				length = strlen(req->payload);
 805e0ae:	83 ec 0c             	sub    $0xc,%esp
 805e0b1:	89 95 04 ff ff ff    	mov    %edx,-0xfc(%ebp)
 805e0b7:	52                   	push   %edx
 805e0b8:	e8 83 b1 fe ff       	call   8049240 <strlen@plt>
 805e0bd:	8b 95 04 ff ff ff    	mov    -0xfc(%ebp),%edx
 805e0c3:	83 c4 10             	add    $0x10,%esp
 805e0c6:	89 c7                	mov    %eax,%edi
			} else {
				length = req->payload_len;
			}

			ret = sendall(sock, req->payload, length);
 805e0c8:	8b 45 08             	mov    0x8(%ebp),%eax
 805e0cb:	89 f9                	mov    %edi,%ecx
 805e0cd:	e8 17 fb ff ff       	call   805dbe9 <sendall>
			if (ret < 0) {
 805e0d2:	85 c0                	test   %eax,%eax
 805e0d4:	0f 88 d9 02 00 00    	js     805e3b3 <http_client_req+0x6be>
				goto out;
			}

			total_sent += length;
 805e0da:	8d 04 3e             	lea    (%esi,%edi,1),%eax
 805e0dd:	eb 31                	jmp    805e110 <http_client_req+0x41b>
		}
	} else {
		ret = http_send_data(sock, send_buf, send_buf_max_len,
 805e0df:	50                   	push   %eax
 805e0e0:	50                   	push   %eax
 805e0e1:	8d 85 0c ff ff ff    	lea    -0xf4(%ebp),%eax
 805e0e7:	6a 00                	push   $0x0
 805e0e9:	68 09 29 06 08       	push   $0x8062909
 805e0ee:	50                   	push   %eax
 805e0ef:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
 805e0f5:	68 c0 00 00 00       	push   $0xc0
 805e0fa:	50                   	push   %eax
 805e0fb:	ff 75 08             	push   0x8(%ebp)
 805e0fe:	e8 2b fb ff ff       	call   805dc2e <http_send_data.constprop.0>
 805e103:	83 c4 20             	add    $0x20,%esp
				     &send_buf_pos, HTTP_CRLF, NULL);
		if (ret < 0) {
 805e106:	85 c0                	test   %eax,%eax
 805e108:	0f 88 a5 02 00 00    	js     805e3b3 <http_client_req+0x6be>
			goto out;
		}

		total_sent += ret;
 805e10e:	01 f8                	add    %edi,%eax
	}

	if (send_buf_pos > 0) {
 805e110:	8b b5 0c ff ff ff    	mov    -0xf4(%ebp),%esi
		total_sent += ret;
 805e116:	89 85 fc fe ff ff    	mov    %eax,-0x104(%ebp)
	if (send_buf_pos > 0) {
 805e11c:	85 f6                	test   %esi,%esi
 805e11e:	74 28                	je     805e148 <http_client_req+0x453>
	ret = sendall(sock, send_buf, send_buf_len);
 805e120:	8b 45 08             	mov    0x8(%ebp),%eax
 805e123:	89 f1                	mov    %esi,%ecx
 805e125:	8d 95 24 ff ff ff    	lea    -0xdc(%ebp),%edx
 805e12b:	e8 b9 fa ff ff       	call   805dbe9 <sendall>
	if (ret < 0) {
 805e130:	85 c0                	test   %eax,%eax
 805e132:	0f 88 7b 02 00 00    	js     805e3b3 <http_client_req+0x6be>
	return (int)send_buf_len;
 805e138:	89 f0                	mov    %esi,%eax
		ret = http_flush_data(sock, send_buf, send_buf_pos);
		if (ret < 0) {
 805e13a:	85 f6                	test   %esi,%esi
 805e13c:	0f 88 71 02 00 00    	js     805e3b3 <http_client_req+0x6be>
			goto out;
		}

		total_sent += ret;
 805e142:	01 b5 fc fe ff ff    	add    %esi,-0x104(%ebp)
	memset(&req->internal.response, 0, sizeof(req->internal.response));
 805e148:	8d 43 48             	lea    0x48(%ebx),%eax
 805e14b:	89 85 f8 fe ff ff    	mov    %eax,-0x108(%ebp)
	}

	NET_DBG("Sent %d bytes", total_sent);

	http_client_init_parser(&req->internal.parser,
 805e151:	8d 43 20             	lea    0x20(%ebx),%eax
 805e154:	89 85 ec fe ff ff    	mov    %eax,-0x114(%ebp)
	http_parser_init(parser, HTTP_RESPONSE);
 805e15a:	50                   	push   %eax
 805e15b:	50                   	push   %eax
 805e15c:	6a 01                	push   $0x1
 805e15e:	53                   	push   %ebx
 805e15f:	e8 28 f5 ff ff       	call   805d68c <http_parser_init>
 805e164:	83 c4 10             	add    $0x10,%esp
	settings->on_body = on_body;
 805e167:	c7 43 38 63 d9 05 08 	movl   $0x805d963,0x38(%ebx)
	settings->on_chunk_complete = on_chunk_complete;
 805e16e:	c7 43 44 26 da 05 08 	movl   $0x805da26,0x44(%ebx)
	settings->on_chunk_header = on_chunk_header;
 805e175:	c7 43 40 02 da 05 08 	movl   $0x805da02,0x40(%ebx)
	settings->on_headers_complete = on_headers_complete;
 805e17c:	c7 43 34 98 db 05 08 	movl   $0x805db98,0x34(%ebx)
	settings->on_header_field = on_header_field;
 805e183:	c7 43 2c 44 db 05 08 	movl   $0x805db44,0x2c(%ebx)
	settings->on_header_value = on_header_value;
 805e18a:	c7 43 30 a4 da 05 08 	movl   $0x805daa4,0x30(%ebx)
	settings->on_message_begin = on_message_begin;
 805e191:	c7 43 20 b2 d9 05 08 	movl   $0x805d9b2,0x20(%ebx)
	settings->on_message_complete = on_message_complete;
 805e198:	c7 43 3c d5 d9 05 08 	movl   $0x805d9d5,0x3c(%ebx)
	settings->on_status = on_status;
 805e19f:	c7 43 28 4a da 05 08 	movl   $0x805da4a,0x28(%ebx)
	settings->on_url = on_url;
 805e1a6:	c7 43 24 3b d9 05 08 	movl   $0x805d93b,0x24(%ebx)
	return z_impl_k_uptime_ticks();
 805e1ad:	e8 62 2a 00 00       	call   8060c14 <z_impl_k_uptime_ticks>
			return t * ((uint64_t)to_hz / from_hz);
 805e1b2:	bf 0a 00 00 00       	mov    $0xa,%edi
	fds[0].events = ZSOCK_POLLIN;
 805e1b7:	66 c7 85 14 ff ff ff 	movw   $0x1,-0xec(%ebp)
 805e1be:	01 00 
	size_t offset = 0;
 805e1c0:	c7 85 04 ff ff ff 00 	movl   $0x0,-0xfc(%ebp)
 805e1c7:	00 00 00 
 805e1ca:	6b ca 0a             	imul   $0xa,%edx,%ecx
 805e1cd:	f7 e7                	mul    %edi
 805e1cf:	89 85 f0 fe ff ff    	mov    %eax,-0x110(%ebp)
	fds[0].fd = sock;
 805e1d5:	8b 45 08             	mov    0x8(%ebp),%eax
 805e1d8:	89 95 f4 fe ff ff    	mov    %edx,-0x10c(%ebp)
 805e1de:	89 85 10 ff ff ff    	mov    %eax,-0xf0(%ebp)
	int32_t remaining_time = timeout;
 805e1e4:	8b 45 10             	mov    0x10(%ebp),%eax
 805e1e7:	01 8d f4 fe ff ff    	add    %ecx,-0x10c(%ebp)
 805e1ed:	89 85 00 ff ff ff    	mov    %eax,-0x100(%ebp)
		if (timeout > 0) {
 805e1f3:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
 805e1f7:	7e 41                	jle    805e23a <http_client_req+0x545>
 805e1f9:	e8 16 2a 00 00       	call   8060c14 <z_impl_k_uptime_ticks>
 805e1fe:	6b ca 0a             	imul   $0xa,%edx,%ecx
 805e201:	ba 0a 00 00 00       	mov    $0xa,%edx
 805e206:	f7 e2                	mul    %edx
 805e208:	01 ca                	add    %ecx,%edx
	delta = uptime - *reftime;
 805e20a:	89 c6                	mov    %eax,%esi
 805e20c:	2b b5 f0 fe ff ff    	sub    -0x110(%ebp),%esi
 805e212:	31 c9                	xor    %ecx,%ecx
			remaining_time -= (int32_t)k_uptime_delta(&timestamp);
 805e214:	29 b5 00 ff ff ff    	sub    %esi,-0x100(%ebp)
 805e21a:	83 bd 00 ff ff ff 00 	cmpl   $0x0,-0x100(%ebp)
 805e221:	0f 49 8d 00 ff ff ff 	cmovns -0x100(%ebp),%ecx
	*reftime = uptime;
 805e228:	89 85 f0 fe ff ff    	mov    %eax,-0x110(%ebp)
 805e22e:	89 95 f4 fe ff ff    	mov    %edx,-0x10c(%ebp)
 805e234:	89 8d 00 ff ff ff    	mov    %ecx,-0x100(%ebp)
	return z_impl_zsock_poll(fds, nfds, timeout);
 805e23a:	8d 85 10 ff ff ff    	lea    -0xf0(%ebp),%eax
 805e240:	57                   	push   %edi
 805e241:	ff b5 00 ff ff ff    	push   -0x100(%ebp)
 805e247:	6a 01                	push   $0x1
 805e249:	50                   	push   %eax
 805e24a:	e8 a5 e8 fe ff       	call   804caf4 <z_impl_zsock_poll>
 805e24f:	83 c4 10             	add    $0x10,%esp
		if (ret == 0) {
 805e252:	85 c0                	test   %eax,%eax
 805e254:	0f 84 fe 00 00 00    	je     805e358 <http_client_req+0x663>
		} else if (ret < 0) {
 805e25a:	0f 88 46 01 00 00    	js     805e3a6 <http_client_req+0x6b1>
		if (fds[0].revents & (ZSOCK_POLLERR | ZSOCK_POLLNVAL)) {
 805e260:	66 8b 85 16 ff ff ff 	mov    -0xea(%ebp),%ax
 805e267:	a8 28                	test   $0x28,%al
 805e269:	0f 85 37 01 00 00    	jne    805e3a6 <http_client_req+0x6b1>
		} else if (fds[0].revents & ZSOCK_POLLHUP) {
 805e26f:	a8 10                	test   $0x10,%al
 805e271:	0f 85 e1 00 00 00    	jne    805e358 <http_client_req+0x663>
		} else if (fds[0].revents & ZSOCK_POLLIN) {
 805e277:	a8 01                	test   $0x1,%al
 805e279:	0f 84 74 ff ff ff    	je     805e1f3 <http_client_req+0x4fe>
			received = zsock_recv(sock, req->internal.response.recv_buf + offset,
 805e27f:	8b b5 04 ff ff ff    	mov    -0xfc(%ebp),%esi
 805e285:	03 73 58             	add    0x58(%ebx),%esi
 805e288:	8b 43 5c             	mov    0x5c(%ebx),%eax
 805e28b:	89 f2                	mov    %esi,%edx
 805e28d:	2b 85 04 ff ff ff    	sub    -0xfc(%ebp),%eax
	return z_impl_zsock_recvfrom(sock, buf, max_len, flags, src_addr, addrlen);
 805e293:	56                   	push   %esi
 805e294:	56                   	push   %esi
 805e295:	6a 00                	push   $0x0
 805e297:	6a 00                	push   $0x0
 805e299:	6a 00                	push   $0x0
 805e29b:	50                   	push   %eax
 805e29c:	52                   	push   %edx
 805e29d:	ff 75 08             	push   0x8(%ebp)
 805e2a0:	e8 24 e5 fe ff       	call   804c7c9 <z_impl_zsock_recvfrom>
 805e2a5:	83 c4 20             	add    $0x20,%esp
			if (received == 0) {
 805e2a8:	85 c0                	test   %eax,%eax
 805e2aa:	0f 84 a8 00 00 00    	je     805e358 <http_client_req+0x663>
			} else if (received < 0) {
 805e2b0:	0f 88 f0 00 00 00    	js     805e3a6 <http_client_req+0x6b1>
				req->internal.response.data_len += received;
 805e2b6:	01 43 60             	add    %eax,0x60(%ebx)
				(void)http_parser_execute(
 805e2b9:	89 85 e8 fe ff ff    	mov    %eax,-0x118(%ebp)
 805e2bf:	50                   	push   %eax
					req->internal.response.recv_buf + offset, received);
 805e2c0:	8b 85 04 ff ff ff    	mov    -0xfc(%ebp),%eax
 805e2c6:	03 43 58             	add    0x58(%ebx),%eax
				(void)http_parser_execute(
 805e2c9:	50                   	push   %eax
 805e2ca:	ff b5 ec fe ff ff    	push   -0x114(%ebp)
 805e2d0:	53                   	push   %ebx
 805e2d1:	e8 fd da ff ff       	call   805bdd3 <http_parser_execute>
			offset += received;
 805e2d6:	8b 95 e8 fe ff ff    	mov    -0x118(%ebp),%edx
				(void)http_parser_execute(
 805e2dc:	83 c4 10             	add    $0x10,%esp
			offset += received;
 805e2df:	01 95 04 ff ff ff    	add    %edx,-0xfc(%ebp)
			if (offset >= req->internal.response.recv_buf_len) {
 805e2e5:	8b 85 04 ff ff ff    	mov    -0xfc(%ebp),%eax
 805e2eb:	3b 43 5c             	cmp    0x5c(%ebx),%eax
 805e2ee:	72 0a                	jb     805e2fa <http_client_req+0x605>
				offset = 0;
 805e2f0:	c7 85 04 ff ff ff 00 	movl   $0x0,-0xfc(%ebp)
 805e2f7:	00 00 00 
			if (req->internal.response.cb) {
 805e2fa:	8b 43 4c             	mov    0x4c(%ebx),%eax
				if (req->internal.response.message_complete) {
 805e2fd:	8a 93 8e 00 00 00    	mov    0x8e(%ebx),%dl
			if (req->internal.response.cb) {
 805e303:	85 c0                	test   %eax,%eax
 805e305:	74 42                	je     805e349 <http_client_req+0x654>
				if (req->internal.response.message_complete) {
 805e307:	80 e2 04             	and    $0x4,%dl
 805e30a:	75 10                	jne    805e31c <http_client_req+0x627>
					event = HTTP_DATA_MORE;
 805e30c:	31 d2                	xor    %edx,%edx
				} else if (offset == 0) {
 805e30e:	83 bd 04 ff ff ff 00 	cmpl   $0x0,-0xfc(%ebp)
 805e315:	74 0a                	je     805e321 <http_client_req+0x62c>
 805e317:	e9 d7 fe ff ff       	jmp    805e1f3 <http_client_req+0x4fe>
					event = HTTP_DATA_FINAL;
 805e31c:	ba 01 00 00 00       	mov    $0x1,%edx
					req->internal.response.cb(&req->internal.response, event,
 805e321:	51                   	push   %ecx
 805e322:	ff b3 90 00 00 00    	push   0x90(%ebx)
 805e328:	52                   	push   %edx
 805e329:	ff b5 f8 fe ff ff    	push   -0x108(%ebp)
 805e32f:	ff d0                	call   *%eax
					req->internal.response.data_len = 0;
 805e331:	c7 43 60 00 00 00 00 	movl   $0x0,0x60(%ebx)
					req->internal.response.body_frag_start = NULL;
 805e338:	c7 43 50 00 00 00 00 	movl   $0x0,0x50(%ebx)
					req->internal.response.body_frag_len = 0;
 805e33f:	c7 43 54 00 00 00 00 	movl   $0x0,0x54(%ebx)
					req->internal.response.cb(&req->internal.response, event,
 805e346:	83 c4 10             	add    $0x10,%esp
			if (req->internal.response.message_complete) {
 805e349:	f6 83 8e 00 00 00 04 	testb  $0x4,0x8e(%ebx)
 805e350:	0f 84 9d fe ff ff    	je     805e1f3 <http_client_req+0x4fe>
 805e356:	eb 4e                	jmp    805e3a6 <http_client_req+0x6b1>
	if (req->internal.response.cb) {
 805e358:	8b 53 4c             	mov    0x4c(%ebx),%edx
 805e35b:	85 d2                	test   %edx,%edx
 805e35d:	74 47                	je     805e3a6 <http_client_req+0x6b1>
 805e35f:	8d 73 6c             	lea    0x6c(%ebx),%esi
 805e362:	31 c0                	xor    %eax,%eax
 805e364:	b9 08 00 00 00       	mov    $0x8,%ecx
		req->internal.response.http_status_code = 0;
 805e369:	66 c7 83 8c 00 00 00 	movw   $0x0,0x8c(%ebx)
 805e370:	00 00 
 805e372:	89 f7                	mov    %esi,%edi
		req->internal.response.processed = 0;
 805e374:	c7 43 68 00 00 00 00 	movl   $0x0,0x68(%ebx)
		req->internal.response.data_len = 0;
 805e37b:	c7 43 60 00 00 00 00 	movl   $0x0,0x60(%ebx)
		req->internal.response.content_length = 0;
 805e382:	c7 43 64 00 00 00 00 	movl   $0x0,0x64(%ebx)
		req->internal.response.body_frag_start = NULL;
 805e389:	c7 43 50 00 00 00 00 	movl   $0x0,0x50(%ebx)
 805e390:	f3 ab                	rep stos %eax,%es:(%edi)
		req->internal.response.cb(&req->internal.response, HTTP_DATA_FINAL,
 805e392:	50                   	push   %eax
 805e393:	ff b3 90 00 00 00    	push   0x90(%ebx)
 805e399:	6a 01                	push   $0x1
 805e39b:	ff b5 f8 fe ff ff    	push   -0x108(%ebp)
 805e3a1:	ff d2                	call   *%edx
 805e3a3:	83 c4 10             	add    $0x10,%esp
		NET_DBG("Wait data failure (%d)", total_recv);
	} else {
		NET_DBG("Received %d bytes", total_recv);
	}

	return total_sent;
 805e3a6:	8b 85 fc fe ff ff    	mov    -0x104(%ebp),%eax
 805e3ac:	eb 05                	jmp    805e3b3 <http_client_req+0x6be>
		return -EINVAL;
 805e3ae:	b8 ea ff ff ff       	mov    $0xffffffea,%eax

out:
	return ret;
}
 805e3b3:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 805e3b6:	65 2b 15 14 00 00 00 	sub    %gs:0x14,%edx
 805e3bd:	74 05                	je     805e3c4 <http_client_req+0x6cf>
 805e3bf:	e8 3c af fe ff       	call   8049300 <__stack_chk_fail@plt>
 805e3c4:	8d 65 f4             	lea    -0xc(%ebp),%esp
 805e3c7:	5b                   	pop    %ebx
 805e3c8:	5e                   	pop    %esi
 805e3c9:	5f                   	pop    %edi
 805e3ca:	5d                   	pop    %ebp
 805e3cb:	c3                   	ret    

0805e3cc <native_posix_console_init>:
	}
}
#endif /* CONFIG_NATIVE_POSIX_STDIN_CONSOLE */

static int native_posix_console_init(void)
{
 805e3cc:	55                   	push   %ebp
 805e3cd:	89 e5                	mov    %esp,%ebp
 805e3cf:	83 ec 08             	sub    $0x8,%esp
	setvbuf(stdout, NULL, _IOLBF, 512);
 805e3d2:	68 00 02 00 00       	push   $0x200
 805e3d7:	6a 01                	push   $0x1
 805e3d9:	6a 00                	push   $0x0
 805e3db:	ff 35 04 77 06 08    	push   0x8067704
 805e3e1:	e8 ea ae fe ff       	call   80492d0 <setvbuf@plt>
 805e3e6:	83 c4 10             	add    $0x10,%esp
	setvbuf(stderr, NULL, _IOLBF, 512);
 805e3e9:	68 00 02 00 00       	push   $0x200
 805e3ee:	6a 01                	push   $0x1
 805e3f0:	6a 00                	push   $0x0
 805e3f2:	ff 35 00 77 06 08    	push   0x8067700
 805e3f8:	e8 d3 ae fe ff       	call   80492d0 <setvbuf@plt>
	__printk_hook_install(putchar);
 805e3fd:	c7 04 24 20 91 04 08 	movl   $0x8049120,(%esp)
 805e404:	e8 8c ba fe ff       	call   8049e95 <__printk_hook_install>
 805e409:	83 c4 10             	add    $0x10,%esp
#if defined(CONFIG_NATIVE_POSIX_STDOUT_CONSOLE)
	native_posix_stdout_init();
#endif

	return 0;
}
 805e40c:	31 c0                	xor    %eax,%eax
 805e40e:	c9                   	leave  
 805e40f:	c3                   	ret    

0805e410 <entropy_native_posix_get_entropy>:
static unsigned int seed = 0x5678;

static int entropy_native_posix_get_entropy(const struct device *dev,
					    uint8_t *buffer,
					    uint16_t length)
{
 805e410:	55                   	push   %ebp
 805e411:	89 e5                	mov    %esp,%ebp
 805e413:	57                   	push   %edi
 805e414:	56                   	push   %esi
 805e415:	53                   	push   %ebx
 805e416:	83 ec 2c             	sub    $0x2c,%esp
 805e419:	8b 55 0c             	mov    0xc(%ebp),%edx
 805e41c:	8b 5d 10             	mov    0x10(%ebp),%ebx
 805e41f:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 805e425:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 805e428:	31 c0                	xor    %eax,%eax
	ARG_UNUSED(dev);

	while (length) {
 805e42a:	66 85 db             	test   %bx,%bx
 805e42d:	74 27                	je     805e456 <entropy_native_posix_get_entropy+0x46>
 805e42f:	89 55 d4             	mov    %edx,-0x2c(%ebp)
  return __builtin___memcpy_chk (__dest, __src, __len,
 805e432:	8d 75 e0             	lea    -0x20(%ebp),%esi
		/*
		 * Note that only 1 thread (Zephyr thread or HW models), runs at
		 * a time, therefore there is no need to use random_r()
		 */
		long int value = random();
 805e435:	e8 56 ac fe ff       	call   8049090 <random@plt>
 805e43a:	8b 7d d4             	mov    -0x2c(%ebp),%edi
 805e43d:	89 45 e0             	mov    %eax,-0x20(%ebp)

		size_t to_copy = MIN(length, sizeof(long int));
 805e440:	b8 04 00 00 00       	mov    $0x4,%eax
 805e445:	66 39 c3             	cmp    %ax,%bx
 805e448:	0f 46 c3             	cmovbe %ebx,%eax
 805e44b:	0f b7 c8             	movzwl %ax,%ecx

		memcpy(buffer, &value, to_copy);
		buffer += to_copy;
		length -= to_copy;
 805e44e:	29 c3                	sub    %eax,%ebx
 805e450:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
		buffer += to_copy;
 805e452:	89 fa                	mov    %edi,%edx
		length -= to_copy;
 805e454:	eb d4                	jmp    805e42a <entropy_native_posix_get_entropy+0x1a>
	}

	return 0;
}
 805e456:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 805e459:	65 2b 05 14 00 00 00 	sub    %gs:0x14,%eax
 805e460:	74 05                	je     805e467 <entropy_native_posix_get_entropy+0x57>
 805e462:	e8 99 ae fe ff       	call   8049300 <__stack_chk_fail@plt>
 805e467:	83 c4 2c             	add    $0x2c,%esp
 805e46a:	31 c0                	xor    %eax,%eax
 805e46c:	5b                   	pop    %ebx
 805e46d:	5e                   	pop    %esi
 805e46e:	5f                   	pop    %edi
 805e46f:	5d                   	pop    %ebp
 805e470:	c3                   	ret    

0805e471 <entropy_native_posix_get_entropy_isr>:

static int entropy_native_posix_get_entropy_isr(const struct device *dev,
						uint8_t *buf,
						uint16_t len, uint32_t flags)
{
 805e471:	55                   	push   %ebp
 805e472:	89 e5                	mov    %esp,%ebp

	/*
	 * entropy_native_posix_get_entropy() is also safe for ISRs
	 * and always produces data.
	 */
	return entropy_native_posix_get_entropy(dev, buf, len);
 805e474:	0f b7 45 10          	movzwl 0x10(%ebp),%eax
 805e478:	89 45 10             	mov    %eax,0x10(%ebp)
}
 805e47b:	5d                   	pop    %ebp
	return entropy_native_posix_get_entropy(dev, buf, len);
 805e47c:	e9 8f ff ff ff       	jmp    805e410 <entropy_native_posix_get_entropy>

0805e481 <entropy_native_posix_init>:

static int entropy_native_posix_init(const struct device *dev)
{
 805e481:	55                   	push   %ebp
 805e482:	89 e5                	mov    %esp,%ebp
 805e484:	83 ec 14             	sub    $0x14,%esp
	ARG_UNUSED(dev);
	srandom(seed);
 805e487:	ff 35 d4 73 06 08    	push   0x80673d4
 805e48d:	e8 1e ae fe ff       	call   80492b0 <srandom@plt>
	posix_print_warning("WARNING: "
 805e492:	c7 04 24 58 3e 06 08 	movl   $0x8063e58,(%esp)
 805e499:	e8 31 01 ff ff       	call   804e5cf <posix_print_warning>
 805e49e:	83 c4 10             	add    $0x10,%esp
			    "Using a test - not safe - entropy source\n");
	return 0;
}
 805e4a1:	31 c0                	xor    %eax,%eax
 805e4a3:	c9                   	leave  
 805e4a4:	c3                   	ret    

0805e4a5 <add_fake_entropy_option>:
		    NULL, NULL,
		    PRE_KERNEL_1, CONFIG_ENTROPY_INIT_PRIORITY,
		    &entropy_native_posix_api_funcs);

static void add_fake_entropy_option(void)
{
 805e4a5:	55                   	push   %ebp
 805e4a6:	89 e5                	mov    %esp,%ebp
 805e4a8:	83 ec 14             	sub    $0x14,%esp
		"A 32-bit integer seed value for the entropy device, such as "
		"97229 (decimal), 0x17BCD (hex), or 0275715 (octal)"},
		ARG_TABLE_ENDMARKER
	};

	native_add_command_line_opts(entropy_options);
 805e4ab:	68 00 67 06 08       	push   $0x8066700
 805e4b0:	e8 36 08 ff ff       	call   804eceb <native_add_command_line_opts>
 805e4b5:	83 c4 10             	add    $0x10,%esp
}
 805e4b8:	c9                   	leave  
 805e4b9:	c3                   	ret    

0805e4ba <eth_init>:

static int eth_init(const struct device *dev)
{
	ARG_UNUSED(dev);
	return 0;
}
 805e4ba:	31 c0                	xor    %eax,%eax
 805e4bc:	c3                   	ret    

0805e4bd <eth_posix_native_get_capabilities>:
#endif
#if defined(CONFIG_NET_LLDP)
		| ETHERNET_LLDP
#endif
		;
}
 805e4bd:	b8 00 00 08 00       	mov    $0x80000,%eax
 805e4c2:	c3                   	ret    

0805e4c3 <eth_stop_device>:

	return ret;
}

static int eth_stop_device(const struct device *dev)
{
 805e4c3:	55                   	push   %ebp
 805e4c4:	89 e5                	mov    %esp,%ebp
	struct eth_context *context = dev->data;
 805e4c6:	8b 45 08             	mov    0x8(%ebp),%eax
 805e4c9:	8b 40 10             	mov    0x10(%eax),%eax

	context->status = false;
 805e4cc:	c6 80 fd 0b 00 00 00 	movb   $0x0,0xbfd(%eax)

	return eth_if_down(context->if_name);
 805e4d3:	8b 80 e8 0b 00 00    	mov    0xbe8(%eax),%eax
 805e4d9:	89 45 08             	mov    %eax,0x8(%ebp)
}
 805e4dc:	5d                   	pop    %ebp
	return eth_if_down(context->if_name);
 805e4dd:	e9 18 04 00 00       	jmp    805e8fa <eth_if_down>

0805e4e2 <eth_start_device>:
{
 805e4e2:	55                   	push   %ebp
 805e4e3:	89 e5                	mov    %esp,%ebp
 805e4e5:	56                   	push   %esi
	struct eth_context *context = dev->data;
 805e4e6:	8b 45 08             	mov    0x8(%ebp),%eax
{
 805e4e9:	53                   	push   %ebx
	struct eth_context *context = dev->data;
 805e4ea:	8b 70 10             	mov    0x10(%eax),%esi
	ret = eth_if_up(context->if_name);
 805e4ed:	83 ec 0c             	sub    $0xc,%esp
	context->status = true;
 805e4f0:	c6 86 fd 0b 00 00 01 	movb   $0x1,0xbfd(%esi)
	ret = eth_if_up(context->if_name);
 805e4f7:	ff b6 e8 0b 00 00    	push   0xbe8(%esi)
 805e4fd:	e8 f5 03 00 00       	call   805e8f7 <eth_if_up>
 805e502:	5a                   	pop    %edx
	eth_setup_host(context->if_name);
 805e503:	ff b6 e8 0b 00 00    	push   0xbe8(%esi)
	ret = eth_if_up(context->if_name);
 805e509:	89 c3                	mov    %eax,%ebx
	eth_setup_host(context->if_name);
 805e50b:	e8 17 03 00 00       	call   805e827 <eth_setup_host>
 805e510:	83 c4 10             	add    $0x10,%esp
}
 805e513:	8d 65 f8             	lea    -0x8(%ebp),%esp
 805e516:	89 d8                	mov    %ebx,%eax
 805e518:	5b                   	pop    %ebx
 805e519:	5e                   	pop    %esi
 805e51a:	5d                   	pop    %ebp
 805e51b:	c3                   	ret    

0805e51c <eth_iface_init>:
{
 805e51c:	55                   	push   %ebp
 805e51d:	89 e5                	mov    %esp,%ebp
 805e51f:	56                   	push   %esi
 805e520:	8b 75 08             	mov    0x8(%ebp),%esi
 805e523:	53                   	push   %ebx
	return iface->if_dev->dev;
 805e524:	8b 06                	mov    (%esi),%eax
	struct eth_context *ctx = net_if_get_device(iface)->data;
 805e526:	8b 00                	mov    (%eax),%eax
 805e528:	8b 58 10             	mov    0x10(%eax),%ebx
	ctx->ll_addr.addr = ctx->mac_addr;
 805e52b:	8d 83 d4 0b 00 00    	lea    0xbd4(%ebx),%eax
	if (ctx->iface == NULL) {
 805e531:	83 bb e4 0b 00 00 00 	cmpl   $0x0,0xbe4(%ebx)
	ctx->ll_addr.len = sizeof(ctx->mac_addr);
 805e538:	c6 83 e0 0b 00 00 06 	movb   $0x6,0xbe0(%ebx)
	ctx->ll_addr.addr = ctx->mac_addr;
 805e53f:	89 83 dc 0b 00 00    	mov    %eax,0xbdc(%ebx)
	if (ctx->iface == NULL) {
 805e545:	75 06                	jne    805e54d <eth_iface_init+0x31>
		ctx->iface = iface;
 805e547:	89 b3 e4 0b 00 00    	mov    %esi,0xbe4(%ebx)
	ethernet_init(iface);
 805e54d:	83 ec 0c             	sub    $0xc,%esp
 805e550:	56                   	push   %esi
 805e551:	e8 bd 12 ff ff       	call   804f813 <ethernet_init>
 805e556:	83 c4 10             	add    $0x10,%esp
	if (ctx->init_done) {
 805e559:	80 bb fc 0b 00 00 00 	cmpb   $0x0,0xbfc(%ebx)
 805e560:	0f 85 bc 00 00 00    	jne    805e622 <eth_iface_init+0x106>
	ctx->init_done = true;
 805e566:	c6 83 fc 0b 00 00 01 	movb   $0x1,0xbfc(%ebx)
 805e56d:	e8 ae 09 ff ff       	call   804ef20 <z_impl_sys_rand32_get>
	ctx->mac_addr[4] = 0x53;
 805e572:	c6 83 d8 0b 00 00 53 	movb   $0x53,0xbd8(%ebx)
	/* Set MAC address locally administered, unicast (LAA) */
	mac_addr[0] |= 0x02;

	mac_addr[3] = (entropy >> 16) & 0xff;
	mac_addr[4] = (entropy >>  8) & 0xff;
	mac_addr[5] = (entropy >>  0) & 0xff;
 805e579:	88 83 d9 0b 00 00    	mov    %al,0xbd9(%ebx)
	if (ctx->mac_addr[5] == 0xff) {
 805e57f:	fe c0                	inc    %al
	mac_addr[0] |= 0x02;
 805e581:	c7 83 d4 0b 00 00 02 	movl   $0x5e0002,0xbd4(%ebx)
 805e588:	00 5e 00 
 805e58b:	75 07                	jne    805e594 <eth_iface_init+0x78>
		ctx->mac_addr[5] = 0x01;
 805e58d:	c6 83 d9 0b 00 00 01 	movb   $0x1,0xbd9(%ebx)
		ctx->if_name = ETH_NATIVE_POSIX_DRV_NAME;
 805e594:	c7 83 e8 0b 00 00 05 	movl   $0x8063f05,0xbe8(%ebx)
 805e59b:	3f 06 08 
	return net_if_set_link_addr_locked(iface, addr, len, type);
 805e59e:	6a 03                	push   $0x3
	net_if_set_link_addr(iface, ll_addr->addr, ll_addr->len,
 805e5a0:	0f b6 83 e0 0b 00 00 	movzbl 0xbe0(%ebx),%eax
 805e5a7:	50                   	push   %eax
 805e5a8:	ff b3 dc 0b 00 00    	push   0xbdc(%ebx)
 805e5ae:	56                   	push   %esi
 805e5af:	e8 68 2a ff ff       	call   805101c <net_if_set_link_addr_locked>
 805e5b4:	58                   	pop    %eax
 805e5b5:	5a                   	pop    %edx
	ctx->dev_fd = eth_iface_create(ctx->if_name, false);
 805e5b6:	6a 00                	push   $0x0
 805e5b8:	ff b3 e8 0b 00 00    	push   0xbe8(%ebx)
 805e5be:	e8 b0 01 00 00       	call   805e773 <eth_iface_create>
 805e5c3:	83 c4 10             	add    $0x10,%esp
 805e5c6:	89 83 f8 0b 00 00    	mov    %eax,0xbf8(%ebx)
	if (ctx->dev_fd < 0) {
 805e5cc:	85 c0                	test   %eax,%eax
 805e5ce:	78 52                	js     805e622 <eth_iface_init+0x106>
	k_thread_create(ctx->rx_thread,
 805e5d0:	8b 8b f4 0b 00 00    	mov    0xbf4(%ebx),%ecx
			ctx->rx_stack,
 805e5d6:	8b 93 f0 0b 00 00    	mov    0xbf0(%ebx),%edx
	k_thread_create(ctx->rx_thread,
 805e5dc:	8b 83 ec 0b 00 00    	mov    0xbec(%ebx),%eax
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
 805e5e2:	56                   	push   %esi
 805e5e3:	6a 00                	push   $0x0
 805e5e5:	6a 00                	push   $0x0
 805e5e7:	6a 00                	push   $0x0
 805e5e9:	6a fe                	push   $0xfffffffe
 805e5eb:	6a 00                	push   $0x0
 805e5ed:	6a 00                	push   $0x0
 805e5ef:	53                   	push   %ebx
 805e5f0:	68 ae e6 05 08       	push   $0x805e6ae
 805e5f5:	51                   	push   %ecx
 805e5f6:	52                   	push   %edx
 805e5f7:	50                   	push   %eax
 805e5f8:	e8 2e 0a 00 00       	call   805f02b <z_impl_k_thread_create>
 805e5fd:	83 c4 24             	add    $0x24,%esp
		eth_setup_host(ctx->if_name);
 805e600:	ff b3 e8 0b 00 00    	push   0xbe8(%ebx)
 805e606:	e8 1c 02 00 00       	call   805e827 <eth_setup_host>
		eth_start_script(ctx->if_name);
 805e60b:	8b 83 e8 0b 00 00    	mov    0xbe8(%ebx),%eax
		eth_setup_host(ctx->if_name);
 805e611:	83 c4 10             	add    $0x10,%esp
		eth_start_script(ctx->if_name);
 805e614:	89 45 08             	mov    %eax,0x8(%ebp)
}
 805e617:	8d 65 f8             	lea    -0x8(%ebp),%esp
 805e61a:	5b                   	pop    %ebx
 805e61b:	5e                   	pop    %esi
 805e61c:	5d                   	pop    %ebp
		eth_start_script(ctx->if_name);
 805e61d:	e9 08 02 00 00       	jmp    805e82a <eth_start_script>
}
 805e622:	8d 65 f8             	lea    -0x8(%ebp),%esp
 805e625:	5b                   	pop    %ebx
 805e626:	5e                   	pop    %esi
 805e627:	5d                   	pop    %ebp
 805e628:	c3                   	ret    

0805e629 <set_config>:
{
 805e629:	55                   	push   %ebp
 805e62a:	89 e5                	mov    %esp,%ebp
	} else if (type == ETHERNET_CONFIG_TYPE_MAC_ADDRESS) {
 805e62c:	83 7d 0c 03          	cmpl   $0x3,0xc(%ebp)
{
 805e630:	8b 55 10             	mov    0x10(%ebp),%edx
	} else if (type == ETHERNET_CONFIG_TYPE_MAC_ADDRESS) {
 805e633:	75 19                	jne    805e64e <set_config+0x25>
 805e635:	8b 45 08             	mov    0x8(%ebp),%eax
 805e638:	8b 0a                	mov    (%edx),%ecx
 805e63a:	8b 40 10             	mov    0x10(%eax),%eax
 805e63d:	89 88 d4 0b 00 00    	mov    %ecx,0xbd4(%eax)
 805e643:	66 8b 52 04          	mov    0x4(%edx),%dx
 805e647:	66 89 90 d8 0b 00 00 	mov    %dx,0xbd8(%eax)
}
 805e64e:	31 c0                	xor    %eax,%eax
 805e650:	5d                   	pop    %ebp
 805e651:	c3                   	ret    

0805e652 <eth_send>:
{
 805e652:	55                   	push   %ebp
 805e653:	89 e5                	mov    %esp,%ebp
 805e655:	57                   	push   %edi
 805e656:	56                   	push   %esi
 805e657:	53                   	push   %ebx
	size_t bytes = 0;
 805e658:	31 db                	xor    %ebx,%ebx
 805e65a:	83 ec 0c             	sub    $0xc,%esp
	struct eth_context *ctx = dev->data;
 805e65d:	8b 45 08             	mov    0x8(%ebp),%eax
{
 805e660:	8b 55 0c             	mov    0xc(%ebp),%edx
	struct eth_context *ctx = dev->data;
 805e663:	8b 70 10             	mov    0x10(%eax),%esi
	int count = net_pkt_get_len(pkt);
 805e666:	8b 42 08             	mov    0x8(%edx),%eax
	while (buf) {
 805e669:	85 c0                	test   %eax,%eax
 805e66b:	74 0b                	je     805e678 <eth_send+0x26>
		bytes += buf->len;
 805e66d:	0f b7 48 10          	movzwl 0x10(%eax),%ecx
		buf = buf->frags;
 805e671:	8b 40 04             	mov    0x4(%eax),%eax
		bytes += buf->len;
 805e674:	01 cb                	add    %ecx,%ebx
		buf = buf->frags;
 805e676:	eb f1                	jmp    805e669 <eth_send+0x17>
	ret = net_pkt_read(pkt, ctx->send, count);
 805e678:	8d be ea 05 00 00    	lea    0x5ea(%esi),%edi
 805e67e:	51                   	push   %ecx
 805e67f:	53                   	push   %ebx
 805e680:	57                   	push   %edi
 805e681:	52                   	push   %edx
 805e682:	e8 93 6e ff ff       	call   805551a <net_pkt_read>
 805e687:	83 c4 10             	add    $0x10,%esp
	if (ret) {
 805e68a:	85 c0                	test   %eax,%eax
 805e68c:	75 18                	jne    805e6a6 <eth_send+0x54>
	ret = eth_write_data(ctx->dev_fd, ctx->send, count);
 805e68e:	50                   	push   %eax
 805e68f:	53                   	push   %ebx
 805e690:	57                   	push   %edi
 805e691:	ff b6 f8 0b 00 00    	push   0xbf8(%esi)
 805e697:	e8 56 02 00 00       	call   805e8f2 <eth_write_data>
	return ret < 0 ? ret : 0;
 805e69c:	31 d2                	xor    %edx,%edx
	ret = eth_write_data(ctx->dev_fd, ctx->send, count);
 805e69e:	83 c4 10             	add    $0x10,%esp
	return ret < 0 ? ret : 0;
 805e6a1:	85 c0                	test   %eax,%eax
 805e6a3:	0f 4f c2             	cmovg  %edx,%eax
}
 805e6a6:	8d 65 f4             	lea    -0xc(%ebp),%esp
 805e6a9:	5b                   	pop    %ebx
 805e6aa:	5e                   	pop    %esi
 805e6ab:	5f                   	pop    %edi
 805e6ac:	5d                   	pop    %ebp
 805e6ad:	c3                   	ret    

0805e6ae <eth_rx>:
{
 805e6ae:	55                   	push   %ebp
 805e6af:	89 e5                	mov    %esp,%ebp
 805e6b1:	57                   	push   %edi
 805e6b2:	56                   	push   %esi
 805e6b3:	53                   	push   %ebx
 805e6b4:	83 ec 0c             	sub    $0xc,%esp
 805e6b7:	8b 5d 08             	mov    0x8(%ebp),%ebx
		if (net_if_is_up(ctx->iface)) {
 805e6ba:	8b 83 e4 0b 00 00    	mov    0xbe4(%ebx),%eax
	if (iface == NULL) {
 805e6c0:	85 c0                	test   %eax,%eax
 805e6c2:	75 10                	jne    805e6d4 <eth_rx+0x26>
	return z_impl_k_sleep(timeout);
 805e6c4:	57                   	push   %edi
 805e6c5:	57                   	push   %edi
 805e6c6:	6a 00                	push   $0x0
 805e6c8:	6a 05                	push   $0x5
 805e6ca:	e8 cf 1e 00 00       	call   806059e <z_impl_k_sleep>
 805e6cf:	83 c4 10             	add    $0x10,%esp
 805e6d2:	eb e6                	jmp    805e6ba <eth_rx+0xc>
 805e6d4:	8b 10                	mov    (%eax),%edx
 805e6d6:	8b 52 0c             	mov    0xc(%edx),%edx
	return net_if_flag_is_set(iface, NET_IF_UP) &&
 805e6d9:	80 e2 01             	and    $0x1,%dl
 805e6dc:	74 e6                	je     805e6c4 <eth_rx+0x16>
 805e6de:	8b 00                	mov    (%eax),%eax
 805e6e0:	8b 40 0c             	mov    0xc(%eax),%eax
 805e6e3:	0f ba e0 08          	bt     $0x8,%eax
 805e6e7:	73 db                	jae    805e6c4 <eth_rx+0x16>
			while (!eth_wait_data(ctx->dev_fd)) {
 805e6e9:	83 ec 0c             	sub    $0xc,%esp
 805e6ec:	ff b3 f8 0b 00 00    	push   0xbf8(%ebx)
 805e6f2:	e8 36 01 00 00       	call   805e82d <eth_wait_data>
 805e6f7:	83 c4 10             	add    $0x10,%esp
 805e6fa:	85 c0                	test   %eax,%eax
 805e6fc:	75 c6                	jne    805e6c4 <eth_rx+0x16>
	count = eth_read_data(fd, ctx->recv, sizeof(ctx->recv));
 805e6fe:	56                   	push   %esi
 805e6ff:	68 ea 05 00 00       	push   $0x5ea
 805e704:	53                   	push   %ebx
 805e705:	ff b3 f8 0b 00 00    	push   0xbf8(%ebx)
 805e70b:	e8 dd 01 00 00       	call   805e8ed <eth_read_data>
 805e710:	83 c4 10             	add    $0x10,%esp
 805e713:	89 c7                	mov    %eax,%edi
	if (count <= 0) {
 805e715:	85 c0                	test   %eax,%eax
 805e717:	7e 50                	jle    805e769 <eth_rx+0xbb>
	pkt = net_pkt_rx_alloc_with_buffer(ctx->iface, count,
 805e719:	51                   	push   %ecx
 805e71a:	51                   	push   %ecx
 805e71b:	6a 00                	push   $0x0
 805e71d:	6a 0a                	push   $0xa
 805e71f:	6a 00                	push   $0x0
 805e721:	6a 00                	push   $0x0
 805e723:	50                   	push   %eax
 805e724:	ff b3 e4 0b 00 00    	push   0xbe4(%ebx)
 805e72a:	e8 0d 6c ff ff       	call   805533c <net_pkt_rx_alloc_with_buffer>
 805e72f:	83 c4 20             	add    $0x20,%esp
 805e732:	89 c6                	mov    %eax,%esi
	if (!pkt) {
 805e734:	85 c0                	test   %eax,%eax
 805e736:	74 31                	je     805e769 <eth_rx+0xbb>
	if (net_pkt_write(pkt, ctx->recv, count)) {
 805e738:	52                   	push   %edx
 805e739:	57                   	push   %edi
 805e73a:	53                   	push   %ebx
 805e73b:	50                   	push   %eax
 805e73c:	e8 38 71 ff ff       	call   8055879 <net_pkt_write>
 805e741:	83 c4 10             	add    $0x10,%esp
 805e744:	85 c0                	test   %eax,%eax
 805e746:	75 15                	jne    805e75d <eth_rx+0xaf>
	if (net_recv_data(iface, pkt) < 0) {
 805e748:	50                   	push   %eax
 805e749:	50                   	push   %eax
 805e74a:	56                   	push   %esi
 805e74b:	ff b3 e4 0b 00 00    	push   0xbe4(%ebx)
 805e751:	e8 ea 1e ff ff       	call   8050640 <net_recv_data>
 805e756:	83 c4 10             	add    $0x10,%esp
 805e759:	85 c0                	test   %eax,%eax
 805e75b:	79 0c                	jns    805e769 <eth_rx+0xbb>
		net_pkt_unref(pkt);
 805e75d:	83 ec 0c             	sub    $0xc,%esp
 805e760:	56                   	push   %esi
 805e761:	e8 82 66 ff ff       	call   8054de8 <net_pkt_unref>
 805e766:	83 c4 10             	add    $0x10,%esp
	z_impl_k_yield();
 805e769:	e8 02 1d 00 00       	call   8060470 <z_impl_k_yield>
}
 805e76e:	e9 76 ff ff ff       	jmp    805e6e9 <eth_rx+0x3b>

0805e773 <eth_iface_create>:

/* Note that we cannot create the TUN/TAP device from the setup script
 * as we need to get a file descriptor to communicate with the interface.
 */
int eth_iface_create(const char *if_name, bool tun_only)
{
 805e773:	55                   	push   %ebp
 805e774:	89 e5                	mov    %esp,%ebp
 805e776:	57                   	push   %edi
 805e777:	56                   	push   %esi
 805e778:	53                   	push   %ebx
 805e779:	83 ec 54             	sub    $0x54,%esp
 805e77c:	8b 45 08             	mov    0x8(%ebp),%eax
 805e77f:	89 45 b4             	mov    %eax,-0x4c(%ebp)
 805e782:	8b 45 0c             	mov    0xc(%ebp),%eax
 805e785:	89 45 b0             	mov    %eax,-0x50(%ebp)
 805e788:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 805e78e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 805e791:	31 c0                	xor    %eax,%eax
      if (__OPEN_NEEDS_MODE (__oflag) && __va_arg_pack_len () < 1)
	{
	  __open_missing_mode ();
	  return __open_2 (__path, __oflag);
	}
      return __open_alias (__path, __oflag, __va_arg_pack ());
 805e793:	6a 02                	push   $0x2
 805e795:	68 1a 3f 06 08       	push   $0x8063f1a
 805e79a:	e8 c1 a8 fe ff       	call   8049060 <open@plt>
 805e79f:	83 c4 10             	add    $0x10,%esp
	struct ifreq ifr;
	int fd, ret = -EINVAL;

	fd = open(ETH_NATIVE_POSIX_DEV_NAME, O_RDWR);
	if (fd < 0) {
 805e7a2:	85 c0                	test   %eax,%eax
 805e7a4:	79 0b                	jns    805e7b1 <eth_iface_create+0x3e>
		return -errno;
 805e7a6:	e8 95 a8 fe ff       	call   8049040 <__errno_location@plt>
 805e7ab:	8b 18                	mov    (%eax),%ebx
 805e7ad:	f7 db                	neg    %ebx
 805e7af:	eb 5b                	jmp    805e80c <eth_iface_create+0x99>
  return __builtin___memset_chk (__dest, __ch, __len,
 805e7b1:	8d 55 d0             	lea    -0x30(%ebp),%edx
 805e7b4:	89 c3                	mov    %eax,%ebx
 805e7b6:	b9 05 00 00 00       	mov    $0x5,%ecx
 805e7bb:	31 c0                	xor    %eax,%eax
 805e7bd:	89 d7                	mov    %edx,%edi
	}

	(void)memset(&ifr, 0, sizeof(ifr));

#ifdef __linux
	ifr.ifr_flags = (tun_only ? IFF_TUN : IFF_TAP) | IFF_NO_PI;
 805e7bf:	0f b6 55 b0          	movzbl -0x50(%ebp),%edx
 805e7c3:	8d 75 c4             	lea    -0x3c(%ebp),%esi
 805e7c6:	f3 ab                	rep stos %eax,%es:(%edi)
 805e7c8:	b8 02 10 00 00       	mov    $0x1002,%eax
 805e7cd:	29 d0                	sub    %edx,%eax
 805e7cf:	66 89 45 d4          	mov    %ax,-0x2c(%ebp)
  return __builtin___strncpy_chk (__dest, __src, __len,
 805e7d3:	50                   	push   %eax
 805e7d4:	6a 0f                	push   $0xf
 805e7d6:	ff 75 b4             	push   -0x4c(%ebp)
 805e7d9:	56                   	push   %esi
 805e7da:	e8 31 a9 fe ff       	call   8049110 <strncpy@plt>
 805e7df:	83 c4 0c             	add    $0xc,%esp

	strncpy(ifr.ifr_name, if_name, IFNAMSIZ - 1);

	ret = ioctl(fd, TUNSETIFF, (void *)&ifr);
 805e7e2:	56                   	push   %esi
 805e7e3:	68 ca 54 04 40       	push   $0x400454ca
 805e7e8:	53                   	push   %ebx
 805e7e9:	e8 f2 a9 fe ff       	call   80491e0 <ioctl@plt>
 805e7ee:	83 c4 10             	add    $0x10,%esp
	if (ret < 0) {
 805e7f1:	85 c0                	test   %eax,%eax
 805e7f3:	79 17                	jns    805e80c <eth_iface_create+0x99>
		ret = -errno;
 805e7f5:	e8 46 a8 fe ff       	call   8049040 <__errno_location@plt>
		close(fd);
 805e7fa:	83 ec 0c             	sub    $0xc,%esp
		ret = -errno;
 805e7fd:	8b 30                	mov    (%eax),%esi
		close(fd);
 805e7ff:	53                   	push   %ebx
		ret = -errno;
 805e800:	f7 de                	neg    %esi
		close(fd);
 805e802:	e8 b9 aa fe ff       	call   80492c0 <close@plt>
		return ret;
 805e807:	89 f3                	mov    %esi,%ebx
		close(fd);
 805e809:	83 c4 10             	add    $0x10,%esp
	}
#endif

	return fd;
}
 805e80c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 805e80f:	65 2b 05 14 00 00 00 	sub    %gs:0x14,%eax
 805e816:	74 05                	je     805e81d <eth_iface_create+0xaa>
 805e818:	e8 e3 aa fe ff       	call   8049300 <__stack_chk_fail@plt>
 805e81d:	8d 65 f4             	lea    -0xc(%ebp),%esp
 805e820:	89 d8                	mov    %ebx,%eax
 805e822:	5b                   	pop    %ebx
 805e823:	5e                   	pop    %esi
 805e824:	5f                   	pop    %edi
 805e825:	5d                   	pop    %ebp
 805e826:	c3                   	ret    

0805e827 <eth_setup_host>:
	 * check that situation in the script itself so that the -i option
	 * we add here is ignored in that case.
	 */
	return ssystem("%s -i %s", ETH_NATIVE_POSIX_SETUP_SCRIPT,
		       if_name);
}
 805e827:	31 c0                	xor    %eax,%eax
 805e829:	c3                   	ret    

0805e82a <eth_start_script>:
 805e82a:	31 c0                	xor    %eax,%eax
 805e82c:	c3                   	ret    

0805e82d <eth_wait_data>:
			       if_name);
	}
}

int eth_wait_data(int fd)
{
 805e82d:	55                   	push   %ebp
	struct timeval timeout;
	fd_set rset;
	int ret;

	FD_ZERO(&rset);
 805e82e:	b9 20 00 00 00       	mov    $0x20,%ecx
{
 805e833:	89 e5                	mov    %esp,%ebp
 805e835:	57                   	push   %edi
 805e836:	56                   	push   %esi
	FD_ZERO(&rset);
 805e837:	8d 95 64 ff ff ff    	lea    -0x9c(%ebp),%edx
{
 805e83d:	53                   	push   %ebx
	FD_ZERO(&rset);
 805e83e:	89 d7                	mov    %edx,%edi

	FD_SET(fd, &rset);
 805e840:	bb 01 00 00 00       	mov    $0x1,%ebx
{
 805e845:	81 ec a8 00 00 00    	sub    $0xa8,%esp
 805e84b:	8b 75 08             	mov    0x8(%ebp),%esi
 805e84e:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 805e854:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 805e857:	31 c0                	xor    %eax,%eax
	FD_ZERO(&rset);
 805e859:	f3 ab                	rep stos %eax,%es:(%edi)
	FD_SET(fd, &rset);
 805e85b:	56                   	push   %esi
 805e85c:	e8 9f ab fe ff       	call   8049400 <__fdelt_chk@plt>
 805e861:	89 f1                	mov    %esi,%ecx

	timeout.tv_sec = 0;
	timeout.tv_usec = 0;

	ret = select(fd + 1, &rset, NULL, NULL, &timeout);
 805e863:	8d 95 64 ff ff ff    	lea    -0x9c(%ebp),%edx
	timeout.tv_sec = 0;
 805e869:	c7 85 5c ff ff ff 00 	movl   $0x0,-0xa4(%ebp)
 805e870:	00 00 00 
	timeout.tv_usec = 0;
 805e873:	c7 85 60 ff ff ff 00 	movl   $0x0,-0xa0(%ebp)
 805e87a:	00 00 00 
	FD_SET(fd, &rset);
 805e87d:	d3 e3                	shl    %cl,%ebx
 805e87f:	09 9c 85 64 ff ff ff 	or     %ebx,-0x9c(%ebp,%eax,4)
	ret = select(fd + 1, &rset, NULL, NULL, &timeout);
 805e886:	8d 85 5c ff ff ff    	lea    -0xa4(%ebp),%eax
 805e88c:	89 04 24             	mov    %eax,(%esp)
 805e88f:	8d 46 01             	lea    0x1(%esi),%eax
 805e892:	6a 00                	push   $0x0
 805e894:	6a 00                	push   $0x0
 805e896:	52                   	push   %edx
 805e897:	50                   	push   %eax
 805e898:	e8 03 aa fe ff       	call   80492a0 <select@plt>
 805e89d:	83 c4 20             	add    $0x20,%esp
	if (ret < 0 && errno != EINTR) {
 805e8a0:	85 c0                	test   %eax,%eax
 805e8a2:	79 17                	jns    805e8bb <eth_wait_data+0x8e>
 805e8a4:	e8 97 a7 fe ff       	call   8049040 <__errno_location@plt>
 805e8a9:	8b 10                	mov    (%eax),%edx
		return -errno;
 805e8ab:	89 d0                	mov    %edx,%eax
 805e8ad:	f7 d8                	neg    %eax
	if (ret < 0 && errno != EINTR) {
 805e8af:	83 fa 04             	cmp    $0x4,%edx
 805e8b2:	75 20                	jne    805e8d4 <eth_wait_data+0xa7>
		if (FD_ISSET(fd, &rset)) {
			return 0;
		}
	}

	return -EAGAIN;
 805e8b4:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
 805e8b9:	eb 19                	jmp    805e8d4 <eth_wait_data+0xa7>
	} else if (ret > 0) {
 805e8bb:	74 f7                	je     805e8b4 <eth_wait_data+0x87>
		if (FD_ISSET(fd, &rset)) {
 805e8bd:	83 ec 0c             	sub    $0xc,%esp
 805e8c0:	56                   	push   %esi
 805e8c1:	e8 3a ab fe ff       	call   8049400 <__fdelt_chk@plt>
 805e8c6:	83 c4 10             	add    $0x10,%esp
 805e8c9:	23 9c 85 64 ff ff ff 	and    -0x9c(%ebp,%eax,4),%ebx
 805e8d0:	74 e2                	je     805e8b4 <eth_wait_data+0x87>
			return 0;
 805e8d2:	31 c0                	xor    %eax,%eax
}
 805e8d4:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 805e8d7:	65 2b 15 14 00 00 00 	sub    %gs:0x14,%edx
 805e8de:	74 05                	je     805e8e5 <eth_wait_data+0xb8>
 805e8e0:	e8 1b aa fe ff       	call   8049300 <__stack_chk_fail@plt>
 805e8e5:	8d 65 f4             	lea    -0xc(%ebp),%esp
 805e8e8:	5b                   	pop    %ebx
 805e8e9:	5e                   	pop    %esi
 805e8ea:	5f                   	pop    %edi
 805e8eb:	5d                   	pop    %ebp
 805e8ec:	c3                   	ret    

0805e8ed <eth_read_data>:
		       "the destination buffer");

__fortify_function __wur ssize_t
read (int __fd, void *__buf, size_t __nbytes)
{
  return __glibc_fortify (read, __nbytes, sizeof (char),
 805e8ed:	e9 6e a8 fe ff       	jmp    8049160 <read@plt>

0805e8f2 <eth_write_data>:
	return read(fd, buf, buf_len);
}

ssize_t eth_write_data(int fd, void *buf, size_t buf_len)
{
	return write(fd, buf, buf_len);
 805e8f2:	e9 39 a8 fe ff       	jmp    8049130 <write@plt>

0805e8f7 <eth_if_up>:
 805e8f7:	31 c0                	xor    %eax,%eax
 805e8f9:	c3                   	ret    

0805e8fa <eth_if_down>:
 805e8fa:	31 c0                	xor    %eax,%eax
 805e8fc:	c3                   	ret    

0805e8fd <np_timer_isr>:
/**
 * Interrupt handler for the timer interrupt
 * Announce to the kernel that a number of ticks have passed
 */
static void np_timer_isr(const void *arg)
{
 805e8fd:	55                   	push   %ebp
 805e8fe:	89 e5                	mov    %esp,%ebp
 805e900:	57                   	push   %edi
 805e901:	56                   	push   %esi
 805e902:	53                   	push   %ebx
 805e903:	83 ec 1c             	sub    $0x1c,%esp
	ARG_UNUSED(arg);

	uint64_t now = hwm_get_time();
 805e906:	e8 c4 f0 fe ff       	call   804d9cf <hwm_get_time>
	int32_t elapsed_ticks = (now - last_tick_time)/tick_period;
 805e90b:	8b 35 f8 88 06 08    	mov    0x80688f8,%esi
 805e911:	8b 3d fc 88 06 08    	mov    0x80688fc,%edi
 805e917:	8b 0d 00 89 06 08    	mov    0x8068900,%ecx
 805e91d:	8b 1d 04 89 06 08    	mov    0x8068904,%ebx
 805e923:	29 f0                	sub    %esi,%eax
 805e925:	19 fa                	sbb    %edi,%edx
 805e927:	53                   	push   %ebx
 805e928:	51                   	push   %ecx
 805e929:	52                   	push   %edx
 805e92a:	50                   	push   %eax
 805e92b:	89 4d e0             	mov    %ecx,-0x20(%ebp)
 805e92e:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
 805e931:	e8 1a ac fe ff       	call   8049550 <__udivdi3>
 805e936:	83 c4 10             	add    $0x10,%esp
 805e939:	89 c1                	mov    %eax,%ecx

	last_tick_time += elapsed_ticks*tick_period;
 805e93b:	99                   	cltd   
 805e93c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 805e93f:	0f af 55 e0          	imul   -0x20(%ebp),%edx
	sys_clock_announce(elapsed_ticks);
 805e943:	89 4d 08             	mov    %ecx,0x8(%ebp)
	last_tick_time += elapsed_ticks*tick_period;
 805e946:	0f af c1             	imul   %ecx,%eax
 805e949:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
 805e94c:	8b 45 e0             	mov    -0x20(%ebp),%eax
 805e94f:	f7 e1                	mul    %ecx
 805e951:	01 da                	add    %ebx,%edx
 805e953:	01 f0                	add    %esi,%eax
 805e955:	11 fa                	adc    %edi,%edx
 805e957:	a3 f8 88 06 08       	mov    %eax,0x80688f8
 805e95c:	89 15 fc 88 06 08    	mov    %edx,0x80688fc
}
 805e962:	8d 65 f4             	lea    -0xc(%ebp),%esp
 805e965:	5b                   	pop    %ebx
 805e966:	5e                   	pop    %esi
 805e967:	5f                   	pop    %edi
 805e968:	5d                   	pop    %ebp
	sys_clock_announce(elapsed_ticks);
 805e969:	e9 5e 21 00 00       	jmp    8060acc <sys_clock_announce>

0805e96e <sys_clock_driver_init>:
 * @brief Initialize system timer driver
 *
 * Enable the hw timer, setting its tick period, and setup its interrupt
 */
static int sys_clock_driver_init(void)
{
 805e96e:	55                   	push   %ebp
 805e96f:	89 e5                	mov    %esp,%ebp
 805e971:	83 ec 08             	sub    $0x8,%esp

	tick_period = 1000000ul / CONFIG_SYS_CLOCK_TICKS_PER_SEC;
 805e974:	c7 05 00 89 06 08 10 	movl   $0x2710,0x8068900
 805e97b:	27 00 00 
 805e97e:	c7 05 04 89 06 08 00 	movl   $0x0,0x8068904
 805e985:	00 00 00 

	last_tick_time = hwm_get_time();
 805e988:	e8 42 f0 fe ff       	call   804d9cf <hwm_get_time>
 805e98d:	89 15 fc 88 06 08    	mov    %edx,0x80688fc
	hwtimer_enable(tick_period);
 805e993:	52                   	push   %edx
 805e994:	52                   	push   %edx
 805e995:	ff 35 04 89 06 08    	push   0x8068904
 805e99b:	ff 35 00 89 06 08    	push   0x8068900
	last_tick_time = hwm_get_time();
 805e9a1:	a3 f8 88 06 08       	mov    %eax,0x80688f8
	hwtimer_enable(tick_period);
 805e9a6:	e8 f8 f3 fe ff       	call   804dda3 <hwtimer_enable>
 805e9ab:	83 c4 10             	add    $0x10,%esp

	IRQ_CONNECT(TIMER_TICK_IRQ, 1, np_timer_isr, 0, 0);
 805e9ae:	6a 00                	push   $0x0
 805e9b0:	68 fd e8 05 08       	push   $0x805e8fd
 805e9b5:	6a 00                	push   $0x0
 805e9b7:	6a 00                	push   $0x0
 805e9b9:	e8 8f f7 fe ff       	call   804e14d <posix_isr_declare>
 805e9be:	83 c4 0c             	add    $0xc,%esp
 805e9c1:	6a 00                	push   $0x0
 805e9c3:	6a 01                	push   $0x1
 805e9c5:	6a 00                	push   $0x0
 805e9c7:	e8 ac f7 fe ff       	call   804e178 <posix_irq_priority_set>
	irq_enable(TIMER_TICK_IRQ);
 805e9cc:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 805e9d3:	e8 0d e6 fe ff       	call   804cfe5 <arch_irq_enable>
 805e9d8:	83 c4 10             	add    $0x10,%esp

	return 0;
}
 805e9db:	31 c0                	xor    %eax,%eax
 805e9dd:	c9                   	leave  
 805e9de:	c3                   	ret    

0805e9df <sys_clock_cycle_get_32>:
{
 805e9df:	55                   	push   %ebp
 805e9e0:	89 e5                	mov    %esp,%ebp
 805e9e2:	83 ec 08             	sub    $0x8,%esp
	return hwm_get_time();
 805e9e5:	e8 e5 ef fe ff       	call   804d9cf <hwm_get_time>
}
 805e9ea:	c9                   	leave  
 805e9eb:	c3                   	ret    

0805e9ec <sys_clock_set_timeout>:
{
 805e9ec:	55                   	push   %ebp
		silent_ticks = INT64_MAX;
 805e9ed:	83 c8 ff             	or     $0xffffffff,%eax
 805e9f0:	ba ff ff ff 7f       	mov    $0x7fffffff,%edx
{
 805e9f5:	89 e5                	mov    %esp,%ebp
 805e9f7:	8b 4d 08             	mov    0x8(%ebp),%ecx
	if (ticks == K_TICKS_FOREVER) {
 805e9fa:	83 f9 ff             	cmp    $0xffffffff,%ecx
 805e9fd:	74 0c                	je     805ea0b <sys_clock_set_timeout+0x1f>
		silent_ticks = 0;
 805e9ff:	31 c0                	xor    %eax,%eax
 805ea01:	31 d2                	xor    %edx,%edx
	} else if (ticks > 0) {
 805ea03:	85 c9                	test   %ecx,%ecx
 805ea05:	7e 04                	jle    805ea0b <sys_clock_set_timeout+0x1f>
		silent_ticks = ticks - 1;
 805ea07:	8d 41 ff             	lea    -0x1(%ecx),%eax
 805ea0a:	99                   	cltd   
	hwtimer_set_silent_ticks(silent_ticks);
 805ea0b:	89 45 08             	mov    %eax,0x8(%ebp)
 805ea0e:	89 55 0c             	mov    %edx,0xc(%ebp)
}
 805ea11:	5d                   	pop    %ebp
	hwtimer_set_silent_ticks(silent_ticks);
 805ea12:	e9 a8 f5 fe ff       	jmp    804dfbf <hwtimer_set_silent_ticks>

0805ea17 <sys_clock_elapsed>:
{
 805ea17:	55                   	push   %ebp
 805ea18:	89 e5                	mov    %esp,%ebp
 805ea1a:	83 ec 08             	sub    $0x8,%esp
	return (hwm_get_time() - last_tick_time)/tick_period;
 805ea1d:	e8 ad ef fe ff       	call   804d9cf <hwm_get_time>
 805ea22:	2b 05 f8 88 06 08    	sub    0x80688f8,%eax
 805ea28:	1b 15 fc 88 06 08    	sbb    0x80688fc,%edx
 805ea2e:	ff 35 04 89 06 08    	push   0x8068904
 805ea34:	ff 35 00 89 06 08    	push   0x8068900
 805ea3a:	52                   	push   %edx
 805ea3b:	50                   	push   %eax
 805ea3c:	e8 0f ab fe ff       	call   8049550 <__udivdi3>
 805ea41:	83 c4 10             	add    $0x10,%esp
}
 805ea44:	c9                   	leave  
 805ea45:	c3                   	ret    

0805ea46 <z_device_state_init>:

	while (dev < __device_end) {
		z_object_init(dev);
		++dev;
	}
}
 805ea46:	c3                   	ret    

0805ea47 <z_device_is_ready>:
	*devices = __device_start;
	return __device_end - __device_start;
}

bool z_device_is_ready(const struct device *dev)
{
 805ea47:	55                   	push   %ebp
 805ea48:	31 c0                	xor    %eax,%eax
 805ea4a:	89 e5                	mov    %esp,%ebp
 805ea4c:	8b 55 08             	mov    0x8(%ebp),%edx
	/*
	 * if an invalid device pointer is passed as argument, this call
	 * reports the `device` as not ready for usage.
	 */
	if (dev == NULL) {
 805ea4f:	85 d2                	test   %edx,%edx
 805ea51:	74 16                	je     805ea69 <z_device_is_ready+0x22>
		return false;
	}

	return dev->state->initialized && (dev->state->init_res == 0U);
 805ea53:	8b 52 0c             	mov    0xc(%edx),%edx
 805ea56:	31 c0                	xor    %eax,%eax
 805ea58:	f6 42 01 01          	testb  $0x1,0x1(%edx)
 805ea5c:	74 08                	je     805ea66 <z_device_is_ready+0x1f>
 805ea5e:	31 c0                	xor    %eax,%eax
 805ea60:	80 3a 00             	cmpb   $0x0,(%edx)
 805ea63:	0f 94 c0             	sete   %al
 805ea66:	83 e0 01             	and    $0x1,%eax
}
 805ea69:	5d                   	pop    %ebp
 805ea6a:	c3                   	ret    

0805ea6b <z_impl_device_get_binding>:
{
 805ea6b:	55                   	push   %ebp
 805ea6c:	89 e5                	mov    %esp,%ebp
 805ea6e:	56                   	push   %esi
 805ea6f:	8b 75 08             	mov    0x8(%ebp),%esi
 805ea72:	53                   	push   %ebx
		return NULL;
 805ea73:	31 db                	xor    %ebx,%ebx
	if ((name == NULL) || (name[0] == '\0')) {
 805ea75:	85 f6                	test   %esi,%esi
 805ea77:	74 60                	je     805ead9 <z_impl_device_get_binding+0x6e>
 805ea79:	80 3e 00             	cmpb   $0x0,(%esi)
 805ea7c:	74 5b                	je     805ead9 <z_impl_device_get_binding+0x6e>
	for (dev = __device_start; dev != __device_end; dev++) {
 805ea7e:	bb 2c 74 06 08       	mov    $0x806742c,%ebx
 805ea83:	81 fb 5c 74 06 08    	cmp    $0x806745c,%ebx
 805ea89:	74 19                	je     805eaa4 <z_impl_device_get_binding+0x39>
		if (z_device_is_ready(dev) && (dev->name == name)) {
 805ea8b:	83 ec 0c             	sub    $0xc,%esp
 805ea8e:	53                   	push   %ebx
 805ea8f:	e8 b3 ff ff ff       	call   805ea47 <z_device_is_ready>
 805ea94:	83 c4 10             	add    $0x10,%esp
 805ea97:	84 c0                	test   %al,%al
 805ea99:	74 04                	je     805ea9f <z_impl_device_get_binding+0x34>
 805ea9b:	39 33                	cmp    %esi,(%ebx)
 805ea9d:	74 3a                	je     805ead9 <z_impl_device_get_binding+0x6e>
	for (dev = __device_start; dev != __device_end; dev++) {
 805ea9f:	83 c3 18             	add    $0x18,%ebx
 805eaa2:	eb df                	jmp    805ea83 <z_impl_device_get_binding+0x18>
	for (dev = __device_start; dev != __device_end; dev++) {
 805eaa4:	bb 2c 74 06 08       	mov    $0x806742c,%ebx
 805eaa9:	81 fb 5c 74 06 08    	cmp    $0x806745c,%ebx
 805eaaf:	74 26                	je     805ead7 <z_impl_device_get_binding+0x6c>
		if (z_device_is_ready(dev) && (strcmp(name, dev->name) == 0)) {
 805eab1:	83 ec 0c             	sub    $0xc,%esp
 805eab4:	53                   	push   %ebx
 805eab5:	e8 8d ff ff ff       	call   805ea47 <z_device_is_ready>
 805eaba:	83 c4 10             	add    $0x10,%esp
 805eabd:	84 c0                	test   %al,%al
 805eabf:	74 11                	je     805ead2 <z_impl_device_get_binding+0x67>
 805eac1:	50                   	push   %eax
 805eac2:	50                   	push   %eax
 805eac3:	ff 33                	push   (%ebx)
 805eac5:	56                   	push   %esi
 805eac6:	e8 f5 a8 fe ff       	call   80493c0 <strcmp@plt>
 805eacb:	83 c4 10             	add    $0x10,%esp
 805eace:	85 c0                	test   %eax,%eax
 805ead0:	74 07                	je     805ead9 <z_impl_device_get_binding+0x6e>
	for (dev = __device_start; dev != __device_end; dev++) {
 805ead2:	83 c3 18             	add    $0x18,%ebx
 805ead5:	eb d2                	jmp    805eaa9 <z_impl_device_get_binding+0x3e>
		return NULL;
 805ead7:	31 db                	xor    %ebx,%ebx
}
 805ead9:	8d 65 f8             	lea    -0x8(%ebp),%esp
 805eadc:	89 d8                	mov    %ebx,%eax
 805eade:	5b                   	pop    %ebx
 805eadf:	5e                   	pop    %esi
 805eae0:	5d                   	pop    %ebp
 805eae1:	c3                   	ret    

0805eae2 <k_sys_fatal_error_handler>:
/* LCOV_EXCL_STOP */

/* LCOV_EXCL_START */
__weak void k_sys_fatal_error_handler(unsigned int reason,
				      const z_arch_esf_t *esf)
{
 805eae2:	55                   	push   %ebp
 805eae3:	89 e5                	mov    %esp,%ebp
 805eae5:	83 ec 14             	sub    $0x14,%esp
	ARG_UNUSED(esf);

	LOG_PANIC();
	LOG_ERR("Halting system");
	arch_system_halt(reason);
 805eae8:	ff 75 08             	push   0x8(%ebp)
 805eaeb:	e8 ce e4 fe ff       	call   804cfbe <arch_system_halt>

0805eaf0 <z_fatal_error>:
	return 0;
#endif
}

void z_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
 805eaf0:	55                   	push   %ebp
 805eaf1:	89 e5                	mov    %esp,%ebp
 805eaf3:	57                   	push   %edi
 805eaf4:	56                   	push   %esi
 805eaf5:	53                   	push   %ebx
 805eaf6:	83 ec 1c             	sub    $0x1c,%esp
 805eaf9:	8b 55 0c             	mov    0xc(%ebp),%edx
 805eafc:	8b 7d 08             	mov    0x8(%ebp),%edi
 805eaff:	89 55 e4             	mov    %edx,-0x1c(%ebp)
	return posix_irq_lock();
 805eb02:	e8 18 f6 fe ff       	call   804e11f <posix_irq_lock>
 805eb07:	89 c6                	mov    %eax,%esi
	return z_impl_z_current_get();
 805eb09:	e8 c6 1a 00 00       	call   80605d4 <z_impl_z_current_get>

#ifndef CONFIG_XTENSA
	coredump(reason, esf, thread);
#endif

	k_sys_fatal_error_handler(reason, esf);
 805eb0e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 805eb11:	89 c3                	mov    %eax,%ebx
 805eb13:	50                   	push   %eax
 805eb14:	50                   	push   %eax
 805eb15:	52                   	push   %edx
 805eb16:	57                   	push   %edi
 805eb17:	e8 c6 ff ff ff       	call   805eae2 <k_sys_fatal_error_handler>
	posix_irq_unlock(key);
 805eb1c:	89 34 24             	mov    %esi,(%esp)
 805eb1f:	e8 0d f6 fe ff       	call   804e131 <posix_irq_unlock>
 805eb24:	83 c4 10             	add    $0x10,%esp
	z_impl_k_thread_abort(thread);
 805eb27:	89 5d 08             	mov    %ebx,0x8(%ebp)
	arch_irq_unlock(key);

	if (IS_ENABLED(CONFIG_MULTITHREADING)) {
		k_thread_abort(thread);
	}
}
 805eb2a:	8d 65 f4             	lea    -0xc(%ebp),%esp
 805eb2d:	5b                   	pop    %ebx
 805eb2e:	5e                   	pop    %esi
 805eb2f:	5f                   	pop    %edi
 805eb30:	5d                   	pop    %ebp
 805eb31:	e9 8c e8 fe ff       	jmp    804d3c2 <z_impl_k_thread_abort>

0805eb36 <z_sys_init_run_level>:
 * off and the next one begins.
 *
 * @param level init level to run.
 */
static void z_sys_init_run_level(enum init_level level)
{
 805eb36:	55                   	push   %ebp
 805eb37:	89 e5                	mov    %esp,%ebp
 805eb39:	57                   	push   %edi
 805eb3a:	56                   	push   %esi
 805eb3b:	53                   	push   %ebx
 805eb3c:	89 c3                	mov    %eax,%ebx
 805eb3e:	83 ec 0c             	sub    $0xc,%esp
		/* End marker */
		__init_end,
	};
	const struct init_entry *entry;

	for (entry = levels[level]; entry < levels[level+1]; entry++) {
 805eb41:	8b 34 85 18 27 06 08 	mov    0x8062718(,%eax,4),%esi
 805eb48:	39 34 9d 1c 27 06 08 	cmp    %esi,0x806271c(,%ebx,4)
 805eb4f:	76 3c                	jbe    805eb8d <z_sys_init_run_level+0x57>
		const struct device *dev = entry->dev;
 805eb51:	8b 7e 04             	mov    0x4(%esi),%edi

		if (dev != NULL) {
			int rc = entry->init_fn.dev(dev);
 805eb54:	8b 06                	mov    (%esi),%eax
		if (dev != NULL) {
 805eb56:	85 ff                	test   %edi,%edi
 805eb58:	74 2c                	je     805eb86 <z_sys_init_run_level+0x50>
			int rc = entry->init_fn.dev(dev);
 805eb5a:	83 ec 0c             	sub    $0xc,%esp
 805eb5d:	57                   	push   %edi
 805eb5e:	ff d0                	call   *%eax
 805eb60:	83 c4 10             	add    $0x10,%esp
			/* Mark device initialized.  If initialization
			 * failed, record the error condition.
			 */
			if (rc != 0) {
 805eb63:	85 c0                	test   %eax,%eax
 805eb65:	74 16                	je     805eb7d <z_sys_init_run_level+0x47>
					rc = -rc;
				}
				if (rc > UINT8_MAX) {
					rc = UINT8_MAX;
				}
				dev->state->init_res = rc;
 805eb67:	89 c2                	mov    %eax,%edx
 805eb69:	8b 4f 0c             	mov    0xc(%edi),%ecx
 805eb6c:	f7 da                	neg    %edx
 805eb6e:	0f 49 c2             	cmovns %edx,%eax
 805eb71:	ba ff 00 00 00       	mov    $0xff,%edx
 805eb76:	39 d0                	cmp    %edx,%eax
 805eb78:	0f 4f c2             	cmovg  %edx,%eax
 805eb7b:	88 01                	mov    %al,(%ecx)
			}
			dev->state->initialized = true;
 805eb7d:	8b 47 0c             	mov    0xc(%edi),%eax
 805eb80:	80 48 01 01          	orb    $0x1,0x1(%eax)
			if (rc == 0) {
 805eb84:	eb 02                	jmp    805eb88 <z_sys_init_run_level+0x52>
				/* Run automatic device runtime enablement */
				(void)pm_device_runtime_auto_enable(dev);
			}
		} else {
			(void)entry->init_fn.sys();
 805eb86:	ff d0                	call   *%eax
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
 805eb88:	83 c6 08             	add    $0x8,%esi
 805eb8b:	eb bb                	jmp    805eb48 <z_sys_init_run_level+0x12>
		}
	}
}
 805eb8d:	8d 65 f4             	lea    -0xc(%ebp),%esp
 805eb90:	5b                   	pop    %ebx
 805eb91:	5e                   	pop    %esi
 805eb92:	5f                   	pop    %edi
 805eb93:	5d                   	pop    %ebp
 805eb94:	c3                   	ret    

0805eb95 <bg_thread_main>:
 * This routine completes kernel initialization by invoking the remaining
 * init functions, then invokes application's main() routine.
 */
__boot_func
static void bg_thread_main(void *unused1, void *unused2, void *unused3)
{
 805eb95:	55                   	push   %ebp
	 */
	z_mem_manage_init();
#endif /* CONFIG_MMU */
	z_sys_post_kernel = true;

	z_sys_init_run_level(INIT_LEVEL_POST_KERNEL);
 805eb96:	b8 03 00 00 00       	mov    $0x3,%eax
{
 805eb9b:	89 e5                	mov    %esp,%ebp
 805eb9d:	83 ec 08             	sub    $0x8,%esp
	z_sys_post_kernel = true;
 805eba0:	c6 05 b4 8a 06 08 01 	movb   $0x1,0x8068ab4
	z_sys_init_run_level(INIT_LEVEL_POST_KERNEL);
 805eba7:	e8 8a ff ff ff       	call   805eb36 <z_sys_init_run_level>
#if CONFIG_STACK_POINTER_RANDOM
	z_stack_adjust_initialized = 1;
#endif
	boot_banner();
 805ebac:	e8 84 25 00 00       	call   8061135 <boot_banner>
	void z_cpp_init_static(void);
	z_cpp_init_static();
#endif

	/* Final init level before app starts */
	z_sys_init_run_level(INIT_LEVEL_APPLICATION);
 805ebb1:	b8 04 00 00 00       	mov    $0x4,%eax
 805ebb6:	e8 7b ff ff ff       	call   805eb36 <z_sys_init_run_level>

	z_init_static_threads();
 805ebbb:	e8 da 04 00 00       	call   805f09a <z_init_static_threads>
	z_mem_manage_boot_finish();
#endif /* CONFIG_MMU */

	extern int main(void);

	(void)main();
 805ebc0:	e8 96 ac fe ff       	call   804985b <_posix_zephyr_main>

	/* Mark nonessential since main() has no more work to do */
	z_main_thread.base.user_options &= ~K_ESSENTIAL;
 805ebc5:	80 25 8c 87 06 08 fe 	andb   $0xfe,0x806878c

#ifdef CONFIG_COVERAGE_DUMP
	/* Dump coverage data once the main() has exited. */
	gcov_coverage_dump();
#endif
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
 805ebcc:	c9                   	leave  
 805ebcd:	c3                   	ret    

0805ebce <z_init_cpu>:
	thread->base.is_idle = 1U;
#endif
}

void z_init_cpu(int id)
{
 805ebce:	55                   	push   %ebp
 805ebcf:	89 e5                	mov    %esp,%ebp
 805ebd1:	57                   	push   %edi
 805ebd2:	56                   	push   %esi
 805ebd3:	53                   	push   %ebx
 805ebd4:	83 ec 14             	sub    $0x14,%esp
 805ebd7:	8b 5d 08             	mov    0x8(%ebp),%ebx
	z_setup_new_thread(thread, stack,
 805ebda:	6a 00                	push   $0x0
	struct k_thread *thread = &z_idle_threads[i];
 805ebdc:	6b fb 54             	imul   $0x54,%ebx,%edi
	k_thread_stack_t *stack = z_idle_stacks[i];
 805ebdf:	89 d8                	mov    %ebx,%eax
	z_setup_new_thread(thread, stack,
 805ebe1:	6a 01                	push   $0x1
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
 805ebe3:	6b f3 14             	imul   $0x14,%ebx,%esi
	k_thread_stack_t *stack = z_idle_stacks[i];
 805ebe6:	c1 e0 08             	shl    $0x8,%eax
	z_setup_new_thread(thread, stack,
 805ebe9:	6a 0f                	push   $0xf
	k_thread_stack_t *stack = z_idle_stacks[i];
 805ebeb:	05 d4 cf 06 08       	add    $0x806cfd4,%eax
	z_setup_new_thread(thread, stack,
 805ebf0:	6a 00                	push   $0x0
	struct k_thread *thread = &z_idle_threads[i];
 805ebf2:	81 c7 20 87 06 08    	add    $0x8068720,%edi
	z_setup_new_thread(thread, stack,
 805ebf8:	6a 00                	push   $0x0
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
 805ebfa:	81 c6 e0 87 06 08    	add    $0x80687e0,%esi
	z_setup_new_thread(thread, stack,
 805ec00:	56                   	push   %esi
 805ec01:	68 4c f1 05 08       	push   $0x805f14c
 805ec06:	68 00 01 00 00       	push   $0x100
 805ec0b:	50                   	push   %eax
 805ec0c:	57                   	push   %edi
 805ec0d:	e8 96 03 00 00       	call   805efa8 <z_setup_new_thread>
	init_idle_thread(id);
	_kernel.cpus[id].idle_thread = &z_idle_threads[id];
	_kernel.cpus[id].id = id;
 805ec12:	88 5e 10             	mov    %bl,0x10(%esi)
	_kernel.cpus[id].irq_stack =
		(Z_KERNEL_STACK_BUFFER(z_interrupt_stacks[id]) +
 805ec15:	c1 e3 0b             	shl    $0xb,%ebx
	z_setup_new_thread(thread, stack,
 805ec18:	83 c4 30             	add    $0x30,%esp
		(Z_KERNEL_STACK_BUFFER(z_interrupt_stacks[id]) +
 805ec1b:	8d 83 d4 cf 06 08    	lea    0x806cfd4(%ebx),%eax
	SYS_PORT_TRACING_FUNC(k_thread, sched_resume, thread);
}

static inline void z_mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
 805ec21:	80 67 0d fb          	andb   $0xfb,0xd(%edi)
	_kernel.cpus[id].idle_thread = &z_idle_threads[id];
 805ec25:	89 7e 0c             	mov    %edi,0xc(%esi)
		(Z_KERNEL_STACK_BUFFER(z_interrupt_stacks[id]) +
 805ec28:	89 46 04             	mov    %eax,0x4(%esi)
		 K_KERNEL_STACK_SIZEOF(z_interrupt_stacks[id]));
#ifdef CONFIG_SCHED_THREAD_USAGE_ALL
	_kernel.cpus[id].usage.track_usage =
		CONFIG_SCHED_THREAD_USAGE_AUTO_ENABLE;
#endif
}
 805ec2b:	8d 65 f4             	lea    -0xc(%ebp),%esp
 805ec2e:	5b                   	pop    %ebx
 805ec2f:	5e                   	pop    %esi
 805ec30:	5f                   	pop    %edi
 805ec31:	5d                   	pop    %ebp
 805ec32:	c3                   	ret    

0805ec33 <z_cstart>:
 * @return Does not return
 */
__boot_func
FUNC_NO_STACK_PROTECTOR
FUNC_NORETURN void z_cstart(void)
{
 805ec33:	55                   	push   %ebp
	/* gcov hook needed to get the coverage report.*/
	gcov_static_init();

	/* initialize early init calls */
	z_sys_init_run_level(INIT_LEVEL_EARLY);
 805ec34:	31 c0                	xor    %eax,%eax
{
 805ec36:	89 e5                	mov    %esp,%ebp
 805ec38:	53                   	push   %ebx
#endif
#ifdef CONFIG_USERSPACE
	dummy_thread->mem_domain_info.mem_domain = &k_mem_domain_default;
#endif
#if (CONFIG_HEAP_MEM_POOL_SIZE > 0)
	k_thread_system_pool_assign(dummy_thread);
 805ec39:	8d 5d a4             	lea    -0x5c(%ebp),%ebx
 805ec3c:	83 ec 64             	sub    $0x64,%esp
	z_sys_init_run_level(INIT_LEVEL_EARLY);
 805ec3f:	e8 f2 fe ff ff       	call   805eb36 <z_sys_init_run_level>
 805ec44:	83 ec 0c             	sub    $0xc,%esp
	dummy_thread->base.user_options = K_ESSENTIAL;
 805ec47:	66 c7 45 b0 01 01    	movw   $0x101,-0x50(%ebp)
	k_thread_system_pool_assign(dummy_thread);
 805ec4d:	53                   	push   %ebx
 805ec4e:	e8 95 24 00 00       	call   80610e8 <k_thread_system_pool_assign>
 805ec53:	83 c4 10             	add    $0x10,%esp

#ifdef CONFIG_TIMESLICE_PER_THREAD
	dummy_thread->base.slice_ticks = 0;
#endif

	_current_cpu->current = dummy_thread;
 805ec56:	89 1d e8 87 06 08    	mov    %ebx,0x80687e8
	struct k_thread dummy_thread;

	z_dummy_thread_init(&dummy_thread);
#endif
	/* do any necessary initialization of static devices */
	z_device_state_init();
 805ec5c:	e8 e5 fd ff ff       	call   805ea46 <z_device_state_init>

	/* perform basic hardware initialization */
	z_sys_init_run_level(INIT_LEVEL_PRE_KERNEL_1);
 805ec61:	b8 01 00 00 00       	mov    $0x1,%eax
 805ec66:	e8 cb fe ff ff       	call   805eb36 <z_sys_init_run_level>
	z_sys_init_run_level(INIT_LEVEL_PRE_KERNEL_2);
 805ec6b:	b8 02 00 00 00       	mov    $0x2,%eax
 805ec70:	e8 c1 fe ff ff       	call   805eb36 <z_sys_init_run_level>
	z_sched_init();
 805ec75:	e8 e1 17 00 00       	call   806045b <z_sched_init>
	_kernel.ready_q.cache = &z_main_thread;
 805ec7a:	c7 05 f4 87 06 08 80 	movl   $0x8068780,0x80687f4
 805ec81:	87 06 08 
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
 805ec84:	50                   	push   %eax
 805ec85:	50                   	push   %eax
 805ec86:	68 37 3f 06 08       	push   $0x8063f37
 805ec8b:	6a 01                	push   $0x1
 805ec8d:	6a 00                	push   $0x0
 805ec8f:	6a 00                	push   $0x0
 805ec91:	6a 00                	push   $0x0
 805ec93:	6a 00                	push   $0x0
 805ec95:	68 95 eb 05 08       	push   $0x805eb95
 805ec9a:	68 00 10 00 00       	push   $0x1000
 805ec9f:	68 d4 d0 06 08       	push   $0x806d0d4
 805eca4:	68 80 87 06 08       	push   $0x8068780
 805eca9:	e8 fa 02 00 00       	call   805efa8 <z_setup_new_thread>
 805ecae:	83 c4 24             	add    $0x24,%esp
 805ecb1:	80 25 8d 87 06 08 fb 	andb   $0xfb,0x806878d
	z_ready_thread(&z_main_thread);
 805ecb8:	68 80 87 06 08       	push   $0x8068780
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
 805ecbd:	89 c3                	mov    %eax,%ebx
	z_ready_thread(&z_main_thread);
 805ecbf:	e8 ea 13 00 00       	call   80600ae <z_ready_thread>
	z_init_cpu(0);
 805ecc4:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 805eccb:	e8 fe fe ff ff       	call   805ebce <z_init_cpu>
 805ecd0:	83 c4 0c             	add    $0xc,%esp
	arch_switch_to_main_thread(&z_main_thread, stack_ptr, bg_thread_main);
 805ecd3:	68 95 eb 05 08       	push   $0x805eb95
 805ecd8:	53                   	push   %ebx
 805ecd9:	68 80 87 06 08       	push   $0x8068780
 805ecde:	e8 b6 e7 fe ff       	call   804d499 <arch_switch_to_main_thread>
 805ece3:	83 c4 0c             	add    $0xc,%esp
	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
 805ece6:	68 c4 01 00 00       	push   $0x1c4
 805eceb:	68 3c 3f 06 08       	push   $0x8063f3c
 805ecf0:	68 46 29 06 08       	push   $0x8062946
 805ecf5:	e8 aa f8 fe ff       	call   804e5a4 <posix_print_error_and_exit>
 805ecfa:	83 c4 10             	add    $0x10,%esp

0805ecfd <k_heap_init>:
#include <zephyr/wait_q.h>
#include <zephyr/init.h>
#include <zephyr/linker/linker-defs.h>

void k_heap_init(struct k_heap *h, void *mem, size_t bytes)
{
 805ecfd:	55                   	push   %ebp
 805ecfe:	89 e5                	mov    %esp,%ebp
 805ed00:	8b 45 08             	mov    0x8(%ebp),%eax
	SYS_DLIST_FOR_EACH_CONTAINER(&((wq)->waitq), thread_ptr, \
				     base.qnode_dlist)

static inline void z_waitq_init(_wait_q_t *w)
{
	sys_dlist_init(&w->waitq);
 805ed03:	8d 50 0c             	lea    0xc(%eax),%edx
 * @param list the doubly-linked list
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
 805ed06:	89 50 0c             	mov    %edx,0xc(%eax)
	list->tail = (sys_dnode_t *)list;
 805ed09:	89 50 10             	mov    %edx,0x10(%eax)
	z_waitq_init(&h->wait_q);
	sys_heap_init(&h->heap, mem, bytes);

	SYS_PORT_TRACING_OBJ_INIT(k_heap, h);
}
 805ed0c:	5d                   	pop    %ebp
	sys_heap_init(&h->heap, mem, bytes);
 805ed0d:	e9 aa b6 fe ff       	jmp    804a3bc <sys_heap_init>

0805ed12 <statics_init>:

static int statics_init(void)
{
 805ed12:	55                   	push   %ebp
 805ed13:	89 e5                	mov    %esp,%ebp
 805ed15:	53                   	push   %ebx
	STRUCT_SECTION_FOREACH(k_heap, h) {
 805ed16:	bb 84 75 06 08       	mov    $0x8067584,%ebx
{
 805ed1b:	52                   	push   %edx
	STRUCT_SECTION_FOREACH(k_heap, h) {
 805ed1c:	81 fb 98 75 06 08    	cmp    $0x8067598,%ebx
 805ed22:	73 15                	jae    805ed39 <statics_init+0x27>
		}

		if (do_clear)
#endif /* CONFIG_DEMAND_PAGING && !CONFIG_LINKER_GENERIC_SECTIONS_PRESENT_AT_BOOT */
		{
			k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
 805ed24:	50                   	push   %eax
 805ed25:	ff 73 08             	push   0x8(%ebx)
 805ed28:	ff 73 04             	push   0x4(%ebx)
 805ed2b:	53                   	push   %ebx
	STRUCT_SECTION_FOREACH(k_heap, h) {
 805ed2c:	83 c3 14             	add    $0x14,%ebx
			k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
 805ed2f:	e8 c9 ff ff ff       	call   805ecfd <k_heap_init>
 805ed34:	83 c4 10             	add    $0x10,%esp
	STRUCT_SECTION_FOREACH(k_heap, h) {
 805ed37:	eb e3                	jmp    805ed1c <statics_init+0xa>
		}
	}
	return 0;
}
 805ed39:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 805ed3c:	31 c0                	xor    %eax,%eax
 805ed3e:	c9                   	leave  
 805ed3f:	c3                   	ret    

0805ed40 <k_heap_aligned_alloc>:
SYS_INIT_NAMED(statics_init_post, statics_init, POST_KERNEL, 0);
#endif /* CONFIG_DEMAND_PAGING && !CONFIG_LINKER_GENERIC_SECTIONS_PRESENT_AT_BOOT */

void *k_heap_aligned_alloc(struct k_heap *h, size_t align, size_t bytes,
			k_timeout_t timeout)
{
 805ed40:	55                   	push   %ebp
 805ed41:	89 e5                	mov    %esp,%ebp
 805ed43:	57                   	push   %edi
 805ed44:	56                   	push   %esi
 805ed45:	53                   	push   %ebx
 805ed46:	83 ec 24             	sub    $0x24,%esp
 805ed49:	8b 7d 18             	mov    0x18(%ebp),%edi
 805ed4c:	8b 75 14             	mov    0x14(%ebp),%esi
	int64_t now, end = sys_clock_timeout_end_calc(timeout);
 805ed4f:	57                   	push   %edi
 805ed50:	56                   	push   %esi
 805ed51:	e8 c3 1e 00 00       	call   8060c19 <sys_clock_timeout_end_calc>
 805ed56:	83 c4 10             	add    $0x10,%esp
	void *ret = NULL;

	end = K_TIMEOUT_EQ(timeout, K_FOREVER) ? INT64_MAX : end;
 805ed59:	47                   	inc    %edi
	int64_t now, end = sys_clock_timeout_end_calc(timeout);
 805ed5a:	89 45 d8             	mov    %eax,-0x28(%ebp)
 805ed5d:	89 55 dc             	mov    %edx,-0x24(%ebp)
	end = K_TIMEOUT_EQ(timeout, K_FOREVER) ? INT64_MAX : end;
 805ed60:	75 11                	jne    805ed73 <k_heap_aligned_alloc+0x33>
 805ed62:	46                   	inc    %esi
 805ed63:	75 0e                	jne    805ed73 <k_heap_aligned_alloc+0x33>
 805ed65:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%ebp)
 805ed6c:	c7 45 dc ff ff ff 7f 	movl   $0x7fffffff,-0x24(%ebp)

	k_spinlock_key_t key = k_spin_lock(&h->lock);
 805ed73:	8b 45 08             	mov    0x8(%ebp),%eax
 805ed76:	8d 78 14             	lea    0x14(%eax),%edi
	return posix_irq_lock();
 805ed79:	e8 a1 f3 fe ff       	call   804e11f <posix_irq_lock>
 805ed7e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	__ASSERT(!arch_is_in_isr() || K_TIMEOUT_EQ(timeout, K_NO_WAIT), "");

	bool blocked_alloc = false;

	while (ret == NULL) {
		ret = sys_heap_aligned_alloc(&h->heap, align, bytes);
 805ed81:	50                   	push   %eax
 805ed82:	ff 75 10             	push   0x10(%ebp)
 805ed85:	ff 75 0c             	push   0xc(%ebp)
 805ed88:	ff 75 08             	push   0x8(%ebp)
 805ed8b:	e8 33 b5 fe ff       	call   804a2c3 <sys_heap_aligned_alloc>
 805ed90:	83 c4 10             	add    $0x10,%esp
 805ed93:	89 c6                	mov    %eax,%esi

		now = sys_clock_tick_get();
 805ed95:	e8 30 1e 00 00       	call   8060bca <sys_clock_tick_get>
		if (!IS_ENABLED(CONFIG_MULTITHREADING) ||
 805ed9a:	85 f6                	test   %esi,%esi
 805ed9c:	75 2c                	jne    805edca <k_heap_aligned_alloc+0x8a>
		    (ret != NULL) || ((end - now) <= 0)) {
 805ed9e:	8b 4d d8             	mov    -0x28(%ebp),%ecx
 805eda1:	8b 5d dc             	mov    -0x24(%ebp),%ebx
 805eda4:	29 c1                	sub    %eax,%ecx
 805eda6:	89 f0                	mov    %esi,%eax
 805eda8:	19 d3                	sbb    %edx,%ebx
 805edaa:	39 ce                	cmp    %ecx,%esi
 805edac:	19 d8                	sbb    %ebx,%eax
 805edae:	7d 1a                	jge    805edca <k_heap_aligned_alloc+0x8a>
			/**
			 * @todo	Trace attempt to avoid empty trace segments
			 */
		}

		(void) z_pend_curr(&h->lock, key, &h->wait_q,
 805edb0:	8b 45 08             	mov    0x8(%ebp),%eax
 805edb3:	83 ec 0c             	sub    $0xc,%esp
 805edb6:	53                   	push   %ebx
 805edb7:	83 c0 0c             	add    $0xc,%eax
 805edba:	51                   	push   %ecx
 805edbb:	50                   	push   %eax
 805edbc:	ff 75 e4             	push   -0x1c(%ebp)
 805edbf:	57                   	push   %edi
 805edc0:	e8 84 14 00 00       	call   8060249 <z_pend_curr>
 805edc5:	83 c4 20             	add    $0x20,%esp
 805edc8:	eb af                	jmp    805ed79 <k_heap_aligned_alloc+0x39>
	posix_irq_unlock(key);
 805edca:	83 ec 0c             	sub    $0xc,%esp
 805edcd:	ff 75 e4             	push   -0x1c(%ebp)
 805edd0:	e8 5c f3 fe ff       	call   804e131 <posix_irq_unlock>
 805edd5:	83 c4 10             	add    $0x10,%esp

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_heap, aligned_alloc, h, timeout, ret);

	k_spin_unlock(&h->lock, key);
	return ret;
}
 805edd8:	8d 65 f4             	lea    -0xc(%ebp),%esp
 805eddb:	89 f0                	mov    %esi,%eax
 805eddd:	5b                   	pop    %ebx
 805edde:	5e                   	pop    %esi
 805eddf:	5f                   	pop    %edi
 805ede0:	5d                   	pop    %ebp
 805ede1:	c3                   	ret    

0805ede2 <k_heap_free>:

	return ret;
}

void k_heap_free(struct k_heap *h, void *mem)
{
 805ede2:	55                   	push   %ebp
 805ede3:	89 e5                	mov    %esp,%ebp
 805ede5:	57                   	push   %edi
 805ede6:	56                   	push   %esi
 805ede7:	53                   	push   %ebx
 805ede8:	83 ec 0c             	sub    $0xc,%esp
 805edeb:	8b 5d 08             	mov    0x8(%ebp),%ebx
 805edee:	8b 7d 0c             	mov    0xc(%ebp),%edi
	return posix_irq_lock();
 805edf1:	e8 29 f3 fe ff       	call   804e11f <posix_irq_lock>
 805edf6:	89 c6                	mov    %eax,%esi
	k_spinlock_key_t key = k_spin_lock(&h->lock);

	sys_heap_free(&h->heap, mem);
 805edf8:	50                   	push   %eax
 805edf9:	50                   	push   %eax
 805edfa:	57                   	push   %edi
 805edfb:	53                   	push   %ebx
 805edfc:	e8 1a b4 fe ff       	call   804a21b <sys_heap_free>

	SYS_PORT_TRACING_OBJ_FUNC(k_heap, free, h);
	if (IS_ENABLED(CONFIG_MULTITHREADING) && z_unpend_all(&h->wait_q) != 0) {
 805ee01:	8d 43 0c             	lea    0xc(%ebx),%eax
 805ee04:	89 04 24             	mov    %eax,(%esp)
 805ee07:	e8 19 16 00 00       	call   8060425 <z_unpend_all>
 805ee0c:	83 c4 10             	add    $0x10,%esp
 805ee0f:	85 c0                	test   %eax,%eax
 805ee11:	74 15                	je     805ee28 <k_heap_free+0x46>
	k_spinlock_key_t key = k_spin_lock(&h->lock);
 805ee13:	83 c3 14             	add    $0x14,%ebx
		z_reschedule(&h->lock, key);
 805ee16:	89 75 0c             	mov    %esi,0xc(%ebp)
	k_spinlock_key_t key = k_spin_lock(&h->lock);
 805ee19:	89 5d 08             	mov    %ebx,0x8(%ebp)
	} else {
		k_spin_unlock(&h->lock, key);
	}
}
 805ee1c:	8d 65 f4             	lea    -0xc(%ebp),%esp
 805ee1f:	5b                   	pop    %ebx
 805ee20:	5e                   	pop    %esi
 805ee21:	5f                   	pop    %edi
 805ee22:	5d                   	pop    %ebp
		z_reschedule(&h->lock, key);
 805ee23:	e9 3a 10 00 00       	jmp    805fe62 <z_reschedule>
	posix_irq_unlock(key);
 805ee28:	89 75 08             	mov    %esi,0x8(%ebp)
}
 805ee2b:	8d 65 f4             	lea    -0xc(%ebp),%esp
 805ee2e:	5b                   	pop    %ebx
 805ee2f:	5e                   	pop    %esi
 805ee30:	5f                   	pop    %edi
 805ee31:	5d                   	pop    %ebp
 805ee32:	e9 fa f2 fe ff       	jmp    804e131 <posix_irq_unlock>

0805ee37 <create_free_list>:
{
	uint32_t j;
	char *p;

	/* blocks must be word aligned */
	CHECKIF(((slab->block_size | (uintptr_t)slab->buffer) &
 805ee37:	8b 48 10             	mov    0x10(%eax),%ecx
 805ee3a:	8b 50 0c             	mov    0xc(%eax),%edx
 805ee3d:	09 ca                	or     %ecx,%edx
 805ee3f:	83 e2 03             	and    $0x3,%edx
 805ee42:	74 06                	je     805ee4a <create_free_list+0x13>
				(sizeof(void *) - 1)) != 0U) {
		return -EINVAL;
 805ee44:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
 805ee49:	c3                   	ret    
	}

	slab->free_list = NULL;
 805ee4a:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
	p = slab->buffer;

	for (j = 0U; j < slab->num_blocks; j++) {
 805ee51:	39 50 08             	cmp    %edx,0x8(%eax)
 805ee54:	77 03                	ja     805ee59 <create_free_list+0x22>
		*(char **)p = slab->free_list;
		slab->free_list = p;
		p += slab->block_size;
	}
	return 0;
 805ee56:	31 c0                	xor    %eax,%eax
}
 805ee58:	c3                   	ret    
{
 805ee59:	55                   	push   %ebp
 805ee5a:	89 e5                	mov    %esp,%ebp
 805ee5c:	53                   	push   %ebx
		*(char **)p = slab->free_list;
 805ee5d:	8b 58 14             	mov    0x14(%eax),%ebx
	for (j = 0U; j < slab->num_blocks; j++) {
 805ee60:	42                   	inc    %edx
		*(char **)p = slab->free_list;
 805ee61:	89 19                	mov    %ebx,(%ecx)
		slab->free_list = p;
 805ee63:	89 48 14             	mov    %ecx,0x14(%eax)
		p += slab->block_size;
 805ee66:	03 48 0c             	add    0xc(%eax),%ecx
	for (j = 0U; j < slab->num_blocks; j++) {
 805ee69:	39 50 08             	cmp    %edx,0x8(%eax)
 805ee6c:	77 ef                	ja     805ee5d <create_free_list+0x26>
	return 0;
 805ee6e:	31 c0                	xor    %eax,%eax
}
 805ee70:	5b                   	pop    %ebx
 805ee71:	5d                   	pop    %ebp
 805ee72:	c3                   	ret    

0805ee73 <init_mem_slab_module>:
 * Perform any initialization that wasn't done at build time.
 *
 * @return 0 on success, fails otherwise.
 */
static int init_mem_slab_module(void)
{
 805ee73:	55                   	push   %ebp
	int rc = 0;
 805ee74:	31 c0                	xor    %eax,%eax
{
 805ee76:	89 e5                	mov    %esp,%ebp
 805ee78:	53                   	push   %ebx

	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
 805ee79:	bb 4c 75 06 08       	mov    $0x806754c,%ebx
{
 805ee7e:	51                   	push   %ecx
	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
 805ee7f:	81 fb 84 75 06 08    	cmp    $0x8067584,%ebx
 805ee85:	73 10                	jae    805ee97 <init_mem_slab_module+0x24>
		rc = create_free_list(slab);
 805ee87:	89 d8                	mov    %ebx,%eax
 805ee89:	e8 a9 ff ff ff       	call   805ee37 <create_free_list>
		if (rc < 0) {
 805ee8e:	85 c0                	test   %eax,%eax
 805ee90:	78 05                	js     805ee97 <init_mem_slab_module+0x24>
	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
 805ee92:	83 c3 1c             	add    $0x1c,%ebx
 805ee95:	eb e8                	jmp    805ee7f <init_mem_slab_module+0xc>
		z_object_init(slab);
	}

out:
	return rc;
}
 805ee97:	5a                   	pop    %edx
 805ee98:	5b                   	pop    %ebx
 805ee99:	5d                   	pop    %ebp
 805ee9a:	c3                   	ret    

0805ee9b <k_mem_slab_alloc>:

	return rc;
}

int k_mem_slab_alloc(struct k_mem_slab *slab, void **mem, k_timeout_t timeout)
{
 805ee9b:	55                   	push   %ebp
 805ee9c:	89 e5                	mov    %esp,%ebp
 805ee9e:	56                   	push   %esi
 805ee9f:	53                   	push   %ebx
 805eea0:	83 ec 10             	sub    $0x10,%esp
 805eea3:	8b 5d 08             	mov    0x8(%ebp),%ebx
 805eea6:	8b 75 0c             	mov    0xc(%ebp),%esi
	return posix_irq_lock();
 805eea9:	e8 71 f2 fe ff       	call   804e11f <posix_irq_lock>
 805eeae:	89 c2                	mov    %eax,%edx
	k_spinlock_key_t key = k_spin_lock(&slab->lock);
	int result;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mem_slab, alloc, slab, timeout);

	if (slab->free_list != NULL) {
 805eeb0:	8b 43 14             	mov    0x14(%ebx),%eax
 805eeb3:	85 c0                	test   %eax,%eax
 805eeb5:	74 0e                	je     805eec5 <k_mem_slab_alloc+0x2a>
		/* take a free block */
		*mem = slab->free_list;
 805eeb7:	89 06                	mov    %eax,(%esi)
		slab->free_list = *(char **)(slab->free_list);
 805eeb9:	8b 00                	mov    (%eax),%eax
		slab->num_used++;
 805eebb:	ff 43 18             	incl   0x18(%ebx)
		slab->free_list = *(char **)(slab->free_list);
 805eebe:	89 43 14             	mov    %eax,0x14(%ebx)

#ifdef CONFIG_MEM_SLAB_TRACE_MAX_UTILIZATION
		slab->max_used = MAX(slab->num_used, slab->max_used);
#endif

		result = 0;
 805eec1:	31 c0                	xor    %eax,%eax
 805eec3:	eb 3d                	jmp    805ef02 <k_mem_slab_alloc+0x67>
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT) ||
 805eec5:	8b 45 14             	mov    0x14(%ebp),%eax
 805eec8:	0b 45 10             	or     0x10(%ebp),%eax
 805eecb:	75 0d                	jne    805eeda <k_mem_slab_alloc+0x3f>
		   !IS_ENABLED(CONFIG_MULTITHREADING)) {
		/* don't wait for a free block to become available */
		*mem = NULL;
 805eecd:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
		result = -ENOMEM;
 805eed3:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
 805eed8:	eb 28                	jmp    805ef02 <k_mem_slab_alloc+0x67>
	} else {
		SYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_mem_slab, alloc, slab, timeout);

		/* wait for a free block or timeout */
		result = z_pend_curr(&slab->lock, key, &slab->wait_q, timeout);
 805eeda:	83 ec 0c             	sub    $0xc,%esp
 805eedd:	ff 75 14             	push   0x14(%ebp)
 805eee0:	ff 75 10             	push   0x10(%ebp)
 805eee3:	53                   	push   %ebx
	k_spinlock_key_t key = k_spin_lock(&slab->lock);
 805eee4:	83 c3 08             	add    $0x8,%ebx
		result = z_pend_curr(&slab->lock, key, &slab->wait_q, timeout);
 805eee7:	52                   	push   %edx
 805eee8:	53                   	push   %ebx
 805eee9:	e8 5b 13 00 00       	call   8060249 <z_pend_curr>
 805eeee:	83 c4 20             	add    $0x20,%esp
		if (result == 0) {
 805eef1:	85 c0                	test   %eax,%eax
 805eef3:	75 1f                	jne    805ef14 <k_mem_slab_alloc+0x79>
			*mem = _current->base.swap_data;
 805eef5:	8b 15 e8 87 06 08    	mov    0x80687e8,%edx
 805eefb:	8b 52 14             	mov    0x14(%edx),%edx
 805eefe:	89 16                	mov    %edx,(%esi)
 805ef00:	eb 12                	jmp    805ef14 <k_mem_slab_alloc+0x79>
	posix_irq_unlock(key);
 805ef02:	83 ec 0c             	sub    $0xc,%esp
 805ef05:	89 45 f4             	mov    %eax,-0xc(%ebp)
 805ef08:	52                   	push   %edx
 805ef09:	e8 23 f2 fe ff       	call   804e131 <posix_irq_unlock>
 805ef0e:	8b 45 f4             	mov    -0xc(%ebp),%eax
 805ef11:	83 c4 10             	add    $0x10,%esp
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, alloc, slab, timeout, result);

	k_spin_unlock(&slab->lock, key);

	return result;
}
 805ef14:	8d 65 f8             	lea    -0x8(%ebp),%esp
 805ef17:	5b                   	pop    %ebx
 805ef18:	5e                   	pop    %esi
 805ef19:	5d                   	pop    %ebp
 805ef1a:	c3                   	ret    

0805ef1b <k_mem_slab_free>:

void k_mem_slab_free(struct k_mem_slab *slab, void **mem)
{
 805ef1b:	55                   	push   %ebp
 805ef1c:	89 e5                	mov    %esp,%ebp
 805ef1e:	57                   	push   %edi
 805ef1f:	56                   	push   %esi
 805ef20:	53                   	push   %ebx
 805ef21:	83 ec 0c             	sub    $0xc,%esp
 805ef24:	8b 5d 08             	mov    0x8(%ebp),%ebx
 805ef27:	8b 7d 0c             	mov    0xc(%ebp),%edi
	return posix_irq_lock();
 805ef2a:	e8 f0 f1 fe ff       	call   804e11f <posix_irq_lock>
	k_spinlock_key_t key = k_spin_lock(&slab->lock);

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mem_slab, free, slab);
	if (slab->free_list == NULL && IS_ENABLED(CONFIG_MULTITHREADING)) {
 805ef2f:	83 7b 14 00          	cmpl   $0x0,0x14(%ebx)
 805ef33:	89 c6                	mov    %eax,%esi
 805ef35:	75 3d                	jne    805ef74 <k_mem_slab_free+0x59>
		struct k_thread *pending_thread = z_unpend_first_thread(&slab->wait_q);
 805ef37:	83 ec 0c             	sub    $0xc,%esp
 805ef3a:	53                   	push   %ebx
 805ef3b:	e8 9c 14 00 00       	call   80603dc <z_unpend_first_thread>
 805ef40:	83 c4 10             	add    $0x10,%esp

		if (pending_thread != NULL) {
 805ef43:	85 c0                	test   %eax,%eax
 805ef45:	74 2d                	je     805ef74 <k_mem_slab_free+0x59>
			SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, free, slab);

			z_thread_return_value_set_with_data(pending_thread, 0, *mem);
 805ef47:	8b 17                	mov    (%edi),%edx
			z_ready_thread(pending_thread);
 805ef49:	83 ec 0c             	sub    $0xc,%esp
}

static ALWAYS_INLINE void
arch_thread_return_value_set(struct k_thread *thread, unsigned int value)
{
	thread->callee_saved.retval = value;
 805ef4c:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%eax)
	k_spinlock_key_t key = k_spin_lock(&slab->lock);
 805ef53:	83 c3 08             	add    $0x8,%ebx
z_thread_return_value_set_with_data(struct k_thread *thread,
				   unsigned int value,
				   void *data)
{
	arch_thread_return_value_set(thread, value);
	thread->base.swap_data = data;
 805ef56:	89 50 14             	mov    %edx,0x14(%eax)
			z_ready_thread(pending_thread);
 805ef59:	50                   	push   %eax
 805ef5a:	e8 4f 11 00 00       	call   80600ae <z_ready_thread>
			z_reschedule(&slab->lock, key);
 805ef5f:	89 75 0c             	mov    %esi,0xc(%ebp)
			z_ready_thread(pending_thread);
 805ef62:	83 c4 10             	add    $0x10,%esp
	k_spinlock_key_t key = k_spin_lock(&slab->lock);
 805ef65:	89 5d 08             	mov    %ebx,0x8(%ebp)
	slab->num_used--;

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, free, slab);

	k_spin_unlock(&slab->lock, key);
}
 805ef68:	8d 65 f4             	lea    -0xc(%ebp),%esp
 805ef6b:	5b                   	pop    %ebx
 805ef6c:	5e                   	pop    %esi
 805ef6d:	5f                   	pop    %edi
 805ef6e:	5d                   	pop    %ebp
			z_reschedule(&slab->lock, key);
 805ef6f:	e9 ee 0e 00 00       	jmp    805fe62 <z_reschedule>
	**(char ***) mem = slab->free_list;
 805ef74:	8b 07                	mov    (%edi),%eax
 805ef76:	8b 53 14             	mov    0x14(%ebx),%edx
 805ef79:	89 10                	mov    %edx,(%eax)
	slab->free_list = *(char **) mem;
 805ef7b:	8b 07                	mov    (%edi),%eax
	slab->num_used--;
 805ef7d:	ff 4b 18             	decl   0x18(%ebx)
	slab->free_list = *(char **) mem;
 805ef80:	89 43 14             	mov    %eax,0x14(%ebx)
	posix_irq_unlock(key);
 805ef83:	89 75 08             	mov    %esi,0x8(%ebp)
}
 805ef86:	8d 65 f4             	lea    -0xc(%ebp),%esp
 805ef89:	5b                   	pop    %ebx
 805ef8a:	5e                   	pop    %esi
 805ef8b:	5f                   	pop    %edi
 805ef8c:	5d                   	pop    %ebp
 805ef8d:	e9 9f f1 fe ff       	jmp    804e131 <posix_irq_unlock>

0805ef92 <k_is_in_isr>:
}
#endif

static inline bool arch_is_in_isr(void)
{
	return _kernel.cpus[0].nested != 0U;
 805ef92:	83 3d e0 87 06 08 00 	cmpl   $0x0,0x80687e0
 805ef99:	0f 95 c0             	setne  %al
}

bool k_is_in_isr(void)
{
	return arch_is_in_isr();
}
 805ef9c:	c3                   	ret    

0805ef9d <z_impl_k_thread_name_set>:

	SYS_PORT_TRACING_OBJ_FUNC(k_thread, name_set, thread, -ENOSYS);

	return -ENOSYS;
#endif /* CONFIG_THREAD_NAME */
}
 805ef9d:	b8 da ff ff ff       	mov    $0xffffffda,%eax
 805efa2:	c3                   	ret    

0805efa3 <z_impl_k_thread_start>:

void z_impl_k_thread_start(struct k_thread *thread)
{
	SYS_PORT_TRACING_OBJ_FUNC(k_thread, start, thread);

	z_sched_start(thread);
 805efa3:	e9 27 11 00 00       	jmp    80600cf <z_sched_start>

0805efa8 <z_setup_new_thread>:
char *z_setup_new_thread(struct k_thread *new_thread,
			 k_thread_stack_t *stack, size_t stack_size,
			 k_thread_entry_t entry,
			 void *p1, void *p2, void *p3,
			 int prio, uint32_t options, const char *name)
{
 805efa8:	55                   	push   %ebp
 805efa9:	89 e5                	mov    %esp,%ebp
 805efab:	53                   	push   %ebx
 805efac:	83 ec 18             	sub    $0x18,%esp
 805efaf:	8b 5d 08             	mov    0x8(%ebp),%ebx
 805efb2:	8b 55 0c             	mov    0xc(%ebp),%edx
 805efb5:	8d 43 3c             	lea    0x3c(%ebx),%eax

void z_init_thread_base(struct _thread_base *thread_base, int priority,
		       uint32_t initial_state, unsigned int options)
{
	/* k_q_node is initialized upon first insertion in a list */
	thread_base->pended_on = NULL;
 805efb8:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
	list->head = (sys_dnode_t *)list;
 805efbf:	89 43 3c             	mov    %eax,0x3c(%ebx)
	list->tail = (sys_dnode_t *)list;
 805efc2:	89 43 40             	mov    %eax,0x40(%ebx)
	thread_base->user_options = (uint8_t)options;
 805efc5:	8b 45 28             	mov    0x28(%ebp),%eax
	thread_base->thread_state = (uint8_t)initial_state;
 805efc8:	c6 43 0d 04          	movb   $0x4,0xd(%ebx)
	thread_base->user_options = (uint8_t)options;
 805efcc:	88 43 0c             	mov    %al,0xc(%ebx)

	thread_base->prio = priority;
 805efcf:	8b 45 24             	mov    0x24(%ebp),%eax

	thread_base->sched_locked = 0U;
 805efd2:	c6 43 0f 00          	movb   $0x0,0xf(%ebx)
	thread_base->prio = priority;
 805efd6:	88 43 0e             	mov    %al,0xe(%ebx)
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
 805efd9:	8b 45 10             	mov    0x10(%ebp),%eax
 * @param node the node
 */

static inline void sys_dnode_init(sys_dnode_t *node)
{
	node->next = NULL;
 805efdc:	c7 43 18 00 00 00 00 	movl   $0x0,0x18(%ebx)
 805efe3:	83 c0 03             	add    $0x3,%eax
	node->prev = NULL;
 805efe6:	c7 43 1c 00 00 00 00 	movl   $0x0,0x1c(%ebx)
 805efed:	83 e0 fc             	and    $0xfffffffc,%eax
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
 805eff0:	ff 75 20             	push   0x20(%ebp)
	stack_ptr = (char *)stack + stack_obj_size;
 805eff3:	01 d0                	add    %edx,%eax
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
 805eff5:	ff 75 1c             	push   0x1c(%ebp)
 805eff8:	ff 75 18             	push   0x18(%ebp)
 805effb:	ff 75 14             	push   0x14(%ebp)
 805effe:	50                   	push   %eax
 805efff:	52                   	push   %edx
 805f000:	53                   	push   %ebx
 805f001:	89 45 f4             	mov    %eax,-0xc(%ebp)
 805f004:	e8 ac e4 fe ff       	call   804d4b5 <arch_new_thread>
	if (!_current) {
 805f009:	8b 15 e8 87 06 08    	mov    0x80687e8,%edx
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
 805f00f:	83 c4 20             	add    $0x20,%esp
	if (!_current) {
 805f012:	8b 45 f4             	mov    -0xc(%ebp),%eax
	new_thread->init_data = NULL;
 805f015:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)
	if (!_current) {
 805f01c:	85 d2                	test   %edx,%edx
 805f01e:	74 03                	je     805f023 <z_setup_new_thread+0x7b>
	new_thread->resource_pool = _current->resource_pool;
 805f020:	8b 52 4c             	mov    0x4c(%edx),%edx
	return stack_ptr;
 805f023:	89 53 4c             	mov    %edx,0x4c(%ebx)
}
 805f026:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 805f029:	c9                   	leave  
 805f02a:	c3                   	ret    

0805f02b <z_impl_k_thread_create>:
{
 805f02b:	55                   	push   %ebp
 805f02c:	89 e5                	mov    %esp,%ebp
 805f02e:	57                   	push   %edi
 805f02f:	56                   	push   %esi
 805f030:	53                   	push   %ebx
 805f031:	83 ec 14             	sub    $0x14,%esp
 805f034:	8b 75 08             	mov    0x8(%ebp),%esi
 805f037:	8b 5d 30             	mov    0x30(%ebp),%ebx
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
 805f03a:	6a 00                	push   $0x0
{
 805f03c:	8b 7d 2c             	mov    0x2c(%ebp),%edi
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
 805f03f:	ff 75 28             	push   0x28(%ebp)
 805f042:	ff 75 24             	push   0x24(%ebp)
 805f045:	ff 75 20             	push   0x20(%ebp)
 805f048:	ff 75 1c             	push   0x1c(%ebp)
 805f04b:	ff 75 18             	push   0x18(%ebp)
 805f04e:	ff 75 14             	push   0x14(%ebp)
 805f051:	ff 75 10             	push   0x10(%ebp)
 805f054:	ff 75 0c             	push   0xc(%ebp)
 805f057:	56                   	push   %esi
 805f058:	e8 4b ff ff ff       	call   805efa8 <z_setup_new_thread>
 805f05d:	83 c4 30             	add    $0x30,%esp
	if (!K_TIMEOUT_EQ(delay, K_FOREVER)) {
 805f060:	89 d8                	mov    %ebx,%eax
 805f062:	43                   	inc    %ebx
 805f063:	89 fa                	mov    %edi,%edx
 805f065:	75 05                	jne    805f06c <z_impl_k_thread_create+0x41>
 805f067:	83 ff ff             	cmp    $0xffffffff,%edi
 805f06a:	74 24                	je     805f090 <z_impl_k_thread_create+0x65>
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
 805f06c:	89 c3                	mov    %eax,%ebx
 805f06e:	09 d3                	or     %edx,%ebx
 805f070:	75 0b                	jne    805f07d <z_impl_k_thread_create+0x52>
	z_sched_start(thread);
 805f072:	83 ec 0c             	sub    $0xc,%esp
 805f075:	56                   	push   %esi
 805f076:	e8 54 10 00 00       	call   80600cf <z_sched_start>
 805f07b:	eb 10                	jmp    805f08d <z_impl_k_thread_create+0x62>

extern void z_thread_timeout(struct _timeout *timeout);

static inline void z_add_thread_timeout(struct k_thread *thread, k_timeout_t ticks)
{
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
 805f07d:	50                   	push   %eax
 805f07e:	8d 46 18             	lea    0x18(%esi),%eax
 805f081:	52                   	push   %edx
 805f082:	68 6b 01 06 08       	push   $0x806016b
 805f087:	50                   	push   %eax
 805f088:	e8 92 18 00 00       	call   806091f <z_add_timeout>
 805f08d:	83 c4 10             	add    $0x10,%esp
}
 805f090:	8d 65 f4             	lea    -0xc(%ebp),%esp
 805f093:	89 f0                	mov    %esi,%eax
 805f095:	5b                   	pop    %ebx
 805f096:	5e                   	pop    %esi
 805f097:	5f                   	pop    %edi
 805f098:	5d                   	pop    %ebp
 805f099:	c3                   	ret    

0805f09a <z_init_static_threads>:
{
 805f09a:	55                   	push   %ebp
 805f09b:	89 e5                	mov    %esp,%ebp
 805f09d:	56                   	push   %esi
 805f09e:	53                   	push   %ebx
	_FOREACH_STATIC_THREAD(thread_data) {
 805f09f:	bb 5c 74 06 08       	mov    $0x806745c,%ebx
 805f0a4:	81 fb 5c 74 06 08    	cmp    $0x806745c,%ebx
 805f0aa:	73 31                	jae    805f0dd <z_init_static_threads+0x43>
		z_setup_new_thread(
 805f0ac:	50                   	push   %eax
 805f0ad:	50                   	push   %eax
 805f0ae:	ff 73 28             	push   0x28(%ebx)
 805f0b1:	ff 73 20             	push   0x20(%ebx)
 805f0b4:	ff 73 1c             	push   0x1c(%ebx)
 805f0b7:	ff 73 18             	push   0x18(%ebx)
 805f0ba:	ff 73 14             	push   0x14(%ebx)
 805f0bd:	ff 73 10             	push   0x10(%ebx)
 805f0c0:	ff 73 0c             	push   0xc(%ebx)
 805f0c3:	ff 73 08             	push   0x8(%ebx)
 805f0c6:	ff 73 04             	push   0x4(%ebx)
 805f0c9:	ff 33                	push   (%ebx)
 805f0cb:	e8 d8 fe ff ff       	call   805efa8 <z_setup_new_thread>
		thread_data->init_thread->init_data = thread_data;
 805f0d0:	8b 03                	mov    (%ebx),%eax
		z_setup_new_thread(
 805f0d2:	83 c4 30             	add    $0x30,%esp
		thread_data->init_thread->init_data = thread_data;
 805f0d5:	89 58 38             	mov    %ebx,0x38(%eax)
	_FOREACH_STATIC_THREAD(thread_data) {
 805f0d8:	83 c3 2c             	add    $0x2c,%ebx
 805f0db:	eb c7                	jmp    805f0a4 <z_init_static_threads+0xa>
	k_sched_lock();
 805f0dd:	e8 ee 0d 00 00       	call   805fed0 <k_sched_lock>
	_FOREACH_STATIC_THREAD(thread_data) {
 805f0e2:	bb 5c 74 06 08       	mov    $0x806745c,%ebx
 805f0e7:	81 fb 5c 74 06 08    	cmp    $0x806745c,%ebx
 805f0ed:	73 52                	jae    805f141 <z_init_static_threads+0xa7>
		if (thread_data->init_delay != K_TICKS_FOREVER) {
 805f0ef:	8b 43 24             	mov    0x24(%ebx),%eax
 805f0f2:	83 f8 ff             	cmp    $0xffffffff,%eax
 805f0f5:	74 45                	je     805f13c <z_init_static_threads+0xa2>
					    K_MSEC(thread_data->init_delay));
 805f0f7:	31 d2                	xor    %edx,%edx
 805f0f9:	85 c0                	test   %eax,%eax
			schedule_new_thread(thread_data->init_thread,
 805f0fb:	8b 33                	mov    (%ebx),%esi
					    K_MSEC(thread_data->init_delay));
 805f0fd:	0f 48 c2             	cmovs  %edx,%eax
 805f100:	99                   	cltd   
		t += off;
 805f101:	83 c0 09             	add    $0x9,%eax
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
 805f104:	89 c1                	mov    %eax,%ecx
 805f106:	83 d2 00             	adc    $0x0,%edx
 805f109:	83 f1 09             	xor    $0x9,%ecx
 805f10c:	09 d1                	or     %edx,%ecx
 805f10e:	75 0b                	jne    805f11b <z_init_static_threads+0x81>
	z_sched_start(thread);
 805f110:	83 ec 0c             	sub    $0xc,%esp
 805f113:	56                   	push   %esi
 805f114:	e8 b6 0f 00 00       	call   80600cf <z_sched_start>
 805f119:	eb 1e                	jmp    805f139 <z_init_static_threads+0x9f>
			return t / ((uint64_t)from_hz / to_hz);
 805f11b:	6a 00                	push   $0x0
 805f11d:	83 c6 18             	add    $0x18,%esi
 805f120:	6a 0a                	push   $0xa
 805f122:	52                   	push   %edx
 805f123:	50                   	push   %eax
 805f124:	e8 27 a4 fe ff       	call   8049550 <__udivdi3>
 805f129:	83 c4 10             	add    $0x10,%esp
 805f12c:	52                   	push   %edx
 805f12d:	50                   	push   %eax
 805f12e:	68 6b 01 06 08       	push   $0x806016b
 805f133:	56                   	push   %esi
 805f134:	e8 e6 17 00 00       	call   806091f <z_add_timeout>
 805f139:	83 c4 10             	add    $0x10,%esp
	_FOREACH_STATIC_THREAD(thread_data) {
 805f13c:	83 c3 2c             	add    $0x2c,%ebx
 805f13f:	eb a6                	jmp    805f0e7 <z_init_static_threads+0x4d>
}
 805f141:	8d 65 f8             	lea    -0x8(%ebp),%esp
 805f144:	5b                   	pop    %ebx
 805f145:	5e                   	pop    %esi
 805f146:	5d                   	pop    %ebp
	k_sched_unlock();
 805f147:	e9 60 12 00 00       	jmp    80603ac <k_sched_unlock>

0805f14c <idle>:
#endif	/* CONFIG_PM */
	sys_clock_idle_exit();
}

void idle(void *unused1, void *unused2, void *unused3)
{
 805f14c:	55                   	push   %ebp
 805f14d:	89 e5                	mov    %esp,%ebp
 805f14f:	83 ec 08             	sub    $0x8,%esp
	return posix_irq_lock();
 805f152:	e8 c8 ef fe ff       	call   804e11f <posix_irq_lock>
 * @note In some architectures, before returning, the function unmasks interrupts
 * unconditionally.
 */
static inline void k_cpu_idle(void)
{
	arch_cpu_idle();
 805f157:	e8 4c de fe ff       	call   804cfa8 <arch_cpu_idle>
 805f15c:	eb f4                	jmp    805f152 <idle+0x6>

0805f15e <adjust_owner_prio.isra.0>:
	return new_prio;
}

static bool adjust_owner_prio(struct k_mutex *mutex, int32_t new_prio)
{
	if (mutex->owner->base.prio != new_prio) {
 805f15e:	0f be 48 0e          	movsbl 0xe(%eax),%ecx
 805f162:	39 d1                	cmp    %edx,%ecx
 805f164:	74 12                	je     805f178 <adjust_owner_prio.isra.0+0x1a>
static bool adjust_owner_prio(struct k_mutex *mutex, int32_t new_prio)
 805f166:	55                   	push   %ebp
 805f167:	89 e5                	mov    %esp,%ebp
 805f169:	83 ec 10             	sub    $0x10,%esp
		LOG_DBG("%p (ready (y/n): %c) prio changed to %d (was %d)",
			mutex->owner, z_is_thread_ready(mutex->owner) ?
			'y' : 'n',
			new_prio, mutex->owner->base.prio);

		return z_set_prio(mutex->owner, new_prio);
 805f16c:	52                   	push   %edx
 805f16d:	50                   	push   %eax
 805f16e:	e8 16 11 00 00       	call   8060289 <z_set_prio>
 805f173:	83 c4 10             	add    $0x10,%esp
	}
	return false;
}
 805f176:	c9                   	leave  
 805f177:	c3                   	ret    
	return false;
 805f178:	31 c0                	xor    %eax,%eax
}
 805f17a:	c3                   	ret    

0805f17b <z_impl_k_mutex_init>:
{
 805f17b:	55                   	push   %ebp
 805f17c:	89 e5                	mov    %esp,%ebp
 805f17e:	8b 45 08             	mov    0x8(%ebp),%eax
	mutex->owner = NULL;
 805f181:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	mutex->lock_count = 0U;
 805f188:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
	list->head = (sys_dnode_t *)list;
 805f18f:	89 00                	mov    %eax,(%eax)
	list->tail = (sys_dnode_t *)list;
 805f191:	89 40 04             	mov    %eax,0x4(%eax)
}
 805f194:	31 c0                	xor    %eax,%eax
 805f196:	5d                   	pop    %ebp
 805f197:	c3                   	ret    

0805f198 <z_impl_k_mutex_lock>:

int z_impl_k_mutex_lock(struct k_mutex *mutex, k_timeout_t timeout)
{
 805f198:	55                   	push   %ebp
 805f199:	89 e5                	mov    %esp,%ebp
 805f19b:	57                   	push   %edi
 805f19c:	56                   	push   %esi
 805f19d:	53                   	push   %ebx
 805f19e:	83 ec 0c             	sub    $0xc,%esp
 805f1a1:	8b 5d 08             	mov    0x8(%ebp),%ebx
 805f1a4:	e8 76 ef fe ff       	call   804e11f <posix_irq_lock>
 805f1a9:	8b 15 e8 87 06 08    	mov    0x80687e8,%edx

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mutex, lock, mutex, timeout);

	key = k_spin_lock(&lock);

	if (likely((mutex->lock_count == 0U) || (mutex->owner == _current))) {
 805f1af:	8b 4b 0c             	mov    0xc(%ebx),%ecx
 805f1b2:	89 c7                	mov    %eax,%edi
 805f1b4:	85 c9                	test   %ecx,%ecx
 805f1b6:	74 25                	je     805f1dd <z_impl_k_mutex_lock+0x45>
 805f1b8:	8b 43 08             	mov    0x8(%ebx),%eax
 805f1bb:	39 d0                	cmp    %edx,%eax
 805f1bd:	74 24                	je     805f1e3 <z_impl_k_mutex_lock+0x4b>
		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, 0);

		return 0;
	}

	if (unlikely(K_TIMEOUT_EQ(timeout, K_NO_WAIT))) {
 805f1bf:	8b 75 10             	mov    0x10(%ebp),%esi
 805f1c2:	0b 75 0c             	or     0xc(%ebp),%esi
 805f1c5:	75 3c                	jne    805f203 <z_impl_k_mutex_lock+0x6b>
	posix_irq_unlock(key);
 805f1c7:	83 ec 0c             	sub    $0xc,%esp
 805f1ca:	57                   	push   %edi
 805f1cb:	e8 61 ef fe ff       	call   804e131 <posix_irq_unlock>
 805f1d0:	83 c4 10             	add    $0x10,%esp
		k_spin_unlock(&lock, key);

		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, -EBUSY);

		return -EBUSY;
 805f1d3:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
 805f1d8:	e9 c1 00 00 00       	jmp    805f29e <z_impl_k_mutex_lock+0x106>
					_current->base.prio :
 805f1dd:	0f be 42 0e          	movsbl 0xe(%edx),%eax
 805f1e1:	eb 03                	jmp    805f1e6 <z_impl_k_mutex_lock+0x4e>
 805f1e3:	8b 43 10             	mov    0x10(%ebx),%eax
 805f1e6:	83 ec 0c             	sub    $0xc,%esp
		mutex->lock_count++;
 805f1e9:	41                   	inc    %ecx
		mutex->owner_orig_prio = (mutex->lock_count == 0U) ?
 805f1ea:	89 43 10             	mov    %eax,0x10(%ebx)
		mutex->lock_count++;
 805f1ed:	89 4b 0c             	mov    %ecx,0xc(%ebx)
		mutex->owner = _current;
 805f1f0:	89 53 08             	mov    %edx,0x8(%ebx)
 805f1f3:	57                   	push   %edi
 805f1f4:	e8 38 ef fe ff       	call   804e131 <posix_irq_unlock>
 805f1f9:	83 c4 10             	add    $0x10,%esp
		return 0;
 805f1fc:	31 c0                	xor    %eax,%eax
 805f1fe:	e9 9b 00 00 00       	jmp    805f29e <z_impl_k_mutex_lock+0x106>
	}

	SYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_mutex, lock, mutex, timeout);

	new_prio = new_prio_for_inheritance(_current->base.prio,
 805f203:	0f be 48 0e          	movsbl 0xe(%eax),%ecx
 805f207:	0f be 52 0e          	movsbl 0xe(%edx),%edx
 805f20b:	be 81 ff ff ff       	mov    $0xffffff81,%esi
 805f210:	39 ca                	cmp    %ecx,%edx
 805f212:	0f 4f d1             	cmovg  %ecx,%edx
 805f215:	39 f2                	cmp    %esi,%edx
 805f217:	0f 4c d6             	cmovl  %esi,%edx
	bool resched = false;
 805f21a:	31 f6                	xor    %esi,%esi
					    mutex->owner->base.prio);

	LOG_DBG("adjusting prio up on mutex %p", mutex);

	if (z_is_prio_higher(new_prio, mutex->owner->base.prio)) {
 805f21c:	39 d1                	cmp    %edx,%ecx
 805f21e:	7e 07                	jle    805f227 <z_impl_k_mutex_lock+0x8f>
		resched = adjust_owner_prio(mutex, new_prio);
 805f220:	e8 39 ff ff ff       	call   805f15e <adjust_owner_prio.isra.0>
 805f225:	89 c6                	mov    %eax,%esi
	}

	int got_mutex = z_pend_curr(&lock, key, &mutex->wait_q, timeout);
 805f227:	83 ec 0c             	sub    $0xc,%esp
 805f22a:	ff 75 10             	push   0x10(%ebp)
 805f22d:	ff 75 0c             	push   0xc(%ebp)
 805f230:	53                   	push   %ebx
 805f231:	57                   	push   %edi
 805f232:	68 b5 8a 06 08       	push   $0x8068ab5
 805f237:	e8 0d 10 00 00       	call   8060249 <z_pend_curr>
 805f23c:	83 c4 20             	add    $0x20,%esp
	LOG_DBG("on mutex %p got_mutex value: %d", mutex, got_mutex);

	LOG_DBG("%p got mutex %p (y/n): %c", _current, mutex,
		got_mutex ? 'y' : 'n');

	if (got_mutex == 0) {
 805f23f:	85 c0                	test   %eax,%eax
 805f241:	74 5b                	je     805f29e <z_impl_k_mutex_lock+0x106>
	return posix_irq_lock();
 805f243:	e8 d7 ee fe ff       	call   804e11f <posix_irq_lock>
 805f248:	89 c7                	mov    %eax,%edi

	/*
	 * Check if mutex was unlocked after this thread was unpended.
	 * If so, skip adjusting owner's priority down.
	 */
	if (likely(mutex->owner != NULL)) {
 805f24a:	8b 43 08             	mov    0x8(%ebx),%eax
 805f24d:	85 c0                	test   %eax,%eax
 805f24f:	74 27                	je     805f278 <z_impl_k_mutex_lock+0xe0>
 * @return true if empty, false otherwise
 */

static inline bool sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
 805f251:	8b 0b                	mov    (%ebx),%ecx
		struct k_thread *waiter = z_waitq_head(&mutex->wait_q);

		new_prio = (waiter != NULL) ?
			new_prio_for_inheritance(waiter->base.prio, mutex->owner_orig_prio) :
 805f253:	8b 53 10             	mov    0x10(%ebx),%edx
 805f256:	85 c9                	test   %ecx,%ecx
 805f258:	74 17                	je     805f271 <z_impl_k_mutex_lock+0xd9>
 805f25a:	39 cb                	cmp    %ecx,%ebx
 805f25c:	74 13                	je     805f271 <z_impl_k_mutex_lock+0xd9>
 805f25e:	0f be 49 0e          	movsbl 0xe(%ecx),%ecx
 805f262:	39 ca                	cmp    %ecx,%edx
 805f264:	0f 4f d1             	cmovg  %ecx,%edx
 805f267:	b9 81 ff ff ff       	mov    $0xffffff81,%ecx
 805f26c:	39 ca                	cmp    %ecx,%edx
 805f26e:	0f 4c d1             	cmovl  %ecx,%edx
			mutex->owner_orig_prio;

		LOG_DBG("adjusting prio down on mutex %p", mutex);

		resched = adjust_owner_prio(mutex, new_prio) || resched;
 805f271:	e8 e8 fe ff ff       	call   805f15e <adjust_owner_prio.isra.0>
 805f276:	09 c6                	or     %eax,%esi
	}

	if (resched) {
 805f278:	89 f0                	mov    %esi,%eax
 805f27a:	84 c0                	test   %al,%al
 805f27c:	74 0f                	je     805f28d <z_impl_k_mutex_lock+0xf5>
		z_reschedule(&lock, key);
 805f27e:	50                   	push   %eax
 805f27f:	50                   	push   %eax
 805f280:	57                   	push   %edi
 805f281:	68 b5 8a 06 08       	push   $0x8068ab5
 805f286:	e8 d7 0b 00 00       	call   805fe62 <z_reschedule>
 805f28b:	eb 09                	jmp    805f296 <z_impl_k_mutex_lock+0xfe>
	posix_irq_unlock(key);
 805f28d:	83 ec 0c             	sub    $0xc,%esp
 805f290:	57                   	push   %edi
 805f291:	e8 9b ee fe ff       	call   804e131 <posix_irq_unlock>
 805f296:	83 c4 10             	add    $0x10,%esp
		k_spin_unlock(&lock, key);
	}

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, -EAGAIN);

	return -EAGAIN;
 805f299:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
}
 805f29e:	8d 65 f4             	lea    -0xc(%ebp),%esp
 805f2a1:	5b                   	pop    %ebx
 805f2a2:	5e                   	pop    %esi
 805f2a3:	5f                   	pop    %edi
 805f2a4:	5d                   	pop    %ebp
 805f2a5:	c3                   	ret    

0805f2a6 <z_impl_k_mutex_unlock>:
}
#include <syscalls/k_mutex_lock_mrsh.c>
#endif

int z_impl_k_mutex_unlock(struct k_mutex *mutex)
{
 805f2a6:	55                   	push   %ebp
	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mutex, unlock, mutex);

	CHECKIF(mutex->owner == NULL) {
		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, unlock, mutex, -EINVAL);

		return -EINVAL;
 805f2a7:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
{
 805f2ac:	89 e5                	mov    %esp,%ebp
 805f2ae:	56                   	push   %esi
 805f2af:	53                   	push   %ebx
 805f2b0:	8b 5d 08             	mov    0x8(%ebp),%ebx
	CHECKIF(mutex->owner == NULL) {
 805f2b3:	8b 53 08             	mov    0x8(%ebx),%edx
 805f2b6:	85 d2                	test   %edx,%edx
 805f2b8:	74 79                	je     805f333 <z_impl_k_mutex_unlock+0x8d>
	 * The current thread does not own the mutex.
	 */
	CHECKIF(mutex->owner != _current) {
		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, unlock, mutex, -EPERM);

		return -EPERM;
 805f2ba:	83 c8 ff             	or     $0xffffffff,%eax
	CHECKIF(mutex->owner != _current) {
 805f2bd:	3b 15 e8 87 06 08    	cmp    0x80687e8,%edx
 805f2c3:	75 6e                	jne    805f333 <z_impl_k_mutex_unlock+0x8d>

	/*
	 * If we are the owner and count is greater than 1, then decrement
	 * the count and return and keep current thread as the owner.
	 */
	if (mutex->lock_count > 1U) {
 805f2c5:	8b 43 0c             	mov    0xc(%ebx),%eax
 805f2c8:	83 f8 01             	cmp    $0x1,%eax
 805f2cb:	76 06                	jbe    805f2d3 <z_impl_k_mutex_unlock+0x2d>
		mutex->lock_count--;
 805f2cd:	48                   	dec    %eax
 805f2ce:	89 43 0c             	mov    %eax,0xc(%ebx)
		goto k_mutex_unlock_return;
 805f2d1:	eb 5e                	jmp    805f331 <z_impl_k_mutex_unlock+0x8b>
	return posix_irq_lock();
 805f2d3:	e8 47 ee fe ff       	call   804e11f <posix_irq_lock>
	}

	k_spinlock_key_t key = k_spin_lock(&lock);

	adjust_owner_prio(mutex, mutex->owner_orig_prio);
 805f2d8:	8b 53 10             	mov    0x10(%ebx),%edx
 805f2db:	89 c6                	mov    %eax,%esi
 805f2dd:	8b 43 08             	mov    0x8(%ebx),%eax
 805f2e0:	e8 79 fe ff ff       	call   805f15e <adjust_owner_prio.isra.0>

	/* Get the new owner, if any */
	new_owner = z_unpend_first_thread(&mutex->wait_q);
 805f2e5:	83 ec 0c             	sub    $0xc,%esp
 805f2e8:	53                   	push   %ebx
 805f2e9:	e8 ee 10 00 00       	call   80603dc <z_unpend_first_thread>
 805f2ee:	83 c4 10             	add    $0x10,%esp

	mutex->owner = new_owner;
 805f2f1:	89 43 08             	mov    %eax,0x8(%ebx)

	LOG_DBG("new owner of mutex %p: %p (prio: %d)",
		mutex, new_owner, new_owner ? new_owner->base.prio : -1000);

	if (new_owner != NULL) {
 805f2f4:	85 c0                	test   %eax,%eax
 805f2f6:	74 26                	je     805f31e <z_impl_k_mutex_unlock+0x78>
		/*
		 * new owner is already of higher or equal prio than first
		 * waiter since the wait queue is priority-based: no need to
		 * adjust its priority
		 */
		mutex->owner_orig_prio = new_owner->base.prio;
 805f2f8:	0f be 50 0e          	movsbl 0xe(%eax),%edx
		arch_thread_return_value_set(new_owner, 0);
		z_ready_thread(new_owner);
 805f2fc:	83 ec 0c             	sub    $0xc,%esp
		mutex->owner_orig_prio = new_owner->base.prio;
 805f2ff:	89 53 10             	mov    %edx,0x10(%ebx)
	thread->callee_saved.retval = value;
 805f302:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%eax)
		z_ready_thread(new_owner);
 805f309:	50                   	push   %eax
 805f30a:	e8 9f 0d 00 00       	call   80600ae <z_ready_thread>
 805f30f:	58                   	pop    %eax
 805f310:	5a                   	pop    %edx
		z_reschedule(&lock, key);
 805f311:	56                   	push   %esi
 805f312:	68 b5 8a 06 08       	push   $0x8068ab5
 805f317:	e8 46 0b 00 00       	call   805fe62 <z_reschedule>
 805f31c:	eb 10                	jmp    805f32e <z_impl_k_mutex_unlock+0x88>
	posix_irq_unlock(key);
 805f31e:	83 ec 0c             	sub    $0xc,%esp
	} else {
		mutex->lock_count = 0U;
 805f321:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
 805f328:	56                   	push   %esi
 805f329:	e8 03 ee fe ff       	call   804e131 <posix_irq_unlock>
 805f32e:	83 c4 10             	add    $0x10,%esp


k_mutex_unlock_return:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, unlock, mutex, 0);

	return 0;
 805f331:	31 c0                	xor    %eax,%eax
}
 805f333:	8d 65 f8             	lea    -0x8(%ebp),%esp
 805f336:	5b                   	pop    %ebx
 805f337:	5e                   	pop    %esi
 805f338:	5d                   	pop    %ebp
 805f339:	c3                   	ret    

0805f33a <queue_insert>:
#include <syscalls/k_queue_cancel_wait_mrsh.c>
#endif

static int32_t queue_insert(struct k_queue *queue, void *prev, void *data,
			    bool alloc, bool is_append)
{
 805f33a:	55                   	push   %ebp
 805f33b:	89 e5                	mov    %esp,%ebp
 805f33d:	57                   	push   %edi
 805f33e:	89 d7                	mov    %edx,%edi
 805f340:	56                   	push   %esi
 805f341:	89 ce                	mov    %ecx,%esi
 805f343:	53                   	push   %ebx
 805f344:	89 c3                	mov    %eax,%ebx
 805f346:	83 ec 1c             	sub    $0x1c,%esp
 805f349:	8b 45 08             	mov    0x8(%ebp),%eax
 805f34c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
 805f34f:	89 45 dc             	mov    %eax,-0x24(%ebp)
	struct k_thread *first_pending_thread;
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
 805f352:	8d 43 08             	lea    0x8(%ebx),%eax
{
 805f355:	89 4d d8             	mov    %ecx,-0x28(%ebp)
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
 805f358:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	return posix_irq_lock();
 805f35b:	e8 bf ed fe ff       	call   804e11f <posix_irq_lock>

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_queue, queue_insert, queue, alloc);

	if (is_append) {
 805f360:	8b 4d d8             	mov    -0x28(%ebp),%ecx
 805f363:	89 45 e0             	mov    %eax,-0x20(%ebp)
 805f366:	84 c9                	test   %cl,%cl
 805f368:	74 03                	je     805f36d <queue_insert+0x33>
 *
 * @return A pointer on the last node of the list (or NULL if none)
 */
static inline sys_sfnode_t *sys_sflist_peek_tail(sys_sflist_t *list)
{
	return list->tail;
 805f36a:	8b 7b 04             	mov    0x4(%ebx),%edi
		prev = sys_sflist_peek_tail(&queue->data_q);
	}
	first_pending_thread = z_unpend_first_thread(&queue->wait_q);
 805f36d:	83 ec 0c             	sub    $0xc,%esp
 805f370:	ff 75 e4             	push   -0x1c(%ebp)
 805f373:	e8 64 10 00 00       	call   80603dc <z_unpend_first_thread>
 805f378:	83 c4 10             	add    $0x10,%esp

	if (first_pending_thread != NULL) {
 805f37b:	85 c0                	test   %eax,%eax
 805f37d:	74 18                	je     805f397 <queue_insert+0x5d>
	z_ready_thread(thread);
 805f37f:	83 ec 0c             	sub    $0xc,%esp
 805f382:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%eax)
 805f389:	89 70 14             	mov    %esi,0x14(%eax)
 805f38c:	50                   	push   %eax
 805f38d:	e8 1c 0d 00 00       	call   80600ae <z_ready_thread>
 805f392:	e9 96 00 00 00       	jmp    805f42d <queue_insert+0xf3>

		return 0;
	}

	/* Only need to actually allocate if no threads are pending */
	if (alloc) {
 805f397:	80 7d dc 00          	cmpb   $0x0,-0x24(%ebp)
 805f39b:	74 32                	je     805f3cf <queue_insert+0x95>
	return z_thread_aligned_alloc(0, size);
 805f39d:	50                   	push   %eax
 805f39e:	50                   	push   %eax
 805f39f:	6a 08                	push   $0x8
 805f3a1:	6a 00                	push   $0x0
 805f3a3:	e8 4f 1d 00 00       	call   80610f7 <z_thread_aligned_alloc>
 805f3a8:	83 c4 10             	add    $0x10,%esp
		struct alloc_node *anode;

		anode = z_thread_malloc(sizeof(*anode));
		if (anode == NULL) {
 805f3ab:	85 c0                	test   %eax,%eax
 805f3ad:	75 15                	jne    805f3c4 <queue_insert+0x8a>
	posix_irq_unlock(key);
 805f3af:	83 ec 0c             	sub    $0xc,%esp
 805f3b2:	ff 75 e0             	push   -0x20(%ebp)
 805f3b5:	e8 77 ed fe ff       	call   804e131 <posix_irq_unlock>
 805f3ba:	83 c4 10             	add    $0x10,%esp
			k_spin_unlock(&queue->lock, key);

			SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, queue_insert, queue, alloc,
				-ENOMEM);

			return -ENOMEM;
 805f3bd:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
 805f3c2:	eb 7b                	jmp    805f43f <queue_insert+0x105>
		}
		anode->data = data;
 805f3c4:	89 70 04             	mov    %esi,0x4(%eax)
 * @param flags A value between 0 and 3 to set the flags value
 */
static inline void sys_sfnode_init(sys_sfnode_t *node, uint8_t flags)
{
	__ASSERT((flags & ~SYS_SFLIST_FLAGS_MASK) == 0UL, "flags too large");
	node->next_and_flags = flags;
 805f3c7:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
		sys_sfnode_init(&anode->node, 0x1);
		data = anode;
 805f3cd:	eb 08                	jmp    805f3d7 <queue_insert+0x9d>
 805f3cf:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
}
 805f3d5:	89 f0                	mov    %esi,%eax
	parent->next_and_flags = cur_flags | (unative_t)child;
 805f3d7:	8b 08                	mov    (%eax),%ecx
 805f3d9:	83 e1 03             	and    $0x3,%ecx
 */
static inline void sys_sflist_insert(sys_sflist_t *list,
				     sys_sfnode_t *prev,
				     sys_sfnode_t *node);

Z_GENLIST_INSERT(sflist, sfnode)
 805f3dc:	85 ff                	test   %edi,%edi
 805f3de:	75 0e                	jne    805f3ee <queue_insert+0xb4>
	parent->next_and_flags = cur_flags | (unative_t)child;
 805f3e0:	0b 0b                	or     (%ebx),%ecx
 805f3e2:	89 08                	mov    %ecx,(%eax)
Z_GENLIST_PREPEND(sflist, sfnode)
 805f3e4:	83 7b 04 00          	cmpl   $0x0,0x4(%ebx)
	list->head = node;
 805f3e8:	89 03                	mov    %eax,(%ebx)
Z_GENLIST_PREPEND(sflist, sfnode)
 805f3ea:	75 34                	jne    805f420 <queue_insert+0xe6>
 805f3ec:	eb 20                	jmp    805f40e <queue_insert+0xd4>
Z_GENLIST_INSERT(sflist, sfnode)
 805f3ee:	8b 37                	mov    (%edi),%esi
 805f3f0:	83 e6 fc             	and    $0xfffffffc,%esi
 805f3f3:	75 1e                	jne    805f413 <queue_insert+0xd9>
	parent->next_and_flags = cur_flags | (unative_t)child;
 805f3f5:	89 08                	mov    %ecx,(%eax)
	return list->tail;
 805f3f7:	8b 4b 04             	mov    0x4(%ebx),%ecx
Z_GENLIST_APPEND(sflist, sfnode)
 805f3fa:	85 c9                	test   %ecx,%ecx
 805f3fc:	75 07                	jne    805f405 <queue_insert+0xcb>
	list->tail = node;
 805f3fe:	89 43 04             	mov    %eax,0x4(%ebx)
	list->head = node;
 805f401:	89 03                	mov    %eax,(%ebx)
}
 805f403:	eb 1b                	jmp    805f420 <queue_insert+0xe6>
	parent->next_and_flags = cur_flags | (unative_t)child;
 805f405:	8b 11                	mov    (%ecx),%edx
 805f407:	83 e2 03             	and    $0x3,%edx
 805f40a:	09 c2                	or     %eax,%edx
 805f40c:	89 11                	mov    %edx,(%ecx)
	list->tail = node;
 805f40e:	89 43 04             	mov    %eax,0x4(%ebx)
}
 805f411:	eb 0d                	jmp    805f420 <queue_insert+0xe6>
	parent->next_and_flags = cur_flags | (unative_t)child;
 805f413:	09 ce                	or     %ecx,%esi
 805f415:	89 30                	mov    %esi,(%eax)
 805f417:	8b 0f                	mov    (%edi),%ecx
 805f419:	83 e1 03             	and    $0x3,%ecx
 805f41c:	09 c8                	or     %ecx,%eax
 805f41e:	89 07                	mov    %eax,(%edi)
	z_handle_obj_poll_events(&queue->poll_events, state);
 805f420:	83 c3 10             	add    $0x10,%ebx
 805f423:	51                   	push   %ecx
 805f424:	51                   	push   %ecx
 805f425:	6a 04                	push   $0x4
 805f427:	53                   	push   %ebx
 805f428:	e8 33 1c 00 00       	call   8061060 <z_handle_obj_poll_events>
 805f42d:	58                   	pop    %eax
 805f42e:	5a                   	pop    %edx

	SYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_queue, queue_insert, queue, alloc, K_FOREVER);

	sys_sflist_insert(&queue->data_q, prev, data);
	handle_poll_events(queue, K_POLL_STATE_DATA_AVAILABLE);
	z_reschedule(&queue->lock, key);
 805f42f:	ff 75 e0             	push   -0x20(%ebp)
 805f432:	ff 75 e4             	push   -0x1c(%ebp)
 805f435:	e8 28 0a 00 00       	call   805fe62 <z_reschedule>
 805f43a:	83 c4 10             	add    $0x10,%esp

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, queue_insert, queue, alloc, 0);

	return 0;
 805f43d:	31 c0                	xor    %eax,%eax
}
 805f43f:	8d 65 f4             	lea    -0xc(%ebp),%esp
 805f442:	5b                   	pop    %ebx
 805f443:	5e                   	pop    %esi
 805f444:	5f                   	pop    %edi
 805f445:	5d                   	pop    %ebp
 805f446:	c3                   	ret    

0805f447 <z_queue_node_peek>:
{
 805f447:	55                   	push   %ebp
 805f448:	89 e5                	mov    %esp,%ebp
 805f44a:	53                   	push   %ebx
 805f44b:	50                   	push   %eax
 805f44c:	8b 45 08             	mov    0x8(%ebp),%eax
 805f44f:	8b 55 0c             	mov    0xc(%ebp),%edx
	if ((node != NULL) && (sys_sfnode_flags_get(node) != (uint8_t)0)) {
 805f452:	85 c0                	test   %eax,%eax
 805f454:	74 1a                	je     805f470 <z_queue_node_peek+0x29>
 805f456:	f6 00 03             	testb  $0x3,(%eax)
 805f459:	74 15                	je     805f470 <z_queue_node_peek+0x29>
		ret = anode->data;
 805f45b:	8b 58 04             	mov    0x4(%eax),%ebx
		if (needs_free) {
 805f45e:	84 d2                	test   %dl,%dl
 805f460:	74 0c                	je     805f46e <z_queue_node_peek+0x27>
			k_free(anode);
 805f462:	83 ec 0c             	sub    $0xc,%esp
 805f465:	50                   	push   %eax
 805f466:	e8 5d 1c 00 00       	call   80610c8 <k_free>
 805f46b:	83 c4 10             	add    $0x10,%esp
 805f46e:	89 d8                	mov    %ebx,%eax
}
 805f470:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 805f473:	c9                   	leave  
 805f474:	c3                   	ret    

0805f475 <z_impl_k_queue_init>:
{
 805f475:	55                   	push   %ebp
 805f476:	89 e5                	mov    %esp,%ebp
 805f478:	8b 45 08             	mov    0x8(%ebp),%eax
 805f47b:	8d 50 08             	lea    0x8(%eax),%edx
	list->head = NULL;
 805f47e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	list->head = (sys_dnode_t *)list;
 805f484:	89 50 08             	mov    %edx,0x8(%eax)
	list->tail = (sys_dnode_t *)list;
 805f487:	89 50 0c             	mov    %edx,0xc(%eax)
	sys_dlist_init(&queue->poll_events);
 805f48a:	8d 50 10             	lea    0x10(%eax),%edx
	list->tail = NULL;
 805f48d:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	list->head = (sys_dnode_t *)list;
 805f494:	89 50 10             	mov    %edx,0x10(%eax)
	list->tail = (sys_dnode_t *)list;
 805f497:	89 50 14             	mov    %edx,0x14(%eax)
}
 805f49a:	5d                   	pop    %ebp
 805f49b:	c3                   	ret    

0805f49c <z_impl_k_queue_cancel_wait>:
{
 805f49c:	55                   	push   %ebp
 805f49d:	89 e5                	mov    %esp,%ebp
 805f49f:	57                   	push   %edi
 805f4a0:	56                   	push   %esi
 805f4a1:	53                   	push   %ebx
 805f4a2:	83 ec 0c             	sub    $0xc,%esp
 805f4a5:	8b 5d 08             	mov    0x8(%ebp),%ebx
	return posix_irq_lock();
 805f4a8:	e8 72 ec fe ff       	call   804e11f <posix_irq_lock>
	first_pending_thread = z_unpend_first_thread(&queue->wait_q);
 805f4ad:	83 ec 0c             	sub    $0xc,%esp
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
 805f4b0:	8d 7b 08             	lea    0x8(%ebx),%edi
 805f4b3:	89 c6                	mov    %eax,%esi
	first_pending_thread = z_unpend_first_thread(&queue->wait_q);
 805f4b5:	57                   	push   %edi
 805f4b6:	e8 21 0f 00 00       	call   80603dc <z_unpend_first_thread>
 805f4bb:	83 c4 10             	add    $0x10,%esp
	if (first_pending_thread != NULL) {
 805f4be:	85 c0                	test   %eax,%eax
 805f4c0:	74 1a                	je     805f4dc <z_impl_k_queue_cancel_wait+0x40>
	z_ready_thread(thread);
 805f4c2:	83 ec 0c             	sub    $0xc,%esp
 805f4c5:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%eax)
	thread->base.swap_data = data;
 805f4cc:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
 805f4d3:	50                   	push   %eax
 805f4d4:	e8 d5 0b 00 00       	call   80600ae <z_ready_thread>
 805f4d9:	83 c4 10             	add    $0x10,%esp
	z_handle_obj_poll_events(&queue->poll_events, state);
 805f4dc:	83 c3 10             	add    $0x10,%ebx
 805f4df:	50                   	push   %eax
 805f4e0:	50                   	push   %eax
 805f4e1:	6a 08                	push   $0x8
 805f4e3:	53                   	push   %ebx
 805f4e4:	e8 77 1b 00 00       	call   8061060 <z_handle_obj_poll_events>
 805f4e9:	5a                   	pop    %edx
 805f4ea:	59                   	pop    %ecx
	z_reschedule(&queue->lock, key);
 805f4eb:	56                   	push   %esi
 805f4ec:	57                   	push   %edi
 805f4ed:	e8 70 09 00 00       	call   805fe62 <z_reschedule>
 805f4f2:	83 c4 10             	add    $0x10,%esp
}
 805f4f5:	8d 65 f4             	lea    -0xc(%ebp),%esp
 805f4f8:	5b                   	pop    %ebx
 805f4f9:	5e                   	pop    %esi
 805f4fa:	5f                   	pop    %edi
 805f4fb:	5d                   	pop    %ebp
 805f4fc:	c3                   	ret    

0805f4fd <k_queue_append>:

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, insert, queue);
}

void k_queue_append(struct k_queue *queue, void *data)
{
 805f4fd:	55                   	push   %ebp
	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_queue, append, queue);

	(void)queue_insert(queue, NULL, data, false, true);
 805f4fe:	31 d2                	xor    %edx,%edx
{
 805f500:	89 e5                	mov    %esp,%ebp
 805f502:	8b 45 08             	mov    0x8(%ebp),%eax
 805f505:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	(void)queue_insert(queue, NULL, data, false, true);
 805f508:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
 805f50f:	c7 45 0c 01 00 00 00 	movl   $0x1,0xc(%ebp)

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, append, queue);
}
 805f516:	5d                   	pop    %ebp
	(void)queue_insert(queue, NULL, data, false, true);
 805f517:	e9 1e fe ff ff       	jmp    805f33a <queue_insert>

0805f51c <k_queue_prepend>:

void k_queue_prepend(struct k_queue *queue, void *data)
{
 805f51c:	55                   	push   %ebp
	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_queue, prepend, queue);

	(void)queue_insert(queue, NULL, data, false, false);
 805f51d:	31 d2                	xor    %edx,%edx
{
 805f51f:	89 e5                	mov    %esp,%ebp
 805f521:	8b 45 08             	mov    0x8(%ebp),%eax
 805f524:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	(void)queue_insert(queue, NULL, data, false, false);
 805f527:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
 805f52e:	c7 45 0c 00 00 00 00 	movl   $0x0,0xc(%ebp)

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, prepend, queue);
}
 805f535:	5d                   	pop    %ebp
	(void)queue_insert(queue, NULL, data, false, false);
 805f536:	e9 ff fd ff ff       	jmp    805f33a <queue_insert>

0805f53b <z_impl_k_queue_get>:

	return 0;
}

void *z_impl_k_queue_get(struct k_queue *queue, k_timeout_t timeout)
{
 805f53b:	55                   	push   %ebp
 805f53c:	89 e5                	mov    %esp,%ebp
 805f53e:	57                   	push   %edi
 805f53f:	56                   	push   %esi
 805f540:	53                   	push   %ebx
 805f541:	83 ec 0c             	sub    $0xc,%esp
 805f544:	8b 7d 08             	mov    0x8(%ebp),%edi
 805f547:	e8 d3 eb fe ff       	call   804e11f <posix_irq_lock>
	return list->head;
 805f54c:	8b 1f                	mov    (%edi),%ebx
 805f54e:	89 c6                	mov    %eax,%esi
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
	void *data;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_queue, get, queue, timeout);

	if (likely(!sys_sflist_is_empty(&queue->data_q))) {
 805f550:	85 db                	test   %ebx,%ebx
 805f552:	74 20                	je     805f574 <z_impl_k_queue_get+0x39>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
 805f554:	8b 03                	mov    (%ebx),%eax
 805f556:	83 e0 fc             	and    $0xfffffffc,%eax
	list->head = node;
 805f559:	89 07                	mov    %eax,(%edi)
 *
 * @return A pointer to the first node of the list
 */
static inline sys_sfnode_t *sys_sflist_get_not_empty(sys_sflist_t *list);

Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
 805f55b:	3b 5f 04             	cmp    0x4(%edi),%ebx
 805f55e:	75 03                	jne    805f563 <z_impl_k_queue_get+0x28>
	list->tail = node;
 805f560:	89 47 04             	mov    %eax,0x4(%edi)
		sys_sfnode_t *node;

		node = sys_sflist_get_not_empty(&queue->data_q);
		data = z_queue_node_peek(node, true);
 805f563:	50                   	push   %eax
 805f564:	50                   	push   %eax
 805f565:	6a 01                	push   $0x1
 805f567:	53                   	push   %ebx
 805f568:	e8 da fe ff ff       	call   805f447 <z_queue_node_peek>
	posix_irq_unlock(key);
 805f56d:	89 34 24             	mov    %esi,(%esp)
 805f570:	89 c3                	mov    %eax,%ebx
 805f572:	eb 0c                	jmp    805f580 <z_impl_k_queue_get+0x45>
		return data;
	}

	SYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_queue, get, queue, timeout);

	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
 805f574:	8b 45 10             	mov    0x10(%ebp),%eax
 805f577:	0b 45 0c             	or     0xc(%ebp),%eax
 805f57a:	75 0e                	jne    805f58a <z_impl_k_queue_get+0x4f>
 805f57c:	83 ec 0c             	sub    $0xc,%esp
 805f57f:	56                   	push   %esi
 805f580:	e8 ac eb fe ff       	call   804e131 <posix_irq_unlock>
 805f585:	83 c4 10             	add    $0x10,%esp
		k_spin_unlock(&queue->lock, key);

		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, get, queue, timeout, NULL);

		return NULL;
 805f588:	eb 23                	jmp    805f5ad <z_impl_k_queue_get+0x72>
	}

	int ret = z_pend_curr(&queue->lock, key, &queue->wait_q, timeout);
 805f58a:	83 ec 0c             	sub    $0xc,%esp
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
 805f58d:	8d 57 08             	lea    0x8(%edi),%edx
	int ret = z_pend_curr(&queue->lock, key, &queue->wait_q, timeout);
 805f590:	ff 75 10             	push   0x10(%ebp)
 805f593:	ff 75 0c             	push   0xc(%ebp)
 805f596:	52                   	push   %edx
 805f597:	56                   	push   %esi
 805f598:	52                   	push   %edx
 805f599:	e8 ab 0c 00 00       	call   8060249 <z_pend_curr>
 805f59e:	83 c4 20             	add    $0x20,%esp

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, get, queue, timeout,
		(ret != 0) ? NULL : _current->base.swap_data);

	return (ret != 0) ? NULL : _current->base.swap_data;
 805f5a1:	85 c0                	test   %eax,%eax
 805f5a3:	75 08                	jne    805f5ad <z_impl_k_queue_get+0x72>
 805f5a5:	a1 e8 87 06 08       	mov    0x80687e8,%eax
 805f5aa:	8b 58 14             	mov    0x14(%eax),%ebx
}
 805f5ad:	8d 65 f4             	lea    -0xc(%ebp),%esp
 805f5b0:	89 d8                	mov    %ebx,%eax
 805f5b2:	5b                   	pop    %ebx
 805f5b3:	5e                   	pop    %esi
 805f5b4:	5f                   	pop    %edi
 805f5b5:	5d                   	pop    %ebp
 805f5b6:	c3                   	ret    

0805f5b7 <k_queue_unique_append>:

	return ret;
}

bool k_queue_unique_append(struct k_queue *queue, void *data)
{
 805f5b7:	55                   	push   %ebp
 805f5b8:	89 e5                	mov    %esp,%ebp
 805f5ba:	83 ec 08             	sub    $0x8,%esp
 805f5bd:	8b 55 08             	mov    0x8(%ebp),%edx
 805f5c0:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	return list->head;
 805f5c3:	8b 02                	mov    (%edx),%eax
	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_queue, unique_append, queue);

	sys_sfnode_t *test;

	SYS_SFLIST_FOR_EACH_NODE(&queue->data_q, test) {
 805f5c5:	85 c0                	test   %eax,%eax
 805f5c7:	74 0b                	je     805f5d4 <k_queue_unique_append+0x1d>
		if (test == (sys_sfnode_t *) data) {
 805f5c9:	39 c8                	cmp    %ecx,%eax
 805f5cb:	74 17                	je     805f5e4 <k_queue_unique_append+0x2d>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
 805f5cd:	8b 00                	mov    (%eax),%eax
 805f5cf:	83 e0 fc             	and    $0xfffffffc,%eax
 805f5d2:	eb f1                	jmp    805f5c5 <k_queue_unique_append+0xe>

			return false;
		}
	}

	k_queue_append(queue, data);
 805f5d4:	50                   	push   %eax
 805f5d5:	50                   	push   %eax
 805f5d6:	51                   	push   %ecx
 805f5d7:	52                   	push   %edx
 805f5d8:	e8 20 ff ff ff       	call   805f4fd <k_queue_append>
 805f5dd:	83 c4 10             	add    $0x10,%esp

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, unique_append, queue, true);

	return true;
 805f5e0:	b0 01                	mov    $0x1,%al
 805f5e2:	eb 02                	jmp    805f5e6 <k_queue_unique_append+0x2f>
			return false;
 805f5e4:	31 c0                	xor    %eax,%eax
}
 805f5e6:	c9                   	leave  
 805f5e7:	c3                   	ret    

0805f5e8 <z_impl_k_queue_peek_head>:

void *z_impl_k_queue_peek_head(struct k_queue *queue)
{
 805f5e8:	55                   	push   %ebp
 805f5e9:	89 e5                	mov    %esp,%ebp
 805f5eb:	83 ec 10             	sub    $0x10,%esp
	void *ret = z_queue_node_peek(sys_sflist_peek_head(&queue->data_q), false);
 805f5ee:	8b 45 08             	mov    0x8(%ebp),%eax
 805f5f1:	6a 00                	push   $0x0
 805f5f3:	ff 30                	push   (%eax)
 805f5f5:	e8 4d fe ff ff       	call   805f447 <z_queue_node_peek>
 805f5fa:	83 c4 10             	add    $0x10,%esp

	SYS_PORT_TRACING_OBJ_FUNC(k_queue, peek_head, queue, ret);

	return ret;
}
 805f5fd:	c9                   	leave  
 805f5fe:	c3                   	ret    

0805f5ff <z_impl_k_queue_peek_tail>:

void *z_impl_k_queue_peek_tail(struct k_queue *queue)
{
 805f5ff:	55                   	push   %ebp
 805f600:	89 e5                	mov    %esp,%ebp
 805f602:	83 ec 10             	sub    $0x10,%esp
	void *ret = z_queue_node_peek(sys_sflist_peek_tail(&queue->data_q), false);
 805f605:	8b 45 08             	mov    0x8(%ebp),%eax
 805f608:	6a 00                	push   $0x0
 805f60a:	ff 70 04             	push   0x4(%eax)
 805f60d:	e8 35 fe ff ff       	call   805f447 <z_queue_node_peek>
 805f612:	83 c4 10             	add    $0x10,%esp

	SYS_PORT_TRACING_OBJ_FUNC(k_queue, peek_tail, queue, ret);

	return ret;
}
 805f615:	c9                   	leave  
 805f616:	c3                   	ret    

0805f617 <z_impl_k_sem_init>:
 */
static struct k_spinlock lock;

int z_impl_k_sem_init(struct k_sem *sem, unsigned int initial_count,
		      unsigned int limit)
{
 805f617:	55                   	push   %ebp
 805f618:	89 e5                	mov    %esp,%ebp
 805f61a:	8b 55 10             	mov    0x10(%ebp),%edx
 805f61d:	8b 45 08             	mov    0x8(%ebp),%eax
 805f620:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	/*
	 * Limit cannot be zero and count cannot be greater than limit
	 */
	CHECKIF(limit == 0U || limit > K_SEM_MAX_LIMIT || initial_count > limit) {
 805f623:	85 d2                	test   %edx,%edx
 805f625:	74 1c                	je     805f643 <z_impl_k_sem_init+0x2c>
 805f627:	39 ca                	cmp    %ecx,%edx
 805f629:	72 18                	jb     805f643 <z_impl_k_sem_init+0x2c>

		return -EINVAL;
	}

	sem->count = initial_count;
	sem->limit = limit;
 805f62b:	89 50 0c             	mov    %edx,0xc(%eax)

	SYS_PORT_TRACING_OBJ_FUNC(k_sem, init, sem, 0);

	z_waitq_init(&sem->wait_q);
#if defined(CONFIG_POLL)
	sys_dlist_init(&sem->poll_events);
 805f62e:	8d 50 10             	lea    0x10(%eax),%edx
	sem->count = initial_count;
 805f631:	89 48 08             	mov    %ecx,0x8(%eax)
	list->head = (sys_dnode_t *)list;
 805f634:	89 00                	mov    %eax,(%eax)
	list->tail = (sys_dnode_t *)list;
 805f636:	89 40 04             	mov    %eax,0x4(%eax)
	list->head = (sys_dnode_t *)list;
 805f639:	89 50 10             	mov    %edx,0x10(%eax)
	list->tail = (sys_dnode_t *)list;
 805f63c:	89 50 14             	mov    %edx,0x14(%eax)
#endif
	z_object_init(sem);

	return 0;
 805f63f:	31 c0                	xor    %eax,%eax
 805f641:	eb 05                	jmp    805f648 <z_impl_k_sem_init+0x31>
		return -EINVAL;
 805f643:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
}
 805f648:	5d                   	pop    %ebp
 805f649:	c3                   	ret    

0805f64a <z_impl_k_sem_give>:
	ARG_UNUSED(sem);
#endif
}

void z_impl_k_sem_give(struct k_sem *sem)
{
 805f64a:	55                   	push   %ebp
 805f64b:	89 e5                	mov    %esp,%ebp
 805f64d:	56                   	push   %esi
 805f64e:	53                   	push   %ebx
 805f64f:	8b 5d 08             	mov    0x8(%ebp),%ebx
	return posix_irq_lock();
 805f652:	e8 c8 ea fe ff       	call   804e11f <posix_irq_lock>
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_thread *thread;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_sem, give, sem);

	thread = z_unpend_first_thread(&sem->wait_q);
 805f657:	83 ec 0c             	sub    $0xc,%esp
 805f65a:	53                   	push   %ebx
 805f65b:	89 c6                	mov    %eax,%esi
 805f65d:	e8 7a 0d 00 00       	call   80603dc <z_unpend_first_thread>
 805f662:	83 c4 10             	add    $0x10,%esp

	if (thread != NULL) {
 805f665:	85 c0                	test   %eax,%eax
 805f667:	74 12                	je     805f67b <z_impl_k_sem_give+0x31>
		arch_thread_return_value_set(thread, 0);
		z_ready_thread(thread);
 805f669:	83 ec 0c             	sub    $0xc,%esp
 805f66c:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%eax)
 805f673:	50                   	push   %eax
 805f674:	e8 35 0a 00 00       	call   80600ae <z_ready_thread>
 805f679:	eb 1d                	jmp    805f698 <z_impl_k_sem_give+0x4e>
	} else {
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
 805f67b:	8b 53 08             	mov    0x8(%ebx),%edx
 805f67e:	31 c0                	xor    %eax,%eax
 805f680:	39 53 0c             	cmp    %edx,0xc(%ebx)
 805f683:	0f 95 c0             	setne  %al
	z_handle_obj_poll_events(&sem->poll_events, K_POLL_STATE_SEM_AVAILABLE);
 805f686:	83 c3 10             	add    $0x10,%ebx
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
 805f689:	01 d0                	add    %edx,%eax
 805f68b:	89 43 f8             	mov    %eax,-0x8(%ebx)
	z_handle_obj_poll_events(&sem->poll_events, K_POLL_STATE_SEM_AVAILABLE);
 805f68e:	52                   	push   %edx
 805f68f:	52                   	push   %edx
 805f690:	6a 02                	push   $0x2
 805f692:	53                   	push   %ebx
 805f693:	e8 c8 19 00 00       	call   8061060 <z_handle_obj_poll_events>
 805f698:	83 c4 10             	add    $0x10,%esp
		handle_poll_events(sem);
	}

	z_reschedule(&lock, key);
 805f69b:	50                   	push   %eax
 805f69c:	50                   	push   %eax
 805f69d:	56                   	push   %esi
 805f69e:	68 b5 8a 06 08       	push   $0x8068ab5
 805f6a3:	e8 ba 07 00 00       	call   805fe62 <z_reschedule>
 805f6a8:	83 c4 10             	add    $0x10,%esp

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_sem, give, sem);
}
 805f6ab:	8d 65 f8             	lea    -0x8(%ebp),%esp
 805f6ae:	5b                   	pop    %ebx
 805f6af:	5e                   	pop    %esi
 805f6b0:	5d                   	pop    %ebp
 805f6b1:	c3                   	ret    

0805f6b2 <z_impl_k_sem_take>:
}
#include <syscalls/k_sem_give_mrsh.c>
#endif

int z_impl_k_sem_take(struct k_sem *sem, k_timeout_t timeout)
{
 805f6b2:	55                   	push   %ebp
 805f6b3:	89 e5                	mov    %esp,%ebp
 805f6b5:	57                   	push   %edi
 805f6b6:	56                   	push   %esi
 805f6b7:	53                   	push   %ebx
 805f6b8:	83 ec 0c             	sub    $0xc,%esp
 805f6bb:	8b 5d 08             	mov    0x8(%ebp),%ebx
 805f6be:	8b 75 0c             	mov    0xc(%ebp),%esi
 805f6c1:	8b 7d 10             	mov    0x10(%ebp),%edi
 805f6c4:	e8 56 ea fe ff       	call   804e11f <posix_irq_lock>

	k_spinlock_key_t key = k_spin_lock(&lock);

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_sem, take, sem, timeout);

	if (likely(sem->count > 0U)) {
 805f6c9:	8b 53 08             	mov    0x8(%ebx),%edx
 805f6cc:	85 d2                	test   %edx,%edx
 805f6ce:	74 14                	je     805f6e4 <z_impl_k_sem_take+0x32>
	posix_irq_unlock(key);
 805f6d0:	83 ec 0c             	sub    $0xc,%esp
		sem->count--;
 805f6d3:	4a                   	dec    %edx
 805f6d4:	89 53 08             	mov    %edx,0x8(%ebx)
 805f6d7:	50                   	push   %eax
 805f6d8:	e8 54 ea fe ff       	call   804e131 <posix_irq_unlock>
 805f6dd:	83 c4 10             	add    $0x10,%esp
		k_spin_unlock(&lock, key);
		ret = 0;
 805f6e0:	31 c0                	xor    %eax,%eax
		goto out;
 805f6e2:	eb 2d                	jmp    805f711 <z_impl_k_sem_take+0x5f>
	}

	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
 805f6e4:	89 f9                	mov    %edi,%ecx
 805f6e6:	09 f1                	or     %esi,%ecx
 805f6e8:	75 13                	jne    805f6fd <z_impl_k_sem_take+0x4b>
 805f6ea:	83 ec 0c             	sub    $0xc,%esp
 805f6ed:	50                   	push   %eax
 805f6ee:	e8 3e ea fe ff       	call   804e131 <posix_irq_unlock>
 805f6f3:	83 c4 10             	add    $0x10,%esp
		k_spin_unlock(&lock, key);
		ret = -EBUSY;
 805f6f6:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
 805f6fb:	eb 14                	jmp    805f711 <z_impl_k_sem_take+0x5f>
		goto out;
	}

	SYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_sem, take, sem, timeout);

	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
 805f6fd:	83 ec 0c             	sub    $0xc,%esp
 805f700:	57                   	push   %edi
 805f701:	56                   	push   %esi
 805f702:	53                   	push   %ebx
 805f703:	50                   	push   %eax
 805f704:	68 b5 8a 06 08       	push   $0x8068ab5
 805f709:	e8 3b 0b 00 00       	call   8060249 <z_pend_curr>
 805f70e:	83 c4 20             	add    $0x20,%esp

out:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_sem, take, sem, timeout, ret);

	return ret;
}
 805f711:	8d 65 f4             	lea    -0xc(%ebp),%esp
 805f714:	5b                   	pop    %ebx
 805f715:	5e                   	pop    %esi
 805f716:	5f                   	pop    %edi
 805f717:	5d                   	pop    %ebp
 805f718:	c3                   	ret    

0805f719 <z_impl_k_sem_reset>:

void z_impl_k_sem_reset(struct k_sem *sem)
{
 805f719:	55                   	push   %ebp
 805f71a:	89 e5                	mov    %esp,%ebp
 805f71c:	56                   	push   %esi
 805f71d:	53                   	push   %ebx
 805f71e:	8b 5d 08             	mov    0x8(%ebp),%ebx
	return posix_irq_lock();
 805f721:	e8 f9 e9 fe ff       	call   804e11f <posix_irq_lock>
 805f726:	89 c6                	mov    %eax,%esi
	struct k_thread *thread;
	k_spinlock_key_t key = k_spin_lock(&lock);

	while (true) {
		thread = z_unpend_first_thread(&sem->wait_q);
 805f728:	83 ec 0c             	sub    $0xc,%esp
 805f72b:	53                   	push   %ebx
 805f72c:	e8 ab 0c 00 00       	call   80603dc <z_unpend_first_thread>
 805f731:	83 c4 10             	add    $0x10,%esp
		if (thread == NULL) {
 805f734:	85 c0                	test   %eax,%eax
 805f736:	74 15                	je     805f74d <z_impl_k_sem_reset+0x34>
			break;
		}
		arch_thread_return_value_set(thread, -EAGAIN);
		z_ready_thread(thread);
 805f738:	83 ec 0c             	sub    $0xc,%esp
 805f73b:	c7 40 30 f5 ff ff ff 	movl   $0xfffffff5,0x30(%eax)
 805f742:	50                   	push   %eax
 805f743:	e8 66 09 00 00       	call   80600ae <z_ready_thread>
 805f748:	83 c4 10             	add    $0x10,%esp
		thread = z_unpend_first_thread(&sem->wait_q);
 805f74b:	eb db                	jmp    805f728 <z_impl_k_sem_reset+0xf>
	}
	sem->count = 0;
 805f74d:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
	z_handle_obj_poll_events(&sem->poll_events, K_POLL_STATE_SEM_AVAILABLE);
 805f754:	83 c3 10             	add    $0x10,%ebx
 805f757:	50                   	push   %eax
 805f758:	50                   	push   %eax
 805f759:	6a 02                	push   $0x2
 805f75b:	53                   	push   %ebx
 805f75c:	e8 ff 18 00 00       	call   8061060 <z_handle_obj_poll_events>
 805f761:	5a                   	pop    %edx
 805f762:	59                   	pop    %ecx

	SYS_PORT_TRACING_OBJ_FUNC(k_sem, reset, sem);

	handle_poll_events(sem);

	z_reschedule(&lock, key);
 805f763:	56                   	push   %esi
 805f764:	68 b5 8a 06 08       	push   $0x8068ab5
 805f769:	e8 f4 06 00 00       	call   805fe62 <z_reschedule>
 805f76e:	83 c4 10             	add    $0x10,%esp
}
 805f771:	8d 65 f8             	lea    -0x8(%ebp),%esp
 805f774:	5b                   	pop    %ebx
 805f775:	5e                   	pop    %esi
 805f776:	5d                   	pop    %ebp
 805f777:	c3                   	ret    

0805f778 <flag_test_and_clear>:
	return (*flagp & BIT(bit)) != 0U;
}

static inline bool flag_test_and_clear(uint32_t *flagp,
				       int bit)
{
 805f778:	55                   	push   %ebp
 805f779:	89 d1                	mov    %edx,%ecx
 805f77b:	89 e5                	mov    %esp,%ebp
 805f77d:	53                   	push   %ebx
	return (*flagp & BIT(bit)) != 0U;
 805f77e:	8b 18                	mov    (%eax),%ebx
	*flagp &= ~BIT(bit);
 805f780:	89 da                	mov    %ebx,%edx
 805f782:	0f b3 ca             	btr    %ecx,%edx
 805f785:	89 10                	mov    %edx,(%eax)
	return (*flagp & BIT(bit)) != 0U;
 805f787:	89 d8                	mov    %ebx,%eax
	bool ret = flag_test(flagp, bit);

	flag_clear(flagp, bit);

	return ret;
}
 805f789:	5b                   	pop    %ebx
	return (*flagp & BIT(bit)) != 0U;
 805f78a:	d3 e8                	shr    %cl,%eax
}
 805f78c:	5d                   	pop    %ebp
	return (*flagp & BIT(bit)) != 0U;
 805f78d:	83 e0 01             	and    $0x1,%eax
}
 805f790:	c3                   	ret    

0805f791 <unschedule_locked>:
 *
 * @return true if and only if work had been delayed so the timeout
 * was cancelled.
 */
static inline bool unschedule_locked(struct k_work_delayable *dwork)
{
 805f791:	55                   	push   %ebp
 805f792:	89 e5                	mov    %esp,%ebp
 805f794:	53                   	push   %ebx
 805f795:	89 c3                	mov    %eax,%ebx
	/* If scheduled, try to cancel.  If it fails, that means the
	 * callback has been dequeued and will inevitably run (or has
	 * already run), so treat that as "undelayed" and return
	 * false.
	 */
	if (flag_test_and_clear(&work->flags, K_WORK_DELAYED_BIT)) {
 805f797:	83 c0 0c             	add    $0xc,%eax
{
 805f79a:	52                   	push   %edx
	if (flag_test_and_clear(&work->flags, K_WORK_DELAYED_BIT)) {
 805f79b:	ba 03 00 00 00       	mov    $0x3,%edx
 805f7a0:	e8 d3 ff ff ff       	call   805f778 <flag_test_and_clear>
 805f7a5:	84 c0                	test   %al,%al
 805f7a7:	74 14                	je     805f7bd <unschedule_locked+0x2c>
		ret = z_abort_timeout(&dwork->timeout) == 0;
 805f7a9:	83 ec 0c             	sub    $0xc,%esp
 805f7ac:	83 c3 10             	add    $0x10,%ebx
 805f7af:	53                   	push   %ebx
 805f7b0:	e8 a9 12 00 00       	call   8060a5e <z_abort_timeout>
 805f7b5:	83 c4 10             	add    $0x10,%esp
 805f7b8:	85 c0                	test   %eax,%eax
 805f7ba:	0f 94 c0             	sete   %al
	}

	return ret;
}
 805f7bd:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 805f7c0:	c9                   	leave  
 805f7c1:	c3                   	ret    

0805f7c2 <notify_queue_locked.isra.0>:
	if (queue != NULL) {
 805f7c2:	85 c0                	test   %eax,%eax
 805f7c4:	74 18                	je     805f7de <notify_queue_locked.isra.0+0x1c>
static inline bool notify_queue_locked(struct k_work_q *queue)
 805f7c6:	55                   	push   %ebp
		rv = z_sched_wake(&queue->notifyq, 0, NULL);
 805f7c7:	83 c0 5c             	add    $0x5c,%eax
static inline bool notify_queue_locked(struct k_work_q *queue)
 805f7ca:	89 e5                	mov    %esp,%ebp
 805f7cc:	83 ec 0c             	sub    $0xc,%esp
		rv = z_sched_wake(&queue->notifyq, 0, NULL);
 805f7cf:	6a 00                	push   $0x0
 805f7d1:	6a 00                	push   $0x0
 805f7d3:	50                   	push   %eax
 805f7d4:	e8 00 0f 00 00       	call   80606d9 <z_sched_wake>
 805f7d9:	83 c4 10             	add    $0x10,%esp
}
 805f7dc:	c9                   	leave  
 805f7dd:	c3                   	ret    
 805f7de:	c3                   	ret    

0805f7df <cancel_async_locked>:
{
 805f7df:	55                   	push   %ebp
 805f7e0:	89 e5                	mov    %esp,%ebp
 805f7e2:	56                   	push   %esi
 805f7e3:	53                   	push   %ebx
 805f7e4:	89 c3                	mov    %eax,%ebx
	if (!flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
 805f7e6:	f6 40 0c 02          	testb  $0x2,0xc(%eax)
 805f7ea:	75 4c                	jne    805f838 <cancel_async_locked+0x59>
		queue_remove_locked(work->queue, work);
 805f7ec:	8b 70 08             	mov    0x8(%eax),%esi
	if (flag_test_and_clear(&work->flags, K_WORK_QUEUED_BIT)) {
 805f7ef:	ba 02 00 00 00       	mov    $0x2,%edx
 805f7f4:	8d 40 0c             	lea    0xc(%eax),%eax
 805f7f7:	e8 7c ff ff ff       	call   805f778 <flag_test_and_clear>
 805f7fc:	84 c0                	test   %al,%al
 805f7fe:	74 38                	je     805f838 <cancel_async_locked+0x59>
	return list->head;
 805f800:	8b 46 54             	mov    0x54(%esi),%eax
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
 805f803:	31 d2                	xor    %edx,%edx
 805f805:	85 c0                	test   %eax,%eax
 805f807:	74 2f                	je     805f838 <cancel_async_locked+0x59>
 805f809:	39 c3                	cmp    %eax,%ebx
 805f80b:	75 25                	jne    805f832 <cancel_async_locked+0x53>
	return node->next;
 805f80d:	8b 03                	mov    (%ebx),%eax
Z_GENLIST_REMOVE(slist, snode)
 805f80f:	85 d2                	test   %edx,%edx
 805f811:	75 0d                	jne    805f820 <cancel_async_locked+0x41>
	list->head = node;
 805f813:	89 46 54             	mov    %eax,0x54(%esi)
Z_GENLIST_REMOVE(slist, snode)
 805f816:	3b 5e 58             	cmp    0x58(%esi),%ebx
 805f819:	75 0f                	jne    805f82a <cancel_async_locked+0x4b>
	list->tail = node;
 805f81b:	89 46 58             	mov    %eax,0x58(%esi)
}
 805f81e:	eb 0a                	jmp    805f82a <cancel_async_locked+0x4b>
	parent->next = child;
 805f820:	89 02                	mov    %eax,(%edx)
Z_GENLIST_REMOVE(slist, snode)
 805f822:	3b 5e 58             	cmp    0x58(%esi),%ebx
 805f825:	75 03                	jne    805f82a <cancel_async_locked+0x4b>
	list->tail = node;
 805f827:	89 56 58             	mov    %edx,0x58(%esi)
	parent->next = child;
 805f82a:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
Z_GENLIST_REMOVE(slist, snode)
 805f830:	eb 06                	jmp    805f838 <cancel_async_locked+0x59>
	return node->next;
 805f832:	89 c2                	mov    %eax,%edx
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
 805f834:	8b 00                	mov    (%eax),%eax
 805f836:	eb cd                	jmp    805f805 <cancel_async_locked+0x26>
	return *flagp;
 805f838:	8b 53 0c             	mov    0xc(%ebx),%edx
	if (ret != 0) {
 805f83b:	89 d0                	mov    %edx,%eax
 805f83d:	83 e0 0f             	and    $0xf,%eax
 805f840:	74 0b                	je     805f84d <cancel_async_locked+0x6e>
	*flagp |= BIT(bit);
 805f842:	89 d0                	mov    %edx,%eax
 805f844:	83 c8 02             	or     $0x2,%eax
 805f847:	89 43 0c             	mov    %eax,0xc(%ebx)
	return flags_get(&work->flags) & K_WORK_MASK;
 805f84a:	83 e0 0f             	and    $0xf,%eax
}
 805f84d:	5b                   	pop    %ebx
 805f84e:	5e                   	pop    %esi
 805f84f:	5d                   	pop    %ebp
 805f850:	c3                   	ret    

0805f851 <work_queue_main>:
{
 805f851:	55                   	push   %ebp
 805f852:	89 e5                	mov    %esp,%ebp
 805f854:	57                   	push   %edi
 805f855:	56                   	push   %esi
 805f856:	53                   	push   %ebx
 805f857:	83 ec 1c             	sub    $0x1c,%esp
 805f85a:	8b 75 08             	mov    0x8(%ebp),%esi
 805f85d:	e8 bd e8 fe ff       	call   804e11f <posix_irq_lock>
	return list->head;
 805f862:	8b 5e 54             	mov    0x54(%esi),%ebx
 805f865:	89 c7                	mov    %eax,%edi
Z_GENLIST_GET(slist, snode)
 805f867:	85 db                	test   %ebx,%ebx
 805f869:	75 2d                	jne    805f898 <work_queue_main+0x47>
		} else if (flag_test_and_clear(&queue->flags,
 805f86b:	8d 46 6c             	lea    0x6c(%esi),%eax
 805f86e:	ba 02 00 00 00       	mov    $0x2,%edx
 805f873:	e8 00 ff ff ff       	call   805f778 <flag_test_and_clear>
 805f878:	84 c0                	test   %al,%al
 805f87a:	75 2b                	jne    805f8a7 <work_queue_main+0x56>
			(void)z_sched_wait(&lock, key, &queue->notifyq,
 805f87c:	8d 46 5c             	lea    0x5c(%esi),%eax
 805f87f:	52                   	push   %edx
 805f880:	52                   	push   %edx
 805f881:	6a 00                	push   $0x0
 805f883:	6a ff                	push   $0xffffffff
 805f885:	6a ff                	push   $0xffffffff
 805f887:	50                   	push   %eax
 805f888:	57                   	push   %edi
 805f889:	68 b5 8a 06 08       	push   $0x8068ab5
 805f88e:	e8 af 0e 00 00       	call   8060742 <z_sched_wait>
 805f893:	83 c4 20             	add    $0x20,%esp
			continue;
 805f896:	eb c5                	jmp    805f85d <work_queue_main+0xc>
	return node->next;
 805f898:	8b 03                	mov    (%ebx),%eax
	list->head = node;
 805f89a:	89 46 54             	mov    %eax,0x54(%esi)
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
 805f89d:	3b 5e 58             	cmp    0x58(%esi),%ebx
 805f8a0:	75 1c                	jne    805f8be <work_queue_main+0x6d>
	list->tail = node;
 805f8a2:	89 46 58             	mov    %eax,0x58(%esi)
}
 805f8a5:	eb 17                	jmp    805f8be <work_queue_main+0x6d>
			(void)z_sched_wake_all(&queue->drainq, 1, NULL);
 805f8a7:	8d 5e 64             	lea    0x64(%esi),%ebx
static inline bool z_sched_wake_all(_wait_q_t *wait_q, int swap_retval,
				    void *swap_data)
{
	bool woken = false;

	while (z_sched_wake(wait_q, swap_retval, swap_data)) {
 805f8aa:	50                   	push   %eax
 805f8ab:	6a 00                	push   $0x0
 805f8ad:	6a 01                	push   $0x1
 805f8af:	53                   	push   %ebx
 805f8b0:	e8 24 0e 00 00       	call   80606d9 <z_sched_wake>
 805f8b5:	83 c4 10             	add    $0x10,%esp
 805f8b8:	84 c0                	test   %al,%al
 805f8ba:	75 ee                	jne    805f8aa <work_queue_main+0x59>
 805f8bc:	eb be                	jmp    805f87c <work_queue_main+0x2b>
	*flagp |= BIT(bit);
 805f8be:	83 4e 6c 02          	orl    $0x2,0x6c(%esi)
	*flagp &= ~BIT(bit);
 805f8c2:	8b 43 0c             	mov    0xc(%ebx),%eax
	posix_irq_unlock(key);
 805f8c5:	83 ec 0c             	sub    $0xc,%esp
 805f8c8:	83 e0 fb             	and    $0xfffffffb,%eax
 805f8cb:	83 c8 01             	or     $0x1,%eax
 805f8ce:	89 43 0c             	mov    %eax,0xc(%ebx)
			handler = work->handler;
 805f8d1:	8b 43 04             	mov    0x4(%ebx),%eax
 805f8d4:	57                   	push   %edi
 805f8d5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 805f8d8:	e8 54 e8 fe ff       	call   804e131 <posix_irq_unlock>
		handler(work);
 805f8dd:	89 1c 24             	mov    %ebx,(%esp)
 805f8e0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 805f8e3:	ff d0                	call   *%eax
 805f8e5:	83 c4 10             	add    $0x10,%esp
	return posix_irq_lock();
 805f8e8:	e8 32 e8 fe ff       	call   804e11f <posix_irq_lock>
 805f8ed:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	*flagp &= ~BIT(bit);
 805f8f0:	8b 43 0c             	mov    0xc(%ebx),%eax
 805f8f3:	89 c2                	mov    %eax,%edx
 805f8f5:	83 e2 fe             	and    $0xfffffffe,%edx
		if (flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
 805f8f8:	a8 02                	test   $0x2,%al
 805f8fa:	0f 84 9e 00 00 00    	je     805f99e <work_queue_main+0x14d>
	*flagp &= ~BIT(bit);
 805f900:	83 e0 fc             	and    $0xfffffffc,%eax
 805f903:	89 43 0c             	mov    %eax,0xc(%ebx)
	return list->head;
 805f906:	a1 84 8a 06 08       	mov    0x8068a84,%eax
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&pending_cancels, wc, tmp, node) {
 805f90b:	85 c0                	test   %eax,%eax
 805f90d:	75 2b                	jne    805f93a <work_queue_main+0xe9>
	*flagp &= ~BIT(bit);
 805f90f:	8b 5e 6c             	mov    0x6c(%esi),%ebx
	posix_irq_unlock(key);
 805f912:	83 ec 0c             	sub    $0xc,%esp
 805f915:	83 e3 fd             	and    $0xfffffffd,%ebx
 805f918:	89 5e 6c             	mov    %ebx,0x6c(%esi)
 805f91b:	ff 75 e4             	push   -0x1c(%ebp)
 805f91e:	e8 0e e8 fe ff       	call   804e131 <posix_irq_unlock>
 805f923:	83 c4 10             	add    $0x10,%esp
		if (yield) {
 805f926:	0f ba e3 08          	bt     $0x8,%ebx
 805f92a:	0f 82 2d ff ff ff    	jb     805f85d <work_queue_main+0xc>
	z_impl_k_yield();
 805f930:	e8 3b 0b 00 00       	call   8060470 <z_impl_k_yield>
}
 805f935:	e9 23 ff ff ff       	jmp    805f85d <work_queue_main+0xc>
	return node->next;
 805f93a:	8b 10                	mov    (%eax),%edx
 805f93c:	31 ff                	xor    %edi,%edi
			sys_slist_remove(&pending_cancels, prev, &wc->node);
 805f93e:	89 c1                	mov    %eax,%ecx
		if (wc->work == work) {
 805f940:	3b 58 04             	cmp    0x4(%eax),%ebx
 805f943:	75 49                	jne    805f98e <work_queue_main+0x13d>
 805f945:	8b 08                	mov    (%eax),%ecx
Z_GENLIST_REMOVE(slist, snode)
 805f947:	85 ff                	test   %edi,%edi
 805f949:	75 16                	jne    805f961 <work_queue_main+0x110>
	list->head = node;
 805f94b:	89 0d 84 8a 06 08    	mov    %ecx,0x8068a84
Z_GENLIST_REMOVE(slist, snode)
 805f951:	39 05 88 8a 06 08    	cmp    %eax,0x8068a88
 805f957:	75 18                	jne    805f971 <work_queue_main+0x120>
	list->tail = node;
 805f959:	89 0d 88 8a 06 08    	mov    %ecx,0x8068a88
}
 805f95f:	eb 10                	jmp    805f971 <work_queue_main+0x120>
	parent->next = child;
 805f961:	89 0f                	mov    %ecx,(%edi)
Z_GENLIST_REMOVE(slist, snode)
 805f963:	39 05 88 8a 06 08    	cmp    %eax,0x8068a88
 805f969:	75 06                	jne    805f971 <work_queue_main+0x120>
	list->tail = node;
 805f96b:	89 3d 88 8a 06 08    	mov    %edi,0x8068a88
 805f971:	89 55 e0             	mov    %edx,-0x20(%ebp)
	parent->next = child;
 805f974:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	z_impl_k_sem_give(sem);
 805f97a:	83 ec 0c             	sub    $0xc,%esp
			k_sem_give(&wc->sem);
 805f97d:	83 c0 08             	add    $0x8,%eax
 805f980:	50                   	push   %eax
 805f981:	e8 c4 fc ff ff       	call   805f64a <z_impl_k_sem_give>
}
 805f986:	8b 55 e0             	mov    -0x20(%ebp),%edx
	z_impl_k_sem_give(sem);
 805f989:	83 c4 10             	add    $0x10,%esp
}
 805f98c:	89 f9                	mov    %edi,%ecx
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&pending_cancels, wc, tmp, node) {
 805f98e:	85 d2                	test   %edx,%edx
 805f990:	0f 84 79 ff ff ff    	je     805f90f <work_queue_main+0xbe>
	return node->next;
 805f996:	89 d0                	mov    %edx,%eax
 805f998:	89 cf                	mov    %ecx,%edi
 805f99a:	8b 12                	mov    (%edx),%edx
 805f99c:	eb a0                	jmp    805f93e <work_queue_main+0xed>
	*flagp &= ~BIT(bit);
 805f99e:	89 53 0c             	mov    %edx,0xc(%ebx)
 805f9a1:	e9 69 ff ff ff       	jmp    805f90f <work_queue_main+0xbe>

0805f9a6 <submit_to_queue_locked>:
{
 805f9a6:	55                   	push   %ebp
 805f9a7:	89 e5                	mov    %esp,%ebp
 805f9a9:	57                   	push   %edi
 805f9aa:	56                   	push   %esi
 805f9ab:	89 d6                	mov    %edx,%esi
 805f9ad:	53                   	push   %ebx
 805f9ae:	89 c3                	mov    %eax,%ebx
 805f9b0:	83 ec 1c             	sub    $0x1c,%esp
	return (*flagp & BIT(bit)) != 0U;
 805f9b3:	8b 40 0c             	mov    0xc(%eax),%eax
	if (flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
 805f9b6:	a8 02                	test   $0x2,%al
 805f9b8:	0f 85 b0 00 00 00    	jne    805fa6e <submit_to_queue_locked+0xc8>
	} else if (!flag_test(&work->flags, K_WORK_QUEUED_BIT)) {
 805f9be:	a8 04                	test   $0x4,%al
 805f9c0:	0f 85 af 00 00 00    	jne    805fa75 <submit_to_queue_locked+0xcf>
		if (*queuep == NULL) {
 805f9c6:	83 3a 00             	cmpl   $0x0,(%edx)
 805f9c9:	75 05                	jne    805f9d0 <submit_to_queue_locked+0x2a>
			*queuep = work->queue;
 805f9cb:	8b 43 08             	mov    0x8(%ebx),%eax
 805f9ce:	89 02                	mov    %eax,(%edx)
		ret = 1;
 805f9d0:	ba 01 00 00 00       	mov    $0x1,%edx
		if (flag_test(&work->flags, K_WORK_RUNNING_BIT)) {
 805f9d5:	f6 43 0c 01          	testb  $0x1,0xc(%ebx)
 805f9d9:	74 0a                	je     805f9e5 <submit_to_queue_locked+0x3f>
			*queuep = work->queue;
 805f9db:	8b 43 08             	mov    0x8(%ebx),%eax
			ret = 2;
 805f9de:	ba 02 00 00 00       	mov    $0x2,%edx
			*queuep = work->queue;
 805f9e3:	89 06                	mov    %eax,(%esi)
		int rc = queue_submit_locked(*queuep, work);
 805f9e5:	8b 3e                	mov    (%esi),%edi
	if (queue == NULL) {
 805f9e7:	85 ff                	test   %edi,%edi
 805f9e9:	0f 84 8a 00 00 00    	je     805fa79 <submit_to_queue_locked+0xd3>
	bool chained = (_current == &queue->thread) && !k_is_in_isr();
 805f9ef:	31 c0                	xor    %eax,%eax
 805f9f1:	39 3d e8 87 06 08    	cmp    %edi,0x80687e8
 805f9f7:	75 11                	jne    805fa0a <submit_to_queue_locked+0x64>
 805f9f9:	89 55 e4             	mov    %edx,-0x1c(%ebp)
 805f9fc:	e8 91 f5 ff ff       	call   805ef92 <k_is_in_isr>
 805fa01:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 805fa04:	83 f0 01             	xor    $0x1,%eax
 805fa07:	0f b6 c0             	movzbl %al,%eax
 805fa0a:	83 e0 01             	and    $0x1,%eax
	return (*flagp & BIT(bit)) != 0U;
 805fa0d:	8b 4f 6c             	mov    0x6c(%edi),%ecx
	bool chained = (_current == &queue->thread) && !k_is_in_isr();
 805fa10:	88 45 e4             	mov    %al,-0x1c(%ebp)
	return (*flagp & BIT(bit)) != 0U;
 805fa13:	8b 47 6c             	mov    0x6c(%edi),%eax
 805fa16:	c1 e9 03             	shr    $0x3,%ecx
 805fa19:	c1 e8 02             	shr    $0x2,%eax
 805fa1c:	83 e1 01             	and    $0x1,%ecx
 805fa1f:	83 e0 01             	and    $0x1,%eax
	if (!flag_test(&queue->flags, K_WORK_QUEUE_STARTED_BIT)) {
 805fa22:	f6 47 6c 01          	testb  $0x1,0x6c(%edi)
 805fa26:	74 58                	je     805fa80 <submit_to_queue_locked+0xda>
	} else if (draining && !chained) {
 805fa28:	80 7d e4 00          	cmpb   $0x0,-0x1c(%ebp)
 805fa2c:	75 06                	jne    805fa34 <submit_to_queue_locked+0x8e>
 805fa2e:	84 c0                	test   %al,%al
 805fa30:	74 06                	je     805fa38 <submit_to_queue_locked+0x92>
 805fa32:	eb 3a                	jmp    805fa6e <submit_to_queue_locked+0xc8>
	} else if (plugged && !draining) {
 805fa34:	84 c0                	test   %al,%al
 805fa36:	75 04                	jne    805fa3c <submit_to_queue_locked+0x96>
 805fa38:	84 c9                	test   %cl,%cl
 805fa3a:	75 32                	jne    805fa6e <submit_to_queue_locked+0xc8>
	parent->next = child;
 805fa3c:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
	return list->tail;
 805fa42:	8b 47 58             	mov    0x58(%edi),%eax
Z_GENLIST_APPEND(slist, snode)
 805fa45:	85 c0                	test   %eax,%eax
 805fa47:	75 08                	jne    805fa51 <submit_to_queue_locked+0xab>
	list->tail = node;
 805fa49:	89 5f 58             	mov    %ebx,0x58(%edi)
	list->head = node;
 805fa4c:	89 5f 54             	mov    %ebx,0x54(%edi)
}
 805fa4f:	eb 05                	jmp    805fa56 <submit_to_queue_locked+0xb0>
	parent->next = child;
 805fa51:	89 18                	mov    %ebx,(%eax)
	list->tail = node;
 805fa53:	89 5f 58             	mov    %ebx,0x58(%edi)
		(void)notify_queue_locked(queue);
 805fa56:	89 f8                	mov    %edi,%eax
 805fa58:	89 55 e4             	mov    %edx,-0x1c(%ebp)
 805fa5b:	e8 62 fd ff ff       	call   805f7c2 <notify_queue_locked.isra.0>
	*flagp |= BIT(bit);
 805fa60:	83 4b 0c 04          	orl    $0x4,0xc(%ebx)
			work->queue = *queuep;
 805fa64:	8b 06                	mov    (%esi),%eax
 805fa66:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 805fa69:	89 43 08             	mov    %eax,0x8(%ebx)
	if (ret <= 0) {
 805fa6c:	eb 1d                	jmp    805fa8b <submit_to_queue_locked+0xe5>
		ret = -EBUSY;
 805fa6e:	ba f0 ff ff ff       	mov    $0xfffffff0,%edx
 805fa73:	eb 10                	jmp    805fa85 <submit_to_queue_locked+0xdf>
	int ret = 0;
 805fa75:	31 d2                	xor    %edx,%edx
 805fa77:	eb 0c                	jmp    805fa85 <submit_to_queue_locked+0xdf>
		return -EINVAL;
 805fa79:	ba ea ff ff ff       	mov    $0xffffffea,%edx
 805fa7e:	eb 05                	jmp    805fa85 <submit_to_queue_locked+0xdf>
		ret = -ENODEV;
 805fa80:	ba ed ff ff ff       	mov    $0xffffffed,%edx
		*queuep = NULL;
 805fa85:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
}
 805fa8b:	83 c4 1c             	add    $0x1c,%esp
 805fa8e:	89 d0                	mov    %edx,%eax
 805fa90:	5b                   	pop    %ebx
 805fa91:	5e                   	pop    %esi
 805fa92:	5f                   	pop    %edi
 805fa93:	5d                   	pop    %ebp
 805fa94:	c3                   	ret    

0805fa95 <work_timeout>:
{
 805fa95:	55                   	push   %ebp
 805fa96:	89 e5                	mov    %esp,%ebp
 805fa98:	57                   	push   %edi
 805fa99:	56                   	push   %esi
 805fa9a:	53                   	push   %ebx
 805fa9b:	83 ec 1c             	sub    $0x1c,%esp
 805fa9e:	8b 75 08             	mov    0x8(%ebp),%esi
 805faa1:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 805faa7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 805faaa:	31 c0                	xor    %eax,%eax
	return posix_irq_lock();
 805faac:	e8 6e e6 fe ff       	call   804e11f <posix_irq_lock>
	if (flag_test_and_clear(&wp->flags, K_WORK_DELAYED_BIT)) {
 805fab1:	ba 03 00 00 00       	mov    $0x3,%edx
 805fab6:	89 c3                	mov    %eax,%ebx
 805fab8:	8d 46 fc             	lea    -0x4(%esi),%eax
 805fabb:	e8 b8 fc ff ff       	call   805f778 <flag_test_and_clear>
 805fac0:	84 c0                	test   %al,%al
 805fac2:	74 13                	je     805fad7 <work_timeout+0x42>
		queue = dw->queue;
 805fac4:	8b 46 14             	mov    0x14(%esi),%eax
 805fac7:	8d 7e f0             	lea    -0x10(%esi),%edi
		(void)submit_to_queue_locked(wp, &queue);
 805faca:	8d 55 e0             	lea    -0x20(%ebp),%edx
		queue = dw->queue;
 805facd:	89 45 e0             	mov    %eax,-0x20(%ebp)
		(void)submit_to_queue_locked(wp, &queue);
 805fad0:	89 f8                	mov    %edi,%eax
 805fad2:	e8 cf fe ff ff       	call   805f9a6 <submit_to_queue_locked>
	posix_irq_unlock(key);
 805fad7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 805fada:	65 2b 05 14 00 00 00 	sub    %gs:0x14,%eax
 805fae1:	74 05                	je     805fae8 <work_timeout+0x53>
 805fae3:	e8 18 98 fe ff       	call   8049300 <__stack_chk_fail@plt>
 805fae8:	89 5d 08             	mov    %ebx,0x8(%ebp)
}
 805faeb:	83 c4 1c             	add    $0x1c,%esp
 805faee:	5b                   	pop    %ebx
 805faef:	5e                   	pop    %esi
 805faf0:	5f                   	pop    %edi
 805faf1:	5d                   	pop    %ebp
 805faf2:	e9 3a e6 fe ff       	jmp    804e131 <posix_irq_unlock>

0805faf7 <k_work_init>:
{
 805faf7:	55                   	push   %ebp
	*work = (struct k_work)Z_WORK_INITIALIZER(handler);
 805faf8:	31 c0                	xor    %eax,%eax
 805fafa:	b9 04 00 00 00       	mov    $0x4,%ecx
{
 805faff:	89 e5                	mov    %esp,%ebp
 805fb01:	57                   	push   %edi
 805fb02:	8b 55 08             	mov    0x8(%ebp),%edx
	*work = (struct k_work)Z_WORK_INITIALIZER(handler);
 805fb05:	89 d7                	mov    %edx,%edi
 805fb07:	f3 ab                	rep stos %eax,%es:(%edi)
 805fb09:	8b 45 0c             	mov    0xc(%ebp),%eax
 805fb0c:	89 42 04             	mov    %eax,0x4(%edx)
}
 805fb0f:	5f                   	pop    %edi
 805fb10:	5d                   	pop    %ebp
 805fb11:	c3                   	ret    

0805fb12 <k_work_busy_get>:
{
 805fb12:	55                   	push   %ebp
 805fb13:	89 e5                	mov    %esp,%ebp
 805fb15:	83 ec 18             	sub    $0x18,%esp
	return posix_irq_lock();
 805fb18:	e8 02 e6 fe ff       	call   804e11f <posix_irq_lock>
	posix_irq_unlock(key);
 805fb1d:	83 ec 0c             	sub    $0xc,%esp
	return posix_irq_lock();
 805fb20:	89 c2                	mov    %eax,%edx
	return flags_get(&work->flags) & K_WORK_MASK;
 805fb22:	8b 45 08             	mov    0x8(%ebp),%eax
 805fb25:	8b 40 0c             	mov    0xc(%eax),%eax
	posix_irq_unlock(key);
 805fb28:	52                   	push   %edx
 805fb29:	83 e0 0f             	and    $0xf,%eax
 805fb2c:	89 45 f4             	mov    %eax,-0xc(%ebp)
 805fb2f:	e8 fd e5 fe ff       	call   804e131 <posix_irq_unlock>
}
 805fb34:	8b 45 f4             	mov    -0xc(%ebp),%eax
 805fb37:	83 c4 10             	add    $0x10,%esp
 805fb3a:	c9                   	leave  
 805fb3b:	c3                   	ret    

0805fb3c <z_work_submit_to_queue>:
{
 805fb3c:	55                   	push   %ebp
 805fb3d:	89 e5                	mov    %esp,%ebp
 805fb3f:	53                   	push   %ebx
 805fb40:	83 ec 14             	sub    $0x14,%esp
	return posix_irq_lock();
 805fb43:	e8 d7 e5 fe ff       	call   804e11f <posix_irq_lock>
	int ret = submit_to_queue_locked(work, &queue);
 805fb48:	8d 55 08             	lea    0x8(%ebp),%edx
 805fb4b:	89 c3                	mov    %eax,%ebx
 805fb4d:	8b 45 0c             	mov    0xc(%ebp),%eax
 805fb50:	e8 51 fe ff ff       	call   805f9a6 <submit_to_queue_locked>
	posix_irq_unlock(key);
 805fb55:	83 ec 0c             	sub    $0xc,%esp
 805fb58:	53                   	push   %ebx
 805fb59:	89 45 f4             	mov    %eax,-0xc(%ebp)
 805fb5c:	e8 d0 e5 fe ff       	call   804e131 <posix_irq_unlock>
}
 805fb61:	8b 45 f4             	mov    -0xc(%ebp),%eax
 805fb64:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 805fb67:	83 c4 10             	add    $0x10,%esp
 805fb6a:	c9                   	leave  
 805fb6b:	c3                   	ret    

0805fb6c <k_work_submit_to_queue>:
{
 805fb6c:	55                   	push   %ebp
 805fb6d:	89 e5                	mov    %esp,%ebp
 805fb6f:	53                   	push   %ebx
 805fb70:	83 ec 0c             	sub    $0xc,%esp
	int ret = z_work_submit_to_queue(queue, work);
 805fb73:	ff 75 0c             	push   0xc(%ebp)
 805fb76:	ff 75 08             	push   0x8(%ebp)
 805fb79:	e8 be ff ff ff       	call   805fb3c <z_work_submit_to_queue>
 805fb7e:	83 c4 10             	add    $0x10,%esp
 805fb81:	89 c3                	mov    %eax,%ebx
	if (ret > 0) {
 805fb83:	85 c0                	test   %eax,%eax
 805fb85:	7e 11                	jle    805fb98 <k_work_submit_to_queue+0x2c>
	return posix_irq_lock();
 805fb87:	e8 93 e5 fe ff       	call   804e11f <posix_irq_lock>
	(void) z_reschedule_irqlock(arch_irq_lock());
 805fb8c:	83 ec 0c             	sub    $0xc,%esp
 805fb8f:	50                   	push   %eax
 805fb90:	e8 01 03 00 00       	call   805fe96 <z_reschedule_irqlock>
 805fb95:	83 c4 10             	add    $0x10,%esp
}
 805fb98:	89 d8                	mov    %ebx,%eax
 805fb9a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 805fb9d:	c9                   	leave  
 805fb9e:	c3                   	ret    

0805fb9f <k_work_queue_init>:
{
 805fb9f:	55                   	push   %ebp
	*queue = (struct k_work_q) {
 805fba0:	b9 1c 00 00 00       	mov    $0x1c,%ecx
 805fba5:	31 c0                	xor    %eax,%eax
{
 805fba7:	89 e5                	mov    %esp,%ebp
 805fba9:	57                   	push   %edi
	*queue = (struct k_work_q) {
 805fbaa:	8b 7d 08             	mov    0x8(%ebp),%edi
 805fbad:	f3 ab                	rep stos %eax,%es:(%edi)
}
 805fbaf:	5f                   	pop    %edi
 805fbb0:	5d                   	pop    %ebp
 805fbb1:	c3                   	ret    

0805fbb2 <k_work_queue_start>:
{
 805fbb2:	55                   	push   %ebp
 805fbb3:	89 e5                	mov    %esp,%ebp
 805fbb5:	57                   	push   %edi
 805fbb6:	56                   	push   %esi
 805fbb7:	53                   	push   %ebx
 805fbb8:	83 ec 0c             	sub    $0xc,%esp
 805fbbb:	8b 5d 08             	mov    0x8(%ebp),%ebx
 805fbbe:	8b 75 18             	mov    0x18(%ebp),%esi
 805fbc1:	8b 55 0c             	mov    0xc(%ebp),%edx
 805fbc4:	8b 4d 10             	mov    0x10(%ebp),%ecx
 805fbc7:	8d 43 5c             	lea    0x5c(%ebx),%eax
	list->head = NULL;
 805fbca:	c7 43 54 00 00 00 00 	movl   $0x0,0x54(%ebx)
 805fbd1:	8b 7d 14             	mov    0x14(%ebp),%edi
	list->head = (sys_dnode_t *)list;
 805fbd4:	89 43 5c             	mov    %eax,0x5c(%ebx)
	list->tail = (sys_dnode_t *)list;
 805fbd7:	89 43 60             	mov    %eax,0x60(%ebx)
 805fbda:	8d 43 64             	lea    0x64(%ebx),%eax
	list->head = (sys_dnode_t *)list;
 805fbdd:	89 43 64             	mov    %eax,0x64(%ebx)
	list->tail = (sys_dnode_t *)list;
 805fbe0:	89 43 68             	mov    %eax,0x68(%ebx)
 805fbe3:	b8 01 00 00 00       	mov    $0x1,%eax
	list->tail = NULL;
 805fbe8:	c7 43 58 00 00 00 00 	movl   $0x0,0x58(%ebx)
	if ((cfg != NULL) && cfg->no_yield) {
 805fbef:	85 f6                	test   %esi,%esi
 805fbf1:	74 0d                	je     805fc00 <k_work_queue_start+0x4e>
		flags |= K_WORK_QUEUE_NO_YIELD;
 805fbf3:	80 7e 04 01          	cmpb   $0x1,0x4(%esi)
 805fbf7:	19 c0                	sbb    %eax,%eax
 805fbf9:	30 c0                	xor    %al,%al
 805fbfb:	05 01 01 00 00       	add    $0x101,%eax
	*flagp = flags;
 805fc00:	89 43 6c             	mov    %eax,0x6c(%ebx)
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
 805fc03:	50                   	push   %eax
 805fc04:	6a ff                	push   $0xffffffff
 805fc06:	6a ff                	push   $0xffffffff
 805fc08:	6a 00                	push   $0x0
 805fc0a:	57                   	push   %edi
 805fc0b:	6a 00                	push   $0x0
 805fc0d:	6a 00                	push   $0x0
 805fc0f:	53                   	push   %ebx
 805fc10:	68 51 f8 05 08       	push   $0x805f851
 805fc15:	51                   	push   %ecx
 805fc16:	52                   	push   %edx
 805fc17:	53                   	push   %ebx
 805fc18:	e8 0e f4 ff ff       	call   805f02b <z_impl_k_thread_create>
 805fc1d:	83 c4 30             	add    $0x30,%esp
	if ((cfg != NULL) && (cfg->name != NULL)) {
 805fc20:	85 f6                	test   %esi,%esi
 805fc22:	74 12                	je     805fc36 <k_work_queue_start+0x84>
 805fc24:	8b 06                	mov    (%esi),%eax
 805fc26:	85 c0                	test   %eax,%eax
 805fc28:	74 0c                	je     805fc36 <k_work_queue_start+0x84>
	return z_impl_k_thread_name_set(thread, str);
 805fc2a:	52                   	push   %edx
 805fc2b:	52                   	push   %edx
 805fc2c:	50                   	push   %eax
 805fc2d:	53                   	push   %ebx
 805fc2e:	e8 6a f3 ff ff       	call   805ef9d <z_impl_k_thread_name_set>
 805fc33:	83 c4 10             	add    $0x10,%esp
	z_impl_k_thread_start(thread);
 805fc36:	89 5d 08             	mov    %ebx,0x8(%ebp)
}
 805fc39:	8d 65 f4             	lea    -0xc(%ebp),%esp
 805fc3c:	5b                   	pop    %ebx
 805fc3d:	5e                   	pop    %esi
 805fc3e:	5f                   	pop    %edi
 805fc3f:	5d                   	pop    %ebp
 805fc40:	e9 5e f3 ff ff       	jmp    805efa3 <z_impl_k_thread_start>

0805fc45 <k_work_init_delayable>:
{
 805fc45:	55                   	push   %ebp
	*dwork = (struct k_work_delayable){
 805fc46:	31 c0                	xor    %eax,%eax
 805fc48:	b9 0a 00 00 00       	mov    $0xa,%ecx
{
 805fc4d:	89 e5                	mov    %esp,%ebp
 805fc4f:	57                   	push   %edi
 805fc50:	8b 55 08             	mov    0x8(%ebp),%edx
	*dwork = (struct k_work_delayable){
 805fc53:	89 d7                	mov    %edx,%edi
 805fc55:	f3 ab                	rep stos %eax,%es:(%edi)
 805fc57:	8b 45 0c             	mov    0xc(%ebp),%eax
 805fc5a:	c7 42 0c 00 01 00 00 	movl   $0x100,0xc(%edx)
 805fc61:	89 42 04             	mov    %eax,0x4(%edx)
}
 805fc64:	5f                   	pop    %edi
 805fc65:	5d                   	pop    %ebp
 805fc66:	c3                   	ret    

0805fc67 <k_work_delayable_busy_get>:
 805fc67:	e9 a6 fe ff ff       	jmp    805fb12 <k_work_busy_get>

0805fc6c <k_work_reschedule_for_queue>:
}

int k_work_reschedule_for_queue(struct k_work_q *queue,
				 struct k_work_delayable *dwork,
				 k_timeout_t delay)
{
 805fc6c:	55                   	push   %ebp
 805fc6d:	89 e5                	mov    %esp,%ebp
 805fc6f:	57                   	push   %edi
 805fc70:	56                   	push   %esi
 805fc71:	53                   	push   %ebx
 805fc72:	83 ec 1c             	sub    $0x1c,%esp
 805fc75:	8b 45 14             	mov    0x14(%ebp),%eax
 805fc78:	8b 5d 0c             	mov    0xc(%ebp),%ebx
 805fc7b:	8b 7d 10             	mov    0x10(%ebp),%edi
 805fc7e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 805fc81:	e8 99 e4 fe ff       	call   804e11f <posix_irq_lock>
 805fc86:	89 c6                	mov    %eax,%esi

	int ret = 0;
	k_spinlock_key_t key = k_spin_lock(&lock);

	/* Remove any active scheduling. */
	(void)unschedule_locked(dwork);
 805fc88:	89 d8                	mov    %ebx,%eax
 805fc8a:	e8 02 fb ff ff       	call   805f791 <unschedule_locked>

	/* Schedule the work item with the new parameters. */
	ret = schedule_for_queue_locked(&queue, dwork, delay);
 805fc8f:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
 805fc92:	89 f8                	mov    %edi,%eax
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
 805fc94:	09 c8                	or     %ecx,%eax
 805fc96:	75 0c                	jne    805fca4 <k_work_reschedule_for_queue+0x38>
		return submit_to_queue_locked(work, queuep);
 805fc98:	8d 55 08             	lea    0x8(%ebp),%edx
 805fc9b:	89 d8                	mov    %ebx,%eax
 805fc9d:	e8 04 fd ff ff       	call   805f9a6 <submit_to_queue_locked>
 805fca2:	eb 22                	jmp    805fcc6 <k_work_reschedule_for_queue+0x5a>
	dwork->queue = *queuep;
 805fca4:	8b 45 08             	mov    0x8(%ebp),%eax
	*flagp |= BIT(bit);
 805fca7:	83 4b 0c 08          	orl    $0x8,0xc(%ebx)
	z_add_timeout(&dwork->timeout, work_timeout, delay);
 805fcab:	83 c3 10             	add    $0x10,%ebx
	dwork->queue = *queuep;
 805fcae:	89 43 14             	mov    %eax,0x14(%ebx)
	z_add_timeout(&dwork->timeout, work_timeout, delay);
 805fcb1:	51                   	push   %ecx
 805fcb2:	57                   	push   %edi
 805fcb3:	68 95 fa 05 08       	push   $0x805fa95
 805fcb8:	53                   	push   %ebx
 805fcb9:	e8 61 0c 00 00       	call   806091f <z_add_timeout>
 805fcbe:	83 c4 10             	add    $0x10,%esp
	return ret;
 805fcc1:	b8 01 00 00 00       	mov    $0x1,%eax
	posix_irq_unlock(key);
 805fcc6:	83 ec 0c             	sub    $0xc,%esp
 805fcc9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 805fccc:	56                   	push   %esi
 805fccd:	e8 5f e4 fe ff       	call   804e131 <posix_irq_unlock>
	k_spin_unlock(&lock, key);

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_work, reschedule_for_queue, queue, dwork, delay, ret);

	return ret;
}
 805fcd2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 805fcd5:	83 c4 10             	add    $0x10,%esp
 805fcd8:	8d 65 f4             	lea    -0xc(%ebp),%esp
 805fcdb:	5b                   	pop    %ebx
 805fcdc:	5e                   	pop    %esi
 805fcdd:	5f                   	pop    %edi
 805fcde:	5d                   	pop    %ebp
 805fcdf:	c3                   	ret    

0805fce0 <k_work_reschedule>:

int k_work_reschedule(struct k_work_delayable *dwork,
				     k_timeout_t delay)
{
 805fce0:	55                   	push   %ebp
 805fce1:	89 e5                	mov    %esp,%ebp
 805fce3:	83 ec 08             	sub    $0x8,%esp
	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_work, reschedule, dwork, delay);

	int ret = k_work_reschedule_for_queue(&k_sys_work_q, dwork, delay);
 805fce6:	ff 75 10             	push   0x10(%ebp)
 805fce9:	ff 75 0c             	push   0xc(%ebp)
 805fcec:	ff 75 08             	push   0x8(%ebp)
 805fcef:	68 00 88 06 08       	push   $0x8068800
 805fcf4:	e8 73 ff ff ff       	call   805fc6c <k_work_reschedule_for_queue>
 805fcf9:	83 c4 10             	add    $0x10,%esp

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_work, reschedule, dwork, delay, ret);

	return ret;
}
 805fcfc:	c9                   	leave  
 805fcfd:	c3                   	ret    

0805fcfe <k_work_cancel_delayable>:

int k_work_cancel_delayable(struct k_work_delayable *dwork)
{
 805fcfe:	55                   	push   %ebp
 805fcff:	89 e5                	mov    %esp,%ebp
 805fd01:	53                   	push   %ebx
 805fd02:	83 ec 14             	sub    $0x14,%esp
	return posix_irq_lock();
 805fd05:	e8 15 e4 fe ff       	call   804e11f <posix_irq_lock>
 805fd0a:	89 c3                	mov    %eax,%ebx
	(void)unschedule_locked(dwork);
 805fd0c:	8b 45 08             	mov    0x8(%ebp),%eax
 805fd0f:	e8 7d fa ff ff       	call   805f791 <unschedule_locked>
	return cancel_async_locked(&dwork->work);
 805fd14:	8b 45 08             	mov    0x8(%ebp),%eax
 805fd17:	e8 c3 fa ff ff       	call   805f7df <cancel_async_locked>
	posix_irq_unlock(key);
 805fd1c:	83 ec 0c             	sub    $0xc,%esp
 805fd1f:	53                   	push   %ebx
 805fd20:	89 45 f4             	mov    %eax,-0xc(%ebp)
 805fd23:	e8 09 e4 fe ff       	call   804e131 <posix_irq_unlock>
	k_spin_unlock(&lock, key);

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_work, cancel_delayable, dwork, ret);

	return ret;
}
 805fd28:	8b 45 f4             	mov    -0xc(%ebp),%eax
 805fd2b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 805fd2e:	83 c4 10             	add    $0x10,%esp
 805fd31:	c9                   	leave  
 805fd32:	c3                   	ret    

0805fd33 <sys_dlist_remove>:
 * @param node the node to remove
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	sys_dnode_t *const prev = node->prev;
 805fd33:	8b 48 04             	mov    0x4(%eax),%ecx
	sys_dnode_t *const next = node->next;
 805fd36:	8b 10                	mov    (%eax),%edx

	prev->next = next;
 805fd38:	89 11                	mov    %edx,(%ecx)
	next->prev = prev;
 805fd3a:	89 4a 04             	mov    %ecx,0x4(%edx)
	node->next = NULL;
 805fd3d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	node->prev = NULL;
 805fd43:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	sys_dnode_init(node);
}
 805fd4a:	c3                   	ret    

0805fd4b <sliceable>:
#endif
	return ret;
}

static inline bool sliceable(struct k_thread *thread)
{
 805fd4b:	89 c2                	mov    %eax,%edx
	bool ret = is_preempt(thread)
		&& slice_time(thread) != 0
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
		&& !z_is_thread_prevented_from_running(thread)
		&& !z_is_idle_thread_object(thread);
 805fd4d:	31 c0                	xor    %eax,%eax
 805fd4f:	66 83 7a 0e 7f       	cmpw   $0x7f,0xe(%edx)
 805fd54:	77 2b                	ja     805fd81 <sliceable+0x36>
	int ret = slice_ticks;
 805fd56:	a1 a4 8a 06 08       	mov    0x8068aa4,%eax
		&& slice_time(thread) != 0
 805fd5b:	85 c0                	test   %eax,%eax
 805fd5d:	74 22                	je     805fd81 <sliceable+0x36>
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
 805fd5f:	0f be 4a 0e          	movsbl 0xe(%edx),%ecx
		&& !z_is_idle_thread_object(thread);
 805fd63:	31 c0                	xor    %eax,%eax
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
 805fd65:	39 0d a0 8a 06 08    	cmp    %ecx,0x8068aa0
 805fd6b:	7f 14                	jg     805fd81 <sliceable+0x36>
		&& !z_is_thread_prevented_from_running(thread)
 805fd6d:	f6 42 0d 1f          	testb  $0x1f,0xd(%edx)
 805fd71:	0f 94 c1             	sete   %cl
		&& !z_is_idle_thread_object(thread);
 805fd74:	31 c0                	xor    %eax,%eax
 805fd76:	81 fa 20 87 06 08    	cmp    $0x8068720,%edx
 805fd7c:	0f 95 c0             	setne  %al
 805fd7f:	21 c8                	and    %ecx,%eax
	bool ret = is_preempt(thread)
 805fd81:	83 e0 01             	and    $0x1,%eax
#ifdef CONFIG_TIMESLICE_PER_THREAD
	ret |= thread->base.slice_ticks != 0;
#endif

	return ret;
}
 805fd84:	c3                   	ret    

0805fd85 <slice_timeout>:

static void slice_timeout(struct _timeout *t)
{
 805fd85:	55                   	push   %ebp
 805fd86:	89 e5                	mov    %esp,%ebp
	int cpu = ARRAY_INDEX(slice_timeouts, t);
 805fd88:	8b 45 08             	mov    0x8(%ebp),%eax
	 * the specific core, but that's not part of the API yet.
	 */
	if (IS_ENABLED(CONFIG_SMP) && cpu != _current_cpu->id) {
		flag_ipi();
	}
}
 805fd8b:	5d                   	pop    %ebp
	int cpu = ARRAY_INDEX(slice_timeouts, t);
 805fd8c:	2d 8c 8a 06 08       	sub    $0x8068a8c,%eax
 805fd91:	c1 f8 02             	sar    $0x2,%eax
 805fd94:	69 c0 cd cc cc cc    	imul   $0xcccccccd,%eax,%eax
	slice_expired[cpu] = true;
 805fd9a:	c6 80 b5 8a 06 08 01 	movb   $0x1,0x8068ab5(%eax)
}
 805fda1:	c3                   	ret    

0805fda2 <unpend_thread_no_timeout>:
		pend_locked(thread, wait_q, timeout);
	}
}

static inline void unpend_thread_no_timeout(struct k_thread *thread)
{
 805fda2:	55                   	push   %ebp
 805fda3:	89 e5                	mov    %esp,%ebp
 805fda5:	83 ec 08             	sub    $0x8,%esp

void z_priq_dumb_remove(sys_dlist_t *pq, struct k_thread *thread)
{
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));

	sys_dlist_remove(&thread->base.qnode_dlist);
 805fda8:	e8 86 ff ff ff       	call   805fd33 <sys_dlist_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
 805fdad:	80 60 0d fd          	andb   $0xfd,0xd(%eax)
	thread->base.pended_on = NULL;
 805fdb1:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
}
 805fdb8:	c9                   	leave  
 805fdb9:	c3                   	ret    

0805fdba <z_sched_prio_cmp>:
{
 805fdba:	55                   	push   %ebp
 805fdbb:	89 e5                	mov    %esp,%ebp
	int32_t b1 = thread_1->base.prio;
 805fdbd:	8b 45 08             	mov    0x8(%ebp),%eax
 805fdc0:	0f be 50 0e          	movsbl 0xe(%eax),%edx
	int32_t b2 = thread_2->base.prio;
 805fdc4:	8b 45 0c             	mov    0xc(%ebp),%eax
 805fdc7:	0f be 48 0e          	movsbl 0xe(%eax),%ecx
	if (b1 != b2) {
 805fdcb:	31 c0                	xor    %eax,%eax
 805fdcd:	39 ca                	cmp    %ecx,%edx
 805fdcf:	74 04                	je     805fdd5 <z_sched_prio_cmp+0x1b>
		return b2 - b1;
 805fdd1:	89 c8                	mov    %ecx,%eax
 805fdd3:	29 d0                	sub    %edx,%eax
}
 805fdd5:	5d                   	pop    %ebp
 805fdd6:	c3                   	ret    

0805fdd7 <z_reset_time_slice>:
{
 805fdd7:	55                   	push   %ebp
 805fdd8:	89 e5                	mov    %esp,%ebp
 805fdda:	56                   	push   %esi
	z_abort_timeout(&slice_timeouts[cpu]);
 805fddb:	0f b6 35 f0 87 06 08 	movzbl 0x80687f0,%esi
{
 805fde2:	53                   	push   %ebx
	z_abort_timeout(&slice_timeouts[cpu]);
 805fde3:	6b de 14             	imul   $0x14,%esi,%ebx
 805fde6:	83 ec 0c             	sub    $0xc,%esp
 805fde9:	81 c3 8c 8a 06 08    	add    $0x8068a8c,%ebx
 805fdef:	53                   	push   %ebx
 805fdf0:	e8 69 0c 00 00       	call   8060a5e <z_abort_timeout>
	if (sliceable(curr)) {
 805fdf5:	8b 45 08             	mov    0x8(%ebp),%eax
	z_abort_timeout(&slice_timeouts[cpu]);
 805fdf8:	83 c4 10             	add    $0x10,%esp
	slice_expired[cpu] = false;
 805fdfb:	c6 86 b5 8a 06 08 00 	movb   $0x0,0x8068ab5(%esi)
	if (sliceable(curr)) {
 805fe02:	e8 44 ff ff ff       	call   805fd4b <sliceable>
 805fe07:	84 c0                	test   %al,%al
 805fe09:	74 17                	je     805fe22 <z_reset_time_slice+0x4b>
			      K_TICKS(slice_time(curr) - 1));
 805fe0b:	a1 a4 8a 06 08       	mov    0x8068aa4,%eax
 805fe10:	48                   	dec    %eax
 805fe11:	99                   	cltd   
		z_add_timeout(&slice_timeouts[cpu], slice_timeout,
 805fe12:	52                   	push   %edx
 805fe13:	50                   	push   %eax
 805fe14:	68 85 fd 05 08       	push   $0x805fd85
 805fe19:	53                   	push   %ebx
 805fe1a:	e8 00 0b 00 00       	call   806091f <z_add_timeout>
 805fe1f:	83 c4 10             	add    $0x10,%esp
}
 805fe22:	8d 65 f8             	lea    -0x8(%ebp),%esp
 805fe25:	5b                   	pop    %ebx
 805fe26:	5e                   	pop    %esi
 805fe27:	5d                   	pop    %ebp
 805fe28:	c3                   	ret    

0805fe29 <z_unpend_thread>:
{
 805fe29:	55                   	push   %ebp
 805fe2a:	89 e5                	mov    %esp,%ebp
 805fe2c:	56                   	push   %esi
 805fe2d:	53                   	push   %ebx
 805fe2e:	8b 5d 08             	mov    0x8(%ebp),%ebx
	return posix_irq_lock();
 805fe31:	e8 e9 e2 fe ff       	call   804e11f <posix_irq_lock>
		if (thread->base.pended_on != NULL) {
 805fe36:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
 805fe3a:	89 c6                	mov    %eax,%esi
 805fe3c:	74 07                	je     805fe45 <z_unpend_thread+0x1c>
			unpend_thread_no_timeout(thread);
 805fe3e:	89 d8                	mov    %ebx,%eax
 805fe40:	e8 5d ff ff ff       	call   805fda2 <unpend_thread_no_timeout>
	posix_irq_unlock(key);
 805fe45:	83 ec 0c             	sub    $0xc,%esp
}

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
	return z_abort_timeout(&thread->base.timeout);
 805fe48:	83 c3 18             	add    $0x18,%ebx
 805fe4b:	56                   	push   %esi
 805fe4c:	e8 e0 e2 fe ff       	call   804e131 <posix_irq_unlock>
 805fe51:	89 5d 08             	mov    %ebx,0x8(%ebp)
 805fe54:	83 c4 10             	add    $0x10,%esp
}
 805fe57:	8d 65 f8             	lea    -0x8(%ebp),%esp
 805fe5a:	5b                   	pop    %ebx
 805fe5b:	5e                   	pop    %esi
 805fe5c:	5d                   	pop    %ebp
 805fe5d:	e9 fc 0b 00 00       	jmp    8060a5e <z_abort_timeout>

0805fe62 <z_reschedule>:
{
 805fe62:	55                   	push   %ebp
 805fe63:	89 e5                	mov    %esp,%ebp
 805fe65:	8b 45 0c             	mov    0xc(%ebp),%eax
	if (resched(key.key) && need_swap()) {
 805fe68:	89 c2                	mov    %eax,%edx
 805fe6a:	0b 15 e0 87 06 08    	or     0x80687e0,%edx
 805fe70:	75 1b                	jne    805fe8d <z_reschedule+0x2b>
 805fe72:	8b 0d e8 87 06 08    	mov    0x80687e8,%ecx
 805fe78:	39 0d f4 87 06 08    	cmp    %ecx,0x80687f4
 805fe7e:	74 0d                	je     805fe8d <z_reschedule+0x2b>
	ret = arch_swap(key);
 805fe80:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
}
 805fe87:	5d                   	pop    %ebp
 805fe88:	e9 bc d5 fe ff       	jmp    804d449 <arch_swap>
 805fe8d:	89 45 08             	mov    %eax,0x8(%ebp)
 805fe90:	5d                   	pop    %ebp
 805fe91:	e9 9b e2 fe ff       	jmp    804e131 <posix_irq_unlock>

0805fe96 <z_reschedule_irqlock>:
{
 805fe96:	55                   	push   %ebp
 805fe97:	89 e5                	mov    %esp,%ebp
	if (resched(key)) {
 805fe99:	8b 45 08             	mov    0x8(%ebp),%eax
 805fe9c:	0b 05 e0 87 06 08    	or     0x80687e0,%eax
 805fea2:	75 0d                	jne    805feb1 <z_reschedule_irqlock+0x1b>
 805fea4:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
}
 805feab:	5d                   	pop    %ebp
 805feac:	e9 98 d5 fe ff       	jmp    804d449 <arch_swap>
 805feb1:	5d                   	pop    %ebp
 805feb2:	e9 7a e2 fe ff       	jmp    804e131 <posix_irq_unlock>

0805feb7 <z_reschedule_unlocked>:
{
 805feb7:	55                   	push   %ebp
 805feb8:	89 e5                	mov    %esp,%ebp
 805feba:	83 ec 08             	sub    $0x8,%esp
	return posix_irq_lock();
 805febd:	e8 5d e2 fe ff       	call   804e11f <posix_irq_lock>
	(void) z_reschedule_irqlock(arch_irq_lock());
 805fec2:	83 ec 0c             	sub    $0xc,%esp
 805fec5:	50                   	push   %eax
 805fec6:	e8 cb ff ff ff       	call   805fe96 <z_reschedule_irqlock>
 805fecb:	83 c4 10             	add    $0x10,%esp
}
 805fece:	c9                   	leave  
 805fecf:	c3                   	ret    

0805fed0 <k_sched_lock>:
{
 805fed0:	55                   	push   %ebp
 805fed1:	89 e5                	mov    %esp,%ebp
 805fed3:	83 ec 08             	sub    $0x8,%esp
 805fed6:	e8 44 e2 fe ff       	call   804e11f <posix_irq_lock>
	--_current->base.sched_locked;
 805fedb:	8b 15 e8 87 06 08    	mov    0x80687e8,%edx
 805fee1:	fe 4a 0f             	decb   0xf(%edx)
	posix_irq_unlock(key);
 805fee4:	83 ec 0c             	sub    $0xc,%esp
 805fee7:	50                   	push   %eax
 805fee8:	e8 44 e2 fe ff       	call   804e131 <posix_irq_unlock>
 805feed:	83 c4 10             	add    $0x10,%esp
}
 805fef0:	c9                   	leave  
 805fef1:	c3                   	ret    

0805fef2 <z_priq_dumb_best>:
}

struct k_thread *z_priq_dumb_best(sys_dlist_t *pq)
{
 805fef2:	55                   	push   %ebp
 805fef3:	89 e5                	mov    %esp,%ebp
 805fef5:	8b 55 08             	mov    0x8(%ebp),%edx
	return list->head == list;
 805fef8:	8b 02                	mov    (%edx),%eax
	struct k_thread *thread = NULL;
	sys_dnode_t *n = sys_dlist_peek_head(pq);

	if (n != NULL) {
 805fefa:	85 c0                	test   %eax,%eax
 805fefc:	74 04                	je     805ff02 <z_priq_dumb_best+0x10>
 805fefe:	39 c2                	cmp    %eax,%edx
 805ff00:	75 02                	jne    805ff04 <z_priq_dumb_best+0x12>
	struct k_thread *thread = NULL;
 805ff02:	31 c0                	xor    %eax,%eax
		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
	}
	return thread;
}
 805ff04:	5d                   	pop    %ebp
 805ff05:	c3                   	ret    

0805ff06 <update_cache>:
{
 805ff06:	55                   	push   %ebp
 805ff07:	89 c1                	mov    %eax,%ecx
 805ff09:	89 e5                	mov    %esp,%ebp
 805ff0b:	53                   	push   %ebx
 805ff0c:	83 ec 10             	sub    $0x10,%esp
	return _priq_run_best(curr_cpu_runq());
 805ff0f:	68 f8 87 06 08       	push   $0x80687f8
 805ff14:	e8 d9 ff ff ff       	call   805fef2 <z_priq_dumb_best>
	return (thread != NULL) ? thread : _current_cpu->idle_thread;
 805ff19:	8b 1d ec 87 06 08    	mov    0x80687ec,%ebx
	return _priq_run_best(curr_cpu_runq());
 805ff1f:	83 c4 10             	add    $0x10,%esp
	return (thread != NULL) ? thread : _current_cpu->idle_thread;
 805ff22:	85 c0                	test   %eax,%eax
 805ff24:	74 02                	je     805ff28 <update_cache+0x22>
 805ff26:	89 c3                	mov    %eax,%ebx
	if (z_is_thread_prevented_from_running(_current)) {
 805ff28:	8b 15 e8 87 06 08    	mov    0x80687e8,%edx
	if (preempt_ok != 0) {
 805ff2e:	85 c9                	test   %ecx,%ecx
 805ff30:	75 0d                	jne    805ff3f <update_cache+0x39>
	if (z_is_thread_prevented_from_running(_current)) {
 805ff32:	f6 42 0d 1f          	testb  $0x1f,0xd(%edx)
 805ff36:	75 07                	jne    805ff3f <update_cache+0x39>
	if (is_preempt(_current) || is_metairq(thread)) {
 805ff38:	66 83 7a 0e 7f       	cmpw   $0x7f,0xe(%edx)
 805ff3d:	77 12                	ja     805ff51 <update_cache+0x4b>
		if (thread != _current) {
 805ff3f:	39 d3                	cmp    %edx,%ebx
 805ff41:	74 0c                	je     805ff4f <update_cache+0x49>
			z_reset_time_slice(thread);
 805ff43:	83 ec 0c             	sub    $0xc,%esp
 805ff46:	53                   	push   %ebx
 805ff47:	e8 8b fe ff ff       	call   805fdd7 <z_reset_time_slice>
 805ff4c:	83 c4 10             	add    $0x10,%esp
		_kernel.ready_q.cache = thread;
 805ff4f:	89 da                	mov    %ebx,%edx
 805ff51:	89 15 f4 87 06 08    	mov    %edx,0x80687f4
}
 805ff57:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 805ff5a:	c9                   	leave  
 805ff5b:	c3                   	ret    

0805ff5c <move_thread_to_end_of_prio_q>:
{
 805ff5c:	55                   	push   %ebp
 805ff5d:	89 e5                	mov    %esp,%ebp
 805ff5f:	56                   	push   %esi
 805ff60:	53                   	push   %ebx
	return (thread->base.thread_state & state) != 0U;
 805ff61:	8a 50 0d             	mov    0xd(%eax),%dl
	if (z_is_thread_queued(thread)) {
 805ff64:	84 d2                	test   %dl,%dl
 805ff66:	79 0b                	jns    805ff73 <move_thread_to_end_of_prio_q+0x17>
	thread->base.thread_state &= ~_THREAD_QUEUED;
 805ff68:	83 e2 7f             	and    $0x7f,%edx
 805ff6b:	88 50 0d             	mov    %dl,0xd(%eax)
	sys_dlist_remove(&thread->base.qnode_dlist);
 805ff6e:	e8 c0 fd ff ff       	call   805fd33 <sys_dlist_remove>
	thread->base.thread_state |= _THREAD_QUEUED;
 805ff73:	80 48 0d 80          	orb    $0x80,0xd(%eax)
 805ff77:	8b 15 f8 87 06 08    	mov    0x80687f8,%edx
 805ff7d:	8b 0d fc 87 06 08    	mov    0x80687fc,%ecx
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 805ff83:	85 d2                	test   %edx,%edx
 805ff85:	74 31                	je     805ffb8 <move_thread_to_end_of_prio_q+0x5c>
 805ff87:	81 fa f8 87 06 08    	cmp    $0x80687f8,%edx
 805ff8d:	74 29                	je     805ffb8 <move_thread_to_end_of_prio_q+0x5c>
	int32_t b1 = thread_1->base.prio;
 805ff8f:	0f be 58 0e          	movsbl 0xe(%eax),%ebx
	int32_t b2 = thread_2->base.prio;
 805ff93:	0f be 72 0e          	movsbl 0xe(%edx),%esi
	if (b1 != b2) {
 805ff97:	39 f3                	cmp    %esi,%ebx
 805ff99:	74 13                	je     805ffae <move_thread_to_end_of_prio_q+0x52>
		if (z_sched_prio_cmp(thread, t) > 0) {
 805ff9b:	39 de                	cmp    %ebx,%esi
 805ff9d:	7e 0f                	jle    805ffae <move_thread_to_end_of_prio_q+0x52>
	sys_dnode_t *const prev = successor->prev;
 805ff9f:	8b 4a 04             	mov    0x4(%edx),%ecx
	node->next = successor;
 805ffa2:	89 10                	mov    %edx,(%eax)
	node->prev = prev;
 805ffa4:	89 48 04             	mov    %ecx,0x4(%eax)
	prev->next = node;
 805ffa7:	89 01                	mov    %eax,(%ecx)
	successor->prev = node;
 805ffa9:	89 42 04             	mov    %eax,0x4(%edx)
}
 805ffac:	eb 1a                	jmp    805ffc8 <move_thread_to_end_of_prio_q+0x6c>
	return (node == list->tail) ? NULL : node->next;
 805ffae:	39 ca                	cmp    %ecx,%edx
 805ffb0:	74 06                	je     805ffb8 <move_thread_to_end_of_prio_q+0x5c>
 805ffb2:	8b 12                	mov    (%edx),%edx
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 805ffb4:	85 d2                	test   %edx,%edx
 805ffb6:	75 db                	jne    805ff93 <move_thread_to_end_of_prio_q+0x37>
	node->next = list;
 805ffb8:	c7 00 f8 87 06 08    	movl   $0x80687f8,(%eax)
	node->prev = tail;
 805ffbe:	89 48 04             	mov    %ecx,0x4(%eax)
	tail->next = node;
 805ffc1:	89 01                	mov    %eax,(%ecx)
	list->tail = node;
 805ffc3:	a3 fc 87 06 08       	mov    %eax,0x80687fc
	update_cache(thread == _current);
 805ffc8:	39 05 e8 87 06 08    	cmp    %eax,0x80687e8
}
 805ffce:	5b                   	pop    %ebx
	update_cache(thread == _current);
 805ffcf:	0f 94 c0             	sete   %al
}
 805ffd2:	5e                   	pop    %esi
 805ffd3:	5d                   	pop    %ebp
	update_cache(thread == _current);
 805ffd4:	0f b6 c0             	movzbl %al,%eax
 805ffd7:	e9 2a ff ff ff       	jmp    805ff06 <update_cache>

0805ffdc <z_time_slice>:
{
 805ffdc:	55                   	push   %ebp
 805ffdd:	89 e5                	mov    %esp,%ebp
 805ffdf:	56                   	push   %esi
 805ffe0:	53                   	push   %ebx
	return posix_irq_lock();
 805ffe1:	e8 39 e1 fe ff       	call   804e11f <posix_irq_lock>
 805ffe6:	89 c6                	mov    %eax,%esi
	if (slice_expired[_current_cpu->id] && sliceable(curr)) {
 805ffe8:	0f b6 05 f0 87 06 08 	movzbl 0x80687f0,%eax
 805ffef:	80 b8 b5 8a 06 08 00 	cmpb   $0x0,0x8068ab5(%eax)
 805fff6:	74 2a                	je     8060022 <z_time_slice+0x46>
	struct k_thread *curr = _current;
 805fff8:	8b 1d e8 87 06 08    	mov    0x80687e8,%ebx
	if (slice_expired[_current_cpu->id] && sliceable(curr)) {
 805fffe:	89 d8                	mov    %ebx,%eax
 8060000:	e8 46 fd ff ff       	call   805fd4b <sliceable>
 8060005:	84 c0                	test   %al,%al
 8060007:	74 19                	je     8060022 <z_time_slice+0x46>
		if (!z_is_thread_prevented_from_running(curr)) {
 8060009:	f6 43 0d 1f          	testb  $0x1f,0xd(%ebx)
 806000d:	75 07                	jne    8060016 <z_time_slice+0x3a>
			move_thread_to_end_of_prio_q(curr);
 806000f:	89 d8                	mov    %ebx,%eax
 8060011:	e8 46 ff ff ff       	call   805ff5c <move_thread_to_end_of_prio_q>
		z_reset_time_slice(curr);
 8060016:	83 ec 0c             	sub    $0xc,%esp
 8060019:	53                   	push   %ebx
 806001a:	e8 b8 fd ff ff       	call   805fdd7 <z_reset_time_slice>
 806001f:	83 c4 10             	add    $0x10,%esp
	posix_irq_unlock(key);
 8060022:	83 ec 0c             	sub    $0xc,%esp
 8060025:	56                   	push   %esi
 8060026:	e8 06 e1 fe ff       	call   804e131 <posix_irq_unlock>
 806002b:	83 c4 10             	add    $0x10,%esp
}
 806002e:	8d 65 f8             	lea    -0x8(%ebp),%esp
 8060031:	5b                   	pop    %ebx
 8060032:	5e                   	pop    %esi
 8060033:	5d                   	pop    %ebp
 8060034:	c3                   	ret    

08060035 <ready_thread>:
 8060035:	8a 50 0d             	mov    0xd(%eax),%dl
	if (!z_is_thread_queued(thread) && z_is_thread_ready(thread)) {
 8060038:	84 d2                	test   %dl,%dl
 806003a:	78 71                	js     80600ad <ready_thread+0x78>
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
 806003c:	f6 c2 1f             	test   $0x1f,%dl
 806003f:	75 6c                	jne    80600ad <ready_thread+0x78>
 8060041:	83 78 18 00          	cmpl   $0x0,0x18(%eax)
 8060045:	75 66                	jne    80600ad <ready_thread+0x78>
{
 8060047:	55                   	push   %ebp
	thread->base.thread_state |= _THREAD_QUEUED;
 8060048:	83 ca 80             	or     $0xffffff80,%edx
{
 806004b:	89 e5                	mov    %esp,%ebp
 806004d:	56                   	push   %esi
 806004e:	53                   	push   %ebx
	thread->base.thread_state |= _THREAD_QUEUED;
 806004f:	88 50 0d             	mov    %dl,0xd(%eax)
	return list->head == list;
 8060052:	8b 15 f8 87 06 08    	mov    0x80687f8,%edx
 8060058:	8b 0d fc 87 06 08    	mov    0x80687fc,%ecx
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 806005e:	85 d2                	test   %edx,%edx
 8060060:	74 31                	je     8060093 <ready_thread+0x5e>
 8060062:	81 fa f8 87 06 08    	cmp    $0x80687f8,%edx
 8060068:	74 29                	je     8060093 <ready_thread+0x5e>
	int32_t b1 = thread_1->base.prio;
 806006a:	0f be 58 0e          	movsbl 0xe(%eax),%ebx
	int32_t b2 = thread_2->base.prio;
 806006e:	0f be 72 0e          	movsbl 0xe(%edx),%esi
	if (b1 != b2) {
 8060072:	39 f3                	cmp    %esi,%ebx
 8060074:	74 13                	je     8060089 <ready_thread+0x54>
		if (z_sched_prio_cmp(thread, t) > 0) {
 8060076:	39 de                	cmp    %ebx,%esi
 8060078:	7e 0f                	jle    8060089 <ready_thread+0x54>
	sys_dnode_t *const prev = successor->prev;
 806007a:	8b 4a 04             	mov    0x4(%edx),%ecx
	node->next = successor;
 806007d:	89 10                	mov    %edx,(%eax)
	node->prev = prev;
 806007f:	89 48 04             	mov    %ecx,0x4(%eax)
	prev->next = node;
 8060082:	89 01                	mov    %eax,(%ecx)
	successor->prev = node;
 8060084:	89 42 04             	mov    %eax,0x4(%edx)
}
 8060087:	eb 1a                	jmp    80600a3 <ready_thread+0x6e>
	return (node == list->tail) ? NULL : node->next;
 8060089:	39 ca                	cmp    %ecx,%edx
 806008b:	74 06                	je     8060093 <ready_thread+0x5e>
 806008d:	8b 12                	mov    (%edx),%edx
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 806008f:	85 d2                	test   %edx,%edx
 8060091:	75 db                	jne    806006e <ready_thread+0x39>
	node->next = list;
 8060093:	c7 00 f8 87 06 08    	movl   $0x80687f8,(%eax)
	node->prev = tail;
 8060099:	89 48 04             	mov    %ecx,0x4(%eax)
	tail->next = node;
 806009c:	89 01                	mov    %eax,(%ecx)
	list->tail = node;
 806009e:	a3 fc 87 06 08       	mov    %eax,0x80687fc
}
 80600a3:	5b                   	pop    %ebx
		update_cache(0);
 80600a4:	31 c0                	xor    %eax,%eax
}
 80600a6:	5e                   	pop    %esi
 80600a7:	5d                   	pop    %ebp
		update_cache(0);
 80600a8:	e9 59 fe ff ff       	jmp    805ff06 <update_cache>
 80600ad:	c3                   	ret    

080600ae <z_ready_thread>:
{
 80600ae:	55                   	push   %ebp
 80600af:	89 e5                	mov    %esp,%ebp
 80600b1:	56                   	push   %esi
 80600b2:	53                   	push   %ebx
 80600b3:	8b 75 08             	mov    0x8(%ebp),%esi
	return posix_irq_lock();
 80600b6:	e8 64 e0 fe ff       	call   804e11f <posix_irq_lock>
 80600bb:	89 c3                	mov    %eax,%ebx
			ready_thread(thread);
 80600bd:	89 f0                	mov    %esi,%eax
 80600bf:	e8 71 ff ff ff       	call   8060035 <ready_thread>
	posix_irq_unlock(key);
 80600c4:	89 5d 08             	mov    %ebx,0x8(%ebp)
}
 80600c7:	5b                   	pop    %ebx
 80600c8:	5e                   	pop    %esi
 80600c9:	5d                   	pop    %ebp
 80600ca:	e9 62 e0 fe ff       	jmp    804e131 <posix_irq_unlock>

080600cf <z_sched_start>:
{
 80600cf:	55                   	push   %ebp
 80600d0:	89 e5                	mov    %esp,%ebp
 80600d2:	56                   	push   %esi
 80600d3:	53                   	push   %ebx
 80600d4:	8b 75 08             	mov    0x8(%ebp),%esi
	return posix_irq_lock();
 80600d7:	e8 43 e0 fe ff       	call   804e11f <posix_irq_lock>
 80600dc:	89 c3                	mov    %eax,%ebx
	return (thread->base.thread_state & _THREAD_PRESTART) == 0U;
 80600de:	8a 46 0d             	mov    0xd(%esi),%al
	if (z_has_thread_started(thread)) {
 80600e1:	a8 04                	test   $0x4,%al
 80600e3:	75 0e                	jne    80600f3 <z_sched_start+0x24>
	posix_irq_unlock(key);
 80600e5:	89 5d 08             	mov    %ebx,0x8(%ebp)
}
 80600e8:	8d 65 f8             	lea    -0x8(%ebp),%esp
 80600eb:	5b                   	pop    %ebx
 80600ec:	5e                   	pop    %esi
 80600ed:	5d                   	pop    %ebp
 80600ee:	e9 3e e0 fe ff       	jmp    804e131 <posix_irq_unlock>
	thread->base.thread_state &= ~_THREAD_PRESTART;
 80600f3:	83 e0 fb             	and    $0xfffffffb,%eax
 80600f6:	88 46 0d             	mov    %al,0xd(%esi)
	ready_thread(thread);
 80600f9:	89 f0                	mov    %esi,%eax
 80600fb:	e8 35 ff ff ff       	call   8060035 <ready_thread>
	z_reschedule(&sched_spinlock, key);
 8060100:	50                   	push   %eax
 8060101:	50                   	push   %eax
 8060102:	53                   	push   %ebx
 8060103:	68 b6 8a 06 08       	push   $0x8068ab6
 8060108:	e8 55 fd ff ff       	call   805fe62 <z_reschedule>
 806010d:	83 c4 10             	add    $0x10,%esp
}
 8060110:	8d 65 f8             	lea    -0x8(%ebp),%esp
 8060113:	5b                   	pop    %ebx
 8060114:	5e                   	pop    %esi
 8060115:	5d                   	pop    %ebp
 8060116:	c3                   	ret    

08060117 <z_sched_wake_thread>:
{
 8060117:	55                   	push   %ebp
 8060118:	89 e5                	mov    %esp,%ebp
 806011a:	57                   	push   %edi
 806011b:	56                   	push   %esi
 806011c:	53                   	push   %ebx
 806011d:	83 ec 0c             	sub    $0xc,%esp
 8060120:	8b 5d 08             	mov    0x8(%ebp),%ebx
 8060123:	8b 7d 0c             	mov    0xc(%ebp),%edi
	return posix_irq_lock();
 8060126:	e8 f4 df fe ff       	call   804e11f <posix_irq_lock>
 806012b:	89 c6                	mov    %eax,%esi
		if (!killed) {
 806012d:	f6 43 0d 28          	testb  $0x28,0xd(%ebx)
 8060131:	75 29                	jne    806015c <z_sched_wake_thread+0x45>
			if (thread->base.pended_on != NULL) {
 8060133:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
 8060137:	74 07                	je     8060140 <z_sched_wake_thread+0x29>
				unpend_thread_no_timeout(thread);
 8060139:	89 d8                	mov    %ebx,%eax
 806013b:	e8 62 fc ff ff       	call   805fda2 <unpend_thread_no_timeout>
 8060140:	8a 43 0d             	mov    0xd(%ebx),%al
 8060143:	89 f9                	mov    %edi,%ecx
 8060145:	89 c2                	mov    %eax,%edx
 8060147:	83 e0 fb             	and    $0xfffffffb,%eax
 806014a:	83 e2 eb             	and    $0xffffffeb,%edx
 806014d:	84 c9                	test   %cl,%cl
 806014f:	0f 45 c2             	cmovne %edx,%eax
 8060152:	88 43 0d             	mov    %al,0xd(%ebx)
			ready_thread(thread);
 8060155:	89 d8                	mov    %ebx,%eax
 8060157:	e8 d9 fe ff ff       	call   8060035 <ready_thread>
	posix_irq_unlock(key);
 806015c:	89 75 08             	mov    %esi,0x8(%ebp)
}
 806015f:	83 c4 0c             	add    $0xc,%esp
 8060162:	5b                   	pop    %ebx
 8060163:	5e                   	pop    %esi
 8060164:	5f                   	pop    %edi
 8060165:	5d                   	pop    %ebp
 8060166:	e9 c6 df fe ff       	jmp    804e131 <posix_irq_unlock>

0806016b <z_thread_timeout>:
{
 806016b:	55                   	push   %ebp
 806016c:	89 e5                	mov    %esp,%ebp
 806016e:	83 ec 10             	sub    $0x10,%esp
	struct k_thread *thread = CONTAINER_OF(timeout,
 8060171:	8b 45 08             	mov    0x8(%ebp),%eax
	z_sched_wake_thread(thread, true);
 8060174:	6a 01                	push   $0x1
	struct k_thread *thread = CONTAINER_OF(timeout,
 8060176:	83 e8 18             	sub    $0x18,%eax
	z_sched_wake_thread(thread, true);
 8060179:	50                   	push   %eax
 806017a:	e8 98 ff ff ff       	call   8060117 <z_sched_wake_thread>
 806017f:	83 c4 10             	add    $0x10,%esp
}
 8060182:	c9                   	leave  
 8060183:	c3                   	ret    

08060184 <unready_thread>:
{
 8060184:	55                   	push   %ebp
 8060185:	89 e5                	mov    %esp,%ebp
 8060187:	83 ec 08             	sub    $0x8,%esp
	return (thread->base.thread_state & state) != 0U;
 806018a:	8a 50 0d             	mov    0xd(%eax),%dl
	if (z_is_thread_queued(thread)) {
 806018d:	84 d2                	test   %dl,%dl
 806018f:	79 0b                	jns    806019c <unready_thread+0x18>
	thread->base.thread_state &= ~_THREAD_QUEUED;
 8060191:	83 e2 7f             	and    $0x7f,%edx
 8060194:	88 50 0d             	mov    %dl,0xd(%eax)
	sys_dlist_remove(&thread->base.qnode_dlist);
 8060197:	e8 97 fb ff ff       	call   805fd33 <sys_dlist_remove>
	update_cache(thread == _current);
 806019c:	39 05 e8 87 06 08    	cmp    %eax,0x80687e8
}
 80601a2:	c9                   	leave  
	update_cache(thread == _current);
 80601a3:	0f 94 c0             	sete   %al
 80601a6:	0f b6 c0             	movzbl %al,%eax
 80601a9:	e9 58 fd ff ff       	jmp    805ff06 <update_cache>

080601ae <add_to_waitq_locked>:
{
 80601ae:	55                   	push   %ebp
 80601af:	89 e5                	mov    %esp,%ebp
 80601b1:	56                   	push   %esi
 80601b2:	89 d6                	mov    %edx,%esi
 80601b4:	53                   	push   %ebx
 80601b5:	89 c3                	mov    %eax,%ebx
	unready_thread(thread);
 80601b7:	e8 c8 ff ff ff       	call   8060184 <unready_thread>
	thread->base.thread_state |= _THREAD_PENDING;
 80601bc:	80 4b 0d 02          	orb    $0x2,0xd(%ebx)
	if (wait_q != NULL) {
 80601c0:	85 f6                	test   %esi,%esi
 80601c2:	74 44                	je     8060208 <add_to_waitq_locked+0x5a>
		thread->base.pended_on = wait_q;
 80601c4:	89 73 08             	mov    %esi,0x8(%ebx)
	return list->head == list;
 80601c7:	8b 06                	mov    (%esi),%eax
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 80601c9:	85 c0                	test   %eax,%eax
 80601cb:	74 2e                	je     80601fb <add_to_waitq_locked+0x4d>
 80601cd:	39 c6                	cmp    %eax,%esi
 80601cf:	74 2a                	je     80601fb <add_to_waitq_locked+0x4d>
	int32_t b1 = thread_1->base.prio;
 80601d1:	0f be 53 0e          	movsbl 0xe(%ebx),%edx
	int32_t b2 = thread_2->base.prio;
 80601d5:	0f be 48 0e          	movsbl 0xe(%eax),%ecx
	if (b1 != b2) {
 80601d9:	39 ca                	cmp    %ecx,%edx
 80601db:	74 13                	je     80601f0 <add_to_waitq_locked+0x42>
		if (z_sched_prio_cmp(thread, t) > 0) {
 80601dd:	39 d1                	cmp    %edx,%ecx
 80601df:	7e 0f                	jle    80601f0 <add_to_waitq_locked+0x42>
	sys_dnode_t *const prev = successor->prev;
 80601e1:	8b 50 04             	mov    0x4(%eax),%edx
	node->next = successor;
 80601e4:	89 03                	mov    %eax,(%ebx)
	node->prev = prev;
 80601e6:	89 53 04             	mov    %edx,0x4(%ebx)
	prev->next = node;
 80601e9:	89 1a                	mov    %ebx,(%edx)
	successor->prev = node;
 80601eb:	89 58 04             	mov    %ebx,0x4(%eax)
}
 80601ee:	eb 18                	jmp    8060208 <add_to_waitq_locked+0x5a>
	return (node == list->tail) ? NULL : node->next;
 80601f0:	3b 46 04             	cmp    0x4(%esi),%eax
 80601f3:	74 06                	je     80601fb <add_to_waitq_locked+0x4d>
 80601f5:	8b 00                	mov    (%eax),%eax
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 80601f7:	85 c0                	test   %eax,%eax
 80601f9:	75 da                	jne    80601d5 <add_to_waitq_locked+0x27>
	sys_dnode_t *const tail = list->tail;
 80601fb:	8b 46 04             	mov    0x4(%esi),%eax
	node->next = list;
 80601fe:	89 33                	mov    %esi,(%ebx)
	node->prev = tail;
 8060200:	89 43 04             	mov    %eax,0x4(%ebx)
	tail->next = node;
 8060203:	89 18                	mov    %ebx,(%eax)
	list->tail = node;
 8060205:	89 5e 04             	mov    %ebx,0x4(%esi)
}
 8060208:	5b                   	pop    %ebx
 8060209:	5e                   	pop    %esi
 806020a:	5d                   	pop    %ebp
 806020b:	c3                   	ret    

0806020c <pend_locked>:
{
 806020c:	55                   	push   %ebp
 806020d:	89 e5                	mov    %esp,%ebp
 806020f:	57                   	push   %edi
 8060210:	56                   	push   %esi
 8060211:	53                   	push   %ebx
 8060212:	89 c3                	mov    %eax,%ebx
 8060214:	83 ec 0c             	sub    $0xc,%esp
 8060217:	8b 75 0c             	mov    0xc(%ebp),%esi
 806021a:	8b 7d 08             	mov    0x8(%ebp),%edi
	add_to_waitq_locked(thread, wait_q);
 806021d:	e8 8c ff ff ff       	call   80601ae <add_to_waitq_locked>
	add_thread_timeout(thread, timeout);
 8060222:	89 f0                	mov    %esi,%eax
	if (!K_TIMEOUT_EQ(timeout, K_FOREVER)) {
 8060224:	46                   	inc    %esi
 8060225:	89 fa                	mov    %edi,%edx
 8060227:	75 05                	jne    806022e <pend_locked+0x22>
 8060229:	83 ff ff             	cmp    $0xffffffff,%edi
 806022c:	74 13                	je     8060241 <pend_locked+0x35>
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
 806022e:	83 c3 18             	add    $0x18,%ebx
 8060231:	50                   	push   %eax
 8060232:	52                   	push   %edx
 8060233:	68 6b 01 06 08       	push   $0x806016b
 8060238:	53                   	push   %ebx
 8060239:	e8 e1 06 00 00       	call   806091f <z_add_timeout>
 806023e:	83 c4 10             	add    $0x10,%esp
}
 8060241:	8d 65 f4             	lea    -0xc(%ebp),%esp
 8060244:	5b                   	pop    %ebx
 8060245:	5e                   	pop    %esi
 8060246:	5f                   	pop    %edi
 8060247:	5d                   	pop    %ebp
 8060248:	c3                   	ret    

08060249 <z_pend_curr>:
{
 8060249:	55                   	push   %ebp
 806024a:	89 e5                	mov    %esp,%ebp
 806024c:	57                   	push   %edi
 806024d:	56                   	push   %esi
 806024e:	53                   	push   %ebx
 806024f:	83 ec 1c             	sub    $0x1c,%esp
 8060252:	8b 55 10             	mov    0x10(%ebp),%edx
 8060255:	8b 75 14             	mov    0x14(%ebp),%esi
 8060258:	8b 7d 18             	mov    0x18(%ebp),%edi
 806025b:	8b 5d 0c             	mov    0xc(%ebp),%ebx
 806025e:	89 55 e4             	mov    %edx,-0x1c(%ebp)
	return posix_irq_lock();
 8060261:	e8 b9 de fe ff       	call   804e11f <posix_irq_lock>
	pend_locked(_current, wait_q, timeout);
 8060266:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 8060269:	50                   	push   %eax
 806026a:	50                   	push   %eax
 806026b:	a1 e8 87 06 08       	mov    0x80687e8,%eax
 8060270:	57                   	push   %edi
 8060271:	56                   	push   %esi
 8060272:	e8 95 ff ff ff       	call   806020c <pend_locked>
 8060277:	89 5d 08             	mov    %ebx,0x8(%ebp)
 806027a:	83 c4 10             	add    $0x10,%esp
}
 806027d:	8d 65 f4             	lea    -0xc(%ebp),%esp
 8060280:	5b                   	pop    %ebx
 8060281:	5e                   	pop    %esi
 8060282:	5f                   	pop    %edi
 8060283:	5d                   	pop    %ebp
 8060284:	e9 c0 d1 fe ff       	jmp    804d449 <arch_swap>

08060289 <z_set_prio>:
{
 8060289:	55                   	push   %ebp
 806028a:	89 e5                	mov    %esp,%ebp
 806028c:	57                   	push   %edi
 806028d:	56                   	push   %esi
 806028e:	53                   	push   %ebx
 806028f:	83 ec 1c             	sub    $0x1c,%esp
 8060292:	8b 7d 08             	mov    0x8(%ebp),%edi
 8060295:	8b 5d 0c             	mov    0xc(%ebp),%ebx
 8060298:	e8 82 de fe ff       	call   804e11f <posix_irq_lock>
 806029d:	89 c6                	mov    %eax,%esi
	uint8_t state = thread->base.thread_state;
 806029f:	8a 47 0d             	mov    0xd(%edi),%al
				thread->base.prio = prio;
 80602a2:	88 5d e7             	mov    %bl,-0x19(%ebp)
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
 80602a5:	a8 1f                	test   $0x1f,%al
 80602a7:	75 78                	jne    8060321 <z_set_prio+0x98>
		if (need_sched) {
 80602a9:	83 7f 18 00          	cmpl   $0x0,0x18(%edi)
 80602ad:	75 72                	jne    8060321 <z_set_prio+0x98>
	thread->base.thread_state &= ~_THREAD_QUEUED;
 80602af:	83 e0 7f             	and    $0x7f,%eax
 80602b2:	88 47 0d             	mov    %al,0xd(%edi)
	sys_dlist_remove(&thread->base.qnode_dlist);
 80602b5:	89 f8                	mov    %edi,%eax
 80602b7:	e8 77 fa ff ff       	call   805fd33 <sys_dlist_remove>
	thread->base.thread_state |= _THREAD_QUEUED;
 80602bc:	80 4f 0d 80          	orb    $0x80,0xd(%edi)
				thread->base.prio = prio;
 80602c0:	88 5f 0e             	mov    %bl,0xe(%edi)
	return list->head == list;
 80602c3:	a1 f8 87 06 08       	mov    0x80687f8,%eax
 80602c8:	8b 15 fc 87 06 08    	mov    0x80687fc,%edx
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 80602ce:	3d f8 87 06 08       	cmp    $0x80687f8,%eax
 80602d3:	74 2d                	je     8060302 <z_set_prio+0x79>
 80602d5:	85 c0                	test   %eax,%eax
 80602d7:	74 29                	je     8060302 <z_set_prio+0x79>
	int32_t b1 = thread_1->base.prio;
 80602d9:	0f be 5d e7          	movsbl -0x19(%ebp),%ebx
	int32_t b2 = thread_2->base.prio;
 80602dd:	0f be 48 0e          	movsbl 0xe(%eax),%ecx
	if (b1 != b2) {
 80602e1:	39 cb                	cmp    %ecx,%ebx
 80602e3:	74 13                	je     80602f8 <z_set_prio+0x6f>
		if (z_sched_prio_cmp(thread, t) > 0) {
 80602e5:	39 d9                	cmp    %ebx,%ecx
 80602e7:	7e 0f                	jle    80602f8 <z_set_prio+0x6f>
	sys_dnode_t *const prev = successor->prev;
 80602e9:	8b 50 04             	mov    0x4(%eax),%edx
	node->next = successor;
 80602ec:	89 07                	mov    %eax,(%edi)
	node->prev = prev;
 80602ee:	89 57 04             	mov    %edx,0x4(%edi)
	prev->next = node;
 80602f1:	89 3a                	mov    %edi,(%edx)
	successor->prev = node;
 80602f3:	89 78 04             	mov    %edi,0x4(%eax)
}
 80602f6:	eb 1b                	jmp    8060313 <z_set_prio+0x8a>
	return (node == list->tail) ? NULL : node->next;
 80602f8:	39 d0                	cmp    %edx,%eax
 80602fa:	74 06                	je     8060302 <z_set_prio+0x79>
 80602fc:	8b 00                	mov    (%eax),%eax
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 80602fe:	85 c0                	test   %eax,%eax
 8060300:	75 db                	jne    80602dd <z_set_prio+0x54>
	node->next = list;
 8060302:	c7 07 f8 87 06 08    	movl   $0x80687f8,(%edi)
	node->prev = tail;
 8060308:	89 57 04             	mov    %edx,0x4(%edi)
	tail->next = node;
 806030b:	89 3a                	mov    %edi,(%edx)
	list->tail = node;
 806030d:	89 3d fc 87 06 08    	mov    %edi,0x80687fc
			update_cache(1);
 8060313:	b8 01 00 00 00       	mov    $0x1,%eax
 8060318:	e8 e9 fb ff ff       	call   805ff06 <update_cache>
 806031d:	b0 01                	mov    $0x1,%al
 806031f:	eb 05                	jmp    8060326 <z_set_prio+0x9d>
			thread->base.prio = prio;
 8060321:	88 5f 0e             	mov    %bl,0xe(%edi)
 8060324:	31 c0                	xor    %eax,%eax
	posix_irq_unlock(key);
 8060326:	83 ec 0c             	sub    $0xc,%esp
 8060329:	88 45 e7             	mov    %al,-0x19(%ebp)
 806032c:	56                   	push   %esi
 806032d:	e8 ff dd fe ff       	call   804e131 <posix_irq_unlock>
}
 8060332:	8a 45 e7             	mov    -0x19(%ebp),%al
 8060335:	83 c4 10             	add    $0x10,%esp
 8060338:	8d 65 f4             	lea    -0xc(%ebp),%esp
 806033b:	5b                   	pop    %ebx
 806033c:	5e                   	pop    %esi
 806033d:	5f                   	pop    %edi
 806033e:	5d                   	pop    %ebp
 806033f:	c3                   	ret    

08060340 <z_impl_k_thread_suspend>:
{
 8060340:	55                   	push   %ebp
 8060341:	89 e5                	mov    %esp,%ebp
 8060343:	56                   	push   %esi
 8060344:	53                   	push   %ebx
 8060345:	8b 5d 08             	mov    0x8(%ebp),%ebx
	return z_abort_timeout(&thread->base.timeout);
 8060348:	8d 43 18             	lea    0x18(%ebx),%eax
 806034b:	83 ec 0c             	sub    $0xc,%esp
 806034e:	50                   	push   %eax
 806034f:	e8 0a 07 00 00       	call   8060a5e <z_abort_timeout>
 8060354:	83 c4 10             	add    $0x10,%esp
	return posix_irq_lock();
 8060357:	e8 c3 dd fe ff       	call   804e11f <posix_irq_lock>
 806035c:	89 c6                	mov    %eax,%esi
	return (thread->base.thread_state & state) != 0U;
 806035e:	8a 43 0d             	mov    0xd(%ebx),%al
		if (z_is_thread_queued(thread)) {
 8060361:	84 c0                	test   %al,%al
 8060363:	79 0d                	jns    8060372 <z_impl_k_thread_suspend+0x32>
	thread->base.thread_state &= ~_THREAD_QUEUED;
 8060365:	83 e0 7f             	and    $0x7f,%eax
 8060368:	88 43 0d             	mov    %al,0xd(%ebx)
	sys_dlist_remove(&thread->base.qnode_dlist);
 806036b:	89 d8                	mov    %ebx,%eax
 806036d:	e8 c1 f9 ff ff       	call   805fd33 <sys_dlist_remove>
	thread->base.thread_state |= _THREAD_SUSPENDED;
 8060372:	80 4b 0d 10          	orb    $0x10,0xd(%ebx)
		update_cache(thread == _current);
 8060376:	31 c0                	xor    %eax,%eax
 8060378:	39 1d e8 87 06 08    	cmp    %ebx,0x80687e8
 806037e:	0f 94 c0             	sete   %al
 8060381:	e8 80 fb ff ff       	call   805ff06 <update_cache>
	posix_irq_unlock(key);
 8060386:	83 ec 0c             	sub    $0xc,%esp
 8060389:	56                   	push   %esi
 806038a:	e8 a2 dd fe ff       	call   804e131 <posix_irq_unlock>
 806038f:	83 c4 10             	add    $0x10,%esp
	if (thread == _current) {
 8060392:	39 1d e8 87 06 08    	cmp    %ebx,0x80687e8
 8060398:	75 0b                	jne    80603a5 <z_impl_k_thread_suspend+0x65>
}
 806039a:	8d 65 f8             	lea    -0x8(%ebp),%esp
 806039d:	5b                   	pop    %ebx
 806039e:	5e                   	pop    %esi
 806039f:	5d                   	pop    %ebp
		z_reschedule_unlocked();
 80603a0:	e9 12 fb ff ff       	jmp    805feb7 <z_reschedule_unlocked>
}
 80603a5:	8d 65 f8             	lea    -0x8(%ebp),%esp
 80603a8:	5b                   	pop    %ebx
 80603a9:	5e                   	pop    %esi
 80603aa:	5d                   	pop    %ebp
 80603ab:	c3                   	ret    

080603ac <k_sched_unlock>:
{
 80603ac:	55                   	push   %ebp
 80603ad:	89 e5                	mov    %esp,%ebp
 80603af:	53                   	push   %ebx
 80603b0:	50                   	push   %eax
	return posix_irq_lock();
 80603b1:	e8 69 dd fe ff       	call   804e11f <posix_irq_lock>
 80603b6:	89 c3                	mov    %eax,%ebx
		++_current->base.sched_locked;
 80603b8:	a1 e8 87 06 08       	mov    0x80687e8,%eax
 80603bd:	fe 40 0f             	incb   0xf(%eax)
		update_cache(0);
 80603c0:	31 c0                	xor    %eax,%eax
 80603c2:	e8 3f fb ff ff       	call   805ff06 <update_cache>
	posix_irq_unlock(key);
 80603c7:	83 ec 0c             	sub    $0xc,%esp
 80603ca:	53                   	push   %ebx
 80603cb:	e8 61 dd fe ff       	call   804e131 <posix_irq_unlock>
}
 80603d0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 80603d3:	83 c4 10             	add    $0x10,%esp
 80603d6:	c9                   	leave  
	z_reschedule_unlocked();
 80603d7:	e9 db fa ff ff       	jmp    805feb7 <z_reschedule_unlocked>

080603dc <z_unpend_first_thread>:
{
 80603dc:	55                   	push   %ebp
 80603dd:	89 e5                	mov    %esp,%ebp
 80603df:	56                   	push   %esi
 80603e0:	53                   	push   %ebx
	return posix_irq_lock();
 80603e1:	e8 39 dd fe ff       	call   804e11f <posix_irq_lock>
		thread = _priq_wait_best(&wait_q->waitq);
 80603e6:	83 ec 0c             	sub    $0xc,%esp
 80603e9:	ff 75 08             	push   0x8(%ebp)
 80603ec:	89 c6                	mov    %eax,%esi
 80603ee:	e8 ff fa ff ff       	call   805fef2 <z_priq_dumb_best>
 80603f3:	83 c4 10             	add    $0x10,%esp
 80603f6:	89 c3                	mov    %eax,%ebx
		if (thread != NULL) {
 80603f8:	85 c0                	test   %eax,%eax
 80603fa:	74 14                	je     8060410 <z_unpend_first_thread+0x34>
			unpend_thread_no_timeout(thread);
 80603fc:	e8 a1 f9 ff ff       	call   805fda2 <unpend_thread_no_timeout>
 8060401:	83 ec 0c             	sub    $0xc,%esp
 8060404:	8d 40 18             	lea    0x18(%eax),%eax
 8060407:	50                   	push   %eax
 8060408:	e8 51 06 00 00       	call   8060a5e <z_abort_timeout>
 806040d:	83 c4 10             	add    $0x10,%esp
	posix_irq_unlock(key);
 8060410:	83 ec 0c             	sub    $0xc,%esp
 8060413:	56                   	push   %esi
 8060414:	e8 18 dd fe ff       	call   804e131 <posix_irq_unlock>
 8060419:	83 c4 10             	add    $0x10,%esp
}
 806041c:	8d 65 f8             	lea    -0x8(%ebp),%esp
 806041f:	89 d8                	mov    %ebx,%eax
 8060421:	5b                   	pop    %ebx
 8060422:	5e                   	pop    %esi
 8060423:	5d                   	pop    %ebp
 8060424:	c3                   	ret    

08060425 <z_unpend_all>:
	}
	return thread;
}

int z_unpend_all(_wait_q_t *wait_q)
{
 8060425:	55                   	push   %ebp
	int need_sched = 0;
 8060426:	31 c0                	xor    %eax,%eax
{
 8060428:	89 e5                	mov    %esp,%ebp
 806042a:	56                   	push   %esi
 806042b:	53                   	push   %ebx
 806042c:	8b 75 08             	mov    0x8(%ebp),%esi
	return list->head == list;
 806042f:	8b 1e                	mov    (%esi),%ebx
	struct k_thread *thread;

	while ((thread = z_waitq_head(wait_q)) != NULL) {
 8060431:	85 db                	test   %ebx,%ebx
 8060433:	74 1f                	je     8060454 <z_unpend_all+0x2f>
 8060435:	39 de                	cmp    %ebx,%esi
 8060437:	74 1b                	je     8060454 <z_unpend_all+0x2f>
		z_unpend_thread(thread);
 8060439:	83 ec 0c             	sub    $0xc,%esp
 806043c:	53                   	push   %ebx
 806043d:	e8 e7 f9 ff ff       	call   805fe29 <z_unpend_thread>
		z_ready_thread(thread);
 8060442:	89 1c 24             	mov    %ebx,(%esp)
 8060445:	e8 64 fc ff ff       	call   80600ae <z_ready_thread>
 806044a:	83 c4 10             	add    $0x10,%esp
		need_sched = 1;
 806044d:	b8 01 00 00 00       	mov    $0x1,%eax
 8060452:	eb db                	jmp    806042f <z_unpend_all+0xa>
	}

	return need_sched;
}
 8060454:	8d 65 f8             	lea    -0x8(%ebp),%esp
 8060457:	5b                   	pop    %ebx
 8060458:	5e                   	pop    %esi
 8060459:	5d                   	pop    %ebp
 806045a:	c3                   	ret    

0806045b <z_sched_init>:
	list->head = (sys_dnode_t *)list;
 806045b:	c7 05 f8 87 06 08 f8 	movl   $0x80687f8,0x80687f8
 8060462:	87 06 08 
	list->tail = (sys_dnode_t *)list;
 8060465:	c7 05 fc 87 06 08 f8 	movl   $0x80687f8,0x80687fc
 806046c:	87 06 08 
		init_ready_q(&_kernel.cpus[i].ready_q);
	}
#else
	init_ready_q(&_kernel.ready_q);
#endif
}
 806046f:	c3                   	ret    

08060470 <z_impl_k_yield>:
	return !(k_is_pre_kernel() || k_is_in_isr() ||
		 z_is_idle_thread_object(_current));
}

void z_impl_k_yield(void)
{
 8060470:	55                   	push   %ebp
 8060471:	89 e5                	mov    %esp,%ebp
 8060473:	57                   	push   %edi
 8060474:	56                   	push   %esi
 8060475:	53                   	push   %ebx
 8060476:	83 ec 0c             	sub    $0xc,%esp
	return posix_irq_lock();
 8060479:	e8 a1 dc fe ff       	call   804e11f <posix_irq_lock>
 806047e:	89 c3                	mov    %eax,%ebx

	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if (!IS_ENABLED(CONFIG_SMP) ||
	    z_is_thread_queued(_current)) {
		dequeue_thread(_current);
 8060480:	a1 e8 87 06 08       	mov    0x80687e8,%eax
	thread->base.thread_state &= ~_THREAD_QUEUED;
 8060485:	80 60 0d 7f          	andb   $0x7f,0xd(%eax)
	sys_dlist_remove(&thread->base.qnode_dlist);
 8060489:	e8 a5 f8 ff ff       	call   805fd33 <sys_dlist_remove>
	}
	queue_thread(_current);
 806048e:	a1 e8 87 06 08       	mov    0x80687e8,%eax
	thread->base.thread_state |= _THREAD_QUEUED;
 8060493:	80 48 0d 80          	orb    $0x80,0xd(%eax)
	return list->head == list;
 8060497:	8b 15 f8 87 06 08    	mov    0x80687f8,%edx
 806049d:	8b 0d fc 87 06 08    	mov    0x80687fc,%ecx
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 80604a3:	85 d2                	test   %edx,%edx
 80604a5:	74 31                	je     80604d8 <z_impl_k_yield+0x68>
 80604a7:	81 fa f8 87 06 08    	cmp    $0x80687f8,%edx
 80604ad:	74 29                	je     80604d8 <z_impl_k_yield+0x68>
	int32_t b1 = thread_1->base.prio;
 80604af:	0f be 70 0e          	movsbl 0xe(%eax),%esi
	int32_t b2 = thread_2->base.prio;
 80604b3:	0f be 7a 0e          	movsbl 0xe(%edx),%edi
	if (b1 != b2) {
 80604b7:	39 fe                	cmp    %edi,%esi
 80604b9:	74 13                	je     80604ce <z_impl_k_yield+0x5e>
		if (z_sched_prio_cmp(thread, t) > 0) {
 80604bb:	39 f7                	cmp    %esi,%edi
 80604bd:	7e 0f                	jle    80604ce <z_impl_k_yield+0x5e>
	sys_dnode_t *const prev = successor->prev;
 80604bf:	8b 4a 04             	mov    0x4(%edx),%ecx
	node->next = successor;
 80604c2:	89 10                	mov    %edx,(%eax)
	node->prev = prev;
 80604c4:	89 48 04             	mov    %ecx,0x4(%eax)
	prev->next = node;
 80604c7:	89 01                	mov    %eax,(%ecx)
	successor->prev = node;
 80604c9:	89 42 04             	mov    %eax,0x4(%edx)
}
 80604cc:	eb 1a                	jmp    80604e8 <z_impl_k_yield+0x78>
	return (node == list->tail) ? NULL : node->next;
 80604ce:	39 ca                	cmp    %ecx,%edx
 80604d0:	74 06                	je     80604d8 <z_impl_k_yield+0x68>
 80604d2:	8b 12                	mov    (%edx),%edx
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 80604d4:	85 d2                	test   %edx,%edx
 80604d6:	75 db                	jne    80604b3 <z_impl_k_yield+0x43>
	node->next = list;
 80604d8:	c7 00 f8 87 06 08    	movl   $0x80687f8,(%eax)
	node->prev = tail;
 80604de:	89 48 04             	mov    %ecx,0x4(%eax)
	tail->next = node;
 80604e1:	89 01                	mov    %eax,(%ecx)
	list->tail = node;
 80604e3:	a3 fc 87 06 08       	mov    %eax,0x80687fc
	update_cache(1);
 80604e8:	b8 01 00 00 00       	mov    $0x1,%eax
 80604ed:	e8 14 fa ff ff       	call   805ff06 <update_cache>
 80604f2:	83 ec 0c             	sub    $0xc,%esp
 80604f5:	53                   	push   %ebx
 80604f6:	e8 4e cf fe ff       	call   804d449 <arch_swap>
 80604fb:	83 c4 10             	add    $0x10,%esp
	z_swap(&sched_spinlock, key);
}
 80604fe:	8d 65 f4             	lea    -0xc(%ebp),%esp
 8060501:	5b                   	pop    %ebx
 8060502:	5e                   	pop    %esi
 8060503:	5f                   	pop    %edi
 8060504:	5d                   	pop    %ebp
 8060505:	c3                   	ret    

08060506 <z_tick_sleep>:
}
#include <syscalls/k_yield_mrsh.c>
#endif

static int32_t z_tick_sleep(k_ticks_t ticks)
{
 8060506:	55                   	push   %ebp
 8060507:	89 e5                	mov    %esp,%ebp
 8060509:	57                   	push   %edi
 806050a:	56                   	push   %esi
 806050b:	53                   	push   %ebx
 806050c:	89 c3                	mov    %eax,%ebx
	__ASSERT(!arch_is_in_isr(), "");

	LOG_DBG("thread %p for %lu ticks", _current, (unsigned long)ticks);

	/* wait of 0 ms is treated as a 'yield' */
	if (ticks == 0) {
 806050e:	89 d0                	mov    %edx,%eax
{
 8060510:	83 ec 1c             	sub    $0x1c,%esp
	if (ticks == 0) {
 8060513:	09 d8                	or     %ebx,%eax
 8060515:	75 09                	jne    8060520 <z_tick_sleep+0x1a>
	z_impl_k_yield();
 8060517:	e8 54 ff ff ff       	call   8060470 <z_impl_k_yield>
		k_yield();
		return 0;
 806051c:	31 c0                	xor    %eax,%eax
}
 806051e:	eb 76                	jmp    8060596 <z_tick_sleep+0x90>
	}

	k_timeout_t timeout = Z_TIMEOUT_TICKS(ticks);
	if (Z_TICK_ABS(ticks) <= 0) {
 8060520:	83 fb fe             	cmp    $0xfffffffe,%ebx
 8060523:	89 d0                	mov    %edx,%eax
 8060525:	89 d6                	mov    %edx,%esi
 8060527:	83 d8 ff             	sbb    $0xffffffff,%eax
 806052a:	7c 09                	jl     8060535 <z_tick_sleep+0x2f>
		expected_wakeup_ticks = ticks + sys_clock_tick_get_32();
 806052c:	e8 d6 06 00 00       	call   8060c07 <sys_clock_tick_get_32>
 8060531:	01 d8                	add    %ebx,%eax
 8060533:	eb 07                	jmp    806053c <z_tick_sleep+0x36>
	} else {
		expected_wakeup_ticks = Z_TICK_ABS(ticks);
 8060535:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
 806053a:	29 d8                	sub    %ebx,%eax
 806053c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 806053f:	e8 db db fe ff       	call   804e11f <posix_irq_lock>
 8060544:	89 c7                	mov    %eax,%edi
	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

#if defined(CONFIG_TIMESLICING) && defined(CONFIG_SWAP_NONATOMIC)
	pending_current = _current;
#endif
	unready_thread(_current);
 8060546:	a1 e8 87 06 08       	mov    0x80687e8,%eax
 806054b:	e8 34 fc ff ff       	call   8060184 <unready_thread>
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
 8060550:	a1 e8 87 06 08       	mov    0x80687e8,%eax
 8060555:	56                   	push   %esi
 8060556:	53                   	push   %ebx

	(void)z_swap(&sched_spinlock, key);

	__ASSERT(!z_is_thread_state_set(_current, _THREAD_SUSPENDED), "");

	ticks = (k_ticks_t)expected_wakeup_ticks - sys_clock_tick_get_32();
 8060557:	31 db                	xor    %ebx,%ebx
 8060559:	83 c0 18             	add    $0x18,%eax
 806055c:	68 6b 01 06 08       	push   $0x806016b
 8060561:	50                   	push   %eax
 8060562:	e8 b8 03 00 00       	call   806091f <z_add_timeout>
	z_mark_thread_as_suspended(_current);
 8060567:	a1 e8 87 06 08       	mov    0x80687e8,%eax
 806056c:	80 48 0d 10          	orb    $0x10,0xd(%eax)
 8060570:	89 3c 24             	mov    %edi,(%esp)
 8060573:	e8 d1 ce fe ff       	call   804d449 <arch_swap>
 8060578:	83 c4 10             	add    $0x10,%esp
	ticks = (k_ticks_t)expected_wakeup_ticks - sys_clock_tick_get_32();
 806057b:	e8 87 06 00 00       	call   8060c07 <sys_clock_tick_get_32>
 8060580:	31 d2                	xor    %edx,%edx
 8060582:	89 c1                	mov    %eax,%ecx
 8060584:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8060587:	29 c8                	sub    %ecx,%eax
 8060589:	19 da                	sbb    %ebx,%edx
	if (ticks > 0) {
 806058b:	31 c9                	xor    %ecx,%ecx
 806058d:	39 c1                	cmp    %eax,%ecx
 806058f:	89 cf                	mov    %ecx,%edi
 8060591:	19 d7                	sbb    %edx,%edi
		return ticks;
 8060593:	0f 4d c1             	cmovge %ecx,%eax
	}
#endif

	return 0;
}
 8060596:	8d 65 f4             	lea    -0xc(%ebp),%esp
 8060599:	5b                   	pop    %ebx
 806059a:	5e                   	pop    %esi
 806059b:	5f                   	pop    %edi
 806059c:	5d                   	pop    %ebp
 806059d:	c3                   	ret    

0806059e <z_impl_k_sleep>:

int32_t z_impl_k_sleep(k_timeout_t timeout)
{
 806059e:	55                   	push   %ebp
 806059f:	89 e5                	mov    %esp,%ebp
 80605a1:	83 ec 08             	sub    $0x8,%esp
 80605a4:	8b 55 0c             	mov    0xc(%ebp),%edx
	__ASSERT(!arch_is_in_isr(), "");

	SYS_PORT_TRACING_FUNC_ENTER(k_thread, sleep, timeout);

	/* in case of K_FOREVER, we suspend */
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
 80605a7:	8b 45 08             	mov    0x8(%ebp),%eax
 80605aa:	83 fa ff             	cmp    $0xffffffff,%edx
 80605ad:	75 1b                	jne    80605ca <z_impl_k_sleep+0x2c>
 80605af:	83 f8 ff             	cmp    $0xffffffff,%eax
 80605b2:	75 16                	jne    80605ca <z_impl_k_sleep+0x2c>
		k_thread_suspend(_current);
 80605b4:	a1 e8 87 06 08       	mov    0x80687e8,%eax
	z_impl_k_thread_suspend(thread);
 80605b9:	83 ec 0c             	sub    $0xc,%esp
 80605bc:	50                   	push   %eax
 80605bd:	e8 7e fd ff ff       	call   8060340 <z_impl_k_thread_suspend>
 80605c2:	83 c4 10             	add    $0x10,%esp

		SYS_PORT_TRACING_FUNC_EXIT(k_thread, sleep, timeout, (int32_t) K_TICKS_FOREVER);

		return (int32_t) K_TICKS_FOREVER;
 80605c5:	83 c8 ff             	or     $0xffffffff,%eax
}
 80605c8:	eb 08                	jmp    80605d2 <z_impl_k_sleep+0x34>
	}

	ticks = timeout.ticks;

	ticks = z_tick_sleep(ticks);
 80605ca:	e8 37 ff ff ff       	call   8060506 <z_tick_sleep>

	int32_t ret = k_ticks_to_ms_floor64(ticks);
 80605cf:	6b c0 0a             	imul   $0xa,%eax,%eax

	SYS_PORT_TRACING_FUNC_EXIT(k_thread, sleep, timeout, ret);

	return ret;
}
 80605d2:	c9                   	leave  
 80605d3:	c3                   	ret    

080605d4 <z_impl_z_current_get>:

#ifdef CONFIG_SMP
	arch_irq_unlock(k);
#endif
	return ret;
}
 80605d4:	a1 e8 87 06 08       	mov    0x80687e8,%eax
 80605d9:	c3                   	ret    

080605da <z_thread_abort>:
#endif
	}
}

void z_thread_abort(struct k_thread *thread)
{
 80605da:	55                   	push   %ebp
 80605db:	89 e5                	mov    %esp,%ebp
 80605dd:	57                   	push   %edi
 80605de:	56                   	push   %esi
 80605df:	53                   	push   %ebx
 80605e0:	83 ec 0c             	sub    $0xc,%esp
 80605e3:	8b 5d 08             	mov    0x8(%ebp),%ebx
 80605e6:	e8 34 db fe ff       	call   804e11f <posix_irq_lock>
 80605eb:	89 c6                	mov    %eax,%esi
	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if ((thread->base.user_options & K_ESSENTIAL) != 0) {
 80605ed:	f6 43 0c 01          	testb  $0x1,0xc(%ebx)
 80605f1:	74 36                	je     8060629 <z_thread_abort+0x4f>
	posix_irq_unlock(key);
 80605f3:	83 ec 0c             	sub    $0xc,%esp
 80605f6:	50                   	push   %eax
 80605f7:	e8 35 db fe ff       	call   804e131 <posix_irq_unlock>
 80605fc:	83 c4 0c             	add    $0xc,%esp
		k_spin_unlock(&sched_spinlock, key);
		__ASSERT(false, "aborting essential thread %p", thread);
		k_panic();
 80605ff:	68 cb 06 00 00       	push   $0x6cb
 8060604:	68 60 3f 06 08       	push   $0x8063f60
 8060609:	68 82 3f 06 08       	push   $0x8063f82
 806060e:	e8 e8 a7 fe ff       	call   804adfb <assert_print>
 8060613:	58                   	pop    %eax
 8060614:	5a                   	pop    %edx
 8060615:	6a 00                	push   $0x0
 8060617:	6a 04                	push   $0x4
 8060619:	e8 d2 e4 ff ff       	call   805eaf0 <z_fatal_error>
 806061e:	83 c4 10             	add    $0x10,%esp
	if (thread == _current && !arch_is_in_isr()) {
		z_swap(&sched_spinlock, key);
		__ASSERT(false, "aborted _current back from dead");
	}
	k_spin_unlock(&sched_spinlock, key);
}
 8060621:	8d 65 f4             	lea    -0xc(%ebp),%esp
 8060624:	5b                   	pop    %ebx
 8060625:	5e                   	pop    %esi
 8060626:	5f                   	pop    %edi
 8060627:	5d                   	pop    %ebp
 8060628:	c3                   	ret    
	if ((thread->base.thread_state & _THREAD_DEAD) != 0U) {
 8060629:	8a 43 0d             	mov    0xd(%ebx),%al
 806062c:	a8 08                	test   $0x8,%al
 806062e:	0f 85 96 00 00 00    	jne    80606ca <z_thread_abort+0xf0>
		thread->base.thread_state &= ~_THREAD_ABORTING;
 8060634:	89 c2                	mov    %eax,%edx
 8060636:	83 e2 df             	and    $0xffffffdf,%edx
		if (z_is_thread_queued(thread)) {
 8060639:	80 ca 08             	or     $0x8,%dl
 806063c:	78 05                	js     8060643 <z_thread_abort+0x69>
		thread->base.thread_state &= ~_THREAD_ABORTING;
 806063e:	88 53 0d             	mov    %dl,0xd(%ebx)
 8060641:	eb 10                	jmp    8060653 <z_thread_abort+0x79>
	thread->base.thread_state &= ~_THREAD_QUEUED;
 8060643:	83 e0 5f             	and    $0x5f,%eax
 8060646:	83 c8 08             	or     $0x8,%eax
 8060649:	88 43 0d             	mov    %al,0xd(%ebx)
	sys_dlist_remove(&thread->base.qnode_dlist);
 806064c:	89 d8                	mov    %ebx,%eax
 806064e:	e8 e0 f6 ff ff       	call   805fd33 <sys_dlist_remove>
		if (thread->base.pended_on != NULL) {
 8060653:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
 8060657:	74 07                	je     8060660 <z_thread_abort+0x86>
			unpend_thread_no_timeout(thread);
 8060659:	89 d8                	mov    %ebx,%eax
 806065b:	e8 42 f7 ff ff       	call   805fda2 <unpend_thread_no_timeout>
	return z_abort_timeout(&thread->base.timeout);
 8060660:	83 ec 0c             	sub    $0xc,%esp
 8060663:	8d 43 18             	lea    0x18(%ebx),%eax
 8060666:	50                   	push   %eax
 8060667:	e8 f2 03 00 00       	call   8060a5e <z_abort_timeout>
 806066c:	83 c4 10             	add    $0x10,%esp
	return list->head == list;
 806066f:	8b 7b 3c             	mov    0x3c(%ebx),%edi
	while ((thread = z_waitq_head(wait_q)) != NULL) {
 8060672:	85 ff                	test   %edi,%edi
 8060674:	74 2d                	je     80606a3 <z_thread_abort+0xc9>
}

static inline struct k_thread *z_waitq_head(_wait_q_t *w)
{
	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
 8060676:	8d 43 3c             	lea    0x3c(%ebx),%eax
 8060679:	39 c7                	cmp    %eax,%edi
 806067b:	74 26                	je     80606a3 <z_thread_abort+0xc9>
		unpend_thread_no_timeout(thread);
 806067d:	89 f8                	mov    %edi,%eax
 806067f:	e8 1e f7 ff ff       	call   805fda2 <unpend_thread_no_timeout>
 8060684:	83 ec 0c             	sub    $0xc,%esp
 8060687:	8d 47 18             	lea    0x18(%edi),%eax
 806068a:	50                   	push   %eax
 806068b:	e8 ce 03 00 00       	call   8060a5e <z_abort_timeout>
 8060690:	c7 47 30 00 00 00 00 	movl   $0x0,0x30(%edi)
 8060697:	83 c4 10             	add    $0x10,%esp
		ready_thread(thread);
 806069a:	89 f8                	mov    %edi,%eax
 806069c:	e8 94 f9 ff ff       	call   8060035 <ready_thread>
 80606a1:	eb cc                	jmp    806066f <z_thread_abort+0x95>
		update_cache(1);
 80606a3:	b8 01 00 00 00       	mov    $0x1,%eax
 80606a8:	e8 59 f8 ff ff       	call   805ff06 <update_cache>
	if (thread == _current && !arch_is_in_isr()) {
 80606ad:	39 1d e8 87 06 08    	cmp    %ebx,0x80687e8
 80606b3:	75 15                	jne    80606ca <z_thread_abort+0xf0>
 80606b5:	83 3d e0 87 06 08 00 	cmpl   $0x0,0x80687e0
 80606bc:	75 0c                	jne    80606ca <z_thread_abort+0xf0>
 80606be:	83 ec 0c             	sub    $0xc,%esp
 80606c1:	56                   	push   %esi
 80606c2:	e8 82 cd fe ff       	call   804d449 <arch_swap>
 80606c7:	83 c4 10             	add    $0x10,%esp
 80606ca:	89 75 08             	mov    %esi,0x8(%ebp)
}
 80606cd:	8d 65 f4             	lea    -0xc(%ebp),%esp
 80606d0:	5b                   	pop    %ebx
 80606d1:	5e                   	pop    %esi
 80606d2:	5f                   	pop    %edi
 80606d3:	5d                   	pop    %ebp
 80606d4:	e9 58 da fe ff       	jmp    804e131 <posix_irq_unlock>

080606d9 <z_sched_wake>:

/*
 * future scheduler.h API implementations
 */
bool z_sched_wake(_wait_q_t *wait_q, int swap_retval, void *swap_data)
{
 80606d9:	55                   	push   %ebp
 80606da:	89 e5                	mov    %esp,%ebp
 80606dc:	56                   	push   %esi
 80606dd:	53                   	push   %ebx
 80606de:	83 ec 10             	sub    $0x10,%esp
	return posix_irq_lock();
 80606e1:	e8 39 da fe ff       	call   804e11f <posix_irq_lock>
	struct k_thread *thread;
	bool ret = false;

	LOCKED(&sched_spinlock) {
		thread = _priq_wait_best(&wait_q->waitq);
 80606e6:	83 ec 0c             	sub    $0xc,%esp
 80606e9:	ff 75 08             	push   0x8(%ebp)
 80606ec:	89 c6                	mov    %eax,%esi
 80606ee:	e8 ff f7 ff ff       	call   805fef2 <z_priq_dumb_best>
 80606f3:	83 c4 10             	add    $0x10,%esp
 80606f6:	89 c3                	mov    %eax,%ebx

		if (thread != NULL) {
 80606f8:	31 c0                	xor    %eax,%eax
 80606fa:	85 db                	test   %ebx,%ebx
 80606fc:	74 2b                	je     8060729 <z_sched_wake+0x50>
 80606fe:	8b 45 0c             	mov    0xc(%ebp),%eax
 8060701:	89 43 30             	mov    %eax,0x30(%ebx)
 8060704:	8b 45 10             	mov    0x10(%ebp),%eax
 8060707:	89 43 14             	mov    %eax,0x14(%ebx)
			z_thread_return_value_set_with_data(thread,
							    swap_retval,
							    swap_data);
			unpend_thread_no_timeout(thread);
 806070a:	89 d8                	mov    %ebx,%eax
 806070c:	e8 91 f6 ff ff       	call   805fda2 <unpend_thread_no_timeout>
 8060711:	83 ec 0c             	sub    $0xc,%esp
 8060714:	8d 43 18             	lea    0x18(%ebx),%eax
 8060717:	50                   	push   %eax
 8060718:	e8 41 03 00 00       	call   8060a5e <z_abort_timeout>
			(void)z_abort_thread_timeout(thread);
			ready_thread(thread);
 806071d:	89 d8                	mov    %ebx,%eax
 806071f:	83 c4 10             	add    $0x10,%esp
 8060722:	e8 0e f9 ff ff       	call   8060035 <ready_thread>
			ret = true;
 8060727:	b0 01                	mov    $0x1,%al
	posix_irq_unlock(key);
 8060729:	83 ec 0c             	sub    $0xc,%esp
 806072c:	88 45 f7             	mov    %al,-0x9(%ebp)
 806072f:	56                   	push   %esi
 8060730:	e8 fc d9 fe ff       	call   804e131 <posix_irq_unlock>
		}
	}

	return ret;
}
 8060735:	8a 45 f7             	mov    -0x9(%ebp),%al
 8060738:	83 c4 10             	add    $0x10,%esp
 806073b:	8d 65 f8             	lea    -0x8(%ebp),%esp
 806073e:	5b                   	pop    %ebx
 806073f:	5e                   	pop    %esi
 8060740:	5d                   	pop    %ebp
 8060741:	c3                   	ret    

08060742 <z_sched_wait>:

int z_sched_wait(struct k_spinlock *lock, k_spinlock_key_t key,
		 _wait_q_t *wait_q, k_timeout_t timeout, void **data)
{
 8060742:	55                   	push   %ebp
 8060743:	89 e5                	mov    %esp,%ebp
 8060745:	53                   	push   %ebx
 8060746:	83 ec 10             	sub    $0x10,%esp
	int ret = z_pend_curr(lock, key, wait_q, timeout);
 8060749:	ff 75 18             	push   0x18(%ebp)
{
 806074c:	8b 5d 1c             	mov    0x1c(%ebp),%ebx
	int ret = z_pend_curr(lock, key, wait_q, timeout);
 806074f:	ff 75 14             	push   0x14(%ebp)
 8060752:	ff 75 10             	push   0x10(%ebp)
 8060755:	ff 75 0c             	push   0xc(%ebp)
 8060758:	ff 75 08             	push   0x8(%ebp)
 806075b:	e8 e9 fa ff ff       	call   8060249 <z_pend_curr>
 8060760:	83 c4 20             	add    $0x20,%esp

	if (data != NULL) {
 8060763:	85 db                	test   %ebx,%ebx
 8060765:	74 0b                	je     8060772 <z_sched_wait+0x30>
		*data = _current->base.swap_data;
 8060767:	8b 15 e8 87 06 08    	mov    0x80687e8,%edx
 806076d:	8b 52 14             	mov    0x14(%edx),%edx
 8060770:	89 13                	mov    %edx,(%ebx)
	}
	return ret;
}
 8060772:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 8060775:	c9                   	leave  
 8060776:	c3                   	ret    

08060777 <z_impl_k_condvar_init>:
#include <zephyr/syscall_handler.h>

static struct k_spinlock lock;

int z_impl_k_condvar_init(struct k_condvar *condvar)
{
 8060777:	55                   	push   %ebp
 8060778:	89 e5                	mov    %esp,%ebp
 806077a:	8b 45 08             	mov    0x8(%ebp),%eax
	list->head = (sys_dnode_t *)list;
 806077d:	89 00                	mov    %eax,(%eax)
	list->tail = (sys_dnode_t *)list;
 806077f:	89 40 04             	mov    %eax,0x4(%eax)
	z_object_init(condvar);

	SYS_PORT_TRACING_OBJ_INIT(k_condvar, condvar, 0);

	return 0;
}
 8060782:	31 c0                	xor    %eax,%eax
 8060784:	5d                   	pop    %ebp
 8060785:	c3                   	ret    

08060786 <z_impl_k_condvar_signal>:
}
#include <syscalls/k_condvar_init_mrsh.c>
#endif

int z_impl_k_condvar_signal(struct k_condvar *condvar)
{
 8060786:	55                   	push   %ebp
 8060787:	89 e5                	mov    %esp,%ebp
 8060789:	53                   	push   %ebx
 806078a:	51                   	push   %ecx
	return posix_irq_lock();
 806078b:	e8 8f d9 fe ff       	call   804e11f <posix_irq_lock>
	k_spinlock_key_t key = k_spin_lock(&lock);

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_condvar, signal, condvar);

	struct k_thread *thread = z_unpend_first_thread(&condvar->wait_q);
 8060790:	83 ec 0c             	sub    $0xc,%esp
 8060793:	ff 75 08             	push   0x8(%ebp)
 8060796:	89 c3                	mov    %eax,%ebx
 8060798:	e8 3f fc ff ff       	call   80603dc <z_unpend_first_thread>
 806079d:	83 c4 10             	add    $0x10,%esp

	if (thread != NULL) {
 80607a0:	85 c0                	test   %eax,%eax
 80607a2:	74 1f                	je     80607c3 <z_impl_k_condvar_signal+0x3d>
		SYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_condvar, signal, condvar, K_FOREVER);

		arch_thread_return_value_set(thread, 0);
		z_ready_thread(thread);
 80607a4:	83 ec 0c             	sub    $0xc,%esp
 80607a7:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%eax)
 80607ae:	50                   	push   %eax
 80607af:	e8 fa f8 ff ff       	call   80600ae <z_ready_thread>
 80607b4:	58                   	pop    %eax
 80607b5:	5a                   	pop    %edx
		z_reschedule(&lock, key);
 80607b6:	53                   	push   %ebx
 80607b7:	68 b6 8a 06 08       	push   $0x8068ab6
 80607bc:	e8 a1 f6 ff ff       	call   805fe62 <z_reschedule>
 80607c1:	eb 09                	jmp    80607cc <z_impl_k_condvar_signal+0x46>
	posix_irq_unlock(key);
 80607c3:	83 ec 0c             	sub    $0xc,%esp
 80607c6:	53                   	push   %ebx
 80607c7:	e8 65 d9 fe ff       	call   804e131 <posix_irq_unlock>
	}

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_condvar, signal, condvar, 0);

	return 0;
}
 80607cc:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 80607cf:	83 c4 10             	add    $0x10,%esp
 80607d2:	31 c0                	xor    %eax,%eax
 80607d4:	c9                   	leave  
 80607d5:	c3                   	ret    

080607d6 <z_impl_k_condvar_wait>:
#include <syscalls/k_condvar_broadcast_mrsh.c>
#endif

int z_impl_k_condvar_wait(struct k_condvar *condvar, struct k_mutex *mutex,
			  k_timeout_t timeout)
{
 80607d6:	55                   	push   %ebp
 80607d7:	89 e5                	mov    %esp,%ebp
 80607d9:	56                   	push   %esi
 80607da:	53                   	push   %ebx
 80607db:	8b 75 0c             	mov    0xc(%ebp),%esi
	return posix_irq_lock();
 80607de:	e8 3c d9 fe ff       	call   804e11f <posix_irq_lock>
 80607e3:	89 c3                	mov    %eax,%ebx
	return z_impl_k_mutex_unlock(mutex);
 80607e5:	83 ec 0c             	sub    $0xc,%esp
 80607e8:	56                   	push   %esi
 80607e9:	e8 b8 ea ff ff       	call   805f2a6 <z_impl_k_mutex_unlock>
 80607ee:	58                   	pop    %eax
	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_condvar, wait, condvar);

	key = k_spin_lock(&lock);
	k_mutex_unlock(mutex);

	ret = z_pend_curr(&lock, key, &condvar->wait_q, timeout);
 80607ef:	ff 75 14             	push   0x14(%ebp)
 80607f2:	ff 75 10             	push   0x10(%ebp)
 80607f5:	ff 75 08             	push   0x8(%ebp)
 80607f8:	53                   	push   %ebx
 80607f9:	68 b6 8a 06 08       	push   $0x8068ab6
 80607fe:	e8 46 fa ff ff       	call   8060249 <z_pend_curr>
 8060803:	83 c4 1c             	add    $0x1c,%esp
 8060806:	89 c3                	mov    %eax,%ebx
	return z_impl_k_mutex_lock(mutex, timeout);
 8060808:	6a ff                	push   $0xffffffff
 806080a:	6a ff                	push   $0xffffffff
 806080c:	56                   	push   %esi
 806080d:	e8 86 e9 ff ff       	call   805f198 <z_impl_k_mutex_lock>
 8060812:	83 c4 10             	add    $0x10,%esp
	k_mutex_lock(mutex, K_FOREVER);

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_condvar, wait, condvar, ret);

	return ret;
}
 8060815:	8d 65 f8             	lea    -0x8(%ebp),%esp
 8060818:	89 d8                	mov    %ebx,%eax
 806081a:	5b                   	pop    %ebx
 806081b:	5e                   	pop    %esi
 806081c:	5d                   	pop    %ebp
 806081d:	c3                   	ret    

0806081e <elapsed>:
	sys_dlist_remove(&t->node);
}

static int32_t elapsed(void)
{
	return announce_remaining == 0 ? sys_clock_elapsed() : 0U;
 806081e:	83 3d a8 8a 06 08 00 	cmpl   $0x0,0x8068aa8
 8060825:	75 05                	jne    806082c <elapsed+0xe>
 8060827:	e9 eb e1 ff ff       	jmp    805ea17 <sys_clock_elapsed>
}
 806082c:	31 c0                	xor    %eax,%eax
 806082e:	c3                   	ret    

0806082f <next_timeout>:

static int32_t next_timeout(void)
{
 806082f:	55                   	push   %ebp
 8060830:	89 e5                	mov    %esp,%ebp
 8060832:	53                   	push   %ebx
 8060833:	51                   	push   %ecx
	return list->head == list;
 8060834:	8b 1d d8 73 06 08    	mov    0x80673d8,%ebx
	return sys_dlist_is_empty(list) ? NULL : list->head;
 806083a:	81 fb d8 73 06 08    	cmp    $0x80673d8,%ebx
 8060840:	75 02                	jne    8060844 <next_timeout+0x15>
 8060842:	31 db                	xor    %ebx,%ebx
	struct _timeout *to = first();
	int32_t ticks_elapsed = elapsed();
 8060844:	e8 d5 ff ff ff       	call   806081e <elapsed>
 8060849:	89 c2                	mov    %eax,%edx
	int32_t ret;

	if ((to == NULL) ||
	    ((int64_t)(to->dticks - ticks_elapsed) > (int64_t)INT_MAX)) {
		ret = MAX_WAIT;
 806084b:	b8 ff ff ff 7f       	mov    $0x7fffffff,%eax
	if ((to == NULL) ||
 8060850:	85 db                	test   %ebx,%ebx
 8060852:	74 2e                	je     8060882 <next_timeout+0x53>
	    ((int64_t)(to->dticks - ticks_elapsed) > (int64_t)INT_MAX)) {
 8060854:	8b 4b 0c             	mov    0xc(%ebx),%ecx
 8060857:	89 d0                	mov    %edx,%eax
 8060859:	8b 5b 10             	mov    0x10(%ebx),%ebx
 806085c:	99                   	cltd   
 806085d:	29 c1                	sub    %eax,%ecx
	if ((to == NULL) ||
 806085f:	b8 ff ff ff 7f       	mov    $0x7fffffff,%eax
	    ((int64_t)(to->dticks - ticks_elapsed) > (int64_t)INT_MAX)) {
 8060864:	19 d3                	sbb    %edx,%ebx
	if ((to == NULL) ||
 8060866:	39 c8                	cmp    %ecx,%eax
 8060868:	b8 00 00 00 00       	mov    $0x0,%eax
 806086d:	19 d8                	sbb    %ebx,%eax
		ret = MAX_WAIT;
 806086f:	b8 ff ff ff 7f       	mov    $0x7fffffff,%eax
	if ((to == NULL) ||
 8060874:	7c 0c                	jl     8060882 <next_timeout+0x53>
	} else {
		ret = MAX(0, to->dticks - ticks_elapsed);
 8060876:	31 c0                	xor    %eax,%eax
 8060878:	89 da                	mov    %ebx,%edx
 806087a:	39 c1                	cmp    %eax,%ecx
 806087c:	83 da 00             	sbb    $0x0,%edx
 806087f:	0f 4d c1             	cmovge %ecx,%eax
	}

	return ret;
}
 8060882:	5a                   	pop    %edx
 8060883:	5b                   	pop    %ebx
 8060884:	5d                   	pop    %ebp
 8060885:	c3                   	ret    

08060886 <remove_timeout>:
{
 8060886:	55                   	push   %ebp
 8060887:	89 e5                	mov    %esp,%ebp
 8060889:	53                   	push   %ebx
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
 806088a:	85 c0                	test   %eax,%eax
 806088c:	74 1a                	je     80608a8 <remove_timeout+0x22>
	return (node == list->tail) ? NULL : node->next;
 806088e:	3b 05 dc 73 06 08    	cmp    0x80673dc,%eax
 8060894:	74 12                	je     80608a8 <remove_timeout+0x22>
 8060896:	8b 10                	mov    (%eax),%edx
	if (next(t) != NULL) {
 8060898:	85 d2                	test   %edx,%edx
 806089a:	74 0c                	je     80608a8 <remove_timeout+0x22>
		next(t)->dticks += t->dticks;
 806089c:	8b 48 0c             	mov    0xc(%eax),%ecx
 806089f:	8b 58 10             	mov    0x10(%eax),%ebx
 80608a2:	01 4a 0c             	add    %ecx,0xc(%edx)
 80608a5:	11 5a 10             	adc    %ebx,0x10(%edx)
	sys_dnode_t *const prev = node->prev;
 80608a8:	8b 48 04             	mov    0x4(%eax),%ecx
	sys_dnode_t *const next = node->next;
 80608ab:	8b 10                	mov    (%eax),%edx
	prev->next = next;
 80608ad:	89 11                	mov    %edx,(%ecx)
	next->prev = prev;
 80608af:	89 4a 04             	mov    %ecx,0x4(%edx)
}
 80608b2:	5b                   	pop    %ebx
	node->next = NULL;
 80608b3:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
 80608b9:	5d                   	pop    %ebp
	node->prev = NULL;
 80608ba:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
 80608c1:	c3                   	ret    

080608c2 <timeout_rem>:
/* must be locked */
static k_ticks_t timeout_rem(const struct _timeout *timeout)
{
	k_ticks_t ticks = 0;

	if (z_is_inactive_timeout(timeout)) {
 80608c2:	83 38 00             	cmpl   $0x0,(%eax)
 80608c5:	74 53                	je     806091a <timeout_rem+0x58>
{
 80608c7:	55                   	push   %ebp
 80608c8:	89 e5                	mov    %esp,%ebp
 80608ca:	57                   	push   %edi
 80608cb:	31 ff                	xor    %edi,%edi
 80608cd:	56                   	push   %esi
 80608ce:	31 f6                	xor    %esi,%esi
 80608d0:	53                   	push   %ebx
 80608d1:	83 ec 0c             	sub    $0xc,%esp
	return list->head == list;
 80608d4:	8b 15 d8 73 06 08    	mov    0x80673d8,%edx
	return (node == list->tail) ? NULL : node->next;
 80608da:	8b 0d dc 73 06 08    	mov    0x80673dc,%ecx
	return sys_dlist_is_empty(list) ? NULL : list->head;
 80608e0:	81 fa d8 73 06 08    	cmp    $0x80673d8,%edx
 80608e6:	74 16                	je     80608fe <timeout_rem+0x3c>
		return 0;
	}

	for (struct _timeout *t = first(); t != NULL; t = next(t)) {
 80608e8:	85 d2                	test   %edx,%edx
 80608ea:	74 12                	je     80608fe <timeout_rem+0x3c>
		ticks += t->dticks;
 80608ec:	03 72 0c             	add    0xc(%edx),%esi
 80608ef:	13 7a 10             	adc    0x10(%edx),%edi
		if (timeout == t) {
 80608f2:	39 c2                	cmp    %eax,%edx
 80608f4:	74 08                	je     80608fe <timeout_rem+0x3c>
	return (node == list->tail) ? NULL : node->next;
 80608f6:	39 ca                	cmp    %ecx,%edx
 80608f8:	74 04                	je     80608fe <timeout_rem+0x3c>
 80608fa:	8b 12                	mov    (%edx),%edx
 80608fc:	eb ea                	jmp    80608e8 <timeout_rem+0x26>
			break;
		}
	}

	return ticks - elapsed();
 80608fe:	e8 1b ff ff ff       	call   806081e <elapsed>
 8060903:	89 fa                	mov    %edi,%edx
 8060905:	89 c1                	mov    %eax,%ecx
 8060907:	89 c3                	mov    %eax,%ebx
 8060909:	89 f0                	mov    %esi,%eax
 806090b:	c1 fb 1f             	sar    $0x1f,%ebx
 806090e:	29 c8                	sub    %ecx,%eax
 8060910:	19 da                	sbb    %ebx,%edx
}
 8060912:	83 c4 0c             	add    $0xc,%esp
 8060915:	5b                   	pop    %ebx
 8060916:	5e                   	pop    %esi
 8060917:	5f                   	pop    %edi
 8060918:	5d                   	pop    %ebp
 8060919:	c3                   	ret    
		return 0;
 806091a:	31 c0                	xor    %eax,%eax
 806091c:	31 d2                	xor    %edx,%edx
}
 806091e:	c3                   	ret    

0806091f <z_add_timeout>:
{
 806091f:	55                   	push   %ebp
 8060920:	89 e5                	mov    %esp,%ebp
 8060922:	57                   	push   %edi
 8060923:	56                   	push   %esi
 8060924:	53                   	push   %ebx
 8060925:	83 ec 1c             	sub    $0x1c,%esp
 8060928:	8b 7d 14             	mov    0x14(%ebp),%edi
 806092b:	8b 5d 08             	mov    0x8(%ebp),%ebx
 806092e:	8b 45 0c             	mov    0xc(%ebp),%eax
 8060931:	8b 75 10             	mov    0x10(%ebp),%esi
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
 8060934:	83 ff ff             	cmp    $0xffffffff,%edi
 8060937:	75 09                	jne    8060942 <z_add_timeout+0x23>
 8060939:	83 fe ff             	cmp    $0xffffffff,%esi
 806093c:	0f 84 14 01 00 00    	je     8060a56 <z_add_timeout+0x137>
	to->fn = fn;
 8060942:	89 43 08             	mov    %eax,0x8(%ebx)
 8060945:	e8 d5 d7 fe ff       	call   804e11f <posix_irq_lock>
 806094a:	89 45 dc             	mov    %eax,-0x24(%ebp)
		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) &&
 806094d:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
 8060952:	39 f0                	cmp    %esi,%eax
 8060954:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 8060959:	19 f8                	sbb    %edi,%eax
 806095b:	7c 2d                	jl     806098a <z_add_timeout+0x6b>
			k_ticks_t ticks = Z_TICK_ABS(timeout.ticks) - curr_tick;
 806095d:	83 ca ff             	or     $0xffffffff,%edx
 8060960:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
 8060965:	2b 05 08 89 06 08    	sub    0x8068908,%eax
 806096b:	1b 15 0c 89 06 08    	sbb    0x806890c,%edx
 8060971:	29 f0                	sub    %esi,%eax
			to->dticks = MAX(1, ticks);
 8060973:	be 01 00 00 00       	mov    $0x1,%esi
			k_ticks_t ticks = Z_TICK_ABS(timeout.ticks) - curr_tick;
 8060978:	19 fa                	sbb    %edi,%edx
			to->dticks = MAX(1, ticks);
 806097a:	31 c9                	xor    %ecx,%ecx
 806097c:	39 f0                	cmp    %esi,%eax
 806097e:	89 d7                	mov    %edx,%edi
 8060980:	19 cf                	sbb    %ecx,%edi
 8060982:	0f 4c c6             	cmovl  %esi,%eax
 8060985:	0f 4c d1             	cmovl  %ecx,%edx
 8060988:	eb 10                	jmp    806099a <z_add_timeout+0x7b>
			to->dticks = timeout.ticks + 1 + elapsed();
 806098a:	e8 8f fe ff ff       	call   806081e <elapsed>
 806098f:	83 c6 01             	add    $0x1,%esi
 8060992:	83 d7 00             	adc    $0x0,%edi
 8060995:	99                   	cltd   
 8060996:	01 f0                	add    %esi,%eax
 8060998:	11 fa                	adc    %edi,%edx
			to->dticks = MAX(1, ticks);
 806099a:	89 43 0c             	mov    %eax,0xc(%ebx)
	return list->head == list;
 806099d:	a1 d8 73 06 08       	mov    0x80673d8,%eax
 80609a2:	89 53 10             	mov    %edx,0x10(%ebx)
 80609a5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	sys_dnode_t *const tail = list->tail;
 80609a8:	a1 dc 73 06 08       	mov    0x80673dc,%eax
 80609ad:	89 45 e0             	mov    %eax,-0x20(%ebp)
	return sys_dlist_is_empty(list) ? NULL : list->head;
 80609b0:	81 7d e4 d8 73 06 08 	cmpl   $0x80673d8,-0x1c(%ebp)
 80609b7:	74 55                	je     8060a0e <z_add_timeout+0xef>
		for (t = first(); t != NULL; t = next(t)) {
 80609b9:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
 80609bd:	74 4f                	je     8060a0e <z_add_timeout+0xef>
			if (t->dticks > to->dticks) {
 80609bf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 80609c2:	8b 53 10             	mov    0x10(%ebx),%edx
 80609c5:	8b 70 0c             	mov    0xc(%eax),%esi
 80609c8:	8b 78 10             	mov    0x10(%eax),%edi
 80609cb:	89 d1                	mov    %edx,%ecx
 80609cd:	8b 43 0c             	mov    0xc(%ebx),%eax
 80609d0:	39 f0                	cmp    %esi,%eax
 80609d2:	19 f9                	sbb    %edi,%ecx
 80609d4:	7d 1f                	jge    80609f5 <z_add_timeout+0xd6>
				t->dticks -= to->dticks;
 80609d6:	29 c6                	sub    %eax,%esi
 80609d8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 80609db:	19 d7                	sbb    %edx,%edi
	node->next = successor;
 80609dd:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 80609e0:	89 70 0c             	mov    %esi,0xc(%eax)
 80609e3:	89 78 10             	mov    %edi,0x10(%eax)
	sys_dnode_t *const prev = successor->prev;
 80609e6:	8b 40 04             	mov    0x4(%eax),%eax
	node->next = successor;
 80609e9:	89 13                	mov    %edx,(%ebx)
	node->prev = prev;
 80609eb:	89 43 04             	mov    %eax,0x4(%ebx)
	prev->next = node;
 80609ee:	89 18                	mov    %ebx,(%eax)
	successor->prev = node;
 80609f0:	89 5a 04             	mov    %ebx,0x4(%edx)
		if (t == NULL) {
 80609f3:	eb 2d                	jmp    8060a22 <z_add_timeout+0x103>
			to->dticks -= t->dticks;
 80609f5:	29 f0                	sub    %esi,%eax
 80609f7:	19 fa                	sbb    %edi,%edx
 80609f9:	89 43 0c             	mov    %eax,0xc(%ebx)
 80609fc:	89 53 10             	mov    %edx,0x10(%ebx)
	return (node == list->tail) ? NULL : node->next;
 80609ff:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 8060a02:	39 55 e0             	cmp    %edx,-0x20(%ebp)
 8060a05:	74 07                	je     8060a0e <z_add_timeout+0xef>
 8060a07:	8b 02                	mov    (%edx),%eax
 8060a09:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 8060a0c:	eb ab                	jmp    80609b9 <z_add_timeout+0x9a>
	node->prev = tail;
 8060a0e:	8b 45 e0             	mov    -0x20(%ebp),%eax
	node->next = list;
 8060a11:	c7 03 d8 73 06 08    	movl   $0x80673d8,(%ebx)
	node->prev = tail;
 8060a17:	89 43 04             	mov    %eax,0x4(%ebx)
	tail->next = node;
 8060a1a:	89 18                	mov    %ebx,(%eax)
	list->tail = node;
 8060a1c:	89 1d dc 73 06 08    	mov    %ebx,0x80673dc
	return list->head == list;
 8060a22:	a1 d8 73 06 08       	mov    0x80673d8,%eax
		if (to == first()) {
 8060a27:	3d d8 73 06 08       	cmp    $0x80673d8,%eax
 8060a2c:	74 16                	je     8060a44 <z_add_timeout+0x125>
 8060a2e:	39 c3                	cmp    %eax,%ebx
 8060a30:	75 12                	jne    8060a44 <z_add_timeout+0x125>
			sys_clock_set_timeout(next_timeout(), false);
 8060a32:	e8 f8 fd ff ff       	call   806082f <next_timeout>
 8060a37:	52                   	push   %edx
 8060a38:	52                   	push   %edx
 8060a39:	6a 00                	push   $0x0
 8060a3b:	50                   	push   %eax
 8060a3c:	e8 ab df ff ff       	call   805e9ec <sys_clock_set_timeout>
 8060a41:	83 c4 10             	add    $0x10,%esp
	posix_irq_unlock(key);
 8060a44:	8b 45 dc             	mov    -0x24(%ebp),%eax
 8060a47:	89 45 08             	mov    %eax,0x8(%ebp)
}
 8060a4a:	8d 65 f4             	lea    -0xc(%ebp),%esp
 8060a4d:	5b                   	pop    %ebx
 8060a4e:	5e                   	pop    %esi
 8060a4f:	5f                   	pop    %edi
 8060a50:	5d                   	pop    %ebp
 8060a51:	e9 db d6 fe ff       	jmp    804e131 <posix_irq_unlock>
 8060a56:	8d 65 f4             	lea    -0xc(%ebp),%esp
 8060a59:	5b                   	pop    %ebx
 8060a5a:	5e                   	pop    %esi
 8060a5b:	5f                   	pop    %edi
 8060a5c:	5d                   	pop    %ebp
 8060a5d:	c3                   	ret    

08060a5e <z_abort_timeout>:
{
 8060a5e:	55                   	push   %ebp
 8060a5f:	89 e5                	mov    %esp,%ebp
 8060a61:	53                   	push   %ebx
 8060a62:	83 ec 14             	sub    $0x14,%esp
	return posix_irq_lock();
 8060a65:	e8 b5 d6 fe ff       	call   804e11f <posix_irq_lock>
		if (sys_dnode_is_linked(&to->node)) {
 8060a6a:	8b 55 08             	mov    0x8(%ebp),%edx
 8060a6d:	89 c3                	mov    %eax,%ebx
	return node->next != NULL;
 8060a6f:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
 8060a74:	83 3a 00             	cmpl   $0x0,(%edx)
 8060a77:	74 09                	je     8060a82 <z_abort_timeout+0x24>
			remove_timeout(to);
 8060a79:	89 d0                	mov    %edx,%eax
 8060a7b:	e8 06 fe ff ff       	call   8060886 <remove_timeout>
			ret = 0;
 8060a80:	31 c0                	xor    %eax,%eax
	posix_irq_unlock(key);
 8060a82:	83 ec 0c             	sub    $0xc,%esp
 8060a85:	89 45 f4             	mov    %eax,-0xc(%ebp)
 8060a88:	53                   	push   %ebx
 8060a89:	e8 a3 d6 fe ff       	call   804e131 <posix_irq_unlock>
}
 8060a8e:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8060a91:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 8060a94:	83 c4 10             	add    $0x10,%esp
 8060a97:	c9                   	leave  
 8060a98:	c3                   	ret    

08060a99 <z_timeout_remaining>:

k_ticks_t z_timeout_remaining(const struct _timeout *timeout)
{
 8060a99:	55                   	push   %ebp
 8060a9a:	89 e5                	mov    %esp,%ebp
 8060a9c:	53                   	push   %ebx
 8060a9d:	83 ec 14             	sub    $0x14,%esp
	return posix_irq_lock();
 8060aa0:	e8 7a d6 fe ff       	call   804e11f <posix_irq_lock>
 8060aa5:	89 c3                	mov    %eax,%ebx
	k_ticks_t ticks = 0;

	LOCKED(&timeout_lock) {
		ticks = timeout_rem(timeout);
 8060aa7:	8b 45 08             	mov    0x8(%ebp),%eax
 8060aaa:	e8 13 fe ff ff       	call   80608c2 <timeout_rem>
	posix_irq_unlock(key);
 8060aaf:	83 ec 0c             	sub    $0xc,%esp
 8060ab2:	53                   	push   %ebx
 8060ab3:	89 45 f0             	mov    %eax,-0x10(%ebp)
 8060ab6:	89 55 f4             	mov    %edx,-0xc(%ebp)
 8060ab9:	e8 73 d6 fe ff       	call   804e131 <posix_irq_unlock>
	}

	return ticks;
}
 8060abe:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8060ac1:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8060ac4:	83 c4 10             	add    $0x10,%esp
 8060ac7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 8060aca:	c9                   	leave  
 8060acb:	c3                   	ret    

08060acc <sys_clock_announce>:
	}
	return ret;
}

void sys_clock_announce(int32_t ticks)
{
 8060acc:	55                   	push   %ebp
 8060acd:	89 e5                	mov    %esp,%ebp
 8060acf:	57                   	push   %edi
 8060ad0:	56                   	push   %esi
 8060ad1:	53                   	push   %ebx
 8060ad2:	83 ec 1c             	sub    $0x1c,%esp
 8060ad5:	8b 5d 08             	mov    0x8(%ebp),%ebx
	return posix_irq_lock();
 8060ad8:	e8 42 d6 fe ff       	call   804e11f <posix_irq_lock>
 8060add:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		announce_remaining += ticks;
		k_spin_unlock(&timeout_lock, key);
		return;
	}

	announce_remaining = ticks;
 8060ae0:	89 1d a8 8a 06 08    	mov    %ebx,0x8068aa8
	return list->head == list;
 8060ae6:	8b 1d d8 73 06 08    	mov    0x80673d8,%ebx
	return sys_dlist_is_empty(list) ? NULL : list->head;
 8060aec:	81 fb d8 73 06 08    	cmp    $0x80673d8,%ebx
 8060af2:	0f 84 8f 00 00 00    	je     8060b87 <sys_clock_announce+0xbb>
	for (t = first();
	     (t != NULL) && (t->dticks <= announce_remaining);
	     t = first()) {
		int dt = t->dticks;

		curr_tick += dt;
 8060af8:	a1 08 89 06 08       	mov    0x8068908,%eax
 8060afd:	8b 15 0c 89 06 08    	mov    0x806890c,%edx
 8060b03:	89 45 d8             	mov    %eax,-0x28(%ebp)
	     (t != NULL) && (t->dticks <= announce_remaining);
 8060b06:	a1 a8 8a 06 08       	mov    0x8068aa8,%eax
		curr_tick += dt;
 8060b0b:	89 55 dc             	mov    %edx,-0x24(%ebp)
	     (t != NULL) && (t->dticks <= announce_remaining);
 8060b0e:	85 db                	test   %ebx,%ebx
 8060b10:	74 75                	je     8060b87 <sys_clock_announce+0xbb>
 8060b12:	89 c7                	mov    %eax,%edi
 8060b14:	8b 53 0c             	mov    0xc(%ebx),%edx
 8060b17:	8b 4b 10             	mov    0x10(%ebx),%ecx
 8060b1a:	89 c6                	mov    %eax,%esi
 8060b1c:	c1 ff 1f             	sar    $0x1f,%edi
 8060b1f:	39 d0                	cmp    %edx,%eax
 8060b21:	89 f8                	mov    %edi,%eax
 8060b23:	19 c8                	sbb    %ecx,%eax
 8060b25:	7c 52                	jl     8060b79 <sys_clock_announce+0xad>
		curr_tick += dt;
 8060b27:	89 d0                	mov    %edx,%eax
		t->dticks = 0;
 8060b29:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
		int dt = t->dticks;
 8060b30:	89 d6                	mov    %edx,%esi
		t->dticks = 0;
 8060b32:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
		curr_tick += dt;
 8060b39:	99                   	cltd   
 8060b3a:	03 45 d8             	add    -0x28(%ebp),%eax
 8060b3d:	a3 08 89 06 08       	mov    %eax,0x8068908
 8060b42:	13 55 dc             	adc    -0x24(%ebp),%edx
		remove_timeout(t);
 8060b45:	89 d8                	mov    %ebx,%eax
		curr_tick += dt;
 8060b47:	89 15 0c 89 06 08    	mov    %edx,0x806890c
		remove_timeout(t);
 8060b4d:	e8 34 fd ff ff       	call   8060886 <remove_timeout>
	posix_irq_unlock(key);
 8060b52:	83 ec 0c             	sub    $0xc,%esp
 8060b55:	ff 75 e4             	push   -0x1c(%ebp)
 8060b58:	e8 d4 d5 fe ff       	call   804e131 <posix_irq_unlock>

		k_spin_unlock(&timeout_lock, key);
		t->fn(t);
 8060b5d:	89 1c 24             	mov    %ebx,(%esp)
 8060b60:	ff 53 08             	call   *0x8(%ebx)
 8060b63:	83 c4 10             	add    $0x10,%esp
	return posix_irq_lock();
 8060b66:	e8 b4 d5 fe ff       	call   804e11f <posix_irq_lock>
		key = k_spin_lock(&timeout_lock);
		announce_remaining -= dt;
 8060b6b:	29 35 a8 8a 06 08    	sub    %esi,0x8068aa8
 8060b71:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 8060b74:	e9 6d ff ff ff       	jmp    8060ae6 <sys_clock_announce+0x1a>
	}

	if (t != NULL) {
		t->dticks -= announce_remaining;
 8060b79:	89 d0                	mov    %edx,%eax
 8060b7b:	89 ca                	mov    %ecx,%edx
 8060b7d:	29 f0                	sub    %esi,%eax
 8060b7f:	19 fa                	sbb    %edi,%edx
 8060b81:	89 43 0c             	mov    %eax,0xc(%ebx)
 8060b84:	89 53 10             	mov    %edx,0x10(%ebx)
	}

	curr_tick += announce_remaining;
 8060b87:	a1 a8 8a 06 08       	mov    0x8068aa8,%eax
	announce_remaining = 0;
 8060b8c:	c7 05 a8 8a 06 08 00 	movl   $0x0,0x8068aa8
 8060b93:	00 00 00 
	curr_tick += announce_remaining;
 8060b96:	99                   	cltd   
 8060b97:	01 05 08 89 06 08    	add    %eax,0x8068908
 8060b9d:	11 15 0c 89 06 08    	adc    %edx,0x806890c

	sys_clock_set_timeout(next_timeout(), false);
 8060ba3:	e8 87 fc ff ff       	call   806082f <next_timeout>
 8060ba8:	52                   	push   %edx
 8060ba9:	52                   	push   %edx
 8060baa:	6a 00                	push   $0x0
 8060bac:	50                   	push   %eax
 8060bad:	e8 3a de ff ff       	call   805e9ec <sys_clock_set_timeout>
 8060bb2:	59                   	pop    %ecx
	posix_irq_unlock(key);
 8060bb3:	ff 75 e4             	push   -0x1c(%ebp)
 8060bb6:	e8 76 d5 fe ff       	call   804e131 <posix_irq_unlock>
 8060bbb:	83 c4 10             	add    $0x10,%esp
	k_spin_unlock(&timeout_lock, key);

#ifdef CONFIG_TIMESLICING
	z_time_slice();
#endif
}
 8060bbe:	8d 65 f4             	lea    -0xc(%ebp),%esp
 8060bc1:	5b                   	pop    %ebx
 8060bc2:	5e                   	pop    %esi
 8060bc3:	5f                   	pop    %edi
 8060bc4:	5d                   	pop    %ebp
	z_time_slice();
 8060bc5:	e9 12 f4 ff ff       	jmp    805ffdc <z_time_slice>

08060bca <sys_clock_tick_get>:

int64_t sys_clock_tick_get(void)
{
 8060bca:	55                   	push   %ebp
 8060bcb:	89 e5                	mov    %esp,%ebp
 8060bcd:	57                   	push   %edi
 8060bce:	83 ec 14             	sub    $0x14,%esp
	return posix_irq_lock();
 8060bd1:	e8 49 d5 fe ff       	call   804e11f <posix_irq_lock>
 8060bd6:	89 c7                	mov    %eax,%edi
	uint64_t t = 0U;

	LOCKED(&timeout_lock) {
		t = curr_tick + elapsed();
 8060bd8:	e8 41 fc ff ff       	call   806081e <elapsed>
 8060bdd:	99                   	cltd   
 8060bde:	03 05 08 89 06 08    	add    0x8068908,%eax
 8060be4:	13 15 0c 89 06 08    	adc    0x806890c,%edx
	posix_irq_unlock(key);
 8060bea:	83 ec 0c             	sub    $0xc,%esp
 8060bed:	57                   	push   %edi
 8060bee:	89 45 f0             	mov    %eax,-0x10(%ebp)
 8060bf1:	89 55 f4             	mov    %edx,-0xc(%ebp)
 8060bf4:	e8 38 d5 fe ff       	call   804e131 <posix_irq_unlock>
	}
	return t;
}
 8060bf9:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8060bfc:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8060bff:	83 c4 10             	add    $0x10,%esp
 8060c02:	8b 7d fc             	mov    -0x4(%ebp),%edi
 8060c05:	c9                   	leave  
 8060c06:	c3                   	ret    

08060c07 <sys_clock_tick_get_32>:

uint32_t sys_clock_tick_get_32(void)
{
 8060c07:	55                   	push   %ebp
 8060c08:	89 e5                	mov    %esp,%ebp
 8060c0a:	83 ec 08             	sub    $0x8,%esp
#ifdef CONFIG_TICKLESS_KERNEL
	return (uint32_t)sys_clock_tick_get();
 8060c0d:	e8 b8 ff ff ff       	call   8060bca <sys_clock_tick_get>
#else
	return (uint32_t)curr_tick;
#endif
}
 8060c12:	c9                   	leave  
 8060c13:	c3                   	ret    

08060c14 <z_impl_k_uptime_ticks>:

int64_t z_impl_k_uptime_ticks(void)
{
	return sys_clock_tick_get();
 8060c14:	e9 b1 ff ff ff       	jmp    8060bca <sys_clock_tick_get>

08060c19 <sys_clock_timeout_end_calc>:
 * timeout object.  When used correctly, this should be called once,
 * synchronously with the user passing a new timeout value.  It should
 * not be used iteratively to adjust a timeout.
 */
uint64_t sys_clock_timeout_end_calc(k_timeout_t timeout)
{
 8060c19:	55                   	push   %ebp
 8060c1a:	89 e5                	mov    %esp,%ebp
 8060c1c:	57                   	push   %edi
 8060c1d:	56                   	push   %esi
 8060c1e:	53                   	push   %ebx
 8060c1f:	83 ec 1c             	sub    $0x1c,%esp
 8060c22:	8b 7d 0c             	mov    0xc(%ebp),%edi
 8060c25:	8b 75 08             	mov    0x8(%ebp),%esi
	k_ticks_t dt;

	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
 8060c28:	83 ff ff             	cmp    $0xffffffff,%edi
 8060c2b:	75 05                	jne    8060c32 <sys_clock_timeout_end_calc+0x19>
 8060c2d:	83 fe ff             	cmp    $0xffffffff,%esi
 8060c30:	74 54                	je     8060c86 <sys_clock_timeout_end_calc+0x6d>
		return UINT64_MAX;
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
 8060c32:	89 f8                	mov    %edi,%eax
 8060c34:	09 f0                	or     %esi,%eax
 8060c36:	75 0c                	jne    8060c44 <sys_clock_timeout_end_calc+0x2b>
		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(dt) >= 0) {
			return Z_TICK_ABS(dt);
		}
		return sys_clock_tick_get() + MAX(1, dt);
	}
}
 8060c38:	83 c4 1c             	add    $0x1c,%esp
 8060c3b:	5b                   	pop    %ebx
 8060c3c:	5e                   	pop    %esi
 8060c3d:	5f                   	pop    %edi
 8060c3e:	5d                   	pop    %ebp
		return sys_clock_tick_get();
 8060c3f:	e9 86 ff ff ff       	jmp    8060bca <sys_clock_tick_get>
		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(dt) >= 0) {
 8060c44:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
 8060c49:	83 ca ff             	or     $0xffffffff,%edx
 8060c4c:	29 f0                	sub    %esi,%eax
 8060c4e:	19 fa                	sbb    %edi,%edx
 8060c50:	85 d2                	test   %edx,%edx
 8060c52:	79 37                	jns    8060c8b <sys_clock_timeout_end_calc+0x72>
		return sys_clock_tick_get() + MAX(1, dt);
 8060c54:	e8 71 ff ff ff       	call   8060bca <sys_clock_tick_get>
 8060c59:	b9 01 00 00 00       	mov    $0x1,%ecx
 8060c5e:	31 db                	xor    %ebx,%ebx
 8060c60:	89 45 d8             	mov    %eax,-0x28(%ebp)
 8060c63:	39 ce                	cmp    %ecx,%esi
 8060c65:	89 f8                	mov    %edi,%eax
 8060c67:	19 d8                	sbb    %ebx,%eax
 8060c69:	89 55 dc             	mov    %edx,-0x24(%ebp)
 8060c6c:	8b 45 d8             	mov    -0x28(%ebp),%eax
 8060c6f:	0f 4d ce             	cmovge %esi,%ecx
 8060c72:	0f 4d df             	cmovge %edi,%ebx
 8060c75:	8b 55 dc             	mov    -0x24(%ebp),%edx
 8060c78:	89 4d e0             	mov    %ecx,-0x20(%ebp)
 8060c7b:	03 45 e0             	add    -0x20(%ebp),%eax
 8060c7e:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
 8060c81:	13 55 e4             	adc    -0x1c(%ebp),%edx
 8060c84:	eb 05                	jmp    8060c8b <sys_clock_timeout_end_calc+0x72>
		return UINT64_MAX;
 8060c86:	83 c8 ff             	or     $0xffffffff,%eax
 8060c89:	89 c2                	mov    %eax,%edx
}
 8060c8b:	83 c4 1c             	add    $0x1c,%esp
 8060c8e:	5b                   	pop    %ebx
 8060c8f:	5e                   	pop    %esi
 8060c90:	5f                   	pop    %edi
 8060c91:	5d                   	pop    %ebp
 8060c92:	c3                   	ret    

08060c93 <add_event>:
	return p ? CONTAINER_OF(p, struct k_thread, poller) : NULL;
}

static inline void add_event(sys_dlist_t *events, struct k_poll_event *event,
			     struct z_poller *poller)
{
 8060c93:	55                   	push   %ebp
 8060c94:	89 e5                	mov    %esp,%ebp
 8060c96:	57                   	push   %edi
 8060c97:	56                   	push   %esi
 8060c98:	89 d6                	mov    %edx,%esi
 8060c9a:	53                   	push   %ebx
 8060c9b:	89 c3                	mov    %eax,%ebx
 8060c9d:	83 ec 1c             	sub    $0x1c,%esp
	return sys_dlist_is_empty(list) ? NULL : list->tail;
 8060ca0:	8b 40 04             	mov    0x4(%eax),%eax
 8060ca3:	3b 1b                	cmp    (%ebx),%ebx
 8060ca5:	74 2b                	je     8060cd2 <add_event+0x3f>
	struct k_poll_event *pending;

	pending = (struct k_poll_event *)sys_dlist_peek_tail(events);
	if ((pending == NULL) ||
 8060ca7:	85 c0                	test   %eax,%eax
 8060ca9:	74 27                	je     8060cd2 <add_event+0x3f>
		(z_sched_prio_cmp(poller_thread(pending->poller),
 8060cab:	8b 40 08             	mov    0x8(%eax),%eax
	return p ? CONTAINER_OF(p, struct k_thread, poller) : NULL;
 8060cae:	8d 79 bc             	lea    -0x44(%ecx),%edi
 8060cb1:	85 c0                	test   %eax,%eax
 8060cb3:	74 03                	je     8060cb8 <add_event+0x25>
 8060cb5:	83 e8 44             	sub    $0x44,%eax
		(z_sched_prio_cmp(poller_thread(pending->poller),
 8060cb8:	51                   	push   %ecx
 8060cb9:	51                   	push   %ecx
 8060cba:	57                   	push   %edi
 8060cbb:	50                   	push   %eax
 8060cbc:	e8 f9 f0 ff ff       	call   805fdba <z_sched_prio_cmp>
 8060cc1:	83 c4 10             	add    $0x10,%esp
	if ((pending == NULL) ||
 8060cc4:	85 c0                	test   %eax,%eax
 8060cc6:	7f 0a                	jg     8060cd2 <add_event+0x3f>
	return list->head == list;
 8060cc8:	8b 13                	mov    (%ebx),%edx
							   poller_thread(poller)) > 0)) {
		sys_dlist_append(events, &event->_node);
		return;
	}

	SYS_DLIST_FOR_EACH_CONTAINER(events, pending, _node) {
 8060cca:	85 d2                	test   %edx,%edx
 8060ccc:	74 04                	je     8060cd2 <add_event+0x3f>
 8060cce:	39 d3                	cmp    %edx,%ebx
 8060cd0:	75 0f                	jne    8060ce1 <add_event+0x4e>
	sys_dnode_t *const tail = list->tail;
 8060cd2:	8b 43 04             	mov    0x4(%ebx),%eax
	node->next = list;
 8060cd5:	89 1e                	mov    %ebx,(%esi)
	node->prev = tail;
 8060cd7:	89 46 04             	mov    %eax,0x4(%esi)
	tail->next = node;
 8060cda:	89 30                	mov    %esi,(%eax)
	list->tail = node;
 8060cdc:	89 73 04             	mov    %esi,0x4(%ebx)
}
 8060cdf:	eb 3a                	jmp    8060d1b <add_event+0x88>
		if (z_sched_prio_cmp(poller_thread(poller),
 8060ce1:	8b 42 08             	mov    0x8(%edx),%eax
	return p ? CONTAINER_OF(p, struct k_thread, poller) : NULL;
 8060ce4:	85 c0                	test   %eax,%eax
 8060ce6:	74 03                	je     8060ceb <add_event+0x58>
 8060ce8:	83 e8 44             	sub    $0x44,%eax
 8060ceb:	89 55 e4             	mov    %edx,-0x1c(%ebp)
		if (z_sched_prio_cmp(poller_thread(poller),
 8060cee:	52                   	push   %edx
 8060cef:	52                   	push   %edx
 8060cf0:	50                   	push   %eax
 8060cf1:	57                   	push   %edi
 8060cf2:	e8 c3 f0 ff ff       	call   805fdba <z_sched_prio_cmp>
 8060cf7:	83 c4 10             	add    $0x10,%esp
 8060cfa:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 8060cfd:	85 c0                	test   %eax,%eax
 8060cff:	7e 0f                	jle    8060d10 <add_event+0x7d>
	sys_dnode_t *const prev = successor->prev;
 8060d01:	8b 42 04             	mov    0x4(%edx),%eax
	node->next = successor;
 8060d04:	89 16                	mov    %edx,(%esi)
	node->prev = prev;
 8060d06:	89 46 04             	mov    %eax,0x4(%esi)
	prev->next = node;
 8060d09:	89 30                	mov    %esi,(%eax)
	successor->prev = node;
 8060d0b:	89 72 04             	mov    %esi,0x4(%edx)
					poller_thread(pending->poller)) > 0) {
			sys_dlist_insert(&pending->_node, &event->_node);
			return;
 8060d0e:	eb 0b                	jmp    8060d1b <add_event+0x88>
	return (node == list->tail) ? NULL : node->next;
 8060d10:	3b 53 04             	cmp    0x4(%ebx),%edx
 8060d13:	74 bd                	je     8060cd2 <add_event+0x3f>
 8060d15:	8b 12                	mov    (%edx),%edx
	SYS_DLIST_FOR_EACH_CONTAINER(events, pending, _node) {
 8060d17:	85 d2                	test   %edx,%edx
 8060d19:	eb b5                	jmp    8060cd0 <add_event+0x3d>
		}
	}

	sys_dlist_append(events, &event->_node);
}
 8060d1b:	8d 65 f4             	lea    -0xc(%ebp),%esp
 8060d1e:	5b                   	pop    %ebx
 8060d1f:	5e                   	pop    %esi
 8060d20:	5f                   	pop    %edi
 8060d21:	5d                   	pop    %ebp
 8060d22:	c3                   	ret    

08060d23 <register_events>:

static inline int register_events(struct k_poll_event *events,
				  int num_events,
				  struct z_poller *poller,
				  bool just_check)
{
 8060d23:	55                   	push   %ebp
 8060d24:	89 e5                	mov    %esp,%ebp
 8060d26:	57                   	push   %edi
 8060d27:	89 c7                	mov    %eax,%edi
 8060d29:	56                   	push   %esi
	int events_registered = 0;

	for (int ii = 0; ii < num_events; ii++) {
 8060d2a:	31 f6                	xor    %esi,%esi
{
 8060d2c:	53                   	push   %ebx
 8060d2d:	89 cb                	mov    %ecx,%ebx
 8060d2f:	83 ec 1c             	sub    $0x1c,%esp
 8060d32:	89 55 dc             	mov    %edx,-0x24(%ebp)
 8060d35:	8a 55 08             	mov    0x8(%ebp),%dl
	int events_registered = 0;
 8060d38:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
{
 8060d3f:	88 55 db             	mov    %dl,-0x25(%ebp)
	for (int ii = 0; ii < num_events; ii++) {
 8060d42:	3b 75 dc             	cmp    -0x24(%ebp),%esi
 8060d45:	0f 8d e8 00 00 00    	jge    8060e33 <register_events+0x110>
	return posix_irq_lock();
 8060d4b:	e8 cf d3 fe ff       	call   804e11f <posix_irq_lock>
 8060d50:	89 45 e0             	mov    %eax,-0x20(%ebp)
	switch (event->type) {
 8060d53:	8a 47 0d             	mov    0xd(%edi),%al
 8060d56:	83 e0 3f             	and    $0x3f,%eax
 8060d59:	3c 04                	cmp    $0x4,%al
 8060d5b:	74 22                	je     8060d7f <register_events+0x5c>
 8060d5d:	77 0a                	ja     8060d69 <register_events+0x46>
 8060d5f:	3c 01                	cmp    $0x1,%al
 8060d61:	74 2b                	je     8060d8e <register_events+0x6b>
 8060d63:	3c 02                	cmp    $0x2,%al
 8060d65:	74 08                	je     8060d6f <register_events+0x4c>
 8060d67:	eb 6c                	jmp    8060dd5 <register_events+0xb2>
 8060d69:	3c 08                	cmp    $0x8,%al
 8060d6b:	74 31                	je     8060d9e <register_events+0x7b>
 8060d6d:	eb 66                	jmp    8060dd5 <register_events+0xb2>
		if (k_sem_count_get(event->sem) > 0U) {
 8060d6f:	8b 47 10             	mov    0x10(%edi),%eax
 8060d72:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
 8060d76:	74 5d                	je     8060dd5 <register_events+0xb2>
			*state = K_POLL_STATE_SEM_AVAILABLE;
 8060d78:	b9 02 00 00 00       	mov    $0x2,%ecx
 8060d7d:	eb 2d                	jmp    8060dac <register_events+0x89>
		if (!k_queue_is_empty(event->queue)) {
 8060d7f:	8b 47 10             	mov    0x10(%edi),%eax
 8060d82:	83 38 00             	cmpl   $0x0,(%eax)
			*state = K_POLL_STATE_FIFO_DATA_AVAILABLE;
 8060d85:	b9 04 00 00 00       	mov    $0x4,%ecx
		if (!k_queue_is_empty(event->queue)) {
 8060d8a:	75 20                	jne    8060dac <register_events+0x89>
 8060d8c:	eb 47                	jmp    8060dd5 <register_events+0xb2>
		if (event->signal->signaled != 0U) {
 8060d8e:	8b 47 10             	mov    0x10(%edi),%eax
 8060d91:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
 8060d95:	74 3e                	je     8060dd5 <register_events+0xb2>
			*state = K_POLL_STATE_SIGNALED;
 8060d97:	b9 01 00 00 00       	mov    $0x1,%ecx
 8060d9c:	eb 0e                	jmp    8060dac <register_events+0x89>
		if (event->msgq->used_msgs > 0) {
 8060d9e:	8b 47 10             	mov    0x10(%edi),%eax
			*state = K_POLL_STATE_MSGQ_DATA_AVAILABLE;
 8060da1:	b9 10 00 00 00       	mov    $0x10,%ecx
		if (event->msgq->used_msgs > 0) {
 8060da6:	83 78 20 00          	cmpl   $0x0,0x20(%eax)
 8060daa:	74 29                	je     8060dd5 <register_events+0xb2>
	event->state |= state;
 8060dac:	8b 47 0c             	mov    0xc(%edi),%eax
	event->poller = NULL;
 8060daf:	c7 47 08 00 00 00 00 	movl   $0x0,0x8(%edi)
	event->state |= state;
 8060db6:	c1 e8 0e             	shr    $0xe,%eax
 8060db9:	83 e0 7f             	and    $0x7f,%eax
 8060dbc:	09 c8                	or     %ecx,%eax
 8060dbe:	c1 e0 0e             	shl    $0xe,%eax
 8060dc1:	89 c1                	mov    %eax,%ecx
 8060dc3:	8b 47 0c             	mov    0xc(%edi),%eax
 8060dc6:	25 ff 3f e0 ff       	and    $0xffe03fff,%eax
 8060dcb:	09 c8                	or     %ecx,%eax
 8060dcd:	89 47 0c             	mov    %eax,0xc(%edi)
		uint32_t state;

		key = k_spin_lock(&lock);
		if (is_condition_met(&events[ii], &state)) {
			set_event_ready(&events[ii], state);
			poller->is_polling = false;
 8060dd0:	c6 03 00             	movb   $0x0,(%ebx)
 8060dd3:	eb 47                	jmp    8060e1c <register_events+0xf9>
		} else if (!just_check && poller->is_polling) {
 8060dd5:	80 7d db 00          	cmpb   $0x0,-0x25(%ebp)
 8060dd9:	75 41                	jne    8060e1c <register_events+0xf9>
 8060ddb:	80 3b 00             	cmpb   $0x0,(%ebx)
 8060dde:	74 3c                	je     8060e1c <register_events+0xf9>
	switch (event->type) {
 8060de0:	8a 47 0d             	mov    0xd(%edi),%al
 8060de3:	83 e0 3f             	and    $0x3f,%eax
 8060de6:	3c 04                	cmp    $0x4,%al
 8060de8:	74 18                	je     8060e02 <register_events+0xdf>
 8060dea:	77 0a                	ja     8060df6 <register_events+0xd3>
 8060dec:	3c 01                	cmp    $0x1,%al
 8060dee:	74 1a                	je     8060e0a <register_events+0xe7>
 8060df0:	3c 02                	cmp    $0x2,%al
 8060df2:	74 0e                	je     8060e02 <register_events+0xdf>
 8060df4:	eb 20                	jmp    8060e16 <register_events+0xf3>
 8060df6:	3c 08                	cmp    $0x8,%al
 8060df8:	75 1c                	jne    8060e16 <register_events+0xf3>
		add_event(&event->msgq->poll_events, event, poller);
 8060dfa:	8b 47 10             	mov    0x10(%edi),%eax
 8060dfd:	83 c0 24             	add    $0x24,%eax
 8060e00:	eb 0b                	jmp    8060e0d <register_events+0xea>
		add_event(&event->queue->poll_events, event, poller);
 8060e02:	8b 47 10             	mov    0x10(%edi),%eax
 8060e05:	83 c0 10             	add    $0x10,%eax
 8060e08:	eb 03                	jmp    8060e0d <register_events+0xea>
		add_event(&event->signal->poll_events, event, poller);
 8060e0a:	8b 47 10             	mov    0x10(%edi),%eax
		add_event(&event->msgq->poll_events, event, poller);
 8060e0d:	89 d9                	mov    %ebx,%ecx
 8060e0f:	89 fa                	mov    %edi,%edx
 8060e11:	e8 7d fe ff ff       	call   8060c93 <add_event>
			register_event(&events[ii], poller);
			events_registered += 1;
 8060e16:	ff 45 e4             	incl   -0x1c(%ebp)
	event->poller = poller;
 8060e19:	89 5f 08             	mov    %ebx,0x8(%edi)
	posix_irq_unlock(key);
 8060e1c:	83 ec 0c             	sub    $0xc,%esp
 8060e1f:	ff 75 e0             	push   -0x20(%ebp)
	for (int ii = 0; ii < num_events; ii++) {
 8060e22:	46                   	inc    %esi
 8060e23:	83 c7 14             	add    $0x14,%edi
 8060e26:	e8 06 d3 fe ff       	call   804e131 <posix_irq_unlock>
 8060e2b:	83 c4 10             	add    $0x10,%esp
 8060e2e:	e9 0f ff ff ff       	jmp    8060d42 <register_events+0x1f>
		}
		k_spin_unlock(&lock, key);
	}

	return events_registered;
}
 8060e33:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8060e36:	8d 65 f4             	lea    -0xc(%ebp),%esp
 8060e39:	5b                   	pop    %ebx
 8060e3a:	5e                   	pop    %esi
 8060e3b:	5f                   	pop    %edi
 8060e3c:	5d                   	pop    %ebp
 8060e3d:	c3                   	ret    

08060e3e <signal_poll_event>:
#include <syscalls/k_poll_mrsh.c>
#endif

/* must be called with interrupts locked */
static int signal_poll_event(struct k_poll_event *event, uint32_t state)
{
 8060e3e:	55                   	push   %ebp
 8060e3f:	89 e5                	mov    %esp,%ebp
 8060e41:	57                   	push   %edi
 8060e42:	89 d7                	mov    %edx,%edi
 8060e44:	56                   	push   %esi
 8060e45:	89 c6                	mov    %eax,%esi
 8060e47:	53                   	push   %ebx
 8060e48:	83 ec 1c             	sub    $0x1c,%esp
	struct z_poller *poller = event->poller;
 8060e4b:	8b 58 08             	mov    0x8(%eax),%ebx
	int retcode = 0;

	if (poller != NULL) {
 8060e4e:	85 db                	test   %ebx,%ebx
 8060e50:	0f 84 a9 00 00 00    	je     8060eff <signal_poll_event+0xc1>
		if (poller->mode == MODE_POLL) {
 8060e56:	8a 43 01             	mov    0x1(%ebx),%al
 8060e59:	3c 01                	cmp    $0x1,%al
 8060e5b:	75 61                	jne    8060ebe <signal_poll_event+0x80>
	if (!z_is_thread_pending(thread)) {
 8060e5d:	f6 43 c9 02          	testb  $0x2,-0x37(%ebx)
 8060e61:	0f 84 95 00 00 00    	je     8060efc <signal_poll_event+0xbe>
	if (z_is_thread_timeout_expired(thread)) {
 8060e67:	83 7b e4 ff          	cmpl   $0xffffffff,-0x1c(%ebx)
 8060e6b:	75 13                	jne    8060e80 <signal_poll_event+0x42>
 8060e6d:	83 7b e0 fe          	cmpl   $0xfffffffe,-0x20(%ebx)
 8060e71:	75 0d                	jne    8060e80 <signal_poll_event+0x42>
		} else {
			/* Poller is not poll or triggered mode. No action needed.*/
			;
		}

		poller->is_polling = false;
 8060e73:	c6 03 00             	movb   $0x0,(%ebx)
		return -EAGAIN;
 8060e76:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
 8060e7b:	e9 a3 00 00 00       	jmp    8060f23 <signal_poll_event+0xe5>
	z_unpend_thread(thread);
 8060e80:	83 ec 0c             	sub    $0xc,%esp
	return p ? CONTAINER_OF(p, struct k_thread, poller) : NULL;
 8060e83:	8d 53 bc             	lea    -0x44(%ebx),%edx
	z_unpend_thread(thread);
 8060e86:	52                   	push   %edx
 8060e87:	89 55 e4             	mov    %edx,-0x1c(%ebp)
 8060e8a:	e8 9a ef ff ff       	call   805fe29 <z_unpend_thread>
	arch_thread_return_value_set(thread,
 8060e8f:	31 c0                	xor    %eax,%eax
	z_unpend_thread(thread);
 8060e91:	83 c4 10             	add    $0x10,%esp
	arch_thread_return_value_set(thread,
 8060e94:	83 ff 08             	cmp    $0x8,%edi
 8060e97:	0f 95 c0             	setne  %al
 8060e9a:	8d 04 85 fc ff ff ff 	lea    -0x4(,%eax,4),%eax
 8060ea1:	89 43 ec             	mov    %eax,-0x14(%ebx)
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
 8060ea4:	f6 43 c9 1f          	testb  $0x1f,-0x37(%ebx)
 8060ea8:	75 52                	jne    8060efc <signal_poll_event+0xbe>
	if (!z_is_thread_ready(thread)) {
 8060eaa:	83 7b d4 00          	cmpl   $0x0,-0x2c(%ebx)
 8060eae:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 8060eb1:	75 49                	jne    8060efc <signal_poll_event+0xbe>
	z_ready_thread(thread);
 8060eb3:	83 ec 0c             	sub    $0xc,%esp
 8060eb6:	52                   	push   %edx
 8060eb7:	e8 f2 f1 ff ff       	call   80600ae <z_ready_thread>
 8060ebc:	eb 3b                	jmp    8060ef9 <signal_poll_event+0xbb>
		} else if (poller->mode == MODE_TRIGGERED) {
 8060ebe:	3c 02                	cmp    $0x2,%al
 8060ec0:	75 3a                	jne    8060efc <signal_poll_event+0xbe>
{
	struct z_poller *poller = event->poller;
	struct k_work_poll *twork =
		CONTAINER_OF(poller, struct k_work_poll, poller);

	if (poller->is_polling && twork->workq != NULL) {
 8060ec2:	80 3b 00             	cmpb   $0x0,(%ebx)
 8060ec5:	74 38                	je     8060eff <signal_poll_event+0xc1>
 8060ec7:	8b 53 fc             	mov    -0x4(%ebx),%edx
 8060eca:	85 d2                	test   %edx,%edx
 8060ecc:	89 55 e0             	mov    %edx,-0x20(%ebp)
 8060ecf:	74 2b                	je     8060efc <signal_poll_event+0xbe>
		struct k_work_q *work_q = twork->workq;

		z_abort_timeout(&twork->timeout);
 8060ed1:	83 ec 0c             	sub    $0xc,%esp
 8060ed4:	8d 43 10             	lea    0x10(%ebx),%eax
 8060ed7:	8d 4b ec             	lea    -0x14(%ebx),%ecx
 8060eda:	50                   	push   %eax
 8060edb:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
 8060ede:	e8 7b fb ff ff       	call   8060a5e <z_abort_timeout>
 8060ee3:	58                   	pop    %eax
		twork->poll_result = 0;
		z_work_submit_to_queue(work_q, &twork->work);
 8060ee4:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
		z_abort_timeout(&twork->timeout);
 8060ee7:	5a                   	pop    %edx
		z_work_submit_to_queue(work_q, &twork->work);
 8060ee8:	8b 55 e0             	mov    -0x20(%ebp),%edx
		twork->poll_result = 0;
 8060eeb:	c7 43 24 00 00 00 00 	movl   $0x0,0x24(%ebx)
		z_work_submit_to_queue(work_q, &twork->work);
 8060ef2:	51                   	push   %ecx
 8060ef3:	52                   	push   %edx
 8060ef4:	e8 43 ec ff ff       	call   805fb3c <z_work_submit_to_queue>
 8060ef9:	83 c4 10             	add    $0x10,%esp
		poller->is_polling = false;
 8060efc:	c6 03 00             	movb   $0x0,(%ebx)
	event->state |= state;
 8060eff:	8b 56 0c             	mov    0xc(%esi),%edx
	event->poller = NULL;
 8060f02:	c7 46 08 00 00 00 00 	movl   $0x0,0x8(%esi)
	event->state |= state;
 8060f09:	89 d0                	mov    %edx,%eax
 8060f0b:	81 e2 ff 3f e0 ff    	and    $0xffe03fff,%edx
 8060f11:	c1 e8 0e             	shr    $0xe,%eax
 8060f14:	09 f8                	or     %edi,%eax
 8060f16:	83 e0 7f             	and    $0x7f,%eax
 8060f19:	c1 e0 0e             	shl    $0xe,%eax
 8060f1c:	09 c2                	or     %eax,%edx
	return retcode;
 8060f1e:	31 c0                	xor    %eax,%eax
	event->state |= state;
 8060f20:	89 56 0c             	mov    %edx,0xc(%esi)
}
 8060f23:	8d 65 f4             	lea    -0xc(%ebp),%esp
 8060f26:	5b                   	pop    %ebx
 8060f27:	5e                   	pop    %esi
 8060f28:	5f                   	pop    %edi
 8060f29:	5d                   	pop    %ebp
 8060f2a:	c3                   	ret    

08060f2b <clear_event_registrations>:
{
 8060f2b:	55                   	push   %ebp
 8060f2c:	89 e5                	mov    %esp,%ebp
 8060f2e:	56                   	push   %esi
 8060f2f:	89 d6                	mov    %edx,%esi
 8060f31:	6b d2 14             	imul   $0x14,%edx,%edx
 8060f34:	53                   	push   %ebx
 8060f35:	89 c3                	mov    %eax,%ebx
 8060f37:	89 c8                	mov    %ecx,%eax
	while (num_events--) {
 8060f39:	8d 5c 1a ec          	lea    -0x14(%edx,%ebx,1),%ebx
 8060f3d:	85 f6                	test   %esi,%esi
 8060f3f:	74 50                	je     8060f91 <clear_event_registrations+0x66>
	switch (event->type) {
 8060f41:	8a 4b 0d             	mov    0xd(%ebx),%cl
	event->poller = NULL;
 8060f44:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
	switch (event->type) {
 8060f4b:	83 e1 3f             	and    $0x3f,%ecx
 8060f4e:	80 f9 08             	cmp    $0x8,%cl
 8060f51:	77 27                	ja     8060f7a <clear_event_registrations+0x4f>
 8060f53:	ba 16 01 00 00       	mov    $0x116,%edx
 8060f58:	d3 ea                	shr    %cl,%edx
 8060f5a:	80 e2 01             	and    $0x1,%dl
 8060f5d:	74 1b                	je     8060f7a <clear_event_registrations+0x4f>
	return node->next != NULL;
 8060f5f:	8b 13                	mov    (%ebx),%edx
	if (remove_event && sys_dnode_is_linked(&event->_node)) {
 8060f61:	85 d2                	test   %edx,%edx
 8060f63:	74 15                	je     8060f7a <clear_event_registrations+0x4f>
	sys_dnode_t *const prev = node->prev;
 8060f65:	8b 4b 04             	mov    0x4(%ebx),%ecx
	prev->next = next;
 8060f68:	89 11                	mov    %edx,(%ecx)
	next->prev = prev;
 8060f6a:	89 4a 04             	mov    %ecx,0x4(%edx)
	node->next = NULL;
 8060f6d:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
	node->prev = NULL;
 8060f73:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
 8060f7a:	83 ec 0c             	sub    $0xc,%esp
 8060f7d:	4e                   	dec    %esi
 8060f7e:	83 eb 14             	sub    $0x14,%ebx
 8060f81:	50                   	push   %eax
 8060f82:	e8 aa d1 fe ff       	call   804e131 <posix_irq_unlock>
 8060f87:	83 c4 10             	add    $0x10,%esp
	return posix_irq_lock();
 8060f8a:	e8 90 d1 fe ff       	call   804e11f <posix_irq_lock>
	z_spin_lock_set_owner(l);
#if defined(CONFIG_SPIN_LOCK_TIME_LIMIT) && (CONFIG_SPIN_LOCK_TIME_LIMIT != 0)
	l->lock_time = sys_clock_cycle_get_32();
#endif /* CONFIG_SPIN_LOCK_TIME_LIMIT */
#endif/* CONFIG_SPIN_VALIDATE */
	return k;
 8060f8f:	eb ac                	jmp    8060f3d <clear_event_registrations+0x12>
}
 8060f91:	8d 65 f8             	lea    -0x8(%ebp),%esp
 8060f94:	5b                   	pop    %ebx
 8060f95:	5e                   	pop    %esi
 8060f96:	5d                   	pop    %ebp
 8060f97:	c3                   	ret    

08060f98 <z_impl_k_poll>:
{
 8060f98:	55                   	push   %ebp
 8060f99:	89 e5                	mov    %esp,%ebp
 8060f9b:	57                   	push   %edi
 8060f9c:	56                   	push   %esi
 8060f9d:	53                   	push   %ebx
 8060f9e:	83 ec 28             	sub    $0x28,%esp
 8060fa1:	8b 45 14             	mov    0x14(%ebp),%eax
	struct z_poller *poller = &_current->poller;
 8060fa4:	8b 5d 10             	mov    0x10(%ebp),%ebx
 8060fa7:	8b 3d e8 87 06 08    	mov    0x80687e8,%edi
	events_registered = register_events(events, num_events, poller,
 8060fad:	8b 55 0c             	mov    0xc(%ebp),%edx
 8060fb0:	09 c3                	or     %eax,%ebx
 8060fb2:	0f 94 c0             	sete   %al
	poller->is_polling = true;
 8060fb5:	66 c7 47 44 01 01    	movw   $0x101,0x44(%edi)
	struct z_poller *poller = &_current->poller;
 8060fbb:	8d 4f 44             	lea    0x44(%edi),%ecx
	events_registered = register_events(events, num_events, poller,
 8060fbe:	0f b6 c0             	movzbl %al,%eax
 8060fc1:	50                   	push   %eax
 8060fc2:	8b 45 08             	mov    0x8(%ebp),%eax
 8060fc5:	e8 59 fd ff ff       	call   8060d23 <register_events>
 8060fca:	83 c4 10             	add    $0x10,%esp
 8060fcd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 8060fd0:	e8 4a d1 fe ff       	call   804e11f <posix_irq_lock>
	if (!poller->is_polling) {
 8060fd5:	80 7f 44 00          	cmpb   $0x0,0x44(%edi)
 8060fd9:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 8060fdc:	89 c6                	mov    %eax,%esi
 8060fde:	75 1a                	jne    8060ffa <z_impl_k_poll+0x62>
		clear_event_registrations(events, events_registered, key);
 8060fe0:	89 c1                	mov    %eax,%ecx
 8060fe2:	8b 45 08             	mov    0x8(%ebp),%eax
		return 0;
 8060fe5:	31 db                	xor    %ebx,%ebx
		clear_event_registrations(events, events_registered, key);
 8060fe7:	e8 3f ff ff ff       	call   8060f2b <clear_event_registrations>
	posix_irq_unlock(key);
 8060fec:	83 ec 0c             	sub    $0xc,%esp
 8060fef:	56                   	push   %esi
 8060ff0:	e8 3c d1 fe ff       	call   804e131 <posix_irq_unlock>
 8060ff5:	83 c4 10             	add    $0x10,%esp
		return 0;
 8060ff8:	eb 5c                	jmp    8061056 <z_impl_k_poll+0xbe>
	poller->is_polling = false;
 8060ffa:	c6 47 44 00          	movb   $0x0,0x44(%edi)
	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
 8060ffe:	85 db                	test   %ebx,%ebx
 8061000:	75 13                	jne    8061015 <z_impl_k_poll+0x7d>
 8061002:	83 ec 0c             	sub    $0xc,%esp
		return -EAGAIN;
 8061005:	bb f5 ff ff ff       	mov    $0xfffffff5,%ebx
 806100a:	50                   	push   %eax
 806100b:	e8 21 d1 fe ff       	call   804e131 <posix_irq_unlock>
 8061010:	83 c4 10             	add    $0x10,%esp
 8061013:	eb 41                	jmp    8061056 <z_impl_k_poll+0xbe>
	int swap_rc = z_pend_curr(&lock, key, &wait_q, timeout);
 8061015:	83 ec 0c             	sub    $0xc,%esp
 8061018:	ff 75 14             	push   0x14(%ebp)
 806101b:	ff 75 10             	push   0x10(%ebp)
 806101e:	68 e0 73 06 08       	push   $0x80673e0
 8061023:	50                   	push   %eax
 8061024:	68 b6 8a 06 08       	push   $0x8068ab6
 8061029:	89 55 e4             	mov    %edx,-0x1c(%ebp)
 806102c:	e8 18 f2 ff ff       	call   8060249 <z_pend_curr>
 8061031:	83 c4 20             	add    $0x20,%esp
 8061034:	89 c3                	mov    %eax,%ebx
	return posix_irq_lock();
 8061036:	e8 e4 d0 fe ff       	call   804e11f <posix_irq_lock>
	clear_event_registrations(events, events_registered, key);
 806103b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 806103e:	89 c1                	mov    %eax,%ecx
 8061040:	89 c6                	mov    %eax,%esi
 8061042:	8b 45 08             	mov    0x8(%ebp),%eax
 8061045:	e8 e1 fe ff ff       	call   8060f2b <clear_event_registrations>
	posix_irq_unlock(key);
 806104a:	83 ec 0c             	sub    $0xc,%esp
 806104d:	56                   	push   %esi
 806104e:	e8 de d0 fe ff       	call   804e131 <posix_irq_unlock>
 8061053:	83 c4 10             	add    $0x10,%esp
}
 8061056:	8d 65 f4             	lea    -0xc(%ebp),%esp
 8061059:	89 d8                	mov    %ebx,%eax
 806105b:	5b                   	pop    %ebx
 806105c:	5e                   	pop    %esi
 806105d:	5f                   	pop    %edi
 806105e:	5d                   	pop    %ebp
 806105f:	c3                   	ret    

08061060 <z_handle_obj_poll_events>:
{
 8061060:	55                   	push   %ebp
 8061061:	89 e5                	mov    %esp,%ebp
 8061063:	53                   	push   %ebx
 8061064:	8b 55 08             	mov    0x8(%ebp),%edx
 8061067:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	return list->head == list;
 806106a:	8b 02                	mov    (%edx),%eax

static inline sys_dnode_t *sys_dlist_get(sys_dlist_t *list)
{
	sys_dnode_t *node = NULL;

	if (!sys_dlist_is_empty(list)) {
 806106c:	39 c2                	cmp    %eax,%edx
 806106e:	74 20                	je     8061090 <z_handle_obj_poll_events+0x30>
	sys_dnode_t *const next = node->next;
 8061070:	8b 10                	mov    (%eax),%edx
	sys_dnode_t *const prev = node->prev;
 8061072:	8b 48 04             	mov    0x4(%eax),%ecx
	prev->next = next;
 8061075:	89 11                	mov    %edx,(%ecx)
	next->prev = prev;
 8061077:	89 4a 04             	mov    %ecx,0x4(%edx)
		(void) signal_poll_event(poll_event, state);
 806107a:	89 da                	mov    %ebx,%edx
	node->next = NULL;
 806107c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	node->prev = NULL;
 8061082:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
}
 8061089:	5b                   	pop    %ebx
 806108a:	5d                   	pop    %ebp
		(void) signal_poll_event(poll_event, state);
 806108b:	e9 ae fd ff ff       	jmp    8060e3e <signal_poll_event>
}
 8061090:	5b                   	pop    %ebx
 8061091:	5d                   	pop    %ebp
 8061092:	c3                   	ret    

08061093 <z_heap_aligned_alloc>:
	return __builtin_add_overflow(a, b, result);
}

static inline bool size_add_overflow(size_t a, size_t b, size_t *result)
{
	return __builtin_add_overflow(a, b, result);
 8061093:	83 c1 04             	add    $0x4,%ecx
 8061096:	72 2d                	jb     80610c5 <z_heap_aligned_alloc+0x32>
#include <string.h>
#include <zephyr/sys/math_extras.h>
#include <zephyr/sys/util.h>

static void *z_heap_aligned_alloc(struct k_heap *heap, size_t align, size_t size)
{
 8061098:	55                   	push   %ebp
	 * boundary without wasting any memory.
	 */
	if (size_add_overflow(size, sizeof(heap_ref), &size)) {
		return NULL;
	}
	__align = align | sizeof(heap_ref);
 8061099:	83 ca 04             	or     $0x4,%edx
{
 806109c:	89 e5                	mov    %esp,%ebp
 806109e:	53                   	push   %ebx
 806109f:	89 c3                	mov    %eax,%ebx
 80610a1:	83 ec 10             	sub    $0x10,%esp

	mem = k_heap_aligned_alloc(heap, __align, size, K_NO_WAIT);
 80610a4:	6a 00                	push   $0x0
 80610a6:	6a 00                	push   $0x0
 80610a8:	51                   	push   %ecx
 80610a9:	52                   	push   %edx
 80610aa:	50                   	push   %eax
 80610ab:	e8 90 dc ff ff       	call   805ed40 <k_heap_aligned_alloc>
 80610b0:	83 c4 20             	add    $0x20,%esp
	if (mem == NULL) {
 80610b3:	85 c0                	test   %eax,%eax
 80610b5:	75 04                	jne    80610bb <z_heap_aligned_alloc+0x28>
		return NULL;
 80610b7:	31 c0                	xor    %eax,%eax
 80610b9:	eb 05                	jmp    80610c0 <z_heap_aligned_alloc+0x2d>
		return NULL;
	}

	heap_ref = mem;
	*heap_ref = heap;
 80610bb:	89 18                	mov    %ebx,(%eax)
	mem = ++heap_ref;
 80610bd:	83 c0 04             	add    $0x4,%eax
	__ASSERT(align == 0 || ((uintptr_t)mem & (align - 1)) == 0,
		 "misaligned memory at %p (align = %zu)", mem, align);

	return mem;
}
 80610c0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 80610c3:	c9                   	leave  
 80610c4:	c3                   	ret    
		return NULL;
 80610c5:	31 c0                	xor    %eax,%eax
}
 80610c7:	c3                   	ret    

080610c8 <k_free>:

void k_free(void *ptr)
{
 80610c8:	55                   	push   %ebp
 80610c9:	89 e5                	mov    %esp,%ebp
 80610cb:	83 ec 08             	sub    $0x8,%esp
 80610ce:	8b 45 08             	mov    0x8(%ebp),%eax
	struct k_heap **heap_ref;

	if (ptr != NULL) {
 80610d1:	85 c0                	test   %eax,%eax
 80610d3:	74 11                	je     80610e6 <k_free+0x1e>
		heap_ref = ptr;
		ptr = --heap_ref;

		SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_heap_sys, k_free, *heap_ref, heap_ref);

		k_heap_free(*heap_ref, ptr);
 80610d5:	52                   	push   %edx
 80610d6:	52                   	push   %edx
		ptr = --heap_ref;
 80610d7:	8d 50 fc             	lea    -0x4(%eax),%edx
		k_heap_free(*heap_ref, ptr);
 80610da:	52                   	push   %edx
 80610db:	ff 70 fc             	push   -0x4(%eax)
 80610de:	e8 ff dc ff ff       	call   805ede2 <k_heap_free>
 80610e3:	83 c4 10             	add    $0x10,%esp

		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_heap_sys, k_free, *heap_ref, heap_ref);
	}
}
 80610e6:	c9                   	leave  
 80610e7:	c3                   	ret    

080610e8 <k_thread_system_pool_assign>:

	return ret;
}

void k_thread_system_pool_assign(struct k_thread *thread)
{
 80610e8:	55                   	push   %ebp
 80610e9:	89 e5                	mov    %esp,%ebp
	thread->resource_pool = _SYSTEM_HEAP;
 80610eb:	8b 45 08             	mov    0x8(%ebp),%eax
 80610ee:	c7 40 4c 84 75 06 08 	movl   $0x8067584,0x4c(%eax)
}
 80610f5:	5d                   	pop    %ebp
 80610f6:	c3                   	ret    

080610f7 <z_thread_aligned_alloc>:
#else
#define _SYSTEM_HEAP	NULL
#endif

void *z_thread_aligned_alloc(size_t align, size_t size)
{
 80610f7:	55                   	push   %ebp
 80610f8:	89 e5                	mov    %esp,%ebp
 80610fa:	83 ec 18             	sub    $0x18,%esp
 80610fd:	8b 55 08             	mov    0x8(%ebp),%edx
 8061100:	8b 4d 0c             	mov    0xc(%ebp),%ecx
 8061103:	89 55 f0             	mov    %edx,-0x10(%ebp)
 8061106:	89 4d f4             	mov    %ecx,-0xc(%ebp)
	void *ret;
	struct k_heap *heap;

	if (k_is_in_isr()) {
 8061109:	e8 84 de ff ff       	call   805ef92 <k_is_in_isr>
 806110e:	8b 4d f4             	mov    -0xc(%ebp),%ecx
 8061111:	8b 55 f0             	mov    -0x10(%ebp),%edx
 8061114:	84 c0                	test   %al,%al
 8061116:	75 0e                	jne    8061126 <z_thread_aligned_alloc+0x2f>
		heap = _SYSTEM_HEAP;
	} else {
		heap = _current->resource_pool;
 8061118:	a1 e8 87 06 08       	mov    0x80687e8,%eax
 806111d:	8b 40 4c             	mov    0x4c(%eax),%eax
	}

	if (heap != NULL) {
 8061120:	85 c0                	test   %eax,%eax
 8061122:	74 0d                	je     8061131 <z_thread_aligned_alloc+0x3a>
 8061124:	eb 05                	jmp    806112b <z_thread_aligned_alloc+0x34>
		heap = _SYSTEM_HEAP;
 8061126:	b8 84 75 06 08       	mov    $0x8067584,%eax
	} else {
		ret = NULL;
	}

	return ret;
}
 806112b:	c9                   	leave  
		ret = z_heap_aligned_alloc(heap, align, size);
 806112c:	e9 62 ff ff ff       	jmp    8061093 <z_heap_aligned_alloc>
}
 8061131:	c9                   	leave  
 8061132:	31 c0                	xor    %eax,%eax
 8061134:	c3                   	ret    

08061135 <boot_banner>:
#else
#define BANNER_VERSION KERNEL_VERSION_STRING
#endif

void boot_banner(void)
{
 8061135:	55                   	push   %ebp
 8061136:	89 e5                	mov    %esp,%ebp
 8061138:	83 ec 14             	sub    $0x14,%esp
	printk("***** delaying boot " DELAY_STR "ms (per build configuration) *****\n");
	k_busy_wait(CONFIG_BOOT_DELAY * USEC_PER_MSEC);
#endif /* defined(CONFIG_BOOT_DELAY) && (CONFIG_BOOT_DELAY > 0) */

#if CONFIG_BOOT_BANNER
	printk("*** Booting Zephyr OS build " BANNER_VERSION BANNER_POSTFIX " ***\n");
 806113b:	68 8b 3f 06 08       	push   $0x8063f8b
 8061140:	e8 7c 8d fe ff       	call   8049ec1 <printk>
 8061145:	83 c4 10             	add    $0x10,%esp
#endif /* CONFIG_BOOT_BANNER */
}
 8061148:	c9                   	leave  
 8061149:	c3                   	ret    

0806114a <k_sys_work_q_init>:
			     CONFIG_SYSTEM_WORKQUEUE_STACK_SIZE);

struct k_work_q k_sys_work_q;

static int k_sys_work_q_init(void)
{
 806114a:	55                   	push   %ebp
 806114b:	89 e5                	mov    %esp,%ebp
 806114d:	83 ec 24             	sub    $0x24,%esp
 8061150:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 8061156:	89 45 f4             	mov    %eax,-0xc(%ebp)
 8061159:	31 c0                	xor    %eax,%eax
	struct k_work_queue_config cfg = {
		.name = "sysworkq",
		.no_yield = IS_ENABLED(CONFIG_SYSTEM_WORKQUEUE_NO_YIELD),
	};

	k_work_queue_start(&k_sys_work_q,
 806115b:	8d 45 ec             	lea    -0x14(%ebp),%eax
	struct k_work_queue_config cfg = {
 806115e:	c7 45 ec b9 3f 06 08 	movl   $0x8063fb9,-0x14(%ebp)
	k_work_queue_start(&k_sys_work_q,
 8061165:	50                   	push   %eax
 8061166:	6a ff                	push   $0xffffffff
 8061168:	68 00 04 00 00       	push   $0x400
 806116d:	68 d8 e4 06 08       	push   $0x806e4d8
 8061172:	68 00 88 06 08       	push   $0x8068800
	struct k_work_queue_config cfg = {
 8061177:	c6 45 f0 00          	movb   $0x0,-0x10(%ebp)
	k_work_queue_start(&k_sys_work_q,
 806117b:	e8 32 ea ff ff       	call   805fbb2 <k_work_queue_start>
 8061180:	83 c4 20             	add    $0x20,%esp
			    sys_work_q_stack,
			    K_KERNEL_STACK_SIZEOF(sys_work_q_stack),
			    CONFIG_SYSTEM_WORKQUEUE_PRIORITY, &cfg);
	return 0;
}
 8061183:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8061186:	65 2b 05 14 00 00 00 	sub    %gs:0x14,%eax
 806118d:	74 05                	je     8061194 <k_sys_work_q_init+0x4a>
 806118f:	e8 6c 81 fe ff       	call   8049300 <__stack_chk_fail@plt>
 8061194:	c9                   	leave  
 8061195:	31 c0                	xor    %eax,%eax
 8061197:	c3                   	ret    

08061198 <_OffsetAbsSyms>:
#include <zephyr/kernel.h>
#include <kernel_arch_data.h>
#include <gen_offset.h>
#include <kernel_offsets.h>

GEN_ABS_SYM_END
 8061198:	c3                   	ret    

Disassembly of section .fini:

0806119c <_fini>:
 806119c:	f3 0f 1e fb          	endbr32 
 80611a0:	53                   	push   %ebx
 80611a1:	83 ec 08             	sub    $0x8,%esp
 80611a4:	e8 a7 82 fe ff       	call   8049450 <__x86.get_pc_thunk.bx>
 80611a9:	81 c3 43 4d 00 00    	add    $0x4d43,%ebx
 80611af:	83 c4 08             	add    $0x8,%esp
 80611b2:	5b                   	pop    %ebx
 80611b3:	c3                   	ret    
